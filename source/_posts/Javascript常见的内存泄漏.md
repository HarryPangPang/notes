---
title: Javascript常见的内存泄漏
date: 2019-01-11 15:42:13
tags:
---
> 什么是内存泄露？
> 程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。
对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。
> 白话解释就是你写的代码里有些东西不用了，就别在保存再内存中了，不然好比你开了100个迅雷CPU卡不卡？卡，但你其实真正用到的只是其中一个迅雷。这就是内存泄漏

想要理解JavaScript的内存泄漏，就要先了解一下js的自动垃圾收集机制
#### js的自动垃圾收集机制
在编写JS时，我们不用像C++一样要手工跟踪内存的使用情况，JS的内存分配和无用内存的回收完全实现了自动化。

JS常用的垃圾收集机制有两种：1. 标记清除 2. 引用计数
1. 标记清除
 在函数声明一个变量的时候，就将这个变量标记为“进入环境”。从逻辑上讲，永远都不能释放进入环境的变量作占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。垃圾回收器在运行时候会给存储在内存中中的所有变量都加上标记。然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。在此之后再被标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清楚工作，销毁那些带标记的值并回收他们所占用的内存空间
```
 
function test(){ 
 var a = 10 ; //被标记 ，进入环境 
 var b = 20 ; //被标记 ，进入环境 
} 
test(); //执行完毕 之后 a、b又被标离开环境，被回收。


 
```

2. 引用计数（现代浏览器不再使用）
  引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。

    但是很重要的一点是当遇到循环引用的时候，函数的引用次数就不会为0，所以不会被垃圾回收器回收内存，会造成内存泄露。在IE中涉及DOM对象，就会存在循环引用的问题。

```

 
function test(){ 
 var a = {} ; //a的引用次数为0 
 
 var b = a ; //a的引用次数加1，为1 
 
 var c =a; //a的引用次数再加1，为2 
 
 var b ={}; //b解除对a的引用，a的引用次数减1，为1 
}

// 循环引用
function cycle() {
    var o1 = {};
    var o2 = {};
    o1.a = o2;
    o2.a = o1; 

    return "cycle reference!"
}
cycle();

//数组
let arr = [1,2,3]

虽然这里没有引用arr，arr对他的值发生了引用，所以会一直存在内存中，可以采用 arr=null来解除引用
```
虽然有了自动垃圾收集机制，我们可以不必太过关注一些内存泄漏的问题，但有些情况下还是会发生这种问题

#### js的常见内存泄漏
1. 全局变量引起的内存泄漏
```
function leaks(){  
    leak = 'xxxxxx';//leak 成为一个全局变量，不会被回收
}
```
2. 闭包引起的内存泄漏
```
var leaks = (function(){  
    var leak = 'xxxxxx';// 被闭包所引用，不会被回收
    return function(){
        console.log(leak);
    }
})()
```
3. dom清空或删除时，事件未清除导致的内存泄漏
```
<div id="container">  
</div>

$('#container').bind('click', function(){
    console.log('click');
}).remove();

// zepto 和原生 js下，#container dom 元素，还在内存里jquery 的 empty和 remove会帮助开发者避免这个问题

<div id="container">  
</div>

$('#container').bind('click', function(){
    console.log('click');
}).off('click').remove();
//把事件清除了，即可从内存中移除
```
4. 计时器或回调函数
定时器setInterval
```
var a = fun();
setInterval(function(){
  var node = document.getElementById('node');
  if(node){
     node.innerHTML = 'test';
  }
}，1000);
```
节点node或数据不需要时，定时器setInterval依然指向这些数据，所以即使node节点被溢出，interval仍旧存活并且垃圾回收期没法回收。

解决是终止定时器。

这种循环定时器，是一定要设置关闭条件，然后将其clear并且将timer指向null]

#### 解决方法及性能优化
发生内存泄漏肯定是不愿看到的，我们可以采取：
一旦确定数据不再使用，可以手动将其值设置为null来释放其引用。 —— 解除引用。