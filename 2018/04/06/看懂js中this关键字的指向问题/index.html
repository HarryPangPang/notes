<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 看懂js中this关键字的指向问题 · HarryPang's Blog</title><meta name="description" content="看懂js中this关键字的指向问题 - Harry Pang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/ZhangQiangQQ/atom.xml" title="HarryPang's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/2019/01/11/关于我" target="_self" class="nav-list-link">关于我</a></li><li class="nav-list-item"><a href="https://github.com/ZhangQiangQQ/" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">看懂js中this关键字的指向问题</h1><div class="post-info">2018年4月6日</div><div class="post-content"><p>this总是指向函数的直接调用者（而非间接调用者）；如果有new关键字，this指向new出来的那个对象；在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；<br>通俗的讲，因为ｔｈｉｓ只存在于函数中，而函数是需要被调用的，然后ｔｈｉｓ是谁（对象）调用函数就指向谁（对象）。下面我们看看不同情况下的ｔｈｉｓ指向情况。</p>
<p>１）单纯的函数调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123; </span><br><span class="line">    this.x = 1; </span><br><span class="line">    alert(this.x)／／结果为：１</span><br><span class="line"> &#125;;</span><br><span class="line">test();／／这里window调用了test函数， window.x即this.x</span><br><span class="line">alert(this.x) ;／／结果为：１</span><br><span class="line">alert(&apos;x&apos; in window);／／结果为：true</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">２）函数作为对象的方法调用</span><br></pre></td></tr></table></figure></p>
<p>var test = {<br>    a:1,<br>    b:function(){<br>        alert(this.a);<br>    }<br>};<br>test.b();／／结果为：1　test调用了函数b，this指向test<br>alert(this.a);//结果为：undefined　 window调用了alert函数，this指向 window而window里并没有a这个属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注：在非严格模式下，this没有正确指向，则指向window对象，在严格模式下，没有正确指向，为 undefined。默认就是非严格模式。</span><br><span class="line"></span><br><span class="line">3)作为构造函数调用</span><br></pre></td></tr></table></figure></p>
<pre><code>function test(){
    this.a = 1;
};
var test2 = new test();
alert(test2.a);//结果为：1
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里this指向的是构造的新对象，也就是 test2，所以test2也有了属性a并等于1。</span><br><span class="line"></span><br><span class="line">4)apply()、call() 调用</span><br></pre></td></tr></table></figure>
<pre><code>var a = 0,
    test1 = {
        a:1,
        fun:function(){
            alert(this.a);
        }
    },
    test2 = {
        a:2
    };
test1.fun();//结果为：1
test1.fun.call(test2);//结果为：2
test1.fun.call();//结果为：0
</code></pre><p><code>`</code></p>
<p>这里的三次调用，this分别指向test1、test2和window。第一种前面已经提到了，第二种是通过call或者apply方法使fun中原本指向test1的this变成了指向test2（即call、apply方法的第一个参数）。第三种情况属于第一个参数为空（好像为undefined时也会指向window）时，会默认指向window，..call() =》 ..call(window)。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/06/17/如何理解es6中的class以及class中的constructor函数/" class="prev">PREV</a><a href="/2018/03/14/zabbix平台搭建/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="https://github.com/ZhangQiangQQ">Harry Pang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>