<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HarryPang&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/ZhangQiangQQ/"/>
  <updated>2019-07-06T02:30:29.587Z</updated>
  <id>https://github.com/ZhangQiangQQ/</id>
  
  <author>
    <name>Harry Pang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>是时候谈谈JavaScript面向对象了</title>
    <link href="https://github.com/ZhangQiangQQ/2019/05/14/%E6%98%AF%E6%97%B6%E5%80%99%E8%B0%88%E8%B0%88JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BA%86/"/>
    <id>https://github.com/ZhangQiangQQ/2019/05/14/是时候谈谈JavaScript面向对象了/</id>
    <published>2019-05-14T08:05:19.000Z</published>
    <updated>2019-07-06T02:30:29.587Z</updated>
    
    <content type="html"><![CDATA[<p>前端技术尤其是JavaScript，经常被后端觉得不是正经编程语言，大多数是因为JavaScript是基于函数的语言，因此潜在上使得它在使用和发展上有所局限。</p><p>我记得在90年代末和21世纪初，JavaScript主要用于使html页面更加动态。比如实现一些弹窗，跑马灯之类的视觉效果。</p><p>现在，我们有很多框架，库，甚至后端系统都在使用JavaScript。用JavaScript开发一个移动应用和桌面应用程序-在以前是闻所未闻的，但如今，这些我们经常听说甚至已经投入使用了。现在我们还可以用JavaScript实现跨平台开发！</p><p>JavaScript无处不在，你可以使用JavaScript轻松完成很多有趣的东西。但随之而来的是潜在的长期问题。许多JavaScript开发者并没有像java开发者一样习惯使用面向对象编程，或者说没有面向对象编程这方面的训练。这很正常，因为我们经常为了追赶进度完成手头的工作，忽略了一些我们还不知道的内容</p><h3 id="什么是面向对象编程？"><a href="#什么是面向对象编程？" class="headerlink" title="什么是面向对象编程？"></a>什么是面向对象编程？</h3><p>面向对象的编程是一种思想，一种心态。它背后的想法是，你为你想象中的对象创建了一个蓝图，然后一次又一次地调用它来完成各种各样的功能。每次你想使用一个对象时，你必须先创建它这样它才会存在，然后设置它的属性，以便使用附加到它的功能。这些功能被称为“方法”。</p><p>例如，一个CustomerOrder对象可能附加了一个GET：Order Details功能(又名方法)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//基于类</span><br><span class="line">class CustomerOrder&#123;</span><br><span class="line">  constructor(customerId,orderId)&#123;</span><br><span class="line">    this.customerId = customerId;</span><br><span class="line">    this.orderId = orderId</span><br><span class="line">  &#125;</span><br><span class="line">  get orderDetails()&#123;</span><br><span class="line">    return this.pullOrderDetails();</span><br><span class="line">  &#125;</span><br><span class="line">  pullOrderDetails()&#123;</span><br><span class="line">    //一些操作</span><br><span class="line">    return </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const order_1 = new CustomerOrder(87873,&quot;Cus-001&quot;)</span><br><span class="line"></span><br><span class="line">console.log(order_1.orderDetails)</span><br></pre></td></tr></table></figure></p><p>我们来看另一个基于函数的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//基于函数</span><br><span class="line">const customerId = 8787</span><br><span class="line">const orderId = &quot;Cus-001&quot;</span><br><span class="line">function pullOrderDetails(customerId,orderId)&#123;</span><br><span class="line">  //一些操作</span><br><span class="line">  return</span><br><span class="line">&#125;</span><br><span class="line">console.log(pullOrderDetails(87873,&quot;Cus-001&quot;))</span><br></pre></td></tr></table></figure><p>上面的问题在于，函数的数量多起来时，很快就会变得混乱。虽然将所有内容都编写为函数，然后根据需要来调用，在一开始可能会很方便，但是日积月累，函数之间的关联关系错综复杂，一旦发生变更，你可能需要修改很多函数，也会引起很多未知问题。</p><p>可能有些难理解，我们看下面的图（使用类的情况）：</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/14/16ab412a436cc03d?w=707&amp;h=431&amp;f=png&amp;s=76202" alt=""></p><p>constructor是设置变量的地方，Getter和setter方法是类做事的入口。使用什么函数以及如何使用它们都是隐藏的。每次创建一个新对象时，整个类及其方法都会被“克隆”，并可访问需要的内容。发生变更时，我们也只需要在类上一次修改，便可以全局生效。</p><p>我们再看下面的图（使用函数的情况）</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/14/16ab41e84a261066?w=514&amp;h=557&amp;f=png&amp;s=100265" alt=""></p><p>当我们用一堆松散的函数编写代码时，它的更改范围通常没有定义。依赖项注入是使函数正常工作所必需的，而一个函数常常需要另一个函数才能正常工作。从表面上看，基于函数的编程可能一开始看起来很简单，但从长远来看，维护它是一个逻辑上的噩梦。</p><p>使用面向对象编程，您只需要调用getter和setter方法来访问黑盒功能。作为类的消费者，你不需要知道它是如何工作的。你只需要知道它是有效的。</p><h3 id="为什么我们要在JavaScript中采用面向对象编程"><a href="#为什么我们要在JavaScript中采用面向对象编程" class="headerlink" title="为什么我们要在JavaScript中采用面向对象编程"></a>为什么我们要在JavaScript中采用面向对象编程</h3><p>上面的两幅图能看出来，过度依赖基于函数的编程可能很快就能完成任务，但是长远来看，这会存在很高的风险。</p><p>随着代码量的增长，你就需要改变组织代码的思维方式，并考虑采用面向对象。与通过一系列依赖注入串在一起的函数相比，对象的则更容易追踪和掌握。</p><p>下面的代码是基于函数：<br><img src="https://user-gold-cdn.xitu.io/2019/5/14/16ab43201df8f7ec?w=659&amp;h=663&amp;f=png&amp;s=375922" alt=""><br>你会需要知道整个调用链，以便弄清楚如何实现你的目的。当然也很乱，不易理解。</p><p>基于函数的编程的问题是，链的中断可能导致整个流程的失败。对于对象，一个被破坏的方法不会(也不应该)影响类的其他部分。</p><p>下面的代码是基于类（面向对象）：<br><img src="https://user-gold-cdn.xitu.io/2019/5/14/16ab434d086a85ce?w=622&amp;h=661&amp;f=png&amp;s=312815" alt=""></p><p>这种方法，可能代码量不会少多少，但你可以复用它，而不需要写很长的调用链。</p><p>当你思考问题时，是基于类，而不是一系列相互关联的函数时，代码自然会减少出现问题的风险。因为每一次依赖注入都会增加一次潜在错误的可能，而且寻找错误时，也会花费更多的时间和精力。、</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>面向对象编程是一种主动的行为，你可以选择使用，也可以选择不使用。随着前端体系的日益庞大，代码量和应用场景也远超于从前，我们更需要思考面向对象编程的重要性。</p><p>面向对象编程的资料：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object-oriented_JS" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object-oriented_JS</a></p><p>———————————————————————————————————————————————————</p><p>放学别走！长按二维码关注 【技术人生路】，无偿免费获取前端学习进阶资料，培训实战视频，就业指导等众多福利哦。我相信我们都是爱学习爱进步的呀！</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/10/16aa05e97ba82933?w=258&amp;h=258&amp;f=jpeg&amp;s=28158" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前端技术尤其是JavaScript，经常被后端觉得不是正经编程语言，大多数是因为JavaScript是基于函数的语言，因此潜在上使得它在使用和发展上有所局限。&lt;/p&gt;
&lt;p&gt;我记得在90年代末和21世纪初，JavaScript主要用于使html页面更加动态。比如实现一些弹窗
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>函数声明？函数表达式？我该怎么选？！</title>
    <link href="https://github.com/ZhangQiangQQ/2019/05/10/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%EF%BC%9F%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9F%E6%88%91%E8%AF%A5%E6%80%8E%E4%B9%88%E9%80%89%EF%BC%9F%EF%BC%81/"/>
    <id>https://github.com/ZhangQiangQQ/2019/05/10/函数声明？函数表达式？我该怎么选？！/</id>
    <published>2019-05-10T06:48:36.000Z</published>
    <updated>2019-07-06T02:30:29.586Z</updated>
    
    <content type="html"><![CDATA[<p>我们在日常开发中经常使用函数，聪明的你肯定已经用的炉火纯青了。<figure class="highlight plain"><figcaption><span>doStuff（）&#123;&#125;```和```（）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">***注：我们这里用的例子都是JavaScript**</span><br><span class="line"></span><br><span class="line">### 第一个不同：名称</span><br><span class="line">当你用一个名称创建函数时，这是一个函数声明。在函数表达式中可以省略该名称，使该函数“匿名”。</span><br><span class="line">#### 函数声明：</span><br><span class="line">`function doStuff() &#123;&#125;;`</span><br><span class="line">#### 函数函数表达式：</span><br><span class="line"></span><br><span class="line">`const doStuff = function() &#123;&#125;`</span><br><span class="line"></span><br><span class="line">日常中我们经常使用ES6创建函数表达式</span><br><span class="line"></span><br><span class="line">`const doStuff = ()=&#123;&#125;`</span><br><span class="line"></span><br><span class="line">### 第二个不同：提升</span><br><span class="line">提升是指函数和变量的提升，变量声明和函数声明提升至当前作用域的顶端，然后进行接下来的处理。</span><br><span class="line"></span><br><span class="line">#### 函数声明会被提升但函数表达式不会。</span><br><span class="line"></span><br><span class="line">我们可以通过例子来加深理解：</span><br></pre></td></tr></table></figure></p><p>//函数声明<br>doStuff();<br>function doStuff() { console.log(‘haha’)};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">结果：</span><br><span class="line">![](https://user-gold-cdn.xitu.io/2019/5/10/16aa030f3dd7cd09?w=361&amp;h=103&amp;f=png&amp;s=5972)</span><br><span class="line">看出来没有任何问题。</span><br><span class="line"></span><br><span class="line">看下一个例子</span><br></pre></td></tr></table></figure></p><p>//函数表达式<br>doStuff();<br>const doStuff = () =&gt; {console.log(‘haha’)};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![](https://user-gold-cdn.xitu.io/2019/5/10/16aa0341887f5f31?w=439&amp;h=122&amp;f=png&amp;s=9366)</span><br><span class="line"></span><br><span class="line">看，这就报错了。</span><br><span class="line"></span><br><span class="line">函数表达式实际解析的过程是这样的：</span><br></pre></td></tr></table></figure></p><p>const doStuff;<br>doStuff();<br>doStuff = () =&gt; {console.log(‘haha’)};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">***注：函数声明提升的优先级比变量提升高。***</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 使用函数表达式的情况：</span><br><span class="line">通过上面两个例子，看起来函数声明在提升方面比函数表达式有用的多。但是在他们两个之间选择的时候应该如何抉择呢？</span><br><span class="line"></span><br><span class="line">调用函数表达式可以避免污染全局环境，因为你不知道你的程序有多少不同的函数，如果你使用函数表达式可能就会覆盖了别人的函数，采用函数表达式，就会避免这些问题。</span><br><span class="line"></span><br><span class="line">#### 立即执行函数（IIFE）</span><br><span class="line">IIFE - 立即调用函数表达式 - 就是字面意思。在创建函数后立即调用函数，使用IIFE，如下所示：</span><br></pre></td></tr></table></figure></p><p>(function() =&gt; {})()<br>//或者<br>(() =&gt; {})()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 回调（callback）</span><br><span class="line">传递给另一个函数的函数通常在JavaScript中称为“回调”。，如下所示：</span><br></pre></td></tr></table></figure></p><p>function mapAction(item) {<br>  // do stuff to an item<br>}<br>array.map(mapAction)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里的问题是mapAction可用于整个应用程序- 其实没有必要。如果该回调是一个函数表达式，它在函数外就不可用了：</span><br></pre></td></tr></table></figure></p><p>array.map(item =&gt; { //do stuff to an item })<br>//或者<br>const mapAction = function(item) {<br>  // do stuff to an item<br>}<br>array.map(mapAction)<br><code>`</code><br>虽然<code>mapAction</code>函数只有在他初始化之后才能使用</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简而言之，如果要在全局范围内创建函数并在整个代码中使用它，请使用函数声明。</p><p>使用函数表达式来限制函数的可用位置，保持全局环境的整洁干净。<br>————————————————————————————————————————————————</p><p>放学别走！长按二维码关注 【技术人生路】，无偿免费获取前端学习进阶资料，培训实战视频，就业指导等众多福利哦。我相信我们都是爱学习爱进步的呀！</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/10/16aa05e97ba82933?w=258&amp;h=258&amp;f=jpeg&amp;s=28158" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在日常开发中经常使用函数，聪明的你肯定已经用的炉火纯青了。&lt;figure class=&quot;highlight plain&quot;&gt;&lt;figcaption&gt;&lt;span&gt;doStuff（）&amp;#123;&amp;#125;```和```（）&lt;/span&gt;&lt;/figcaption&gt;&lt;table
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>手把手教你实现脚手架工具Koa-generator</title>
    <link href="https://github.com/ZhangQiangQQ/2019/05/09/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B0%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7Koa-generator/"/>
    <id>https://github.com/ZhangQiangQQ/2019/05/09/手把手教你实现脚手架工具Koa-generator/</id>
    <published>2019-05-09T08:36:13.000Z</published>
    <updated>2019-07-06T02:30:29.587Z</updated>
    
    <content type="html"><![CDATA[<p>我们日常中经常使用各种cli来加速我们的工作，你们也一定和我一样想知道这些cli内部都干了什么？接下来我们就以实现一个koa-generator来打开脚手架工具的大门，来跟着我一步一步做吧：</p><p><code>为了加快我们的学习进度，更快的理解cli，我们这里会省略一些内容，旨在帮助大家更快建立基本的概念和入门方法</code></p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>首先我们先对我们要实现的工具做一个简单的需求分析：</p><ol><li>自动化生成koa初始项目结构</li><li>可以自定义一些内容</li><li>发布</li></ol><p>是不是很简单？没错，真的很简单！</p><h3 id="逐步实现"><a href="#逐步实现" class="headerlink" title="逐步实现"></a>逐步实现</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>想要自动化生成koa初始项目结构的前提，就是要知道我们构建出来的结构是什么样的：</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/9/16a9b4ab026e0644?w=299&amp;h=371&amp;f=png&amp;s=17255" alt=""></p><p>上图就是我们想要生成的项目结构</p><p>明确了我们的目的接下来就开始着手吧！</p><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><h4 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h4><p>创建文件夹<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir koa-simple-generator</span><br></pre></td></tr></table></figure></p><h4 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h4><p>进入项目目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd koa-simple-generator</span><br></pre></td></tr></table></figure></p><h4 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h4><p>初始化npm（等不及实践就一路enter，后面也可以再做修改）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure></p><h4 id="2-4"><a href="#2-4" class="headerlink" title="2.4"></a>2.4</h4><p>打开我们的package.json，如下</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/9/16a9b511c3717d41?w=498&amp;h=235&amp;f=png&amp;s=14605" alt=""></p><p>将下面的代码复制到package.json里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;koa-simple-generator&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &quot;main&quot;: &quot;bin/wowKoa&quot;,</span><br><span class="line">  &quot;bin&quot;: &#123;</span><br><span class="line">    &quot;koa2&quot;: &quot;./bin/wowKoa&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;commander&quot;: &quot;2.7.1&quot;,</span><br><span class="line">    &quot;mkdirp&quot;: &quot;0.5.1&quot;,</span><br><span class="line">    &quot;sorted-object&quot;: &quot;1.0.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;mocha&quot;: &quot;2.2.5&quot;,</span><br><span class="line">    &quot;rimraf&quot;: &quot;~2.2.8&quot;,</span><br><span class="line">    &quot;supertest&quot;: &quot;1.0.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;engines&quot;: &#123;</span><br><span class="line">    &quot;node&quot;: &quot;&gt;= 7.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. dependencies和devDependencies简单来说就是应用的依赖包，devDependencies只会在开发环境安装</span><br><span class="line"></span><br><span class="line">2. 这句话的意思是我们的这个工具需要node7.0及以上的版本才能支持</span><br><span class="line">&quot;engines&quot;: &#123;</span><br><span class="line">    &quot;node&quot;: &quot;&gt;= 7.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">重点是这两句</span><br><span class="line">&quot;main&quot;: &quot;bin/wowKoa&quot;,</span><br><span class="line">  &quot;bin&quot;: &#123;</span><br><span class="line">    &quot;wowKoa&quot;: &quot;./bin/wowKoa&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  意思是默认执行的是bin目录下的wowKoa，</span><br><span class="line">  执行wowKoa的命令，执行的也是bin目录下的wowKoa，</span><br></pre></td></tr></table></figure><p>####2.5<br>接下来安装我们的依赖吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i</span><br></pre></td></tr></table></figure></p><h4 id="2-6"><a href="#2-6" class="headerlink" title="2.6"></a>2.6</h4><p>安装完，我们新建一个目录template<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir template</span><br></pre></td></tr></table></figure></p><p>然后我们可以把我们想要生成的目录结构拷贝进去，这里我就只是把koa2的目录拷贝进去，现在我们的目录长这样：</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/9/16a9b5f29ca24773?w=256&amp;h=240&amp;f=png&amp;s=10184" alt=""></p><h4 id="2-7"><a href="#2-7" class="headerlink" title="2.7"></a>2.7</h4><p>新建bin目录，在bin下新建文件wowKoa</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/9/16a9b632f0c8d54e?w=314&amp;h=166&amp;f=png&amp;s=7354" alt=""></p><h4 id="2-8"><a href="#2-8" class="headerlink" title="2.8"></a>2.8</h4><p>接下来就是关键了，我们的所有工作都是在bin下的wowKoa文件里完成的<br>直接复制粘贴下面的，然后进入项目目录运行<code>node bin/wowKoa</code>就能看到结果了</p><p><em>代码我已经大部分都注释啦</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env node</span><br><span class="line"> // 告诉Unix和Linux系统这个文件中的代码用node可执行程序去运行</span><br><span class="line">var program = require(&apos;commander&apos;);</span><br><span class="line">var mkdirp = require(&apos;mkdirp&apos;);</span><br><span class="line">var os = require(&apos;os&apos;);</span><br><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">var fsm = require(&apos;fs-extra&apos;)</span><br><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line">var readline = require(&apos;readline&apos;);</span><br><span class="line">var pkg = require(&apos;../package.json&apos;);</span><br><span class="line"></span><br><span class="line">// 退出node进程</span><br><span class="line">var _exit = process.exit;</span><br><span class="line">// s.EOL属性是一个常量，返回当前操作系统的换行符（Windows系统是\r\n，其他系统是\n）</span><br><span class="line">var eol = os.EOL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var version = pkg.version;</span><br><span class="line">// Re-assign process.exit because of commander</span><br><span class="line">// TODO: Switch to a different command framework</span><br><span class="line">process.exit = exit</span><br><span class="line"></span><br><span class="line">program</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * .version(&apos;0.0.1&apos;, &apos;-v, --version&apos;)</span><br><span class="line">     * 1版本号&lt;必须&gt;,</span><br><span class="line">     * 2自定义标志&lt;可省略&gt;：默认为 -V 和 --version</span><br><span class="line">     * </span><br><span class="line">     * .option(&apos;-n, --name&lt;path&gt;&apos;, &apos;name description&apos;, &apos;default name&apos;)</span><br><span class="line">     * 1 自定义标志&lt;必须&gt;：分为长短标识，中间用逗号、竖线或者空格分割；标志后面可跟必须参数或可选参数，前者用 &lt;&gt; 包含，后者用 [] 包含</span><br><span class="line">     * 2 选项描述&lt;省略不报错&gt;：在使用 --help 命令时显示标志描述</span><br><span class="line">     * 3 默认值&lt;可省略&gt;</span><br><span class="line">     * </span><br><span class="line">     * .usage(&apos;[options] [dir]&apos;)</span><br><span class="line">     * 作用：只是打印用法说明</span><br><span class="line">     * </span><br><span class="line">     * .parse(process.argv)</span><br><span class="line">     * 作用：用于解析process.argv，设置options以及触发commands</span><br><span class="line">     * process.argv获取命令行参数</span><br><span class="line">     * </span><br><span class="line">     * </span><br><span class="line">     * Commander提供了api来取消未定义的option自动报错机制， .allowUnknownOption()</span><br><span class="line">     */</span><br><span class="line">    .version(version, &apos;-v, --version&apos;)</span><br><span class="line">    .allowUnknownOption()</span><br><span class="line">    .usage(&apos;[options] [dir]&apos;)</span><br><span class="line">    .option(&apos;-f, --force&apos;, &apos;force on non-empty directory&apos;)</span><br><span class="line">    .parse(process.argv);</span><br><span class="line"></span><br><span class="line">// 没有退出时执行主函数</span><br><span class="line">if (!exit.exited) &#123;</span><br><span class="line">    main();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 主函数</span><br><span class="line"> */</span><br><span class="line">function main() &#123;</span><br><span class="line">    // 获取当前命令执行路径</span><br><span class="line">    var destinationPath = program.args.shift() || &apos;.&apos;;</span><br><span class="line">    // 根据文件夹名称定义appname</span><br><span class="line">    // 用于package.json里的name</span><br><span class="line">    var appName = path.basename(path.resolve(destinationPath));</span><br><span class="line"></span><br><span class="line">    // 判断当前文件目录是否为空</span><br><span class="line">    emptyDirectory(destinationPath, function (empty) &#123;</span><br><span class="line">        // 如果为空或者强制执行时，就直接生成项目</span><br><span class="line">        if (empty || program.force) &#123;</span><br><span class="line">            createApplication(appName, destinationPath);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 否则询问</span><br><span class="line">            confirm(&apos;当前文件夹不为空，是否继续？[y/N] &apos;, function (ok) &#123;</span><br><span class="line">                if (ok) &#123;</span><br><span class="line">                        // 控制台不再输入时销毁</span><br><span class="line">                        process.stdin.destroy();</span><br><span class="line">                        createApplication(appName, destinationPath);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    console.error(&apos;aborting&apos;);</span><br><span class="line">                    exit(1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Check if the given directory `path` is empty.</span><br><span class="line"> * 判断文件夹是否为空</span><br><span class="line"> * @param &#123;String&#125; path</span><br><span class="line"> * @param &#123;Function&#125; fn</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">function emptyDirectory(path, fn) &#123;</span><br><span class="line">    fs.readdir(path, function (err, files) &#123;</span><br><span class="line">        if (err &amp;&amp; &apos;ENOENT&apos; != err.code) throw err;</span><br><span class="line">        fn(!files || !files.length);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 在给定路径中创建应用</span><br><span class="line"> * @param &#123;String&#125; path</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">function createApplication(app_name, path) &#123;</span><br><span class="line">    // wait的值等于complete函数执行的次数</span><br><span class="line">    // 用于选择在哪一次complete函数执行后执行控制台打印引导使用的文案</span><br><span class="line">    var wait = 1;</span><br><span class="line">    console.log();</span><br><span class="line"></span><br><span class="line">    function complete() &#123;</span><br><span class="line">        if (--wait) return;</span><br><span class="line">        var prompt = launchedFromCmd() ? &apos;&gt;&apos; : &apos;$&apos;;</span><br><span class="line"></span><br><span class="line">        console.log();</span><br><span class="line">        console.log(&apos;   install dependencies:&apos;);</span><br><span class="line">        console.log(&apos;     %s cd %s &amp;&amp; npm install&apos;, prompt, path);</span><br><span class="line">        console.log();</span><br><span class="line">        console.log(&apos;   run the app:&apos;);</span><br><span class="line"></span><br><span class="line">        // 根据控制台的环境不同打印不同文案（linux或者win）</span><br><span class="line">        if (launchedFromCmd()) &#123;</span><br><span class="line">            console.log(&apos;     %s SET DEBUG=koa* &amp; npm start&apos;, prompt, app_name);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(&apos;     %s DEBUG=%s:* npm start&apos;, prompt, app_name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    copytmp(complete, path,app_name)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 拷贝模拟里的文件到本地</span><br><span class="line">function copytmp(fn, destinationPath,app_name) &#123;</span><br><span class="line">    // 获取模板文件的文件目录</span><br><span class="line">    tmpPath = path.join(__dirname, &apos;..&apos;, &apos;template&apos;)</span><br><span class="line">    // 创建目录</span><br><span class="line">    fsm.ensureDir(destinationPath + &apos;/&apos;+app_name)</span><br><span class="line">        .then(() =&gt; &#123;</span><br><span class="line">            // 拷贝模板</span><br><span class="line">            fsm.copy(tmpPath, destinationPath + &apos;/&apos;+app_name, err =&gt; &#123;</span><br><span class="line">                if (err) return console.log(err)</span><br><span class="line">                fn()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Determine if launched from cmd.exe</span><br><span class="line"> * 判断控制台环境（liux或者win获取其他）</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">function launchedFromCmd() &#123;</span><br><span class="line">    return process.platform === &apos;win32&apos; &amp;&amp;</span><br><span class="line">        process.env._ === undefined;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * node是使用process.stdin和process.stdout来实现标准输入和输出的</span><br><span class="line"> * readline 模块提供了一个接口，用于一次一行地读取可读流（例如 process.stdin）中的数据。 它可以使用以下方式访问：</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">var rl = readline.createInterface(&#123;</span><br><span class="line">    input: process.stdin,</span><br><span class="line">    output: process.stdout</span><br><span class="line">&#125;);</span><br><span class="line">// 控制台问答</span><br><span class="line">function confirm(msg, callback) &#123;</span><br><span class="line">    rl.question(msg, function (input) &#123;</span><br><span class="line">        callback(/^y|yes|ok|true$/i.test(input));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 控制台问答</span><br><span class="line">function wrieQuestion(msg, callback) &#123;</span><br><span class="line">    rl.question(msg, function (input) &#123;</span><br><span class="line">        // rl.close()后就不再监听控制台输入了</span><br><span class="line">        rl.close();</span><br><span class="line">        callback(input)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 通过fs读取模板文件内容</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">function loadTemplate(name) &#123;</span><br><span class="line">    return fs.readFileSync(path.join(__dirname, &apos;..&apos;, &apos;template&apos;, name), &apos;utf-8&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * echo str &gt; path.</span><br><span class="line"> * 写入文件</span><br><span class="line"> * @param &#123;String&#125; path</span><br><span class="line"> * @param &#123;String&#125; str</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">function write(path, str, mode) &#123;</span><br><span class="line">    fs.writeFileSync(path, str, &#123; mode: mode || 0666 &#125;);</span><br><span class="line">    console.log(&apos;   \x1b[36mcreate\x1b[0m : &apos; + path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 这里是主要解决在winodws上的一些bug，不用卡在这里，核心目的就是为了能让进程优雅退出</span><br><span class="line"> * Graceful exit for async STDIO</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">function exit(code) &#123;</span><br><span class="line">    // flush output for Node.js Windows pipe bug</span><br><span class="line">    // https://github.com/joyent/node/issues/6247 is just one bug example</span><br><span class="line">    // https://github.com/visionmedia/mocha/issues/333 has a good discussion</span><br><span class="line">    function done() &#123;</span><br><span class="line">        if (!(draining--)) _exit(code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var draining = 0;</span><br><span class="line">    var streams = [process.stdout, process.stderr];</span><br><span class="line"></span><br><span class="line">    exit.exited = true;</span><br><span class="line"></span><br><span class="line">    streams.forEach(function (stream) &#123;</span><br><span class="line">        // submit empty write request and wait for completion</span><br><span class="line">        draining += 1;</span><br><span class="line">        stream.write(&apos;&apos;, done);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们日常中经常使用各种cli来加速我们的工作，你们也一定和我一样想知道这些cli内部都干了什么？接下来我们就以实现一个koa-generator来打开脚手架工具的大门，来跟着我一步一步做吧：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;为了加快我们的学习进度，更快的理解cli，我们这里会省略
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>10个前端面试必会题目！（适用于中高级）</title>
    <link href="https://github.com/ZhangQiangQQ/2019/05/07/10%E4%B8%AA%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%BF%85%E4%BC%9A%E9%A2%98%E7%9B%AE%EF%BC%81%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E4%B8%AD%E9%AB%98%E7%BA%A7%EF%BC%89/"/>
    <id>https://github.com/ZhangQiangQQ/2019/05/07/10个前端面试必会题目！（适用于中高级）/</id>
    <published>2019-05-07T09:04:14.000Z</published>
    <updated>2019-07-06T02:30:29.586Z</updated>
    
    <content type="html"><![CDATA[<p>现在大部分公司的管理者都会通过技术面试来考察开发者的能力。如果你成为了候选人，那你一定需要去经历面试。</p><p>大部分的面试相信大家一定经历过，但是其实我们不应该过度关注于语法和一些怪异生僻的特性中。诚然这些能考察到候选人的基础功扎实与否，但我们应该更多的是从全局来考虑，询问架构和范例（这方面决定会对整个项目有重大的影响）。</p><p>语法和特性其实都能在谷歌中找到。但是软件工程师的智慧和JS开发者在经验中获得的通用范例和用法是无法从谷歌中获得的。</p><p>Javascript是特殊的，他现在几乎在所有大型应用中都扮演中重要的角色。那你又知道JS和其他的语言有什么不同之处吗？</p><p>接下来的几个问题会帮助你探索真正需要关注的内容：</p><h3 id="1-你能说出两个在Javascript中很重要的编程范式吗？"><a href="#1-你能说出两个在Javascript中很重要的编程范式吗？" class="headerlink" title="1. 你能说出两个在Javascript中很重要的编程范式吗？"></a>1. 你能说出两个在Javascript中很重要的编程范式吗？</h3><p>Javascript是多范式语言：<strong>命令式/过程式，函数式，面向对象</strong>。Javascript支持通过<strong>原型继承</strong>实现面向对象编程</p><p><strong>优秀回答：</strong></p><ul><li>原型继承（或者原型）</li><li>函数式编程（闭包，一等函数，lambda演算，箭头函数）</li></ul><p><strong>红色预警：</strong><br>-不知道范式是什么，也没有提及原型面向对象或者函数式编程</p><p>参考：</p><p><a href="https://www.cnblogs.com/sirkevin/p/8283110.html" target="_blank" rel="noopener">https://www.cnblogs.com/sirkevin/p/8283110.html</a></p><p><a href="https://www.cnblogs.com/nunn/p/3460175.html" target="_blank" rel="noopener">https://www.cnblogs.com/nunn/p/3460175.html</a></p><h3 id="2-什么是函数式编程"><a href="#2-什么是函数式编程" class="headerlink" title="2.什么是函数式编程"></a>2.什么是函数式编程</h3><p>函数式编程，可以归结为面向过程的程序设计，但是结合了更多的数学计算的思想。函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p><p>函数式编程是JavaScript中的一个基本概念（JavaScript两大支柱之一（原型继承和函数式编程））</p><p><strong>优秀回答：</strong></p><ul><li>纯函数</li><li>避免副作用</li><li>简单的函数功能组合</li><li>函数语言的例子：Lisp，ML，Haskell，Erlang，Clojure，Elm，F Sharp，OCaml等……</li><li>提到函数式编程的功能：一等函数，高阶函数，函数作为参数/值</li></ul><p><strong>红色预警：</strong></p><ul><li>没有提到纯函数，或者避免副作用</li><li>无法提供函数式编程语言的示例</li><li>无法识别启用函数式编程的JavaScript功能</li></ul><h3 id="3-类继承和原型继承有什么区别"><a href="#3-类继承和原型继承有什么区别" class="headerlink" title="3.类继承和原型继承有什么区别"></a>3.类继承和原型继承有什么区别</h3><p><strong>类继承：</strong> JavaScript本来是没有类继承的，我们可以通过关键词new来将构造函数实例化，call和apply方法为类式继承提供了支持。通过改变this的作用环境，使得子类本身具有父类的各种属性。当然，我们现在拥有了ES6的calss，也可以使用calss来实现类继承。</p><p><strong>原型继承：</strong> 实例直接从其他对象继承。实例通常通过工厂函数或“Object.create()”实例化。实例可以由许多不同的对象组成，从而可以方便地选择继承。</p><blockquote><p>在JavaScript中，原型继承比类继承更简单、更灵活。</p></blockquote><p><strong>优秀回答：</strong></p><ul><li>类继承：紧密耦合或基于层级的分类</li><li>原型继承：提到了原型委托，功能继承，对象组合。</li><li><strong>红色预警：</strong></li><li>不依赖于原型继承和而类继承的组合</li></ul><h3 id="4-函数式编程与面向对象编程的优缺点是什么？"><a href="#4-函数式编程与面向对象编程的优缺点是什么？" class="headerlink" title="4.函数式编程与面向对象编程的优缺点是什么？"></a>4.函数式编程与面向对象编程的优缺点是什么？</h3><p><strong>面向对象编程的优点：</strong><br>很容易理解对象的基本概念，也很容易解释调用方法的含义。面向对象编程更倾向于命令式而不是声明式，声明式读起来就像是给计算机遵循的直接命令</p><p><strong>面向对象编程的缺点：</strong><br>面向对象编程通常依赖于共享状态。对象和行为通常连接在同一个实体上，该实体可以被任意数量的顺序不确定的函数随机访问，这可能导致不需要的行为，如竞争条件。</p><p><strong>函数式编程的优点：</strong><br>使用函数式编程，程序员可以避免任何共享状态或副作用，从而消除由于多个函数争夺相同资源而导致的错误。与面向对象编程相比，函数式编程从根本上简化，并易于重新组合，以获得更普遍可重用的代码。</p><p>函数式编程倾向于声明式和外延式，它们不详细说明操作的一步一步的指令，而是专注于做什么，让底层函数来处理如何做。这为重构和性能优化留下了巨大的空间，甚至允许你用更高效的算法替换整个算法，而只需很少的代码更改。</p><p>使用纯函数进行计算，也容易跨多个处理器或跨分布式计算集群扩展，而无需担心线程资源冲突、竞争条件等问题。</p><p><strong>函数式编程的缺点：</strong><br>过度使用函数式编程特性(如大型组合)可能会降低可读性，因为生成的代码通常更抽象、更简洁、更不具体。</p><p>与函数式编程相比，更多人熟悉面向对象编程和命令式编程，因此即使是函数式编程中的常见习惯用法也可能让新团队成员感到困惑。</p><p>函数式编程的学习曲线要比面向对象编程陡峭得多，因为面向对象编程的广泛流行使面向对象编程的语言和学习材料变得更加语义化，而函数式编程的语言则趋向于更加学术化和形式化。函数式编程概念经常涉及到使用lambda演算、代数和范畴理论中的习惯用法和符号，所有这些都需要去了解这些领域的知识。</p><p><strong>优秀回答：</strong></p><ul><li>提到共享状态的问题，竞争相同资源的不同事物等等……</li><li>意识到函数式编程能够从根本上简化许多应用程序。</li><li>意识到学习曲线的差异。</li><li>阐明副作用以及它们如何影响程序的可维护性。</li><li>意识到功能强大的代码库可能具有陡峭的学习曲线。</li><li>意识到与同等的函数式编程代码库相比，过多的OOP代码会非常难以应对变化并且非常脆弱。</li></ul><p><strong>红色预警：</strong></p><ul><li>无法列出一种风格或另一种风格的缺点 - 任何一种风格都有其不足。</li></ul><h3 id="5-什么时候适合选择类继承？"><a href="#5-什么时候适合选择类继承？" class="headerlink" title="5. 什么时候适合选择类继承？"></a>5. 什么时候适合选择类继承？</h3><p>答案是啥时候都不适合，多层次的类结构是反模式。<br><strong>优秀回答：</strong></p><ul><li>很少，几乎从来没有，或从未</li><li>单级别的时候有时候是可以的，比如React.Component</li><li>对象继承比类继承更好</li></ul><h3 id="6-什么时候适合原型继承？"><a href="#6-什么时候适合原型继承？" class="headerlink" title="6. 什么时候适合原型继承？"></a>6. 什么时候适合原型继承？</h3><p>原型继承有多种类型：</p><ul><li>原型链</li><li>mixins，Object.assign()</li><li>函数式（别和函数式编程混淆，这里是创建闭包函数实现私有状态/封装）</li></ul><p>每种类型的原型继承都有自己的创建方法，但是它们合成对象的能力都一样，它创建了has-a或uses-a或can-do关系，而不是类继承创建的is-a的关系。</p><p><strong>优秀回答：</strong></p><ul><li>在模块或函数编程没有提供明显解决方案的情况下</li><li>当需要从多个地方组合对象时</li><li>任何需要继承的地方</li></ul><p><strong>红色预警：</strong></p><ul><li>不知道何时使用原型。</li><li>没有意识到mixins或<code>Object.assign（）</code></li></ul><h3 id="7-对象继承比类继承更好是为什么"><a href="#7-对象继承比类继承更好是为什么" class="headerlink" title="7. 对象继承比类继承更好是为什么"></a>7. 对象继承比类继承更好是为什么</h3><p>代码重用应该通过将较小的功能单元组装到新对象中来实现，而不是继承类并创建对象分类法。</p><p>换句话说，使用can-do，has-a或使用关系而不是is-a关系。<br><strong>优秀回答：</strong></p><ul><li>避免使用类层次结构</li><li>避免脆弱的类问题</li><li>避免紧密耦合</li><li>避免严格的分类（强制is-a关系对于新的代码使用是不友好的）</li><li>避免大猩猩香蕉问题（“你想要的是香蕉，你得到的是拿着香蕉的大猩猩，以及整个丛林”）</li><li>使代码更灵活</li></ul><p><strong>红色预警：</strong></p><ul><li>上面的一个都不知道</li></ul><h3 id="8-什么是双向数据绑定和单向数据流，它们有何不同？"><a href="#8-什么是双向数据绑定和单向数据流，它们有何不同？" class="headerlink" title="8. 什么是双向数据绑定和单向数据流，它们有何不同？"></a>8. 什么是双向数据绑定和单向数据流，它们有何不同？</h3><p>双向数据绑定意味着View层数据变化，Model层的数据也会相应变化，反之亦然。</p><p>单向数据流意味着Model层数据变化会引起View层数据变化，但View层数据变化无法引起Model层的数据变化，数据总是朝着一个方向流动（就像React里的store）。这使得理解起来更容易。</p><p>单向数据流具有是确定性的，而双向绑定可能导致更难以遵循和理解的副作用。</p><p><strong>优秀回答：</strong></p><ul><li>React是单向数据流的范例，因此提及React是一个很好的信号。 Cycle.js是单向数据流的另一种流行实现。</li><li>Angular/Vue是一种使用双向绑定的流行框架。</li></ul><p><strong>红色预警：</strong></p><ul><li>不了解任何一个意味着什么，无法阐明差异。</li></ul><h3 id="9-单体架构与微服务架构的优缺点是什么？"><a href="#9-单体架构与微服务架构的优缺点是什么？" class="headerlink" title="9.单体架构与微服务架构的优缺点是什么？"></a>9.单体架构与微服务架构的优缺点是什么？</h3><p>所谓的单体架构就是把所有的业务模块编写在一个项目中，最终会打包成一个war包，然后进行部署</p><p>微服务架构意味着应用程序由许多较小的独立应用程序组成，这些应用程序能够在自己的内存空间中运行，并且可能在许多不同的机器上相互独立地进行扩展和协作。</p><p><strong>单体架构优点：</strong></p><p>单片架构的主要优点是大多数应用程序可以共用很多东西，例如日志记录，速率限制以及审计跟踪和DOS保护等安全功能。</p><p>还有性能优势，因为共享内存访问比进程间通信（IPC）更快。</p><p><strong>单体架构缺点：</strong><br>随着应用程序的发展，应用程序服务往往会紧密耦合和纠缠，从而难以将服务隔离并独立扩展出来，并且实现代码可维护性等。<br>单体架构也很难理解，因为当你查看特定服务或控制器时，可能存在依赖性，副作用等不明显的隐形问题</p><p>它们还可以根据组织方式获得性能优势，因为可以独立于应用程序的其他部分，与核心服务隔离并对其进行伸缩。</p><p><strong>微服务架构优点</strong><br>微服务体系结构通常组织得更好，因为每个微服务都有一个非常特定的任务，并且不关心其他组件的任务。解耦的服务也更容易重新组合和配置，以满足不同应用程序的需要(例如，同时服务于web客户机和公共API)。</p><p><strong>微服务架构缺点</strong><br>微服务部署在虚拟机或容器上，导致VM争用工作激增。<br>运维复杂度提供</p><p><strong>优秀回答：</strong></p><ul><li>微服务架构一开始成本较高，但微服务从长远来看往往会表现更好并且规模更大。</li><li>关于微服务和单片应用程序的实用性。两者在不同情况下的使用选择</li></ul><p><strong>红色预警：</strong></p><ul><li>不了解单体架构和微服务架构之间的差异。</li><li>对微服务的额外开销没有意识到。</li><li>不知道IPC和网络通信对微服务造成的额外性能开销。</li><li>无法明确解决单片应用程序的分离方式，以便在时机成熟时将它们轻松拆分为微服务。</li><li>低估了独立可扩展微服务的优势。</li></ul><h3 id="10-什么是异步编程，为什么它在JavaScript中很重要？"><a href="#10-什么是异步编程，为什么它在JavaScript中很重要？" class="headerlink" title="10. 什么是异步编程，为什么它在JavaScript中很重要？"></a>10. 什么是异步编程，为什么它在JavaScript中很重要？</h3><p>同步编程意味着，除了条件和函数调用之外，代码从上到下依次执行，阻塞长时间运行的任务，如网络请求和磁盘I / O等。</p><p>异步编程意味着引擎在一个事件循环中运行。当需要阻塞操作时，将启动请求，并且代码将继续运行，而不会阻塞结果。当响应就绪时，将触发一个中断，这时运行一个事件处理程序，其中控制流将继续运行。通过这种方式，一个程序线程可以处理许多并发操作。</p><p>用户界面本质上是异步的，并且花费大部分时间等待用户输入来中断事件循环并触发事件处理程序。</p><p>默认情况下，Node是异步的，这意味着服务器的工作方式大致相同，在循环中等待网络请求，并在处理第一个请求时接受更多的传入请求。</p><p>这在JavaScript中很重要，因为它非常适合UI代码，并且非常有利于服务器上的性能。</p><p><strong>优秀回答：</strong></p><ul><li>了解阻塞意味着什么，以及性能影响。</li><li>了解事件处理，以及为什么它对UI代码很重要。</li></ul><p><strong>红色预警：</strong></p><ul><li>不熟悉异步或同步的术语。</li><li>无法阐明性能影响或异步代码与UI代码之间的关系。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在大部分公司的管理者都会通过技术面试来考察开发者的能力。如果你成为了候选人，那你一定需要去经历面试。&lt;/p&gt;
&lt;p&gt;大部分的面试相信大家一定经历过，但是其实我们不应该过度关注于语法和一些怪异生僻的特性中。诚然这些能考察到候选人的基础功扎实与否，但我们应该更多的是从全局来考
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>强制缓存（200）和协商缓存（304）</title>
    <link href="https://github.com/ZhangQiangQQ/2019/05/06/%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98%EF%BC%88200%EF%BC%89%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%EF%BC%88304%EF%BC%89/"/>
    <id>https://github.com/ZhangQiangQQ/2019/05/06/强制缓存（200）和协商缓存（304）/</id>
    <published>2019-05-06T09:09:18.000Z</published>
    <updated>2019-07-06T02:28:09.977Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍强制缓存（200）和协商缓存（304）的区别</p><h4 id="1-什么是缓存？"><a href="#1-什么是缓存？" class="headerlink" title="1. 什么是缓存？"></a>1. 什么是缓存？</h4><p>浏览器缓存(Brower Caching)是浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用，节省带宽，提高访问速度，降低服务器压力</p><p>http缓存机制主要在http响应头中设定，响应头中相关字段为Expires、Cache-Control、Last-Modified、If-Modified-Since、Etag。</p><p>HTTP 1.0协议中的。简而言之，就是告诉浏览器在约定的这个时间前，可以直接从缓存中获取资源（representations），而无需跑到服务器去获取。</p><p>另：Expires因为是对时间设定的，且时间是Greenwich Mean Time （GMT），而不是本地时间，所以对时间要求较高。</p><h4 id="2-浏览器是如何判断是否使用缓存的"><a href="#2-浏览器是如何判断是否使用缓存的" class="headerlink" title="2. 浏览器是如何判断是否使用缓存的"></a>2. 浏览器是如何判断是否使用缓存的</h4><p>第一次请求：</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/6/16a8bbc2df77f4f6?w=411&amp;h=369&amp;f=png&amp;s=26885" alt=""><br>第二次请求相同网页：</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/6/16a8bbaefa56810f?w=554&amp;h=528&amp;f=png&amp;s=103197" alt=""></p><h4 id="3-缓存的类别"><a href="#3-缓存的类别" class="headerlink" title="3. 缓存的类别"></a>3. 缓存的类别</h4><p>浏览器缓存分为强缓存和协商缓存</p><h5 id="强缓存：浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回Status-Code-200-OK"><a href="#强缓存：浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回Status-Code-200-OK" class="headerlink" title="强缓存：浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回Status Code: 200 OK"></a>强缓存：浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回Status Code: 200 OK</h5><p><img src="https://user-gold-cdn.xitu.io/2019/5/6/16a8bc0c7e54f6ec?w=317&amp;h=112&amp;f=png&amp;s=9790" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2019/5/6/16a8bdbc4b9c8720?w=280&amp;h=96&amp;f=png&amp;s=7498" alt=""></p><blockquote><p>200 form memory cache :<br>不访问服务器，一般已经加载过该资源且缓存在了内存当中，直接从内存中读取缓存。浏览器关闭后，数据将不存在（资源被释放掉了），再次打开相同的页面时，不会出现from memory cache。</p></blockquote><blockquote><p>200 from disk cache：<br>不访问服务器，已经在之前的某个时间加载过该资源，直接从硬盘中读取缓存，关闭浏览器后，数据依然存在，此资源不会随着该页面的关闭而释放掉下次打开仍然会是from disk cache。</p></blockquote><blockquote><p>优先访问memory cache,其次是disk cache，最后是请求网络资源</p></blockquote><h5 id="协商缓存-向服务器发送请求，服务器会根据这个请求的request-header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response-header通知浏览器从缓存中读取资源；"><a href="#协商缓存-向服务器发送请求，服务器会根据这个请求的request-header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response-header通知浏览器从缓存中读取资源；" class="headerlink" title="协商缓存: 向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；"></a>协商缓存: 向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；</h5><p><img src="https://user-gold-cdn.xitu.io/2019/5/6/16a8bc3172e3a167?w=293&amp;h=47&amp;f=png&amp;s=3340" alt=""></p><h4 id="4-强缓存和协商缓存的header参数"><a href="#4-强缓存和协商缓存的header参数" class="headerlink" title="4. 强缓存和协商缓存的header参数"></a>4. 强缓存和协商缓存的header参数</h4><p>强缓存：</p><p>Expires：过期时间，如果设置了时间，则浏览器会在设置的时间内直接读取缓存，不再请求</p><p>Cache-Control：当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p><p>cache-control：除了该字段外，还有下面几个比较常用的设置值：</p><pre><code>（1） max-age：用来设置资源（representations）可以被缓存多长时间，单位为秒；（2） s-maxage：和max-age是一样的，不过它只针对代理服务器缓存而言；（3）public：指示响应可被任何缓存区缓存；（4）private：只能针对个人用户，而不能被代理服务器缓存；（5）no-cache：强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到     请求，然后判断资源是否变更，是则返回新内容，否则返回304，未变更。这个很容易让人产生误解，使人误     以为是响应不被缓存。实际上Cache-Control:     no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。（6）no-store：禁止一切缓存（这个才是响应不被缓存的意思）。</code></pre><p>协商缓存：</p><p>Last-Modifued/If-Modified-Since和Etag/If-None-Match是分别成对出现的，呈一一对应关系</p><h5 id="Etag-If-None-Match："><a href="#Etag-If-None-Match：" class="headerlink" title="Etag/If-None-Match："></a>Etag/If-None-Match：</h5><p>Etag：</p><blockquote><p>Etag是属于HTTP 1.1属性，它是由服务器（Apache或者其他工具）生成返回给前端，用来帮助服务器控制Web端的缓存验证。<br>Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。</p></blockquote><p>If-None-Match: </p><blockquote><p>当资源过期时，浏览器发现响应头里有Etag,则再次像服务器请求时带上请求头if-none-match(值是Etag的值)。服务器收到请求进行比对，决定返回200或304</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2019/5/6/16a8c60fb0ef49f0?w=918&amp;h=279&amp;f=png&amp;s=20766" alt=""></p><h5 id="Last-Modifued-If-Modified-Since："><a href="#Last-Modifued-If-Modified-Since：" class="headerlink" title="Last-Modifued/If-Modified-Since："></a>Last-Modifued/If-Modified-Since：</h5><p>Last-Modified：</p><blockquote><p>浏览器向服务器发送资源最后的修改时间</p></blockquote><p>If-Modified-Since：</p><blockquote><p>当资源过期时（浏览器判断Cache-Control标识的max-age过期），发现响应头具有Last-Modified声明，则再次像服务器请求时带上头if-modified-since，表示请求时间。服务器收到请求后发现有if-modified-since则与被请求资源的最后修改时间进行对比（Last-Modified）,若最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK;若最后修改时间较旧（小），说明资源无新修改，响应HTTP 304 走缓存。</p></blockquote><blockquote><p>Last-Modifued/If-Modified-Since的时间精度是秒，而Etag可以更精确。<br>Etag优先级是高于Last-Modifued的，所以服务器会优先验证Etag</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文将介绍强制缓存（200）和协商缓存（304）的区别&lt;/p&gt;
&lt;h4 id=&quot;1-什么是缓存？&quot;&gt;&lt;a href=&quot;#1-什么是缓存？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是缓存？&quot;&gt;&lt;/a&gt;1. 什么是缓存？&lt;/h4&gt;&lt;p&gt;浏览器缓存(Bro
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浏览器缓存的了解</title>
    <link href="https://github.com/ZhangQiangQQ/2019/04/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%9A%84%E4%BA%86%E8%A7%A3/"/>
    <id>https://github.com/ZhangQiangQQ/2019/04/10/浏览器缓存的了解/</id>
    <published>2019-04-10T02:44:03.000Z</published>
    <updated>2019-07-06T02:28:09.978Z</updated>
    
    <content type="html"><![CDATA[<ol><li>浏览器缓存 主要指的是 htttp的缓存 ，即协议层的缓存</li><li>协议层的缓存 分为 强制缓存 和 对比缓存</li></ol><p>强制缓存：<br>概念：只有当 缓存失效时 才会向服务器获取最新资源。<br>方式： Expires  和  Cache-Control</p><p>1.Expires：<br>  Expires: Thu, 10 Nov 2017 08:45:11 GMT<br>绝对时间，受客户端本地时间的影响，修改后会导致浏览器的缓存判断失效，而重新请求。并且 修改后会导致 客户端 与服务端时间不一致，使得缓存失效</p><p>2.Cache-Control：<br>例：  Response Header：<br>        Cache-Control：max-age=25454500<br>max-age：即最大有效时间，在上面的例子中我们可以看到<br>no-cache：表示没有缓存，即告诉浏览器该资源并没有设置缓存<br>s-maxage：同max-age，但是仅用于共享缓存，如CDN缓存<br>public：多用户共享缓存，默认设置<br>private：不能够多用户共享，HTTP认证之后，字段会自动转换成private。<br>相对时间，所以不会受客户端的 影响。可配置性强。</p><p>对比缓存：<br>概念：简单来说就是 先去找缓存，然后获取缓存的标识，拿着标识去服务请求 确认该数据是否更新过，<br>如果更新了 就返回最新的数据。否则 返回304，从缓存中获取数据。<br>方式：Last-Modified和If-Modified-Since  和 Etag</p><p>Last-Modified：服务器告知客户端，资源最后一次被修改的时间<br>例： Response Header：<br>      Last-Modified: Thu, 10 Nov 2015 08:45:11 GMT</p><p>If-Modified-Since：<br>再次请求时，请求头中带有该字段，服务器会将If-Modified-Since的值与Last-Modified字段进行对比，<br>如果相等，则表示未修改，响应304；<br>反之，则表示修改了，响应200状态码，返回数据。</p><p>Etag：就是个hash值。每次随着数据资源返回，来回传递，进行识别对比，来判断是否返回304或者数据资源</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;浏览器缓存 主要指的是 htttp的缓存 ，即协议层的缓存&lt;/li&gt;
&lt;li&gt;协议层的缓存 分为 强制缓存 和 对比缓存&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;强制缓存：&lt;br&gt;概念：只有当 缓存失效时 才会向服务器获取最新资源。&lt;br&gt;方式： Expires  和  C
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>发布流程</title>
    <link href="https://github.com/ZhangQiangQQ/2019/03/01/%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B/"/>
    <id>https://github.com/ZhangQiangQQ/2019/03/01/发布流程/</id>
    <published>2019-03-01T07:28:21.000Z</published>
    <updated>2019-07-06T02:28:09.975Z</updated>
    
    <content type="html"><![CDATA[<h3 id="不能算是正规的发布系统，只是按照自己的需求、能力和想法实现的一个简单的自动化"><a href="#不能算是正规的发布系统，只是按照自己的需求、能力和想法实现的一个简单的自动化" class="headerlink" title="不能算是正规的发布系统，只是按照自己的需求、能力和想法实现的一个简单的自动化"></a>不能算是正规的发布系统，只是按照自己的需求、能力和想法实现的一个简单的自动化</h3><h5 id="主要涉及的地方"><a href="#主要涉及的地方" class="headerlink" title="主要涉及的地方"></a>主要涉及的地方</h5><ol><li>代码仓库</li><li>静态资源站点</li><li>web站点</li></ol><h5 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h5><ol><li><p>打包 </p><pre><code>1. 从代码仓库拉取代码到静态资源站点2. 生成版本号（即时间戳）命名的文件夹3. 输出版本号</code></pre></li><li>发布<pre><code>1. 修改输出HTML引用文件的版本号</code></pre></li></ol><h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><ol><li>web服务</li><li>静态资源站点</li><li>可视化发布站点</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;不能算是正规的发布系统，只是按照自己的需求、能力和想法实现的一个简单的自动化&quot;&gt;&lt;a href=&quot;#不能算是正规的发布系统，只是按照自己的需求、能力和想法实现的一个简单的自动化&quot; class=&quot;headerlink&quot; title=&quot;不能算是正规的发布系统，只是按照
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React学习笔记</title>
    <link href="https://github.com/ZhangQiangQQ/2019/02/26/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/ZhangQiangQQ/2019/02/26/React学习笔记/</id>
    <published>2019-02-26T06:39:32.000Z</published>
    <updated>2019-07-06T02:28:09.966Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>React是一种  声明式   高效 灵活 构建用户界面的框架</p></li><li><p>组件 ：React.Component{}</p></li><li><p>组件是接受 名为 props的参数 {this.props.name}， 即 当前组件被应用时， 传入的各个数据，包括事件等；</p></li></ol><p>4.render返回的是一个React元素 ：渲染内容的描述   一般使用JSX语法来扩展  ： <div> —–&gt; React.createElement(“div”)</div></p><p>5.通过 <shoppinglist> 这样的标签你就可以在 React 当中调用整个 ShoppingList 组件</shoppinglist></p><ol start="6"><li><p>添加样式用  className = “aaaa”,  事件： onClick={ () =&gt; alert(“click”)}</p></li><li><p>this.state 为自身设置自身的状态数据，  存储变化的数据</p></li><li><p>this.setState 用于设置 值 ，每次触发时都会开始准备更新组件 跟随数据改变了的内容。</p></li></ol><p>状态提升：</p><ol start="9"><li><p>子组件的state数据提升至共同的 父组件 中保存。然后 父组件 通过Props  将 状态 数据传递到子组件中     ——&gt;  方便状态数据共享交流</p></li><li><p>key React当中使用的一种特殊的属性，(以及ref属性)，无法通过props获取到key，React会自动判断元素更新时使用key，而组件自己无法获取到key的。<br>组件key值被改变就会被当作新创建的组件处理。<br>组件的 keys 值并不需要在全局都保证唯一，只需要在当前的节点里保证唯一即可</p></li></ol><p>二.Redux<br>概念：<br>（1）Web 应用是一个状态机，视图与状态是一一对应的。</p><p>（2）所有的状态，保存在一个对象里面。</p><p>Store:<br>保存数据的地方，看成一个容器， 整个应用只能有一个store</p><p>提供的方法函数： createStore，用于生成store，接受了另一个函数参数，返回新生成的store对象<br>例：import { createStore } from ‘redux’;<br>   const store = createStore(fn);<br>State：<br>时点的数据集合叫做 State， 如，当前时刻的 State，通过 store.getState() 拿到<br>import { createStore } from ‘redux’;<br>const store = createStore(fn);<br>const state = store.getState();<br>Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。</p><p>Action：<br>Action 就是 View 发出的通知，表示 State 应该要发生变化了<br>Action 是一个对象。其中的type属性是必须的。表示Action 的名称。其他属性可以自由设置，<br>const action = {<br>  type: ‘ADD_TODO’,<br>  payload: ‘Learn Redux’<br>};<br>可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。</p><p>Action Creator:<br>View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。</p><p>例：<br>const ADD_TODO = ‘添加 TODO’;</p><p>function addTodo(text) {<br>  return {<br>    type: ADD_TODO,<br>    text<br>  }<br>}</p><p>const action =addTodo(‘Learn Redux’);</p><p>store.dispatch()：</p><p>store.dispatch()是 View 发出 Action 的唯一方法。<br>store.dispatch接受一个 Action 对象作为参数，将它发送出去<br>store.dispatch(addTodo(‘Learn Redux’));</p><p>Reducer：<br>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。<br>例：</p><p>const defaultState = 0;<br>const reducer = (state = defaultState, action) =&gt; {<br>  switch (action.type) {<br>    case ‘ADD’:<br>      return state + action.payload;<br>    default:<br>      return state;<br>  }};</p><p>const state = reducer(1, {<br>  type: ‘ADD’,<br>  payload: 2});</p><p>createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。<br>例：</p><p>const actions = [<br>  { type: ‘ADD’, payload: 0 },<br>  { type: ‘ADD’, payload: 1 },<br>  { type: ‘ADD’, payload: 2 }];</p><p>const total = actions.reduce(reducer, 0); // 3</p><p>纯函数： 只要是同样的输入，必定得到同样的输出。</p><p>store.subscribe()：<br>方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。<br>例：</p><p>import { createStore } from ‘redux’;<br>const store = createStore(reducer);</p><p>store.subscribe(listener);</p><p>只要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染。<br>store.subscribe方法返回一个函数，调用这个函数就可以解除监听。</p><p>Reducer 的拆分：<br>combinReducers:用于 Reducer 的拆分。你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer。<br>例：</p><p>import { combineReducers } from ‘redux’;</p><p>const chatReducer = combineReducers({<br>  chatLog,<br>  statusMessage,<br>  userName<br>})</p><p>export default todoApp;<br>State 的属性名必须与子 Reducer 同名</p><p>不同名的写法：</p><p>const reducer = combineReducers({<br>  a: doSomethingWithA,<br>  b: processB,<br>  c: c<br>})<br>// 等同于<br>function reducer(state = {}, action) {<br>  return {<br>    a: doSomethingWithA(state.a, action),<br>    b: processB(state.b, action),<br>    c: c(state.c, action)<br>  }}</p><p>可以把所有子 Reducer 放在一个文件里面，然后统一引入。</p><p>import { combineReducers } from ‘redux’<br>import * as reducers from ‘./reducers’</p><p>const reducer = combineReducers(reducers)</p><p>Redux流程：<br>1.用户发出Action–&gt; stroe.dispatch(action);<br>2.store自动调用Reducer,传入（当前state，action），返回新的State。<br>例： let nextState = todoApp（previousState，action）；</p><p>3.state发生变化，store会调用监听函数。：</p><p>例：stroe.subscribe(listener);</p><p>listener可以通过 store.getStore() 得到当前状态，react此时会触发重新渲染view； </p><p>例：</p><p>function listerner() {<br>  let newState = store.getState();<br>  component.setState(newState);<br>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;React是一种  声明式   高效 灵活 构建用户界面的框架&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;组件 ：React.Component{}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;组件是接受 名为 props的参数 {this.props.name}， 即 当
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常用的一些git命令行</title>
    <link href="https://github.com/ZhangQiangQQ/2019/02/16/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9Bgit%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <id>https://github.com/ZhangQiangQQ/2019/02/16/常用的一些git命令行/</id>
    <published>2019-02-16T03:41:21.000Z</published>
    <updated>2019-07-06T02:28:09.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工作中常用的一些git命令行"><a href="#工作中常用的一些git命令行" class="headerlink" title="工作中常用的一些git命令行"></a>工作中常用的一些git命令行</h2><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><table><thead><tr><th style="text-align:left">四个库</th><th style="text-align:right">四种文件状态</th></tr></thead><tbody><tr><td style="text-align:left">工作区</td><td style="text-align:right">Unstracked(未被跟踪的)</td></tr><tr><td style="text-align:left"></td><td style="text-align:right">Modified(有修改的，和本地仓库快照不同)</td></tr><tr><td style="text-align:left">暂存区</td><td style="text-align:right">staged(暂存状态)</td></tr><tr><td style="text-align:left">本地仓库</td><td style="text-align:right">Unmodify(未改动)</td></tr><tr><td style="text-align:left">远程仓库</td></tr></tbody></table><h4 id="克隆代码仓库"><a href="#克隆代码仓库" class="headerlink" title="克隆代码仓库"></a>克隆代码仓库</h4><ul><li><code>git clone 仓库地址</code></li></ul><p>远程地址为仓库地址</p><hr><h4 id="暂存区操作"><a href="#暂存区操作" class="headerlink" title="暂存区操作"></a>暂存区操作</h4><ul><li><p><code>git add 文件名</code> 添加文件到暂存区</p></li><li><p><code>git add .</code> 添加所有（未被添加过但存在在仓库文件夹里的）文件到暂存区</p></li><li><p><code>git rm 文件名</code> 从暂存区删除文件,文件会被删除</p></li><li><p><code>git rm 文件名 -f</code> 从暂存区强制删除，文件会被删除</p></li><li><p><code>git rm 文件名 --cached</code> 从暂存区删除，但是文件不会被删除，状态变为Unstracked</p></li><li><p><code>git checkout -- 文件名</code> 从暂存区拉取文件覆盖到工作区</p></li><li><p><code>git reset HEAD 文件名</code> 从本地仓库拉取文件覆盖到暂存区</p></li><li><p><code>git mv &#39;oldName&#39; &#39;newName&#39;</code> 更改文件名</p></li><li><p><code>git status</code> 获取仓库状态，包含四个库和文件状态</p></li><li><p><code>git reset --hard HEAD^</code> 重置到上一个commit状态，覆盖staged和工作区</p></li><li><p><code>git reset --hard &lt;commitkey&gt;</code> 重置到对应commit版本，覆盖staged和工作区</p></li></ul><h5 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h5><p><em>工作区误删文件（手动删除）</em><br><code>git checkout -- 文件名</code> </p><p><em>暂存区误删文件，删除之后想恢复</em><br><code>git reset HEAD 文件名 + git checkout -- 文件名</code></p><h4 id="本地仓库操作"><a href="#本地仓库操作" class="headerlink" title="本地仓库操作"></a>本地仓库操作</h4><ul><li><p><code>git commit -m 提交描述信息</code> 将暂存区里的改动提交到本地仓库， -m 参数表示带入提交描述信息，不加命令行会打开vim在让你输入</p></li><li><p><code>git commit -a -m 提交描述信息</code> 将所有非Unstracked状态的文件改动提交到本地仓库，相当于<code>git add 改动文件 + git commit -m</code></p></li><li><p><code>git commit --amend</code> 补充上一次的提交</p></li></ul><h4 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h4><ul><li><p><code>git remote -v</code> 查看目前远程仓库地址</p></li><li><p><code>git remote add origin 远程仓库地址</code> 添加远程仓库地址，已经有了的话会失败</p></li><li><p><code>git remote origin</code> 删除远程仓库，解除关联</p></li><li><p><code>git remote set-url origin 远程仓库地址</code> 设置远程仓库地址，可覆盖</p></li><li><p><code>git push -u origin master</code> 推送本地仓库到远程仓库master分支，-u表示关联，之后可省略为<code>git push, git pull</code></p></li><li><p><code>git pull</code> 从远程仓库拉取到本地</p></li></ul><h4 id="基础操作流程图-不包含全部"><a href="#基础操作流程图-不包含全部" class="headerlink" title="基础操作流程图(不包含全部)"></a>基础操作流程图(不包含全部)</h4><p><img src="https://img-blog.csdn.net/20140417113336421" alt="流程图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;工作中常用的一些git命令行&quot;&gt;&lt;a href=&quot;#工作中常用的一些git命令行&quot; class=&quot;headerlink&quot; title=&quot;工作中常用的一些git命令行&quot;&gt;&lt;/a&gt;工作中常用的一些git命令行&lt;/h2&gt;&lt;h4 id=&quot;相关概念&quot;&gt;&lt;a href=&quot;#相
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack下build报错</title>
    <link href="https://github.com/ZhangQiangQQ/2019/02/09/webpack%E4%B8%8Bbuild%E6%8A%A5%E9%94%99/"/>
    <id>https://github.com/ZhangQiangQQ/2019/02/09/webpack下build报错/</id>
    <published>2019-02-09T08:01:23.000Z</published>
    <updated>2019-07-06T02:28:09.970Z</updated>
    
    <content type="html"><![CDATA[<p>执行npm run build时报错如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">D:\MyProjects\react_ssr_demo&gt;npm run build</span><br><span class="line"></span><br><span class="line">&gt; react_ssr_demo@1.0.0 build D:\MyProjects\react_ssr_demo</span><br><span class="line">&gt; webpack --config build/webpack.config.js</span><br><span class="line"></span><br><span class="line">Hash: 0b1003a436390263970e</span><br><span class="line">Version: webpack 4.29.3</span><br><span class="line">Time: 633ms</span><br><span class="line">Built at: 2019-02-09 15:46:04</span><br><span class="line"> 1 asset</span><br><span class="line">Entrypoint app = app.0b1003a436390263970e.js</span><br><span class="line">[2] ./client/App.jsx 3 KiB &#123;0&#125; [not cacheable] [built] [failed] [1 error]</span><br><span class="line">[3] ./client/app.js 100 bytes &#123;0&#125; [built]</span><br><span class="line">[9] (webpack)/buildin/global.js 472 bytes &#123;0&#125; [built]</span><br><span class="line">    + 7 hidden modules</span><br><span class="line"></span><br><span class="line">WARNING in configuration</span><br><span class="line">The &apos;mode&apos; option has not been set, webpack will fallback to &apos;production&apos; for th</span><br><span class="line">is value. Set &apos;mode&apos; option to &apos;development&apos; or &apos;production&apos; to enable defaults</span><br><span class="line">for each environment.</span><br><span class="line">You can also set it to &apos;none&apos; to disable any default behavior. Learn more: https</span><br><span class="line">://webpack.js.org/concepts/mode/</span><br><span class="line"></span><br><span class="line">ERROR in ./client/App.jsx</span><br><span class="line">Module build failed (from ./node_modules/_babel-loader@8.0.5@babel-loader/lib/in</span><br><span class="line">dex.js):</span><br><span class="line">Error: Cannot find module &apos;@babel/core&apos;</span><br><span class="line"> babel-loader@8 requires Babel 7.x (the package &apos;@babel/core&apos;). If you&apos;d like to</span><br><span class="line"> use Babel 6.x (&apos;babel-core&apos;), you should install &apos;babel-loader@7&apos;.</span><br><span class="line">    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:581:15)</span><br><span class="line">    at Function.Module._load (internal/modules/cjs/loader.js:507:25)</span><br><span class="line">    at Module.require (internal/modules/cjs/loader.js:637:17)</span><br><span class="line">    at require (D:\MyProjects\react_ssr_demo\node_modules\_v8-compile-cache@2.0.</span><br><span class="line">2@v8-compile-cache\v8-compile-cache.js:159:20)</span><br><span class="line">    at Object.&lt;anonymous&gt; (D:\MyProjects\react_ssr_demo\node_modules\_babel-load</span><br><span class="line">er@8.0.5@babel-loader\lib\index.js:10:11)</span><br><span class="line">    at Module._compile (D:\MyProjects\react_ssr_demo\node_modules\_v8-compile-ca</span><br><span class="line">che@2.0.2@v8-compile-cache\v8-compile-cache.js:178:30)</span><br><span class="line">    at Object.Module._extensions..js (internal/modules/cjs/loader.js:700:10)</span><br><span class="line">    at Module.load (internal/modules/cjs/loader.js:599:32)</span><br><span class="line">    at tryModuleLoad (internal/modules/cjs/loader.js:538:12)</span><br><span class="line">    at Function.Module._load (internal/modules/cjs/loader.js:530:3)</span><br><span class="line">    at Module.require (internal/modules/cjs/loader.js:637:17)</span><br><span class="line">    at require (D:\MyProjects\react_ssr_demo\node_modules\_v8-compile-cache@2.0.</span><br><span class="line">2@v8-compile-cache\v8-compile-cache.js:159:20)</span><br><span class="line">    at loadLoader (D:\MyProjects\react_ssr_demo\node_modules\_loader-runner@2.4.</span><br><span class="line">0@loader-runner\lib\loadLoader.js:18:17)</span><br><span class="line">    at iteratePitchingLoaders (D:\MyProjects\react_ssr_demo\node_modules\_loader</span><br><span class="line">-runner@2.4.0@loader-runner\lib\LoaderRunner.js:169:2)</span><br><span class="line">    at runLoaders (D:\MyProjects\react_ssr_demo\node_modules\_loader-runner@2.4.</span><br><span class="line">0@loader-runner\lib\LoaderRunner.js:365:2)</span><br><span class="line">    at NormalModule.doBuild (D:\MyProjects\react_ssr_demo\node_modules\_webpack@</span><br><span class="line">4.29.3@webpack\lib\NormalModule.js:280:3)</span><br><span class="line">    at NormalModule.build (D:\MyProjects\react_ssr_demo\node_modules\_webpack@4.</span><br><span class="line">29.3@webpack\lib\NormalModule.js:427:15)</span><br><span class="line">    at Compilation.buildModule (D:\MyProjects\react_ssr_demo\node_modules\_webpa</span><br><span class="line">ck@4.29.3@webpack\lib\Compilation.js:635:10)</span><br><span class="line">    at factory.create (D:\MyProjects\react_ssr_demo\node_modules\_webpack@4.29.3</span><br><span class="line">@webpack\lib\Compilation.js:884:14)</span><br><span class="line">    at factory (D:\MyProjects\react_ssr_demo\node_modules\_webpack@4.29.3@webpac</span><br><span class="line">k\lib\NormalModuleFactory.js:405:6)</span><br><span class="line">    at hooks.afterResolve.callAsync (D:\MyProjects\react_ssr_demo\node_modules\_</span><br><span class="line">webpack@4.29.3@webpack\lib\NormalModuleFactory.js:155:13)</span><br><span class="line">    at AsyncSeriesWaterfallHook.eval [as callAsync] (eval at create (D:\MyProjec</span><br><span class="line">ts\react_ssr_demo\node_modules\_tapable@1.1.1@tapable\lib\HookCodeFactory.js:32:</span><br><span class="line">10), &lt;anonymous&gt;:6:1)</span><br><span class="line">    at resolver (D:\MyProjects\react_ssr_demo\node_modules\_webpack@4.29.3@webpa</span><br><span class="line">ck\lib\NormalModuleFactory.js:138:29)</span><br><span class="line">    at process.nextTick (D:\MyProjects\react_ssr_demo\node_modules\_webpack@4.29</span><br><span class="line">.3@webpack\lib\NormalModuleFactory.js:342:9)</span><br><span class="line">    at process._tickCallback (internal/process/next_tick.js:61:11)</span><br><span class="line"> @ ./client/app.js 2:0-27 4:16-19</span><br><span class="line">npm ERR! code ELIFECYCLE</span><br><span class="line">npm ERR! errno 2</span><br><span class="line">npm ERR! react_ssr_demo@1.0.0 build: `webpack --config build/webpack.config.js`</span><br><span class="line">npm ERR! Exit status 2</span><br><span class="line">npm ERR!</span><br><span class="line">npm ERR! Failed at the react_ssr_demo@1.0.0 build script.</span><br><span class="line">npm ERR! This is probably not a problem with npm. There is likely additional log</span><br><span class="line">ging output above.</span><br><span class="line"></span><br><span class="line">npm ERR! A complete log of this run can be found in:</span><br><span class="line">npm ERR!     C:\Users\Administrator.PC-201812050004\AppData\Roaming\npm-cache\_l</span><br><span class="line">ogs\2019-02-09T07_46_04_537Z-debug.log</span><br></pre></td></tr></table></figure></p><p>这里面有两个问题</p><ol><li>WARNING in configuration<blockquote><p>解决方法：在webpack.config.js下增加mode: ‘none’<br>module.exports = {<br> mode: ‘none’,</p></blockquote></li></ol><ol start="2"><li>Error: Cannot find module ‘@babel/core’<br>babel-loader@8 requires Babel 7.x (the package ‘@babel/core’). If you’d like to<br>use Babel 6.x (‘babel-core’), you should install ‘babel-loader@7’.<blockquote><p>解决方法：npm i babel-loader@7 -D</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;执行npm run build时报错如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React虚拟dom和diff算法</title>
    <link href="https://github.com/ZhangQiangQQ/2019/01/30/React%E8%99%9A%E6%8B%9Fdom%E5%92%8Cdiff%E7%AE%97%E6%B3%95/"/>
    <id>https://github.com/ZhangQiangQQ/2019/01/30/React虚拟dom和diff算法/</id>
    <published>2019-01-30T07:02:10.000Z</published>
    <updated>2019-07-06T02:28:09.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是虚拟dom？"><a href="#什么是虚拟dom？" class="headerlink" title="什么是虚拟dom？"></a>什么是虚拟dom？</h2><p>这就要从react如何渲染出页面开始<br>通常情况下的步骤是这样</p><ol><li>获取state数据</li><li>JSX模板</li><li>state+JSX模板结合，生成真实dom并显示</li></ol><p>这个是在state不发生变化的情况下，（state或者prop发生变化都会调用render函数，重新渲染页面）</p><p>state数据变化时，通常理解下应该是下面的步骤</p><ol><li>获取state数据</li><li>JSX模板</li><li>state数据+JSX模板结合，生成真实dom并显示</li><li>state数据发生变化</li><li>新的state数据+JSX模板结合，生成真实dom并显示</li></ol><p>这样可以实现，但是非常消耗性能，因为会渲染两次dom树，所以react就采用一种虚拟dom的方法来进行dom更新。</p><p>JSX转成dom流程</p><blockquote><p>用JSX语法时，渲染dom的流程：JSX——JS dom描述对象——真实dom</p></blockquote><p>具体步骤：</p><ol><li>获取state数据</li><li>JSX模板</li><li>生成虚拟dom（虚拟dom就是一个JS对象，里面包含了对真实dom的描述</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;div&apos;,&#123;id:&apos;a&apos;&#125;,[&apos;span&apos;,&#123;&#125;,&apos;hello&apos;]]</span><br></pre></td></tr></table></figure><ol start="4"><li><p>用虚拟dom解构，生成真实dom并显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&apos;a&apos;&gt;&lt;span&gt;hello&lt;/span&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>state数据发生变化（比如hello变成了hi）</p></li><li><p>生成新的虚拟dom</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;div&apos;,&#123;id:&apos;a&apos;&#125;,[&apos;span&apos;,&#123;&#125;,&apos;hi&apos;]]</span><br></pre></td></tr></table></figure></li><li><p>比较原始虚拟dom和新的虚拟dom的区别，找出区别是span里的内容</p></li><li>直接操作dom，只改变span里的内容</li></ol><h4 id="虚拟dom的好处"><a href="#虚拟dom的好处" class="headerlink" title="虚拟dom的好处"></a>虚拟dom的好处</h4><ol><li>性能提升，dom比对变成js对象比对</li><li>使得跨端应用得以实现（react native）<blockquote><p>在浏览器中可以用虚拟dom生成真实dom显示，在原生应用中也可以用虚拟dom生成对应的方式来显示页面</p></blockquote></li></ol><h2 id="虚拟dom中的diff算法"><a href="#虚拟dom中的diff算法" class="headerlink" title="虚拟dom中的diff算法"></a>虚拟dom中的diff算法</h2><p>在上面我们介绍了react中state变化时，dom是如何发生变化的，在第七步中比较原始虚拟dom和新的虚拟dom的区别采用的方法，就是diff算法（diffrence）</p><p>虚拟dom在什么时候会发生比对？没错，数据发生变化时，也就是调用setState时</p><p>react的虚拟dom其实是同级比较的</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/30/1689dac3232d3b6d?w=582&amp;h=300&amp;f=png&amp;s=69471" alt=""><br>如上图<br>他的对比步骤如下</p><ol><li>红色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对</li><li>蓝色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对</li><li>绿色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对，浅蓝色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对</li></ol><blockquote><p>但凡在上面哪一步骤出现不同，就不再继续比对，而是删除下面的全部节点，采用新的虚拟dom(例如：如果红色框的原始虚拟dom和新的虚拟dom不一致，那么就不在进行比对，采用新的虚拟dom来生成dom)</p></blockquote><h4 id="key的作用"><a href="#key的作用" class="headerlink" title="key的作用"></a>key的作用</h4><p>react利用key来识别组件，它是一种身份标识标识，来提高虚拟dom的比对速度看下面</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/30/1689dbb06ec80cda?w=477&amp;h=191&amp;f=png&amp;s=7412" alt=""><br>比如我要在abcde中添加一个f</p><p>如果我们没有key值，那我们就需要A比对一遍，B对比一遍，以此类推很好性能，而有了key，就像下面的图一样，我们很快就知道只有f与之前不同，提高了列表渲染的性能<br><img src="https://user-gold-cdn.xitu.io/2019/1/30/1689dbbc688199b4?w=565&amp;h=201&amp;f=png&amp;s=11659" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是虚拟dom？&quot;&gt;&lt;a href=&quot;#什么是虚拟dom？&quot; class=&quot;headerlink&quot; title=&quot;什么是虚拟dom？&quot;&gt;&lt;/a&gt;什么是虚拟dom？&lt;/h2&gt;&lt;p&gt;这就要从react如何渲染出页面开始&lt;br&gt;通常情况下的步骤是这样&lt;/p&gt;
&lt;ol&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>react生命周期</title>
    <link href="https://github.com/ZhangQiangQQ/2019/01/27/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://github.com/ZhangQiangQQ/2019/01/27/react生命周期/</id>
    <published>2019-01-27T08:30:48.000Z</published>
    <updated>2019-07-06T02:28:09.969Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>生命周期函数：在某一个时刻组件会自动调用执行的函数</p></blockquote><h3 id="React-生命周期"><a href="#React-生命周期" class="headerlink" title="React 生命周期"></a>React 生命周期</h3><p><img src="https://user-gold-cdn.xitu.io/2017/11/11/88e11709488aeea3f9c6595ee4083bf3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><blockquote><p>如图，React生命周期主要包括三个阶段：初始化阶段、运行中阶段和销毁阶段，在React不同的生命周期里，会依次触发不同的钩子函数，下面我们就来详细介绍一下React的生命周期函数</p></blockquote><h4 id="一、初始化阶段"><a href="#一、初始化阶段" class="headerlink" title="一、初始化阶段"></a>一、初始化阶段</h4><h5 id="1、设置组件的默认属性"><a href="#1、设置组件的默认属性" class="headerlink" title="1、设置组件的默认属性"></a>1、设置组件的默认属性</h5><pre><code>static defaultProps = {    name: &apos;sls&apos;,    age:23};//orCounter.defaltProps={name:&apos;sls&apos;}复制代码</code></pre><h5 id="2、设置组件的初始化状态"><a href="#2、设置组件的初始化状态" class="headerlink" title="2、设置组件的初始化状态"></a>2、设置组件的初始化状态</h5><pre><code>constructor() {    super();    this.state = {number: 0}}复制代码</code></pre><h5 id="3、componentWillMount"><a href="#3、componentWillMount" class="headerlink" title="3、componentWillMount()"></a>3、componentWillMount()</h5><blockquote><p>组件即将被渲染到页面之前触发，此时可以进行开启定时器、向服务器发送请求等操作</p></blockquote><h5 id="4、render"><a href="#4、render" class="headerlink" title="4、render()"></a>4、render()</h5><blockquote><p>组件渲染</p></blockquote><h5 id="5、componentDidMount"><a href="#5、componentDidMount" class="headerlink" title="5、componentDidMount()"></a>5、componentDidMount()</h5><blockquote><p>组件已经被渲染到页面中后触发：此时页面中有了真正的DOM的元素，可以进行DOM相关的操作</p></blockquote><h4 id="二、运行中阶段"><a href="#二、运行中阶段" class="headerlink" title="二、运行中阶段"></a>二、运行中阶段</h4><h5 id="1、componentWillReceiveProps"><a href="#1、componentWillReceiveProps" class="headerlink" title="1、componentWillReceiveProps()"></a>1、componentWillReceiveProps()</h5><blockquote><p>组件接收到属性时触发</p></blockquote><h5 id="2、shouldComponentUpdate"><a href="#2、shouldComponentUpdate" class="headerlink" title="2、shouldComponentUpdate()"></a>2、shouldComponentUpdate()</h5><blockquote><p>当组件接收到新属性，或者组件的状态发生改变时触发。组件首次渲染时并不会触发</p></blockquote><pre><code>shouldComponentUpdate(newProps, newState) {    if (newProps.number &lt; 5) return true;    return false}//该钩子函数可以接收到两个参数，新的属性和状态，返回true/false来控制组件是否需要更新。复制代码</code></pre><blockquote><p>一般我们通过该函数来优化性能：</p></blockquote><blockquote><p>一个React项目需要更新一个小组件时，很可能需要父组件更新自己的状态。而一个父组件的重新更新会造成它旗下所有的子组件重新执行render()方法，形成新的虚拟DOM，再用diff算法对新旧虚拟DOM进行结构和属性的比较，决定组件是否需要重新渲染</p></blockquote><blockquote><p>无疑这样的操作会造成很多的性能浪费，所以我们开发者可以根据项目的业务逻辑，在<code>shouldComponentUpdate()</code>中加入条件判断，从而优化性能</p></blockquote><blockquote><p>例如React中的就提供了一个<code>PureComponent</code>的类，当我们的组件继承于它时，组件更新时就会默认先比较新旧属性和状态，从而决定组件是否更新。值得注意的是，<code>PureComponent</code>进行的是浅比较，所以组件状态或属性改变时，都需要返回一个新的对象或数组</p></blockquote><h5 id="3、componentWillUpdate"><a href="#3、componentWillUpdate" class="headerlink" title="3、componentWillUpdate()"></a>3、componentWillUpdate()</h5><blockquote><p>组件即将被更新时触发</p></blockquote><h5 id="4、componentDidUpdate"><a href="#4、componentDidUpdate" class="headerlink" title="4、componentDidUpdate()"></a>4、componentDidUpdate()</h5><blockquote><p>组件被更新完成后触发。页面中产生了新的DOM的元素，可以进行DOM操作</p></blockquote><h4 id="三、销毁阶段"><a href="#三、销毁阶段" class="headerlink" title="三、销毁阶段"></a>三、销毁阶段</h4><h5 id="1、componentWillUnmount"><a href="#1、componentWillUnmount" class="headerlink" title="1、componentWillUnmount()"></a>1、componentWillUnmount()</h5><blockquote><p>组件被销毁时触发。这里我们可以进行一些清理操作，例如清理定时器，取消Redux的订阅事件等等。</p></blockquote><h3 id="有兴趣的同学也可以用下面的代码进行测试"><a href="#有兴趣的同学也可以用下面的代码进行测试" class="headerlink" title="有兴趣的同学也可以用下面的代码进行测试"></a>有兴趣的同学也可以用下面的代码进行测试</h3><h4 id="废话少说，放码过来"><a href="#废话少说，放码过来" class="headerlink" title="废话少说，放码过来!"></a>废话少说，放码过来!</h4><pre><code>import React from &apos;react&apos;import ReactDOM from &apos;react-dom&apos;;class SubCounter extends React.Component {    componentWillReceiveProps() {        console.log(&apos;9、子组件将要接收到新属性&apos;);    }    shouldComponentUpdate(newProps, newState) {        console.log(&apos;10、子组件是否需要更新&apos;);        if (newProps.number &lt; 5) return true;        return false    }    componentWillUpdate() {        console.log(&apos;11、子组件将要更新&apos;);    }    componentDidUpdate() {        console.log(&apos;13、子组件更新完成&apos;);    }    componentWillUnmount() {        console.log(&apos;14、子组件将卸载&apos;);    }    render() {        console.log(&apos;12、子组件挂载中&apos;);        return (                &lt;p&gt;{this.props.number}&lt;/p&gt;        )    }}class Counter extends React.Component {    static defaultProps = {        //1、加载默认属性        name: &apos;sls&apos;,        age:23    };    constructor() {        super();        //2、加载默认状态        this.state = {number: 0}    }    componentWillMount() {        console.log(&apos;3、父组件挂载之前&apos;);    }    componentDidMount() {        console.log(&apos;5、父组件挂载完成&apos;);    }    shouldComponentUpdate(newProps, newState) {        console.log(&apos;6、父组件是否需要更新&apos;);        if (newState.number&lt;15) return true;        return false    }    componentWillUpdate() {        console.log(&apos;7、父组件将要更新&apos;);    }    componentDidUpdate() {        console.log(&apos;8、父组件更新完成&apos;);    }    handleClick = () =&gt; {        this.setState({            number: this.state.number + 1        })    };    render() {        console.log(&apos;4、render(父组件挂载)&apos;);        return (            &lt;div&gt;                &lt;p&gt;{this.state.number}&lt;/p&gt;                &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt;                {this.state.number&lt;10?&lt;SubCounter number={this.state.number}/&gt;:null}            &lt;/div&gt;        )    }}ReactDOM.render(&lt;Counter/&gt;, document.getElementById(&apos;root&apos;));</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;生命周期函数：在某一个时刻组件会自动调用执行的函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;React-生命周期&quot;&gt;&lt;a href=&quot;#React-生命周期&quot; class=&quot;headerlink&quot; title=&quot;React 生命周期&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>201901面试题分享</title>
    <link href="https://github.com/ZhangQiangQQ/2019/01/22/201901%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB/"/>
    <id>https://github.com/ZhangQiangQQ/2019/01/22/201901面试题分享/</id>
    <published>2019-01-22T03:01:04.000Z</published>
    <updated>2019-07-06T02:28:09.962Z</updated>
    
    <content type="html"><![CDATA[<ul><li>vue生命周期</li><li>vue父子组通信</li><li>箭头函数什么情况下不能用</li><li>原型原型链介绍一下</li><li>闭包是什么</li><li>自己有没有写过node中间件</li><li>webpack有没有用过，都用哪些功能</li><li>移动端适配怎么做</li><li>rem和em的区别</li><li>css怎么画一个三角形</li><li>常规函数，箭头函数的this指向</li><li>class的super怎么用</li><li>class如何实现继承的,子类如何使用父类里的方法</li><li>数组如何去重（ES5,ES6）</li><li>let const var 区别</li><li>call apply bind区别和用法</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.sayhello()</span><br><span class="line">2.sayhello()</span><br><span class="line">怎么都输出1</span><br></pre></td></tr></table></figure></li><li><p>服务端渲染有没有了解过</p></li><li>vue的虚拟dom原理是什么？怎么实现的？</li><li>vue的beforeCreate和created区别</li><li>promise怎么实现两个同时执行</li><li>promise怎么让两个接口，接口1执行完成后执行接口2</li><li>await怎么知道后面执行的成功还是失败</li><li>promise遇到错误，catch里会有什么</li><li>用一个变量等于await+函数，那这个变量结果是什么</li><li>数组里都是数字时怎么排序？有几种方法</li><li>http请求头里都有什么内容</li><li>cookie和localstorage的区别</li><li>node登陆注册怎么做的</li><li>node token的实现</li><li>如何在同一台服务器起多个pm2进程</li><li>还有个手写的题目记不起来了，不过考的就是闭包内私有变量和全局变量的区别</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;vue生命周期&lt;/li&gt;
&lt;li&gt;vue父子组通信&lt;/li&gt;
&lt;li&gt;箭头函数什么情况下不能用&lt;/li&gt;
&lt;li&gt;原型原型链介绍一下&lt;/li&gt;
&lt;li&gt;闭包是什么&lt;/li&gt;
&lt;li&gt;自己有没有写过node中间件&lt;/li&gt;
&lt;li&gt;webpack有没有用过，都用哪
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React_V16入门手册</title>
    <link href="https://github.com/ZhangQiangQQ/2019/01/18/React_V16%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/"/>
    <id>https://github.com/ZhangQiangQQ/2019/01/18/React_V16入门手册/</id>
    <published>2019-01-18T09:09:19.000Z</published>
    <updated>2019-07-06T02:28:09.966Z</updated>
    
    <content type="html"><![CDATA[<p>原文<a href="">https://medium.freecodecamp.org/the-react-handbook-b71c27b0a795</a></p><p>开始着手学习React，就看到大佬推荐的这篇文章，因为是英文，就尽自己能力翻译一下有错的烦请指正。原文一共220页A4纸，内容有点多，所以会分期更新，见谅</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这本React手册遵循二八原则：用20%的时间学习80%的内容</p><p>在本手册里使用了React Hooks，所以你需要使用高于等于 16.7.0-alpha.2 版本的React和ReactDom.</p><p>如果你使用create-react-app初始化项目时，在初始化项目之后运行<figure class="highlight plain"><figcaption><span>install react@16.7.0-alpha.2 react-dom@16.7.0-</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alpha.2</span><br></pre></td></tr></table></figure></p><p>我希望你能在你阅读完本手册后能达到一个目标：学会React的基础</p><h2 id="React介绍"><a href="#React介绍" class="headerlink" title="React介绍"></a>React介绍</h2><p>先来介绍一下React库</p><h4 id="什么是React"><a href="#什么是React" class="headerlink" title="什么是React"></a>什么是React</h4><p>React是一个旨在简化开发可视化界面的Javascript库。它由Facebook开发，并于2013年向世界发布，并支持着很多被广泛使用的App，包括Facebook和Instagram等无数应用程序。<br>它的主要目标是通过将UI划分为一组组件，使得在任何时间点都可以轻松地构建界面及其状态。</p><h4 id="为什么React这么流行？"><a href="#为什么React这么流行？" class="headerlink" title="为什么React这么流行？"></a>为什么React这么流行？</h4><p>React席卷了整个前端开发领域，为什么？</p><h4 id="比其他框架更低的复杂性"><a href="#比其他框架更低的复杂性" class="headerlink" title="比其他框架更低的复杂性"></a>比其他框架更低的复杂性</h4><p>在React出道之前，Ember.js和Angular1.X是主流框架。这两种方法在代码上强加了太多的约定，以至于移植现有的应用程序一点都不方便。React选择了非常容易集成到现有项目中的方式，因为Facebook必须实现这一点，这样才能将其引入现有代码库。另外，这两个框架本身包含的内容太多了，而React只选择实现视图层而不是完整的MVC技术栈。</p><h4 id="完美的时间"><a href="#完美的时间" class="headerlink" title="完美的时间"></a>完美的时间</h4><p>当谷歌宣布Angular2.X时，宣称Angular1.X并不能平滑升级到Angular2.X，这两个就像不同的框架一样，所以想要从Angular1.X升级到Angular2.X就得重构项目。因为这一点，再加上React承诺说能带来执行速度的提升，所以很多程序员就迫不及待的尝试。</p><h4 id="Facebook的支持"><a href="#Facebook的支持" class="headerlink" title="Facebook的支持"></a>Facebook的支持</h4><p>如果一个项目最终成功，得到Facebook的支持显然也会让它受益。Facebook目前对React非常感兴趣，并看到了它开源的价值，这对所有在自己项目中使用React的开发者来说都是一个巨大的优势。</p><h4 id="React学起来容易吗？"><a href="#React学起来容易吗？" class="headerlink" title="React学起来容易吗？"></a>React学起来容易吗？</h4><p>虽然我说React要比其他框架简单，但是深入学习React的话还是挺有难度的，难的主要原因是要与React搭配使用的技术，比如Redux,GraphQL等等。</p><p>React本身有一个非常小的API，你至少需要理解4个概念才能开始:</p><ul><li>Components</li><li>JSX</li><li>State</li><li>Props</li></ul><p>上面这些（甚至更多）都会在手册中一一解释</p><h2 id="如何安装React"><a href="#如何安装React" class="headerlink" title="如何安装React"></a>如何安装React</h2><h4 id="如何在你的电脑上安装React"><a href="#如何在你的电脑上安装React" class="headerlink" title="如何在你的电脑上安装React?"></a>如何在你的电脑上安装React?</h4><p>React是一个库，所以说安装这个词会有点奇怪，倒不如说“设置”更贴切。在你的app或者网页中有很多方式可以设置React</p><h4 id="直接在网页里引入"><a href="#直接在网页里引入" class="headerlink" title="直接在网页里引入"></a>直接在网页里引入</h4><p>最简单的方法是直接将React JavaScript文件添加到页面中。当React应用与单个页面上的元素进行交互，而不是实际控制整个导航时，这是最好的选择。</p><p>下面的例子中，你在body的最后添加了两个script标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">    ...</span><br><span class="line">        &lt;script</span><br><span class="line">        src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/16.7.0-alpha.2/umd/react.development.js&quot; </span><br><span class="line">        crossorigin&gt;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">        &lt;script</span><br><span class="line">        src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react-dom/16.7.0-alpha.2/umd/react-dom.production.min.js&quot;</span><br><span class="line">        crossorigin&gt;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在这里我们引入两个库（React和React Dom），是为什么呢？因为React是百分之的独立于浏览器的，你也可以在浏览器之外使用React（比如用React Native开发移动应用时，也能用React），因此需要React Dom来操作dom。</p><p>在引入Javascript文件后，你需要为react，在html里添加script标签，才能使用JSX语法，下面两种方式都可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//在app.js里写JSX</span><br><span class="line">&lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- or --&gt;</span><br><span class="line"></span><br><span class="line">//直接在标签内写JSX</span><br><span class="line">&lt;script&gt;</span><br><span class="line">//my app</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>如果要使用JSX，你还需要引入Babel</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>引入后要在之前写的script标签里添加type=”text/babel”才会生效，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;app.js&quot; type=&quot;text/babel&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>现在你可以在你的app.js里写JSX的代码了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const Button = () =&gt; &#123;</span><br><span class="line">return &lt;button&gt;Click me!&lt;/button&gt;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;Button /&gt;, document.getElementById(&apos;root&apos;))</span><br></pre></td></tr></table></figure><p>演示代码地址：<br><a href="演示代码">https://glitch.com/edit/#!/react-example-inline-jsx?path=index.html:21:19</a></p><h4 id="用官方脚手架create-react-app（推荐）"><a href="#用官方脚手架create-react-app（推荐）" class="headerlink" title="用官方脚手架create-react-app（推荐）"></a>用官方脚手架create-react-app（推荐）</h4><p>create-react-app旨在让你能快速构建一个React项目，任何React应用都可以使用create-react-app来生成一个单页页面。</p><p>首先你需要安装npm和node （地址：<a href="">https://nodejs.org/en/</a>）就不多说了<br>然后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app todolist</span><br></pre></td></tr></table></figure><p>npx是npm 5.2之后才有的工具，npx会下载create-react-app，然后解压安装，然后执行<figure class="highlight plain"><figcaption><span>todolist```,然后再把create-react-app从系统中删除。这样你就永远能够使用最新的create-react-app，不会在电脑里存放着过时的create-react-app。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行完之后你能看到下面的界面</span><br><span class="line"></span><br><span class="line">![](https://user-gold-cdn.xitu.io/2019/1/18/168602568623fb3a?w=741&amp;h=677&amp;f=png&amp;s=36167)</span><br><span class="line"></span><br><span class="line">create-react-app会在文件夹内创建相应的文件结构，文件名就是todolist（自己取的）</span><br><span class="line">package.json也同样生成了，只需要安装指示，进入相应的文件夹，执行npm start就可以启动项目了</span><br><span class="line"></span><br><span class="line">如图</span><br><span class="line"></span><br><span class="line">![](https://user-gold-cdn.xitu.io/2019/1/18/168602a792310119?w=454&amp;h=260&amp;f=png&amp;s=12615)</span><br><span class="line"></span><br><span class="line">打开浏览器进入http://localhost:3000/就能看到最开始的界面了。</span><br><span class="line"></span><br><span class="line">除了 npm start , create-react-app这两个命令之外，还有下面一些命令</span><br><span class="line">* npm run build ：要在构建文件夹中构建准备部署到服务器的React应用程序文件</span><br><span class="line">* npm test：运行Jest测试包</span><br><span class="line">* npm eject ：弹出配置文件 </span><br><span class="line">何时用npm eject？create-react-app已经做了很多工作了，但你想要完成更多的工作时，就要弹出配置文件来自己配置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">因为create-react-app 是为了满足大部分人的需求和有限的配置，当你有一些独特的需求时，就需要自己来配置一些内容了。</span><br><span class="line"></span><br><span class="line">当你使用npm eject时，你的页面就不会自动更新了，但你可以在Babel和Webpack配置中获得更大的灵活性。</span><br><span class="line"></span><br><span class="line">eject时是不可逆的，当你执行后你会获得两个新的文件夹，配置和脚本。你就可以开始自由的编辑他们了。</span><br><span class="line"></span><br><span class="line">&gt; 下节预告：下节我们将学习在学习React之前需要了解的JS语法及一些知识</span><br><span class="line"></span><br><span class="line">## 使用React需要什么样的JS能力</span><br><span class="line">#### 在深入学习React之前找到你必须要掌握的内容</span><br><span class="line">如果你想学习React时，首先你需要做一些事情。您必须熟悉一些必要的技术，特别是你将在React中反复使用的一些最新JavaScript特性相关的技术。</span><br><span class="line"></span><br><span class="line">有些人以为一些功能是React提供的一些特定的功能，实际上它们只是Javascript最新的语法。</span><br><span class="line"></span><br><span class="line">立即掌握这些新语法，成为这方面的专家是不可能的，也没必要。但你如果想要深入研究React，那你就需要熟练掌握他们了。</span><br><span class="line"></span><br><span class="line">我会把它们列举下来让你快速了解一下。</span><br><span class="line"></span><br><span class="line">## 变量</span><br><span class="line">变量是分配给标识符的文字，因此您可以引用它并在后面的程序里使用它。学习如何用JavaScript声明一个。</span><br><span class="line"></span><br><span class="line">JavaScript中的变量没有附加任何类型。将特定的文字类型分配给变量后，可以稍后再给这个变量分配类型，而不会出现类型错误或任何问题。</span><br><span class="line"></span><br><span class="line">所以这就是为什么有时候Javascript会报&apos;untyped&apos;这样的问题。</span><br><span class="line"></span><br><span class="line">一个变量必须在你使用之前就声明。有三种方法可以做到这一点，使用var、let或const，这三种方法在以后与变量的交互方式上有所不同。</span><br><span class="line"></span><br><span class="line">#### 用Var</span><br><span class="line">知道ES2015，var一直都是定义变量的唯一方法。</span><br></pre></td></tr></table></figure></p><p>var a = 0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果你忘了添加var，你给未声明的变量赋值，结果可能会有所不同，在严格模式下，会得到一个错误，在旧的环境，或者禁用严格模式下，就会使得该变量成为一个全局变量，赋值也自然会赋值给一个全局变量。</span><br><span class="line"></span><br><span class="line">如果你没有将变量初始化，那他的值就是undefined</span><br></pre></td></tr></table></figure></p><p>var a //typeof a === ‘undefined’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你可以多次声明变量</span><br></pre></td></tr></table></figure><p>var a = 1<br>var a = 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最重要的，你可以一次就声明多个变量</span><br></pre></td></tr></table></figure></p><p>var a = 1, b = 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">作用域是代码中变量可见的部分（有效）。在函数外部声明一个变量，变量就是全局的，所有的函数都可以获得该变量的值，但在函数内部声明一个变量，变量就是局部的，只有在该函数内才能获得该变量的值，就像函数的一个参数。</span><br><span class="line"></span><br><span class="line">在与全局变量同名的函数中定义的任何变量都优先于全局变量，并对其进行跟踪。</span><br><span class="line"></span><br><span class="line">重要的是要理解一个块(由一对花括号标识)没有定义一个新的作用域。新作用域只在创建函数时创建，因为var没有块作用域，而是函数作用域。</span><br><span class="line"></span><br><span class="line">函数内部,在函数的所有代码中，变量在任何位置都是可见的,即使函数的变量声明在函数最后仍然可以引用。,因为JavaScript执行代码之前将所有变量提升。但为了避免混淆，总是在函数的开头声明变量。</span><br><span class="line"></span><br><span class="line">#### 用Let</span><br><span class="line"></span><br><span class="line">let是ES2015中引入的一个新特性，它本质上是var的块范围版本。它的作用域仅限于定义它的块、语句或表达式以及所有包含的内部块。</span><br><span class="line"></span><br><span class="line">现代JavaScript开发人员可能选择只使用let，而完全放弃使用var。</span><br><span class="line"></span><br><span class="line">&gt; 如果let看起来是一个模糊的术语，只要看let color = &apos;red&apos;就是让颜色是红色，这就更容易理解了</span><br><span class="line"></span><br><span class="line">与var相反，在任何函数外部定义let都不会创建全局变量。</span><br><span class="line">#### 用Const</span><br><span class="line"></span><br><span class="line">用var或let声明的变量可以稍后在程序中更改并重新分配。一旦const被初始化，它的值就再也不会被更改，也不能被重新分配到不同的值。</span><br></pre></td></tr></table></figure></p><p>const a = ‘test’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">我们不能给a常量定义不同的文字了。但是，如果对象提供了改变其内容的方法，我们可以对它进行变异。</span><br><span class="line">const 定义了就不能修改或重新赋值</span><br><span class="line"></span><br><span class="line">const和let一样都有块级作用域</span><br><span class="line"></span><br><span class="line">现代JavaScript开发人员可能会选择始终对不需要在程序中稍后重新分配的变量使用const。</span><br><span class="line"></span><br><span class="line">&gt; 为什么?因为我们应该总是使用最简单的结构来避免将来犯错误。</span><br><span class="line"></span><br><span class="line">## 箭头函数</span><br><span class="line"></span><br><span class="line">箭头函数是在ES6 / ECMAScript 2015中引入的，自从引入以来，它们彻底改变了JavaScript代码的外观(和工作方式)。</span><br><span class="line"></span><br><span class="line">在我看来，这种变化非常受欢迎，以至于你现在很少看到在现代代码库中使用function关键字。</span><br><span class="line"></span><br><span class="line">从视觉上看，这是一个简单而受欢迎的改变，它允许你用更短的语法编写函数，从:</span><br></pre></td></tr></table></figure></p><p>const myFunction = function() {<br>//…<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">到</span><br></pre></td></tr></table></figure></p><p>const myFunction = () =&gt; {<br>//…<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果函数体只包含一条语句，则可以省略括号，并将所有内容写在一行中:</span><br></pre></td></tr></table></figure></p><p>const myFunction = () =&gt; doSomething()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参数在括号中传递:</span><br></pre></td></tr></table></figure></p><p>const myFunction = (param1, param2) =&gt; doSomething(param1, param2)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果有一个(且只有一个)参数，可以完全省略括号:</span><br></pre></td></tr></table></figure></p><p>const myFunction = param =&gt; doSomething(param)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">由于这种简短的语法，箭头函数让我们能使用小体积的函数。</span><br><span class="line"></span><br><span class="line">#### 隐式返回</span><br><span class="line"></span><br><span class="line">箭头函数允许你使用隐式返回：返回的值不需要使用return关键字。</span><br><span class="line"></span><br><span class="line">当函数体中有一行语句时，它就可以工作:</span><br></pre></td></tr></table></figure></p><p>const myFunction = () =&gt; ‘test’<br>myFunction() //‘test’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">另一个例子，当返回一个对象时，记得将大括号括起来，以避免它被认为是括起来的函数的括号:</span><br></pre></td></tr></table></figure></p><p>const myFunction = () =&gt; ({ value: ‘test’ })<br>myFunction() //{value: ‘test’}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#### this在箭头函数里如何工作</span><br><span class="line">this是一个很难理解的概念。因为它会根据上下文和JavaScript的模式(严格模式或非严格模式)产生不同的含义。</span><br><span class="line"></span><br><span class="line">澄清这个概念很重要，因为在箭头函数中的this与常规函数中的this非常不同。</span><br><span class="line"></span><br><span class="line">当定义一个对象的方法时，在常规函数中的this指向这个对象，案例如下：</span><br></pre></td></tr></table></figure></p><p>const car = {<br>    model: ‘Fiesta’,<br>    manufacturer: ‘Ford’,<br>    fullName: function() {<br>        return <code>${this.manufacturer} ${this.model}</code><br>    }<br>}<br>car.fullName() //“Ford Fiesta”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行car.fullName()时会返回&quot;Ford Fiesta&quot;</span><br><span class="line"></span><br><span class="line">带有箭头函数的this作用域是从执行上下文中继承的。箭头函数根本不绑定this，因此它的值将在调用堆栈中查找。因此在这个代码car.fullName()中不起作用，并将返回字符串“undefined undefined”:</span><br></pre></td></tr></table></figure></p><p>const car = {<br>    model: ‘Fiesta’,<br>    manufacturer: ‘Ford’,<br>    fullName: () =&gt; {<br>        return <code>${this.manufacturer} ${this.model}</code><br>    }<br>}<br>car.fullName() //“undefined undefined”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">参考上面两个例子，可以看出，箭头函数并不适用于对象的方法。</span><br><span class="line"></span><br><span class="line">箭头函数也不能用作构造函数，因为实例化对象时将报错TypeError。当不需要动态上下文时，应该在这里使用箭头函数来代替常规函数。</span><br><span class="line"></span><br><span class="line">在处理事件时还有一个问题，DOM事件侦听器将this设置为目标元素，如果在事件处理程序中依赖于此元素，则需要一个常规函数:</span><br></pre></td></tr></table></figure></p><p>const link = document.querySelector(‘#link’)<br>link.addEventListener(‘click’, () =&gt; {<br>    // this === window<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>const link = document.querySelector(‘#link’)<br>link.addEventListener(‘click’, function() {<br>    // this === link<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 使用Rest和Spread处理对象和数组</span><br><span class="line">#### 学习使用JavaScript处理数组和对象的两种现代技术</span><br><span class="line">您可以使用spread操作符展开数组、对象或字符串  ...</span><br><span class="line"></span><br><span class="line">看下面的例子：</span><br></pre></td></tr></table></figure></p><p>const a = [1, 2, 3]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你可以像下面一样创建一个新数组</span><br></pre></td></tr></table></figure></p><p>const b = […a, 4, 5, 6]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">还可以像下面一样创建一个数组的副本</span><br></pre></td></tr></table></figure></p><p>const b = […a]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也能用这种方式拷贝一个对象</span><br></pre></td></tr></table></figure></p><p>const newObj = { …oldObj }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用字符串时，spread操作符创建一个数组，数组内是每个字符:</span><br></pre></td></tr></table></figure></p><p>const hey = ‘hey’<br>const arrayized = […hey] // [‘h’, ‘e’, ‘y’]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个操作符有一些非常有用的应用。最重要的是能够以一种非常简单的方式将数组作为函数参数:</span><br></pre></td></tr></table></figure></p><p>const f = (foo, bar) =&gt; {}<br>const a = [1, 2]<br>f(…a)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(在过去，你可以用f.apply(null, a) 来做这个但是这样做不太好，可读性也不好)</span><br><span class="line"></span><br><span class="line">rest元素和spread元素在使用数组解构赋值时非常有用:</span><br></pre></td></tr></table></figure></p><p>const numbers = [1, 2, 3, 4, 5]<br>[first, second, …others] = numbers</p><p>const numbers = [1, 2, 3, 4, 5]<br>const sum = (a, b, c, d, e) =&gt; a + b + c + d + e<br>const sum = sum(…numbers)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ES2018引入了rest属性，它们是相同的，但是是用于对象。</span><br><span class="line"></span><br><span class="line">Rest属性</span><br></pre></td></tr></table></figure></p><p>const { first, second, …others } = {<br>    first: 1,<br>    second: 2,<br>    third: 3,<br>    fourth: 4,<br>    fifth: 5<br>}<br>first // 1<br>second // 2<br>others // { third: 3, fourth: 4, fifth: 5 }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">扩展属性允许通过合并在扩展操作符之后传递的对象属性来创建一个新对象:</span><br></pre></td></tr></table></figure></p><p>const items = { first, second, …others }<br>items //{ first: 1, second: 2, third: 3, fourth: 4, fifth: 5 }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## 数组和对象的解构赋值</span><br><span class="line">#### 学习如何使用解构赋值语法来处理JavaScript中的数组和对象</span><br><span class="line">给定一个对象，使用解构赋值语法，您可以提取一些值，并将它们放入命名变量:</span><br></pre></td></tr></table></figure></p><p>const person = {<br>firstName: ‘Tom’,<br>lastName: ‘Cruise’,<br>actor: true,<br>age: 54 //made up<br>}<br>const { firstName: name, age } = person //name: Tom, age: 54<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name和age包含了所需要的值。</span><br><span class="line"></span><br><span class="line">这个语法也可以在数组上使用</span><br></pre></td></tr></table></figure></p><p>const a = [1, 2, 3, 4, 5]<br>const [first, second] = a<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该语句通过从数组a中获取索引0、1、4的项来创建3个新变量（first，second，fifth）</span><br></pre></td></tr></table></figure></p><p>const [first, second, , , fifth] = a<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">## 模板字符串</span><br><span class="line">在ES2015(又名ES6)中引入的模板字符串提供了一种声明字符串的新方法，也提供了一些已经非常流行的有趣的新构造方法。</span><br><span class="line"></span><br><span class="line">#### 模板字符串介绍</span><br><span class="line"></span><br><span class="line">模板文字是ES2015 / ES6的新特性，与ES5及以下版本相比，它允许你以一种新颖的方式处理字符串。</span><br><span class="line">语法乍一看非常简单，只需使用反引号而不是单引号或双引号:</span><br></pre></td></tr></table></figure></p><p>const a_string = <code>something</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">它们是很独特的的，因为它们提供了许多用引号构建的普通字符串所没有的特性，特别是:</span><br><span class="line">* 它们提供了一个很好的语法来定义多行字符串</span><br><span class="line">* 它们提供了一种简单的方法在字符串中用变量和表达式插值</span><br><span class="line">* 它们允许您使用模板标记创建DSL (DSL意味着特定于领域的语言，例如在React by style组件中使用DSL为组件定义CSS)</span><br><span class="line"></span><br><span class="line">#### 让我们详细研究上面三个东西</span><br><span class="line">#### 多行字符串</span><br><span class="line">在es6之前，要创建一个跨越两行的字符串，您必须在一行末尾使用\字符</span><br></pre></td></tr></table></figure></p><p>const string =<br>  ‘first part \<br>second part’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这允许在两行创建一个字符串，但它只呈现在一行:</span><br></pre></td></tr></table></figure></p><p>first part second part<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">要在多行渲染字符串，你需要显式地在每行末尾添加\n，如下所示:</span><br></pre></td></tr></table></figure></p><p>const string =<br>  ‘first line\n \<br>second line’</p><p>//或者<br>const string = ‘first line\n’ + ‘second line’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用模板字符串就简单多了</span><br><span class="line"></span><br><span class="line">一旦模板文字使用回车，你只需按回车键来创建一个没有特殊字符的新行，它就会按原样呈现:</span><br></pre></td></tr></table></figure></p><p>const string = `Hey<br>this</p><p>string<br>is awesome!`</p><p>//结果如下<br>Hey<br>this</p><p>string<br>is awesome!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">记住，模板字符串的空格是有意义的，所以这样做:</span><br></pre></td></tr></table></figure></p><p>const string = <code>First                Second</code></p><p>//结果如下<br>First<br>                Second<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解决这个问题的一种简单方法是，在第一行中设置一个空行，并在结束后加上trim()方法，这将消除第一个字符之前的任何空格:</span><br></pre></td></tr></table></figure></p><p>const string = <code>FirstSecond</code>.trim()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#### 模板字符串插值</span><br><span class="line">模板字符串提供了一种将变量和表达式插入字符串的简单方法。</span><br><span class="line">你可以用这样的语法```$&#123;...&#125;```：</span><br></pre></td></tr></table></figure></p><p>const var = ‘test’<br>const string = <code>something ${var}</code> //something test<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在```$&#123;...&#125;```里你可以插入任何东西，甚至是表达式</span><br></pre></td></tr></table></figure></p><p>const string = <code>something ${1 + 2 + 3}</code><br>const string2 = <code>something ${foo() ? &#39;x&#39; : &#39;y&#39;}</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">## Class（类）</span><br><span class="line">2015年，ECMAScript 6 (ES6)标准引入了类。</span><br><span class="line"></span><br><span class="line">JavaScript有一种非常少见的实现继承的方法:原型继承。虽然原型继承在我看来很好，但它不同于大多数其他流行编程语言的继承实现，后者是基于类的。</span><br><span class="line"></span><br><span class="line">来自Java、Python或其他语言的人很难理解原型继承的复杂性，所以ECMAScript委员会决定在原型继承的基础上添加语法糖，这样就像其他流行实现中的基于类的继承一样。</span><br><span class="line"></span><br><span class="line">这一点很重要:底层的JavaScript仍然是相同的，您还是可以用常规的方式访问对象原型。</span><br><span class="line"></span><br><span class="line">#### 一个class类的定义</span><br><span class="line">一个类长下面这样</span><br></pre></td></tr></table></figure></p><p>class Person {<br>  constructor(name) {<br>    this.name = name<br>  }<br>  hello() {<br>    return ‘Hello, I am ‘ + this.name + ‘.’<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类有一个标识符，我们可以使用它来使用new ClassIdentifier()创建新对象</span><br><span class="line"></span><br><span class="line">初始化对象时，调用constructor方法，并传递任意参数。</span><br><span class="line"></span><br><span class="line">一个类也有它所需要的所有方法。在这种情况下，hello是一个方法，这个类派生的所有对象都可以调用这个方法:</span><br></pre></td></tr></table></figure></p><p>const flavio = new Person(‘Flavio’)<br>flavio.hello()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#### 类的实例</span><br><span class="line"></span><br><span class="line">类可以扩展另一个类，使用该类初始化的对象继承父类的所有方法。</span><br><span class="line"></span><br><span class="line">如果继承的类的方法与层次结构中较高层的类的名称相同，则最近的方法优先:</span><br></pre></td></tr></table></figure></p><p>class Programmer extends Person {<br>  hello() {<br>    return super.hello() + ‘ I am a programmer.’<br>  }<br>}<br>const flavio = new Programmer(‘Flavio’)<br>flavio.hello()<br>//输出 Hello, I am Flavio. I am a programmer.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">类没有显式的类变量声明，但是必须初始化构造函数中的任何变量</span><br><span class="line"></span><br><span class="line">在类中，可以用super()来引用父类。</span><br><span class="line"></span><br><span class="line">#### 静态方法</span><br><span class="line">通用方法是在实例上定义的，而不是在类上定义的。</span><br><span class="line">静态方法在类上执行:</span><br></pre></td></tr></table></figure></p><p>class Person {<br>  static genericHello() {<br>    return ‘Hello’<br>  }<br>}<br>Person.genericHello() //Hello<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#### 私有方法</span><br><span class="line">JavaScript没有内置的方法来定义私有或受保护的方法。（可以参考闭包等概念）</span><br><span class="line"></span><br><span class="line">有一些变通方法，但我不会在这里描述它们。</span><br><span class="line">#### Getters 和 setters</span><br><span class="line">你可以添加以get或set为前缀的方法来创建getter和setter，这是根据您正在做的事情执行两段不同的代码:访问变量或修改其值。</span><br></pre></td></tr></table></figure></p><p>class Person {<br>  constructor(name) {<br>    this._name = name<br>  }<br>  set name(value) {<br>    this._name = value<br>  }<br>  get name() {<br>    return this._name<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果您只有一个getter，则无法设置该属性，并且任何这样做的尝试都将被忽略:</span><br></pre></td></tr></table></figure></p><p>class Person {<br>  constructor(name) {<br>    this.name = name<br>  }<br>  get name() {<br>    return this.name<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果你只有一个setter，你可以改变值，但不能从外部访问它:</span><br></pre></td></tr></table></figure></p><p>class Person {<br>  constructor(name) {<br>    this.name = name<br>  }<br>  set name(value) {<br>    this.name = value<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">## 回调</span><br><span class="line">计算机在设计上是异步的。</span><br><span class="line"></span><br><span class="line">异步意味着事情可以独立于主程序流发生。</span><br><span class="line"></span><br><span class="line">在当前的客户端计算机中，每个程序都运行一个特定的时间段，然后停止执行，让另一个程序继续执行。这个东西以一种无法察觉的速度循环运行，我们认为计算机同时运行许多程序，但这是一种错觉(多处理器机器除外)。</span><br><span class="line"></span><br><span class="line">程序在内部使用中断——这是一种向处理器发出的信号，以引起系统的注意。</span><br><span class="line"></span><br><span class="line">我不会深入讨论它的内部原理，但是要记住，程序是异步的是很正常的，在它们需要注意的时候停止它们的执行，而计算机可以同时执行其他事情。当程序正在等待来自网络的响应时，它不能在请求完成之前停止处理器。</span><br><span class="line"></span><br><span class="line">通常，编程语言是同步的，有些语言提供了一种方法来管理语言或库中的异步性。C, Java, c#， PHP, Go, Ruby, Swift, Python，它们默认都是同步的。其中一些通过使用线程处理异步，生成一个新进程。</span><br><span class="line"></span><br><span class="line">JavaScript默认是同步的，并且是单线程的。这意味着代码不能创建新线程并并行运行。</span><br><span class="line"></span><br><span class="line">一行接一行的执行代码，例如:</span><br></pre></td></tr></table></figure></p><p>const a = 1<br>const b = 2<br>const c = a * b<br>console.log(c)<br>doSomething()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">但是JavaScript是在浏览器中诞生的，它最初的主要工作是响应用户操作，比如onClick、onMouseOver、onChange、onSubmit等等。它如何使用同步编程模型实现这一点呢?</span><br><span class="line"></span><br><span class="line">答案就在它所处的环境中。浏览器提供了一种方法，它提供了一组api来处理这种功能。</span><br><span class="line"></span><br><span class="line">最近，NodeJS引入了一个非阻塞I/O环境，将这个概念扩展到文件访问、网络调用等。</span><br><span class="line"></span><br><span class="line">你不知道用户什么时候会点击按钮，所以你要做的是，为点击事件定义一个事件处理器。此事件处理程序接受一个函数，该函数将在事件触发时被调用:</span><br></pre></td></tr></table></figure></p><p>document.getElementById(‘button’).addEventListener(‘click’, () =&gt; {<br>  //item clicked<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这就是回调（callback)</span><br><span class="line"></span><br><span class="line">回调是一个简单的函数，它作为一个值传递给另一个函数，只在事件发生时执行。我们可以这样做，因为JavaScript具有一流的函数，可以将其分配给变量并传递给其他函数(称为高阶函数)</span><br><span class="line"></span><br><span class="line">将所有代码包装在windows对象上的load事件监听器中是很常见的，它只在页面准备好时才运行回调函数:</span><br></pre></td></tr></table></figure></p><p>window.addEventListener(‘load’, () =&gt; {<br>  //window loaded<br>  //do what you want<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">回调可以用在任何地方，不只是dom事件上</span><br><span class="line"></span><br><span class="line">一个常用的定时器例子：</span><br></pre></td></tr></table></figure></p><p>setTimeout(() =&gt; {<br>  // runs after 2 seconds<br>}, 2000)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">XHR请求也接受回调，在本例中，它将一个函数分配给一个属性，该属性将在特定事件发生时被调用(在本例中，请求状态发生变化):</span><br></pre></td></tr></table></figure></p><p>const xhr = new XMLHttpRequest()<br>xhr.onreadystatechange = () =&gt; {<br>  if (xhr.readyState === 4) {<br>    xhr.status === 200 ? console.log(xhr.responseText) : console.error(‘error’)<br>  }<br>}<br>xhr.open(‘GET’, ‘<a href="https://yoursite.com&#39;" target="_blank" rel="noopener">https://yoursite.com&#39;</a>)<br>xhr.send()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 处理回调中的错误</span><br><span class="line"></span><br><span class="line">如何在回调处理错误?一个非常常见的策略是使用Node所采用的方法:任何回调函数中的第一个参数都是error对象:error-first回调</span><br><span class="line"></span><br><span class="line">如果没有错误，则对象为null。如果有错误，它包含错误的一些描述和其他信息。</span><br></pre></td></tr></table></figure></p><p>fs.readFile(‘/file.json’, (err, data) =&gt; {<br>  if (err !== null) {<br>    //handle error<br>    console.log(err)<br>    return<br>  }<br>  //no errors, process data<br>  console.log(data)<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 回调存在的问题</span><br><span class="line"></span><br><span class="line">回调对于简单的情况非常有用</span><br><span class="line"></span><br><span class="line">然而，每个回调都会增加一个嵌套级别，当你有很多回调时，代码开始变得非常复杂:</span><br></pre></td></tr></table></figure></p><p>window.addEventListener(‘load’, () =&gt; {<br>  document.getElementById(‘button’).addEventListener(‘click’, () =&gt; {<br>    setTimeout(() =&gt; {<br>      items.forEach(item =&gt; {<br>        //your code here<br>      })<br>    }, 2000)<br>  })<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这只是一个简单的4层代码，但我见过更多级别的嵌套，这并不有趣。</span><br><span class="line">怎么解呢?</span><br><span class="line"></span><br><span class="line">## 回调的替代品</span><br><span class="line">从ES6开始，JavaScript引入了几个特性，帮助我们处理不涉及回调的异步代码:</span><br><span class="line"></span><br><span class="line">* Promises (ES6)</span><br><span class="line">* Async/Await (ES8)</span><br><span class="line">## Promise</span><br><span class="line">Promise是处理异步代码的一种方法，无需在代码中编写太多回调。</span><br><span class="line"></span><br><span class="line">尽管它们已经存在多年，但是在ES2015中已经被标准化并引入，现在在ES2017中已经被异步函数所取代。</span><br><span class="line"></span><br><span class="line">Async函数使用promise API作为它们的构建块，因此理解它们是非常重要的，即使在较新的代码中您可能会使用Async函数而不是promise。</span><br><span class="line"></span><br><span class="line">#### 简而言之，Promise是如何工作的</span><br><span class="line">一旦Promise被调用，它将以pending状态启动。这意味着调用方函数将继续执行，同时等待Promise自己进行处理，并给调用方函数一些反馈。</span><br><span class="line"></span><br><span class="line">此时，调用方函数等待它以resolved状态或rejected状态返回承诺，但如您所知，JavaScript是异步的，因此函数在Promise工作时继续执行。</span><br><span class="line"></span><br><span class="line">#### 哪个JS API使用Promise?</span><br><span class="line">除了您自己的代码和库代码之外，Promises还被标准的现代Web api(如Fetch或Service Workers)使用。</span><br><span class="line"></span><br><span class="line">在现代JavaScript中，您不太可能不使用承诺，所以让我们开始深入研究它们。</span><br><span class="line"></span><br><span class="line">#### 创建一个promise</span><br><span class="line"></span><br><span class="line">Promise API公开了一个Promise构造函数，您可以使用它进行初始化```new Promise()```：</span><br></pre></td></tr></table></figure></p><p>let done = true<br>const isItDoneYet = new Promise((resolve, reject) =&gt; {<br>  if (done) {<br>    const workDone = ‘Here is the thing I built’<br>    resolve(workDone)<br>  } else {<br>    const why = ‘Still working on something else’<br>    reject(why)<br>  }<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">正如您所看到的，promise检查done全局常量，如果它为真，则返回一个resolve的promise，否则返回一个 reject的promise。</span><br><span class="line"></span><br><span class="line">使用resolve和reject，我们可以返回一个值，在上面的例子中，我们只返回一个字符串，但它也可以是一个对象。</span><br><span class="line"></span><br><span class="line">#### 使用promise</span><br><span class="line">在上一节中，我们介绍了如何创建承诺。</span><br><span class="line">现在让我们看看如何使用承诺。</span><br></pre></td></tr></table></figure></p><p>const isItDoneYet = new Promise()<br>//…<br>const checkIfItsDone = () =&gt; {<br>  isItDoneYet<br>    .then(ok =&gt; {<br>      console.log(ok)<br>    })<br>    .catch(err =&gt; {<br>      console.error(err)<br>    })<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">运行checkIfItsDone()将执行isItDoneYet() promise，并使用then回调等待它解决，如果出现错误，它将在catch回调中处理它。</span><br><span class="line"></span><br><span class="line">#### promise链</span><br><span class="line"></span><br><span class="line">一个promise可以返回给另一个promise，创建一个promise链。</span><br><span class="line"></span><br><span class="line">Fetch API是链接承诺的一个很好的例子，它是XMLHttpRequest API之上的一层，我们可以使用它来获取资源，并在获取资源时对要执行的promise链进行排队。</span><br><span class="line"></span><br><span class="line">Fetch API是一种基于promise的机制，调用Fetch()相当于使用new promise()定义我们自己的promise。</span><br><span class="line"></span><br><span class="line">例子：</span><br></pre></td></tr></table></figure></p><p>const status = response =&gt; {<br>  if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) {<br>    return Promise.resolve(response)<br>  }<br>  return Promise.reject(new Error(response.statusText))<br>}<br>const json = response =&gt; response.json()<br>fetch(‘/todos.json’)<br>  .then(status)<br>  .then(json)<br>  .then(data =&gt; {<br>    console.log(‘Request succeeded with JSON response’, data)<br>  })<br>  .catch(error =&gt; {<br>    console.log(‘Request failed’, error)<br>  })<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在本例中，我们调用fetch()从TODO中获取TODO项的列表。在域根目录中找到json文件，然后创建promise链。</span><br><span class="line"></span><br><span class="line">运行 fetch()后返回一个响应，它有很多属性，在这些属性中我们引用:</span><br><span class="line">* status表示HTTP状态代码的数值</span><br><span class="line">* statusText状态消息，如果是OK就是请求成功</span><br><span class="line"></span><br><span class="line">response也有一个json()方法，它返回一个promise，该promise将解析处理并转换为JSON的主体内容。</span><br><span class="line"></span><br><span class="line">在这些前提下，会发生这样的情况:链中的第一个promise是我们定义的一个函数status()，它检查响应状态，如果它不是一个成功响应(在200到299之间)，则拒绝该promise。</span><br><span class="line"></span><br><span class="line">此操作将导致promise链跳过列出的所有链接的promise，并直接跳到底部的catch()语句，记录请求失败的文本和错误消息。</span><br><span class="line"></span><br><span class="line">如果成功，则调用我们定义的json()函数。由于上一个promise成功时返回响应对象，所以我们将它作为第二个promise的输入。</span><br><span class="line"></span><br><span class="line">在这种情况下，我们返回JSON处理过的数据，所以第三个promise直接接收JSON:</span><br></pre></td></tr></table></figure></p><p>.then((data) =&gt; {<br>  console.log(‘Request succeeded with JSON response’, data)<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">我们只需将其打印到控制台</span><br><span class="line"></span><br><span class="line">#### 处理错误</span><br><span class="line">在上面的例子中，在上一节中，我们有一个catch，它被附加到promise链中。</span><br><span class="line"></span><br><span class="line">当promise链中的任何内容失败并引发错误或拒绝promise时，该控件将转到链中最近的catch()语句。</span><br></pre></td></tr></table></figure></p><p>new Promise((resolve, reject) =&gt; {<br>  throw new Error(‘Error’)<br>}).catch(err =&gt; {<br>  console.error(err)<br>})<br>// or<br>new Promise((resolve, reject) =&gt; {<br>  reject(‘Error’)<br>}).catch(err =&gt; {<br>  console.error(err)<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 串联错误</span><br><span class="line">如果在catch()中引发错误，可以附加第二个catch()来处理它，依此类推。</span><br></pre></td></tr></table></figure></p><p>new Promise((resolve, reject) =&gt; {<br>  throw new Error(‘Error’)<br>})<br>  .catch(err =&gt; {<br>    throw new Error(‘Error’)<br>  })<br>  .catch(err =&gt; {<br>    console.error(err)<br>  })<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#### 用 Promise.all()来编排promise</span><br><span class="line">如果您需要同步执行不同的promise，Promise.all()可以帮助您定义一个promise列表，并在所有promise都得到解析时执行某些操作。</span><br><span class="line"></span><br><span class="line">例子：</span><br></pre></td></tr></table></figure></p><p>const f1 = fetch(‘/something.json’)<br>const f2 = fetch(‘/something2.json’)<br>Promise.all([f1, f2])<br>  .then(res =&gt; {<br>    console.log(‘Array of results’, res)<br>  })<br>  .catch(err =&gt; {<br>    console.error(err)<br>  })<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ES2015析构赋值语法也允许您这样做</span><br></pre></td></tr></table></figure></p><p>Promise.all([f1, f2]).then(([res1, res2]) =&gt; {<br>  console.log(‘Results’, res1, res2)<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当然你不局限于使用fetch，任何promise都是好的。</span><br><span class="line">#### 用Promise.race()编排promise</span><br><span class="line"></span><br><span class="line">Promise.race()在您传递给它的某个promise解析时立即运行，并且在解析第一个promise的结果时，它只运行附加的回调一次（最先执行成功的promise后就返回该promise，其他的promise就不管了）。</span><br><span class="line"></span><br><span class="line">例子：</span><br></pre></td></tr></table></figure></p><p>const promiseOne = new Promise((resolve, reject) =&gt; {<br>  setTimeout(resolve, 500, ‘one’)<br>})<br>const promiseTwo = new Promise((resolve, reject) =&gt; {<br>  setTimeout(resolve, 100, ‘two’)<br>})<br>Promise.race([promiseOne, promiseTwo]).then(result =&gt; {<br>  console.log(result) // ‘two’<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">## Async/Await</span><br><span class="line">JavaScript在很短的时间内从回调发展到了promise (ES2015)，而且由于ES2017异步JavaScript使用async/ wait语法更加简单。</span><br><span class="line"></span><br><span class="line">异步函数是 promise和generate的组合，基本上，它们是比promise更高层次的抽象。让我重复一遍:async/ wait基于promise。</span><br><span class="line"></span><br><span class="line">#### 为什么要Async/Await</span><br><span class="line"></span><br><span class="line">这种方式减少了promise的使用，和‘不打破promise链’的限制</span><br><span class="line"></span><br><span class="line">当promise在ES2015中引入时，它们是为了解决异步代码的问题，它们确实解决了这个问题，但是在ES2015和ES2017分开的两年时间里，很明显promise并不是最终的解决方案。</span><br><span class="line"></span><br><span class="line">引入promise是为了解决著名的回调地狱问题，但它们本身也带来了复杂性，以及语法复杂性。</span><br><span class="line"></span><br><span class="line">它们语义化更好，可以向开发人员提供更好的语法，因此当时机成熟时，我们就可以使用async函数。</span><br><span class="line"></span><br><span class="line">它们使代码看起来是同步的，但在幕后它是异步的，非阻塞的。</span><br><span class="line"></span><br><span class="line">#### async如何工作的</span><br><span class="line"></span><br><span class="line">一个async函数返回一个promise，就像这个例子:</span><br></pre></td></tr></table></figure></p><p>const doSomethingAsync = () =&gt; {<br>  return new Promise(resolve =&gt; {<br>    setTimeout(() =&gt; resolve(‘I did something’), 3000)<br>  })<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当您想要调用这个函数时，您需要预先等待，调用代码将停止，直到promise被resolve或reject。一个警告:函数必须定义为async的。这里有一个例子:</span><br></pre></td></tr></table></figure></p><p>const doSomething = async () =&gt; {<br>  console.log(await doSomethingAsync())<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 一个快速的案例</span><br><span class="line">这是一个简单的async/await 的例子，用于异步运行一个函数:</span><br></pre></td></tr></table></figure></p><p>const doSomethingAsync = () =&gt; {<br>  return new Promise(resolve =&gt; {<br>    setTimeout(() =&gt; resolve(‘I did something’), 3000)<br>  })<br>}<br>const doSomething = async () =&gt; {<br>  console.log(await doSomethingAsync())<br>}<br>console.log(‘Before’)<br>doSomething()<br>console.log(‘After’)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以上代码将打印以下内容到浏览器控制台:</span><br></pre></td></tr></table></figure></p><p>Before<br>After<br>I did something //after 3s<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#### 所有的事都是promise</span><br><span class="line">在任何函数前面加上async关键字意味着函数将返回一个promise。</span><br><span class="line"></span><br><span class="line">即使它没有显式地返回promise，它也会在内部让它返回一个promise。</span><br><span class="line"></span><br><span class="line">这就是为什么这个代码是有效的:</span><br></pre></td></tr></table></figure></p><p>const aFunction = async () =&gt; {<br>  return ‘test’<br>}<br>aFunction().then(alert) // This will alert ‘test’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面也和下面一样</span><br></pre></td></tr></table></figure></p><p>const aFunction = async () =&gt; {<br>  return Promise.resolve(‘test’)<br>}<br>aFunction().then(alert) // This will alert ‘test’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#### 代码更易读</span><br><span class="line">正如您在上面的示例中看到的，我们的代码看起来非常简单。将其与使用纯promise(带有链接和回调函数)的代码进行比较。</span><br><span class="line"></span><br><span class="line">这是一个非常简单的例子，当代码更加复杂时，主要的好处就会显现出来。</span><br><span class="line"></span><br><span class="line">例如，下面是如何获得JSON资源，并使用promise对其进行解析:</span><br></pre></td></tr></table></figure></p><p>const getFirstUserData = () =&gt; {<br>  return fetch(‘/users.json’) // get users list<br>    .then(response =&gt; response.json()) // parse JSON<br>    .then(users =&gt; users[0]) // pick first user<br>    .then(user =&gt; fetch(<code>/users/${user.name}</code>)) // get user data<br>    .then(userResponse =&gt; response.json()) // parse JSON<br>}<br>getFirstUserData()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用await/async来实现上面的功能时</span><br></pre></td></tr></table></figure></p><p>const getFirstUserData = async () =&gt; {<br>  const response = await fetch(‘/users.json’) // get users list<br>  const users = await response.json() // parse JSON<br>  const user = users[0] // pick first user<br>  const userResponse = await fetch(<code>/users/${user.name}</code>) // get user data<br>  const userData = await user.json() // parse JSON<br>  return userData<br>}<br>getFirstUserData()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 串联多个异步函数</span><br><span class="line">异步函数可以很容易地链接起来，而且语法比普通的承诺更易读</span><br></pre></td></tr></table></figure></p><p>const promiseToDoSomething = () =&gt; {<br>  return new Promise(resolve =&gt; {<br>    setTimeout(() =&gt; resolve(‘I did something’), 10000)<br>  })<br>}<br>const watchOverSomeoneDoingSomething = async () =&gt; {<br>  const something = await promiseToDoSomething()<br>  return something + ‘ and I watched’<br>}<br>const watchOverSomeoneWatchingSomeoneDoingSomething = async () =&gt; {<br>  const something = await watchOverSomeoneDoingSomething()<br>  return something + ‘ and I watched as well’<br>}<br>watchOverSomeoneWatchingSomeoneDoingSomething().then(res =&gt; {<br>  console.log(res)<br>})</p><p>//输出<br>I did something and I watched and I watched as well<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#### 更好debug</span><br><span class="line">调试promise很困难，因为调试器不会跳过异步代码。</span><br><span class="line"></span><br><span class="line">Async/ wait使这一切变得非常简单，因为对于编译器来说，它就像同步代码一样。</span><br><span class="line"></span><br><span class="line">## ES 模块</span><br><span class="line">ES模块是用于处理模块的ECMAScript标准。</span><br><span class="line"></span><br><span class="line">nodeJS多年来一直使用CommonJS标准，浏览器从来没有模块系统，因为每一个重大决策，比如模块系统，都必须首先由ECMAScript标准化，然后由浏览器实现。</span><br><span class="line"></span><br><span class="line">这个标准化过程用ES6完成，浏览器开始实现这个标准，试图保持一切正常运行，以相同的方式工作，现在在Chrome、Safari、Edge和Firefox(从版本60开始)中都支持ES模块。</span><br><span class="line"></span><br><span class="line">模块非常酷，因为它们允许您封装各种功能，并将这些功能作为库公开给其他JavaScript文件。</span><br><span class="line"></span><br><span class="line">#### ES模块语法</span><br><span class="line">导入模块的语法是:</span><br></pre></td></tr></table></figure></p><p>import package from ‘module-name’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用CommonJS 时：</span><br></pre></td></tr></table></figure></p><p>const package = require(‘module-name’)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">模块是一个JavaScript文件，它使用export关键字导出一个或多个值(对象、函数或变量)。例如，这个模块导出一个函数，返回一个大写字符串:</span><br><span class="line">&gt; uppercase.js</span><br></pre></td></tr></table></figure></p><p>export default str =&gt; str.toUpperCase()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在本例中，模块定义了一个default export，因此它可以是一个匿名函数。否则，它需要一个名称来将其与其他导出区分开。</span><br><span class="line"></span><br><span class="line">现在，通过导入这个文件，任何其他JavaScript模块都可以用导入的uppercase.js提供的功能。</span><br><span class="line">HTML页面可以使用</span><br><span class="line">```&lt;script&gt;``` 标记添加模块，该标记具有特殊的```type=&quot;module&quot;```属性:</span><br></pre></td></tr></table></figure></p><p><script type="module" src="index.js"></script><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 注意:此模块导入的行为类似于defer脚本加载。</span><br><span class="line"></span><br><span class="line">需要注意的是，使用```type=&quot;module&quot;```加载的任何脚本都是在严格模式下加载的。</span><br><span class="line"></span><br><span class="line">在这个例子中，uppercase.js 模块定义了一个 default export,所以当我们导入它的时候，我们可以给它分配一个我们喜欢的名字:</span><br></pre></td></tr></table></figure></p><p>import toUpperCase from ‘./uppercase.js’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们可以这样使用</span><br></pre></td></tr></table></figure></p><p>toUpperCase(‘test’) //‘TEST’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">您还可以使用模块导入的绝对路径，来引用在另一个域中定义的模块:</span><br></pre></td></tr></table></figure></p><p>import toUpperCase from ‘<a href="https://flavio-es-modules-example.glitch.me/uppercase.js&#39;" target="_blank" rel="noopener">https://flavio-es-modules-example.glitch.me/uppercase.js&#39;</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这也是有效的导入语法:</span><br></pre></td></tr></table></figure></p><p>import { foo } from ‘/uppercase.js’<br>import { foo } from ‘../uppercase.js’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下面是不对的：</span><br></pre></td></tr></table></figure></p><p>import { foo } from ‘uppercase.js’<br>import { foo } from ‘utils/uppercase.js’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">它要么是绝对的，要么在名字前有一个./或者/。</span><br><span class="line"></span><br><span class="line">## 其他 import/export方法</span><br><span class="line">我们看到上面的例子:</span><br></pre></td></tr></table></figure></p><p>export default str =&gt; str.toUpperCase()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这将创建一个默认导出。在一个文件中，你可以导出多个东西，通过使用以下语法:</span><br></pre></td></tr></table></figure></p><p>const a = 1<br>const b = 2<br>const c = 3<br>export { a, b, c }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">另一个模块可以使用import *来导入所有这些export的内容</span><br></pre></td></tr></table></figure></p><p>import * from ‘module’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你可以只导入其中的几个导出，使用析构赋值:</span><br></pre></td></tr></table></figure></p><p>import { a } from ‘module’<br>import { a, b } from ‘module’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了方便，可以使用as重命名任何导入</span><br></pre></td></tr></table></figure></p><p>import { a, b as two } from ‘module’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">您可以按名称导入默认导出和任何非默认导出，如以下常见的React导入:</span><br></pre></td></tr></table></figure></p><p>import React, { Component } from ‘react’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## CORS(跨域)</span><br><span class="line">使用CORS获取模块。这意味着如果您引用来自其他域的脚本，它们必须具有允许跨站点加载的有效CORS头（比如Access-Control-Allow-Origin: *）</span><br><span class="line">#### 那么不支持模块的浏览器呢?</span><br><span class="line">结合使用```type=&quot;module&quot;``` 和```nomodule</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script nomodule src=&quot;fallback.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>ES模块是现代浏览器中引入的最大特性之一。它们是ES6的一部分，但实现它们的道路是漫长的。</p><p>我们现在可以使用它们了!但是我们还必须记住，如果有多个模块，那么页面的性能将受到影响，因为这是浏览器在运行时必须执行更多一个步骤。</p><p>即使ES模块在浏览器里能用了，Webpack可能仍然是一个巨大的玩家，但是直接在语言中构建这样的特性对于统一模块在客户端和nodeJS的工作方式是非常重要的。</p><blockquote><p>下节预告：React的概念</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文&lt;a href=&quot;&quot;&gt;https://medium.freecodecamp.org/the-react-handbook-b71c27b0a795&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;开始着手学习React，就看到大佬推荐的这篇文章，因为是英文，就尽自己能力翻译一下有错的烦请指正。
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue使用踩坑记录</title>
    <link href="https://github.com/ZhangQiangQQ/2019/01/14/Vue%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://github.com/ZhangQiangQQ/2019/01/14/Vue使用踩坑记录/</id>
    <published>2019-01-14T05:52:15.000Z</published>
    <updated>2019-07-06T02:28:09.967Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>主要记录在Vue项目中遇到的一些问题</p><ol><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: Unexpected console statement (no-console) at src\components\leftSideBar\index.vue:41:9:</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* eslint no-console: 0*/</span><br><span class="line">console.log(&apos;a&apos;)</span><br></pre></td></tr></table></figure></p><ol start="2"><li>使用module.exports时遇到问题<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">menu-conf.js?6ce3:1 Uncaught TypeError: Cannot assign to read only property &apos;exports&apos; of object &apos;#&lt;Object&gt;&apos;</span><br><span class="line"></span><br><span class="line">&quot;export &apos;default&apos; (imported as &apos;sidebarconf&apos;) was not found in &apos;../../conf/menu-conf&apos;</span><br></pre></td></tr></table></figure></li></ol><p>解决：<br>改用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default a;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;主要记录在Vue项目中遇到的一些问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于我</title>
    <link href="https://github.com/ZhangQiangQQ/2019/01/11/%E5%85%B3%E4%BA%8E%E6%88%91/"/>
    <id>https://github.com/ZhangQiangQQ/2019/01/11/关于我/</id>
    <published>2019-01-11T10:00:59.000Z</published>
    <updated>2019-07-06T02:28:09.971Z</updated>
    
    <content type="html"><![CDATA[<h3 id="我是Harry🐷"><a href="#我是Harry🐷" class="headerlink" title="我是Harry🐷"></a>我是Harry🐷</h3><blockquote><p>17年正式毕业出栏，喜欢学习，编程，健身，做饭，吃喝玩乐<br>前端开发从16年6月就开始，执迷于业务，所以至今技术方面仍然在追赶大佬，终究会有成功的一天<br>主要使用Vue，Angualr1，React，Mongodb，Node，Express，mysql，小程序等<br>如果客官有啥好事情，请速速带我上车<br><strong><code>邮箱：1562055324@qq.com</code></strong><br><strong><code>微信：zq156205</code></strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;我是Harry🐷&quot;&gt;&lt;a href=&quot;#我是Harry🐷&quot; class=&quot;headerlink&quot; title=&quot;我是Harry🐷&quot;&gt;&lt;/a&gt;我是Harry🐷&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;17年正式毕业出栏，喜欢学习，编程，健身，做饭，吃喝玩乐&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Javascript常见的内存泄漏</title>
    <link href="https://github.com/ZhangQiangQQ/2019/01/11/Javascript%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>https://github.com/ZhangQiangQQ/2019/01/11/Javascript常见的内存泄漏/</id>
    <published>2019-01-11T07:42:13.000Z</published>
    <updated>2019-07-06T02:28:09.963Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>什么是内存泄露？<br>程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。<br>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。<br>白话解释就是你写的代码里有些东西不用了，就别在保存再内存中了，不然好比你开了100个迅雷CPU卡不卡？卡，但你其实真正用到的只是其中一个迅雷。这就是内存泄漏</p></blockquote><p>想要理解JavaScript的内存泄漏，就要先了解一下js的自动垃圾收集机制</p><h4 id="js的自动垃圾收集机制"><a href="#js的自动垃圾收集机制" class="headerlink" title="js的自动垃圾收集机制"></a>js的自动垃圾收集机制</h4><p>在编写JS时，我们不用像C++一样要手工跟踪内存的使用情况，JS的内存分配和无用内存的回收完全实现了自动化。</p><p>JS常用的垃圾收集机制有两种：1. 标记清除 2. 引用计数</p><ol><li><p>标记清除<br>在函数声明一个变量的时候，就将这个变量标记为“进入环境”。从逻辑上讲，永远都不能释放进入环境的变量作占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。垃圾回收器在运行时候会给存储在内存中中的所有变量都加上标记。然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。在此之后再被标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清楚工作，销毁那些带标记的值并回收他们所占用的内存空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">function test()&#123; </span><br><span class="line"> var a = 10 ; //被标记 ，进入环境 </span><br><span class="line"> var b = 20 ; //被标记 ，进入环境 </span><br><span class="line">&#125; </span><br><span class="line">test(); //执行完毕 之后 a、b又被标离开环境，被回收。</span><br></pre></td></tr></table></figure></li><li><p>引用计数（现代浏览器不再使用）<br>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。</p><p> 但是很重要的一点是当遇到循环引用的时候，函数的引用次数就不会为0，所以不会被垃圾回收器回收内存，会造成内存泄露。在IE中涉及DOM对象，就会存在循环引用的问题。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line">function test()&#123; </span><br><span class="line"> var a = &#123;&#125; ; //a的引用次数为0 </span><br><span class="line"> </span><br><span class="line"> var b = a ; //a的引用次数加1，为1 </span><br><span class="line"> </span><br><span class="line"> var c =a; //a的引用次数再加1，为2 </span><br><span class="line"> </span><br><span class="line"> var b =&#123;&#125;; //b解除对a的引用，a的引用次数减1，为1 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 循环引用</span><br><span class="line">function cycle() &#123;</span><br><span class="line">    var o1 = &#123;&#125;;</span><br><span class="line">    var o2 = &#123;&#125;;</span><br><span class="line">    o1.a = o2;</span><br><span class="line">    o2.a = o1; </span><br><span class="line"></span><br><span class="line">    return &quot;cycle reference!&quot;</span><br><span class="line">&#125;</span><br><span class="line">cycle();</span><br><span class="line"></span><br><span class="line">//数组</span><br><span class="line">let arr = [1,2,3]</span><br><span class="line"></span><br><span class="line">虽然这里没有引用arr，arr对他的值发生了引用，所以会一直存在内存中，可以采用 arr=null来解除引用</span><br></pre></td></tr></table></figure><p>虽然有了自动垃圾收集机制，我们可以不必太过关注一些内存泄漏的问题，但有些情况下还是会发生这种问题</p><h4 id="js的常见内存泄漏"><a href="#js的常见内存泄漏" class="headerlink" title="js的常见内存泄漏"></a>js的常见内存泄漏</h4><ol><li><p>全局变量引起的内存泄漏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function leaks()&#123;  </span><br><span class="line">    leak = &apos;xxxxxx&apos;;//leak 成为一个全局变量，不会被回收</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>闭包引起的内存泄漏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var leaks = (function()&#123;  </span><br><span class="line">    var leak = &apos;xxxxxx&apos;;// 被闭包所引用，不会被回收</span><br><span class="line">    return function()&#123;</span><br><span class="line">        console.log(leak);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li><li><p>dom清空或删除时，事件未清除导致的内存泄漏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;  </span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">$(&apos;#container&apos;).bind(&apos;click&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;click&apos;);</span><br><span class="line">&#125;).remove();</span><br><span class="line"></span><br><span class="line">// zepto 和原生 js下，#container dom 元素，还在内存里jquery 的 empty和 remove会帮助开发者避免这个问题</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;container&quot;&gt;  </span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">$(&apos;#container&apos;).bind(&apos;click&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;click&apos;);</span><br><span class="line">&#125;).off(&apos;click&apos;).remove();</span><br><span class="line">//把事件清除了，即可从内存中移除</span><br></pre></td></tr></table></figure></li><li><p>计时器或回调函数<br>定时器setInterval</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = fun();</span><br><span class="line">setInterval(function()&#123;</span><br><span class="line">  var node = document.getElementById(&apos;node&apos;);</span><br><span class="line">  if(node)&#123;</span><br><span class="line">     node.innerHTML = &apos;test&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;，1000);</span><br></pre></td></tr></table></figure></li></ol><p>节点node或数据不需要时，定时器setInterval依然指向这些数据，所以即使node节点被溢出，interval仍旧存活并且垃圾回收期没法回收。</p><p>解决是终止定时器。</p><p>这种循环定时器，是一定要设置关闭条件，然后将其clear并且将timer指向null]</p><h4 id="解决方法及性能优化"><a href="#解决方法及性能优化" class="headerlink" title="解决方法及性能优化"></a>解决方法及性能优化</h4><p>发生内存泄漏肯定是不愿看到的，我们可以采取：<br>一旦确定数据不再使用，可以手动将其值设置为null来释放其引用。 —— 解除引用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;什么是内存泄露？&lt;br&gt;程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。&lt;br&gt;对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端知识点1901</title>
    <link href="https://github.com/ZhangQiangQQ/2019/01/11/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9190111/"/>
    <id>https://github.com/ZhangQiangQQ/2019/01/11/前端知识点190111/</id>
    <published>2019-01-11T06:11:16.000Z</published>
    <updated>2019-07-06T02:28:09.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一面-1：ES-基础知识点与高频考题解析"><a href="#一面-1：ES-基础知识点与高频考题解析" class="headerlink" title="一面 1：ES 基础知识点与高频考题解析"></a><strong>一面 1：ES 基础知识点与高频考题解析</strong></h1><p>JavaScript 是 ECMAScript 规范的一种实现，本小节重点梳理下 ECMAScript 中的常考知识点，然后就一些容易出现的题目进行解析。</p><h2 id="知识点梳理"><a href="#知识点梳理" class="headerlink" title="知识点梳理"></a><strong>知识点梳理</strong></h2><ul><li>变量类型<ul><li>JS 的数据类型分类和判断</li><li>值类型和引用类型</li></ul></li><li>原型与原型链（继承）<ul><li>原型和原型链定义</li><li>继承写法</li></ul></li><li>作用域和闭包<ul><li>执行上下文</li><li>this</li><li>闭包是什么</li></ul></li><li>异步<ul><li>同步 vs 异步</li><li>异步和单线程</li><li>前端异步的场景</li></ul></li><li>ES6/7 新标准的考查<ul><li>箭头函数</li><li>Module</li><li>Class</li><li>Set 和 Map</li><li>Promise</li></ul></li></ul><hr><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a><strong>变量类型</strong></h2><p>JavaScript 是一种弱类型脚本语言，所谓弱类型指的是定义变量时，不需要什么类型，在程序运行过程中会自动判断类型。</p><p>ECMAScript 中定义了 6 种原始类型：</p><ul><li>Boolean</li><li>String</li><li>Number</li><li>Null</li><li>Undefined</li><li>Symbol（ES6 新定义）</li></ul><p><strong>注意</strong>：原始类型不包含 Object。</p><blockquote><p>题目：类型判断用到哪些方法？</p></blockquote><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a><strong><code>typeof</code></strong></h3><p><code>typeof xxx</code>得到的值有以下几种类型：<code>undefined`</code>boolean<code>number</code>string<code>object</code>function<code>、</code>symbol` ，比较简单，不再一一演示了。这里需要注意的有三点：</p><ul><li><code>typeof null</code>结果是<code>object</code> ，实际这是<code>typeof</code>的一个bug，null是原始值，非引用类型</li><li><code>typeof [1, 2]</code>结果是<code>object</code>，结果中没有<code>array</code>这一项，引用类型除了<code>function</code>其他的全部都是<code>object</code></li><li><code>typeof Symbol()</code> 用<code>typeof</code>获取<code>symbol</code>类型的值得到的是<code>symbol</code>，这是 ES6 新增的知识点</li></ul><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><strong><code>instanceof</code></strong></h3><p>用于实例和构造函数的对应。例如判断一个变量是否是数组，使用<code>typeof</code>无法判断，但可以使用<code>[1, 2] instanceof Array</code>来判断。因为，<code>[1, 2]</code>是数组，它的构造函数就是<code>Array</code>。同理：</p><pre><code>function Foo(name) {    this.name = name}var foo = new Foo(&apos;bar&apos;)console.log(foo instanceof Foo) // true</code></pre><p>复制</p><blockquote><p>题目：值类型和引用类型的区别</p></blockquote><h3 id="值类型-vs-引用类型"><a href="#值类型-vs-引用类型" class="headerlink" title="值类型 vs 引用类型"></a><strong>值类型 vs 引用类型</strong></h3><p>除了原始类型，ES 还有引用类型，上文提到的<code>typeof</code>识别出来的类型中，只有<code>object</code>和<code>function</code>是引用类型，其他都是值类型。</p><p>根据 JavaScript 中的变量类型传递方式，又分为<strong>值类型</strong>和<strong>引用类型</strong>，值类型变量包括 Boolean、String、Number、Undefined、Null，引用类型包括了 Object 类的所有，如 Date、Array、Function 等。在参数传递方式上，值类型是按值传递，引用类型是按共享传递。</p><p>下面通过一个小题目，来看下两者的主要区别，以及实际开发中需要注意的地方。</p><pre><code>// 值类型var a = 10var b = ab = 20console.log(a)  // 10console.log(b)  // 20</code></pre><p>复制</p><p>上述代码中，<code>a`</code>b`都是值类型，两者分别修改赋值，相互之间没有任何影响。再看引用类型的例子：</p><pre><code>// 引用类型var a = {x: 10, y: 20}var b = ab.x = 100b.y = 200console.log(a)  // {x: 100, y: 200}console.log(b)  // {x: 100, y: 200}</code></pre><p>复制</p><p>上述代码中，<code>a`</code>b<code>都是引用类型。在执行了</code>b = a<code>之后，修改</code>b<code>的属性值，</code>a<code>的也跟着变化。因为</code>a<code>和</code>b<code>都是引用类型，指向了同一个内存地址，即两者引用的是同一个值，因此</code>b<code>修改属性时，</code>a`的值随之改动。</p><p>再借助题目进一步讲解一下。</p><blockquote><p>说出下面代码的执行结果，并分析其原因。</p></blockquote><pre><code>function foo(a){    a = a * 10;}function bar(b){    b.value = &apos;new&apos;;}var a = 1;var b = {value: &apos;old&apos;};foo(a);bar(b);console.log(a); // 1console.log(b); // value: new</code></pre><p>复制</p><p>通过代码执行，会发现：</p><ul><li><code>a</code>的值没有发生改变</li><li>而<code>b</code>的值发生了改变</li></ul><p>这就是因为<code>Number</code>类型的<code>a</code>是按值传递的，而<code>Object</code>类型的<code>b</code>是按共享传递的。</p><p>JS 中这种设计的原因是：按值传递的类型，复制一份存入栈内存，这类类型一般不占用太多内存，而且按值传递保证了其访问速度。按共享传递的类型，是复制其引用，而不是整个复制其值（C 语言中的指针），保证过大的对象等不会因为不停复制内容而造成内存的浪费。</p><p>引用类型经常会在代码中按照下面的写法使用，或者说<strong>容易不知不觉中造成错误</strong>！</p><pre><code>var obj = {    a: 1,    b: [1,2,3]}var a = obj.avar b = obj.ba = 2b.push(4)console.log(obj, a, b)</code></pre><p>复制</p><p>虽然<code>obj</code>本身是个引用类型的变量（对象），但是内部的<code>a</code>和<code>b</code>一个是值类型一个是引用类型，<code>a</code>的赋值不会改变<code>obj.a</code>，但是<code>b</code>的操作却会反映到<code>obj</code>对象上。</p><hr><h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a><strong>原型和原型链</strong></h2><p>JavaScript 是基于原型的语言，原型理解起来非常简单，但却特别重要，下面还是通过题目来理解下JavaScript 的原型概念。</p><blockquote><p>题目：如何理解 JavaScript 的原型</p></blockquote><p>对于这个问题，可以从下面这几个要点来理解和回答，<strong>下面几条必须记住并且理解</strong></p><ul><li><strong>所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（<code>null</code>除外）</strong></li><li><strong>所有的引用类型（数组、对象、函数），都有一个<code>__proto__</code>属性，属性值是一个普通的对象</strong></li><li><strong>所有的函数，都有一个<code>prototype</code>属性，属性值也是一个普通的对象</strong></li><li><strong>所有的引用类型（数组、对象、函数），<code>__proto__</code>属性值指向它的构造函数的<code>prototype</code>属性值</strong></li></ul><p>通过代码解释一下，大家可自行运行以下代码，看结果。</p><pre><code>// 要点一：自由扩展属性var obj = {}; obj.a = 100;var arr = []; arr.a = 100;function fn () {}fn.a = 100;// 要点二：__proto__console.log(obj.__proto__);console.log(arr.__proto__);console.log(fn.__proto__);// 要点三：函数有 prototypeconsole.log(fn.prototype)// 要点四：引用类型的 __proto__ 属性值指向它的构造函数的 prototype 属性值console.log(obj.__proto__ === Object.prototype)</code></pre><p>复制</p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a><strong>原型</strong></h3><p>先写一个简单的代码示例。</p><pre><code>// 构造函数function Foo(name, age) {    this.name = name}Foo.prototype.alertName = function () {    alert(this.name)}// 创建示例var f = new Foo(&apos;zhangsan&apos;)f.printName = function () {    console.log(this.name)}// 测试f.printName()f.alertName()</code></pre><p>复制</p><p>执行<code>printName</code>时很好理解，但是执行<code>alertName</code>时发生了什么？这里再记住一个重点 <strong>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的<code>__proto__</code>（即它的构造函数的<code>prototype</code>）中寻找</strong>，因此<code>f.alertName</code>就会找到<code>Foo.prototype.alertName</code>。</p><p>那么如何判断这个属性是不是对象本身的属性呢？使用<code>hasOwnProperty</code>，常用的地方是遍历一个对象的时候。</p><pre><code>var itemfor (item in f) {    // 高级浏览器已经在 for in 中屏蔽了来自原型的属性，但是这里建议大家还是加上这个判断，保证程序的健壮性    if (f.hasOwnProperty(item)) {        console.log(item)    }}</code></pre><p>复制</p><blockquote><p>题目：如何理解 JS 的原型链</p></blockquote><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a><strong>原型链</strong></h3><p>还是接着上面的示例，如果执行<code>f.toString()</code>时，又发生了什么？</p><pre><code>// 省略 N 行// 测试f.printName()f.alertName()f.toString()</code></pre><p>复制</p><p>因为<code>f</code>本身没有<code>toString()</code>，并且<code>f.__proto__</code>（即<code>Foo.prototype</code>）中也没有<code>toString</code>。这个问题还是得拿出刚才那句话——<strong>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的<code>__proto__</code>（即它的构造函数的<code>prototype</code>）中寻找</strong>。</p><p>如果在<code>f.__proto__</code>中没有找到<code>toString</code>，那么就继续去<code>f.__proto__.__proto__</code>中寻找，因为<code>f.__proto__</code>就是一个普通的对象而已嘛！</p><ul><li><code>f.__proto__</code>即<code>Foo.prototype</code>，没有找到<code>toString</code>，继续往上找</li><li><code>f.__proto__.__proto__</code>即<code>Foo.prototype.__proto__</code>。<code>Foo.prototype</code>就是一个普通的对象，因此<code>Foo.prototype.__proto__</code>就是<code>Object.prototype</code>，在这里可以找到<code>toString</code></li><li>因此<code>f.toString</code>最终对应到了<code>Object.prototype.toString</code></li></ul><p>这样一直往上找，你会发现是一个链式的结构，所以叫做“原型链”。如果一直找到最上层都没有找到，那么就宣告失败，返回<code>undefined</code>。最上层是什么 —— <code>Object.prototype.__proto__ === null</code></p><h3 id="原型链中的this"><a href="#原型链中的this" class="headerlink" title="原型链中的this"></a><strong>原型链中的<code>this</code></strong></h3><p>所有从原型或更高级原型中得到、执行的方法，其中的<code>this</code>在执行时，就指向了当前这个触发事件执行的对象。因此<code>printName</code>和<code>alertName</code>中的<code>this</code>都是<code>f</code>。</p><hr><h2 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a><strong>作用域和闭包</strong></h2><p>作用域和闭包是前端面试中，最可能考查的知识点。例如下面的题目：</p><blockquote><p>题目：现在有个 HTML 片段，要求编写代码，点击编号为几的链接就<code>alert</code>弹出其编号</p></blockquote><pre><code>&lt;ul&gt;    &lt;li&gt;编号1，点击我请弹出1&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;    &lt;li&gt;3&lt;/li&gt;    &lt;li&gt;4&lt;/li&gt;    &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt;</code></pre><p>复制</p><p>一般不知道这个题目用闭包的话，会写出下面的代码：</p><pre><code>var list = document.getElementsByTagName(&apos;li&apos;);for (var i = 0; i &lt; list.length; i++) {    list[i].addEventListener(&apos;click&apos;, function(){        alert(i + 1)    }, true)}</code></pre><p>复制</p><p>实际上执行才会发现始终弹出的是<code>6</code>，这时候就应该通过闭包来解决：</p><pre><code>var list = document.getElementsByTagName(&apos;li&apos;);for (var i = 0; i &lt; list.length; i++) {    list[i].addEventListener(&apos;click&apos;, function(i){        return function(){            alert(i + 1)        }    }(i), true)}</code></pre><p>复制</p><p>要理解闭包，就需要我们从「执行上下文」开始讲起。</p><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a><strong>执行上下文</strong></h3><p>先讲一个关于 <strong>变量提升</strong> 的知识点，面试中可能会遇见下面的问题，很多候选人都回答错误：</p><blockquote><p>题目：说出下面执行的结果（这里笔者直接注释输出了）</p></blockquote><pre><code>console.log(a)  // undefinedvar a = 100fn(&apos;zhangsan&apos;)  // &apos;zhangsan&apos; 20function fn(name) {    age = 20    console.log(name, age)    var age}console.log(b); // 这里报错// Uncaught ReferenceError: b is not definedb = 100;</code></pre><p>复制</p><p>在一段 JS 脚本（即一个<code>&lt;script&gt;</code>标签中）执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个 <strong>全局执行上下文</strong> 环境，先把代码中即将执行的（内部函数的不算，因为你不知道函数何时执行）变量、函数声明都拿出来。变量先暂时赋值为<code>undefined</code>，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。再次强调，这是在代码执行之前才开始的工作。</p><p>我们来看下上面的面试小题目，为什么<code>a</code>是<code>undefined</code>，而<code>b</code>却报错了，实际 JS 在代码执行之前，要「全文解析」，发现<code>var a</code>，知道有个<code>a</code>的变量，存入了执行上下文，而<code>b</code>没有找到<code>var</code>关键字，这时候没有在执行上下文提前「占位」，所以代码执行的时候，提前报到的<code>a</code>是有记录的，只不过值暂时还没有赋值，即为<code>undefined</code>，而<code>b</code>在执行上下文没有找到，自然会报错（没有找到<code>b</code>的引用）。</p><p>另外，一个函数在执行之前，也会创建一个 <strong>函数执行上下文</strong> 环境，跟 <strong>全局上下文</strong> 差不多，不过 <strong>函数执行上下文</strong> 中会多出<code>this`</code>arguments<code>和函数的参数。参数和</code>arguments<code>好理解，这里的</code>this`咱们需要专门讲解。</p><p>总结一下：</p><ul><li>范围：一段<code>&lt;script&gt;</code>、js 文件或者一个函数</li><li>全局上下文：变量定义，函数声明</li><li>函数上下文：变量定义，函数声明，<code>this</code>，<code>arguments</code></li></ul><h3 id="this"><a href="#this" class="headerlink" title="this"></a><strong><code>this</code></strong></h3><p>先搞明白一个很重要的概念 —— <strong><code>this</code>的值是在执行的时候才能确认，定义的时候不能确认！</strong> 为什么呢 —— 因为<code>this</code>是执行上下文环境的一部分，而执行上下文需要在代码执行之前确定，而不是定义的时候。看如下例子</p><pre><code>var a = {    name: &apos;A&apos;,    fn: function () {        console.log(this.name)    }}a.fn()  // this === aa.fn.call({name: &apos;B&apos;})  // this === {name: &apos;B&apos;}var fn1 = a.fnfn1()  // this === window</code></pre><p>复制</p><p><code>this</code>执行会有不同，主要集中在这几个场景中</p><ul><li>作为构造函数执行，构造函数中</li><li>作为对象属性执行，上述代码中<code>a.fn()</code></li><li>作为普通函数执行，上述代码中<code>fn1()</code></li><li>用于<code>call`</code>apply<code></code>bind<code>，上述代码中</code>a.fn.call({name: ‘B’})`</li></ul><p>下面再来讲解下什么是作用域和作用域链，作用域链和作用域也是常考的题目。</p><blockquote><p>题目：如何理解 JS 的作用域和作用域链</p></blockquote><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a><strong>作用域</strong></h3><p>ES6 之前 JS 没有块级作用域。例如</p><pre><code>if (true) {    var name = &apos;zhangsan&apos;}console.log(name)</code></pre><p>复制</p><p>从上面的例子可以体会到作用域的概念，作用域就是一个独立的地盘，让变量不会外泄、暴露出去。上面的<code>name</code>就被暴露出去了，因此，<strong>JS 没有块级作用域，只有全局作用域和函数作用域</strong>。</p><pre><code>var a = 100function fn() {    var a = 200    console.log(&apos;fn&apos;, a)}console.log(&apos;global&apos;, a)fn()</code></pre><p>复制</p><p>全局作用域就是最外层的作用域，如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样的坏处就是很容易撞车、冲突。</p><pre><code>// 张三写的代码中var data = {a: 100}// 李四写的代码中var data = {x: true}</code></pre><p>复制</p><p>这就是为何 jQuery、Zepto 等库的源码，所有的代码都会放在<code>(function(){....})()</code>中。因为放在里面的所有变量，都不会被外泄和暴露，不会污染到外面，不会对其他的库或者 JS 脚本造成影响。这是函数作用域的一个体现。</p><p>附：ES6 中开始加入了块级作用域，使用<code>let</code>定义变量即可，如下：</p><pre><code>if (true) {    let name = &apos;zhangsan&apos;}console.log(name)  // undefined</code></pre><p>复制</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a><strong>作用域链</strong></h3><p>首先认识一下什么叫做 <strong>自由变量</strong> 。如下代码中，<code>console.log(a)</code>要得到<code>a</code>变量，但是在当前的作用域中没有定义<code>a</code>（可对比一下<code>b</code>）。当前作用域没有定义的变量，这成为 <strong>自由变量</strong> 。自由变量如何得到 —— 向父级作用域寻找。</p><pre><code>var a = 100function fn() {    var b = 200    console.log(a)    console.log(b)}fn()</code></pre><p>复制</p><p>如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 <strong>作用域链</strong> 。</p><pre><code>var a = 100function F1() {    var b = 200    function F2() {        var c = 300        console.log(a) // 自由变量，顺作用域链向父作用域找        console.log(b) // 自由变量，顺作用域链向父作用域找        console.log(c) // 本作用域的变量    }    F2()}F1()</code></pre><p>复制</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a><strong>闭包</strong></h3><p>讲完这些内容，我们再来看一个例子，通过例子来理解闭包。</p><pre><code>function F1() {    var a = 100    return function () {        console.log(a)    }}var f1 = F1()var a = 200f1()</code></pre><p>复制</p><p>自由变量将从作用域链中去寻找，但是 <strong>依据的是函数定义时的作用域链，而不是函数执行时</strong>，以上这个例子就是闭包。闭包主要有两个应用场景：</p><ul><li><strong>函数作为返回值</strong>，上面的例子就是</li><li><p><strong>函数作为参数传递</strong>，看以下例子</p><p>function F1() {</p><pre><code>var a = 100return function () {    console.log(a)}</code></pre><p>}<br>function F2(f1) {</p><pre><code>var a = 200console.log(f1())</code></pre><p>}<br>var f1 = F1()<br>F2(f1)</p></li></ul><p>复制</p><p>至此，对应着「作用域和闭包」这部分一开始的点击弹出<code>alert</code>的代码再看闭包，就很好理解了。</p><hr><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a><strong>异步</strong></h2><p>异步和同步也是面试中常考的内容，下面笔者来讲解下同步和异步的区别。</p><h3 id="同步-vs-异步"><a href="#同步-vs-异步" class="headerlink" title="同步 vs 异步"></a><strong>同步 vs 异步</strong></h3><p>先看下面的 demo，根据程序阅读起来表达的意思，应该是先打印<code>100</code>，1秒钟之后打印<code>200</code>，最后打印<code>300</code>。但是实际运行根本不是那么回事。</p><pre><code>console.log(100)setTimeout(function () {    console.log(200)}, 1000)console.log(300)</code></pre><p>复制</p><p>再对比以下程序。先打印<code>100</code>，再弹出<code>200</code>（等待用户确认），最后打印<code>300</code>。这个运行效果就符合预期要求。</p><pre><code>console.log(100)alert(200)  // 1秒钟之后点击确认console.log(300)</code></pre><p>复制</p><p>这俩到底有何区别？—— 第一个示例中间的步骤根本没有阻塞接下来程序的运行，而第二个示例却阻塞了后面程序的运行。前面这种表现就叫做 <strong>异步</strong>（后面这个叫做 <strong>同步</strong> ），即<strong>不会阻塞后面程序的运行</strong>。</p><h3 id="异步和单线程"><a href="#异步和单线程" class="headerlink" title="异步和单线程"></a><strong>异步和单线程</strong></h3><p>JS 需要异步的根本原因是 <strong>JS 是单线程运行的</strong>，即在同一时间只能做一件事，不能“一心二用”。</p><p>一个 Ajax 请求由于网络比较慢，请求需要 5 秒钟。如果是同步，这 5 秒钟页面就卡死在这里啥也干不了了。异步的话，就好很多了，5 秒等待就等待了，其他事情不耽误做，至于那 5 秒钟等待是网速太慢，不是因为 JS 的原因。</p><p>讲到单线程，我们再来看个真题：</p><blockquote><p>题目：讲解下面代码的执行过程和结果</p></blockquote><pre><code>var a = true;setTimeout(function(){    a = false;}, 100)while(a){    console.log(&apos;while执行了&apos;)}</code></pre><p>复制</p><p>这是一个很有迷惑性的题目，不少候选人认为<code>100ms</code>之后，由于<code>a</code>变成了<code>false</code>，所以<code>while</code>就中止了，实际不是这样，因为JS是单线程的，所以进入<code>while</code>循环之后，没有「时间」（线程）去跑定时器了，所以这个代码跑起来是个死循环！</p><h3 id="前端异步的场景"><a href="#前端异步的场景" class="headerlink" title="前端异步的场景"></a><strong>前端异步的场景</strong></h3><ul><li>定时 <code>setTimeout`</code>setInverval`</li><li>网络请求，如 <code>Ajax`</code><img>`加载</li></ul><p>Ajax 代码示例</p><pre><code>console.log(&apos;start&apos;)$.get(&apos;./data1.json&apos;, function (data1) {    console.log(data1)})console.log(&apos;end&apos;)</code></pre><p>复制</p><p>img 代码示例（常用于打点统计）</p><pre><code>console.log(&apos;start&apos;)var img = document.createElement(&apos;img&apos;)// 或者 img = new Image()img.onload = function () {    console.log(&apos;loaded&apos;)    img.onload = null}img.src = &apos;/xxx.png&apos;console.log(&apos;end&apos;)</code></pre><p>复制</p><hr><h2 id="ES6-7-新标准的考查"><a href="#ES6-7-新标准的考查" class="headerlink" title="ES6/7 新标准的考查"></a><strong>ES6/7 新标准的考查</strong></h2><blockquote><p>题目：ES6 箭头函数中的<code>this</code>和普通函数中的有什么不同</p></blockquote><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a><strong>箭头函数</strong></h3><p>箭头函数是 ES6 中新的函数定义形式，<code>function name(arg1, arg2) {...}</code>可以使用<code>(arg1, arg2) =&gt; {...}</code>来定义。示例如下：</p><pre><code>// JS 普通函数var arr = [1, 2, 3]arr.map(function (item) {    console.log(index)    return item + 1})// ES6 箭头函数const arr = [1, 2, 3]arr.map((item, index) =&gt; {    console.log(index)    return item + 1})</code></pre><p>复制</p><p>箭头函数存在的意义，第一写起来更加简洁，第二可以解决 ES6 之前函数执行中<code>this</code>是全局变量的问题，看如下代码</p><pre><code>function fn() {    console.log(&apos;real&apos;, this)  // {a: 100} ，该作用域下的 this 的真实的值    var arr = [1, 2, 3]    // 普通 JS    arr.map(function (item) {        console.log(&apos;js&apos;, this)  // window 。普通函数，这里打印出来的是全局变量，令人费解        return item + 1    })    // 箭头函数    arr.map(item =&gt; {        console.log(&apos;es6&apos;, this)  // {a: 100} 。箭头函数，这里打印的就是父作用域的 this        return item + 1    })}fn.call({a: 100})</code></pre><p>复制</p><blockquote><p>题目：ES6 模块化如何使用？</p></blockquote><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a><strong>Module</strong></h3><p>ES6 中模块化语法更加简洁，直接看示例。</p><p>如果只是输出一个唯一的对象，使用<code>export default</code>即可，代码如下</p><pre><code>// 创建 util1.js 文件，内容如export default {    a: 100}// 创建 index.js 文件，内容如import obj from &apos;./util1.js&apos;console.log(obj)</code></pre><p>复制</p><p>如果想要输出许多个对象，就不能用<code>default</code>了，且<code>import</code>时候要加<code>{...}</code>，代码如下</p><pre><code>// 创建 util2.js 文件，内容如export function fn1() {    alert(&apos;fn1&apos;)}export function fn2() {    alert(&apos;fn2&apos;)}// 创建 index.js 文件，内容如import { fn1, fn2 } from &apos;./util2.js&apos;fn1()fn2()</code></pre><p>复制</p><blockquote><p>题目：ES6 class 和普通构造函数的区别</p></blockquote><h3 id="class"><a href="#class" class="headerlink" title="class"></a><strong>class</strong></h3><p>class 其实一直是 JS 的关键字（保留字），但是一直没有正式使用，直到 ES6 。 ES6 的 class 就是取代之前构造函数初始化对象的形式，从语法上更加符合面向对象的写法。例如：</p><p>JS 构造函数的写法</p><pre><code>function MathHandle(x, y) {  this.x = x;  this.y = y;}MathHandle.prototype.add = function () {  return this.x + this.y;};var m = new MathHandle(1, 2);console.log(m.add())</code></pre><p>复制</p><p>用 ES6 class 的写法</p><pre><code>class MathHandle {  constructor(x, y) {    this.x = x;    this.y = y;  }  add() {    return this.x + this.y;  }}const m = new MathHandle(1, 2);console.log(m.add())</code></pre><p>复制</p><p>注意以下几点，全都是关于 class 语法的：</p><ul><li>class 是一种新的语法形式，是<code>class Name {...}</code>这种形式，和函数的写法完全不一样</li><li>两者对比，构造函数函数体的内容要放在 class 中的<code>constructor</code>函数中，<code>constructor</code>即构造器，初始化实例时默认执行</li><li>class 中函数的写法是<code>add() {...}</code>这种形式，并没有<code>function</code>关键字</li></ul><p>使用 class 来实现继承就更加简单了，至少比构造函数实现继承简单很多。看下面例子</p><p>JS 构造函数实现继承</p><pre><code>// 动物function Animal() {    this.eat = function () {        console.log(&apos;animal eat&apos;)    }}// 狗function Dog() {    this.bark = function () {        console.log(&apos;dog bark&apos;)    }}Dog.prototype = new Animal()// 哈士奇var hashiqi = new Dog()</code></pre><p>复制</p><p>ES6 class 实现继承</p><pre><code>class Animal {    constructor(name) {        this.name = name    }    eat() {        console.log(`${this.name} eat`)    }}class Dog extends Animal {    constructor(name) {        super(name)        this.name = name    }    say() {        console.log(`${this.name} say`)    }}const dog = new Dog(&apos;哈士奇&apos;)dog.say()dog.eat()</code></pre><p>复制</p><p>注意以下两点：</p><ul><li>使用<code>extends</code>即可实现继承，更加符合经典面向对象语言的写法，如 Java</li><li>子类的<code>constructor</code>一定要执行<code>super()</code>，以调用父类的<code>constructor</code></li></ul><blockquote><p>题目：ES6 中新增的数据类型有哪些？</p></blockquote><h3 id="Set-和-Map"><a href="#Set-和-Map" class="headerlink" title="Set 和 Map"></a><strong>Set 和 Map</strong></h3><p>Set 和 Map 都是 ES6 中新增的数据结构，是对当前 JS 数组和对象这两种重要数据结构的扩展。由于是新增的数据结构，目前尚未被大规模使用，但是作为前端程序员，提前了解是必须做到的。先总结一下两者最关键的地方：</p><ul><li>Set 类似于数组，但数组可以允许元素重复，Set 不允许元素重复</li><li>Map 类似于对象，但普通对象的 key 必须是字符串或者数字，而 Map 的 key 可以是任何数据类型</li></ul><p><strong>Set</strong></p><p>Set 实例不允许元素有重复，可以通过以下示例证明。可以通过一个数组初始化一个 Set 实例，或者通过<code>add</code>添加元素，元素不能重复，重复的会被忽略。</p><pre><code>// 例1const set = new Set([1, 2, 3, 4, 4]);console.log(set) // Set(4) {1, 2, 3, 4}// 例2const set = new Set();[2, 3, 5, 4, 5, 8, 8].forEach(item =&gt; set.add(item));for (let item of set) {  console.log(item);}// 2 3 5 4 8</code></pre><p>复制</p><p>Set 实例的属性和方法有</p><ul><li><code>size</code>：获取元素数量。</li><li><code>add(value)</code>：添加元素，返回 Set 实例本身。</li><li><code>delete(value)</code>：删除元素，返回一个布尔值，表示删除是否成功。</li><li><code>has(value)</code>：返回一个布尔值，表示该值是否是 Set 实例的元素。</li><li><p><code>clear()</code>：清除所有元素，没有返回值。</p><p>const s = new Set();<br>s.add(1).add(2).add(2); // 添加元素</p><p>s.size // 2</p><p>s.has(1) // true<br>s.has(2) // true<br>s.has(3) // false</p><p>s.delete(2);<br>s.has(2) // false</p><p>s.clear();<br>console.log(s);  // Set(0) {}</p></li></ul><p>复制</p><p>Set 实例的遍历，可使用如下方法</p><ul><li><code>keys()</code>：返回键名的遍历器。</li><li><code>values()</code>：返回键值的遍历器。不过由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys()</code>和<code>values()</code>返回结果一致。</li><li><code>entries()</code>：返回键值对的遍历器。</li><li><p><code>forEach()</code>：使用回调函数遍历每个成员。</p><p>let set = new Set([‘aaa’, ‘bbb’, ‘ccc’]);</p><p>for (let item of set.keys()) {<br>  console.log(item);<br>}<br>// aaa<br>// bbb<br>// ccc</p><p>for (let item of set.values()) {<br>  console.log(item);<br>}<br>// aaa<br>// bbb<br>// ccc</p><p>for (let item of set.entries()) {<br>  console.log(item);<br>}<br>// [“aaa”, “aaa”]<br>// [“bbb”, “bbb”]<br>// [“ccc”, “ccc”]</p><p>set.forEach((value, key) =&gt; console.log(key + ‘ : ‘ + value))<br>// aaa : aaa<br>// bbb : bbb<br>// ccc : ccc</p></li></ul><p>复制</p><p><strong>Map</strong></p><p>Map 的用法和普通对象基本一致，先看一下它能用非字符串或者数字作为 key 的特性。</p><pre><code>const map = new Map();const obj = {p: &apos;Hello World&apos;};map.set(obj, &apos;OK&apos;)map.get(obj) // &quot;OK&quot;map.has(obj) // truemap.delete(obj) // truemap.has(obj) // false</code></pre><p>复制</p><p>需要使用<code>new Map()</code>初始化一个实例，下面代码中<code>set`</code>get<code>has</code>delete<code>顾名即可思义（下文也会演示）。其中，</code>map.set(obj, ‘OK’)<code>就是用对象作为的 key （不光可以是对象，任何数据类型都可以），并且后面通过</code>map.get(obj)`正确获取了。</p><p>Map 实例的属性和方法如下：</p><ul><li><code>size</code>：获取成员的数量</li><li><code>set</code>：设置成员 key 和 value</li><li><code>get</code>：获取成员属性值</li><li><code>has</code>：判断成员是否存在</li><li><code>delete</code>：删除成员</li><li><p><code>clear</code>：清空所有</p><p>const map = new Map();<br>map.set(‘aaa’, 100);<br>map.set(‘bbb’, 200);</p><p>map.size // 2</p><p>map.get(‘aaa’) // 100</p><p>map.has(‘aaa’) // true</p><p>map.delete(‘aaa’)<br>map.has(‘aaa’) // false</p><p>map.clear()</p></li></ul><p>复制</p><p>Map 实例的遍历方法有：</p><ul><li><code>keys()</code>：返回键名的遍历器。</li><li><code>values()</code>：返回键值的遍历器。</li><li><code>entries()</code>：返回所有成员的遍历器。</li><li><p><code>forEach()</code>：遍历 Map 的所有成员。</p><p>const map = new Map();<br>map.set(‘aaa’, 100);<br>map.set(‘bbb’, 200);</p><p>for (let key of map.keys()) {<br>  console.log(key);<br>}<br>// “aaa”<br>// “bbb”</p><p>for (let value of map.values()) {<br>  console.log(value);<br>}<br>// 100<br>// 200</p><p>for (let item of map.entries()) {<br>  console.log(item[0], item[1]);<br>}<br>// aaa 100<br>// bbb 200</p><p>// 或者<br>for (let [key, value] of map.entries()) {<br>  console.log(key, value);<br>}<br>// aaa 100<br>// bbb 200</p></li></ul><p>复制</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a><strong>Promise</strong></h3><p><code>Promise</code>是 CommonJS 提出来的这一种规范，有多个版本，在 ES6 当中已经纳入规范，原生支持 Promise 对象，非 ES6 环境可以用类似 Bluebird、Q 这类库来支持。</p><p><code>Promise</code> 可以将回调变成链式调用写法，流程更加清晰，代码更加优雅。</p><p>简单归纳下 Promise：<strong>三个状态、两个过程、一个方法</strong>，快速记忆方法：<strong>3-2-1</strong></p><p>三个状态：<code>pending</code>、<code>fulfilled</code>、<code>rejected</code></p><p>两个过程：</p><ul><li>pending→fulfilled（resolve）</li><li>pending→rejected（reject）</li></ul><p>一个方法：<code>then</code></p><p>当然还有其他概念，如<code>catch</code>、 <code>Promise.all/race</code>，这里就不展开了。</p><p>关于 ES6/7 的考查内容还有很多，本小节就不逐一介绍了，如果想继续深入学习，可以在线看《<a href="https://link.juejin.im?target=http%3A%2F%2Fes6.ruanyifeng.com%2F" target="_blank" rel="noopener">ES6入门</a>》。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>本小节主要总结了 ES 基础语法中面试经常考查的知识点，包括之前就考查较多的原型、异步、作用域，以及 ES6 的一些新内容，这些知识点希望大家都要掌握。</p><p>上一篇：<a href="541670">准备：简历编写和面试前准备</a>下一篇：<a href="541672">一面 2：JS-Web-API 知识点与高频考题解析</a></p><h1 id="一面-2：JS-Web-API-知识点与高频考题解析"><a href="#一面-2：JS-Web-API-知识点与高频考题解析" class="headerlink" title="一面 2：JS-Web-API 知识点与高频考题解析"></a><strong>一面 2：JS-Web-API 知识点与高频考题解析</strong></h1><p>除 ES 基础之外，Web 前端经常会用到一些跟浏览器相关的 API，接下来我们一起梳理一下。</p><h2 id="知识点梳理-1"><a href="#知识点梳理-1" class="headerlink" title="知识点梳理"></a><strong>知识点梳理</strong></h2><ul><li>BOM 操作</li><li>DOM 操作</li><li>事件绑定</li><li>Ajax</li><li>存储</li></ul><hr><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a><strong>BOM</strong></h2><p>BOM（浏览器对象模型）是浏览器本身的一些信息的设置和获取，例如获取浏览器的宽度、高度，设置让浏览器跳转到哪个地址。</p><ul><li><code>navigator</code></li><li><code>screen</code></li><li><code>location</code></li><li><code>history</code></li></ul><p>这些对象就是一堆非常简单粗暴的 API，没任何技术含量，讲起来一点意思都没有，大家去 MDN 或者 w3school 这种网站一查就都明白了。面试的时候，面试官基本不会出太多这方面的题目，因为只要基础知识过关了，这些 API 即便你记不住，上网一查也都知道了。下面列举一下常用功能的代码示例</p><p>获取浏览器特性（即俗称的<code>UA</code>）然后识别客户端，例如判断是不是 Chrome 浏览器</p><pre><code>var ua = navigator.userAgentvar isChrome = ua.indexOf(&apos;Chrome&apos;)console.log(isChrome)</code></pre><p>复制</p><p>获取屏幕的宽度和高度</p><pre><code>console.log(screen.width)console.log(screen.height)</code></pre><p>复制</p><p>获取网址、协议、path、参数、hash 等</p><pre><code>// 例如当前网址是 https://juejin.im/timeline/frontend?a=10&amp;b=10#someconsole.log(location.href)  // https://juejin.im/timeline/frontend?a=10&amp;b=10#someconsole.log(location.protocol) // https:console.log(location.pathname) // /timeline/frontendconsole.log(location.search) // ?a=10&amp;b=10console.log(location.hash) // #some</code></pre><p>复制</p><p>另外，还有调用浏览器的前进、后退功能等</p><pre><code>history.back()history.forward()</code></pre><p>复制</p><hr><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a><strong>DOM</strong></h2><blockquote><p>题目：DOM 和 HTML 区别和联系</p></blockquote><h3 id="什么是-DOM"><a href="#什么是-DOM" class="headerlink" title="什么是 DOM"></a><strong>什么是 DOM</strong></h3><p>讲 DOM 先从 HTML 讲起，讲 HTML 先从 XML 讲起。XML 是一种可扩展的标记语言，所谓可扩展就是它可以描述任何结构化的数据，它是一棵树！</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;note&gt;  &lt;to&gt;Tove&lt;/to&gt;  &lt;from&gt;Jani&lt;/from&gt;  &lt;heading&gt;Reminder&lt;/heading&gt;  &lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt;  &lt;other&gt;    &lt;a&gt;&lt;/a&gt;    &lt;b&gt;&lt;/b&gt;  &lt;/other&gt;&lt;/note&gt;</code></pre><p>复制</p><p>HTML 是一个有既定标签标准的 XML 格式，标签的名字、层级关系和属性，都被标准化（否则浏览器无法解析）。同样，它也是一棵树。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;p&gt;this is p&lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>复制</p><p>我们开发完的 HTML 代码会保存到一个文档中（一般以<code>.html</code>或者<code>.htm</code>结尾），文档放在服务器上，浏览器请求服务器，这个文档被返回。因此，最终浏览器拿到的是一个文档而已，文档的内容就是 HTML 格式的代码。</p><p>但是浏览器要把这个文档中的 HTML 按照标准渲染成一个页面，此时浏览器就需要将这堆代码处理成自己能理解的东西，也得处理成 JS 能理解的东西，因为还得允许 JS 修改页面内容呢。</p><p>基于以上需求，浏览器就需要把 HTML 转变成 DOM，HTML 是一棵树，DOM 也是一棵树。对 DOM 的理解，可以暂时先抛开浏览器的内部因素，先从 JS 着手，即可以认为 DOM 就是 JS 能识别的 HTML 结构，一个普通的 JS 对象或者数组。</p><p>![DOM图示](data:image/svg+xml;utf8,)</p><h3 id="获取-DOM-节点"><a href="#获取-DOM-节点" class="headerlink" title="获取 DOM 节点"></a><strong>获取 DOM 节点</strong></h3><p>最常用的 DOM API 就是获取节点，其中常用的获取方法如下面代码示例：</p><pre><code>// 通过 id 获取var div1 = document.getElementById(&apos;div1&apos;) // 元素// 通过 tagname 获取var divList = document.getElementsByTagName(&apos;div&apos;)  // 集合console.log(divList.length)console.log(divList[0])// 通过 class 获取var containerList = document.getElementsByClassName(&apos;container&apos;) // 集合// 通过 CSS 选择器获取var pList = document.querySelectorAll(&apos;p&apos;) // 集合</code></pre><p>复制</p><blockquote><p>题目：property 和 attribute 的区别是什么？</p></blockquote><h3 id="property"><a href="#property" class="headerlink" title="property"></a><strong>property</strong></h3><p>DOM 节点就是一个 JS 对象，它符合之前讲述的对象的特征 —— 可扩展属性，因为 DOM 节点本质上也是一个 JS 对象。因此，如下代码所示，<code>p</code>可以有<code>style</code>属性，有<code>className`</code>nodeName<code></code>nodeType`属性。注意，<strong>这些都是 JS 范畴的属性，符合 JS 语法标准的</strong>。</p><pre><code>var pList = document.querySelectorAll(&apos;p&apos;)var p = pList[0]console.log(p.style.width)  // 获取样式p.style.width = &apos;100px&apos;  // 修改样式console.log(p.className)  // 获取 classp.className = &apos;p1&apos;  // 修改 class// 获取 nodeName 和 nodeTypeconsole.log(p.nodeName)console.log(p.nodeType)</code></pre><p>复制</p><h3 id="attribute"><a href="#attribute" class="headerlink" title="attribute"></a><strong>attribute</strong></h3><p>property 的获取和修改，是直接改变 JS 对象，而 attribute 是直接改变 HTML 的属性，两种有很大的区别。attribute 就是对 HTML 属性的 get 和 set，和 DOM 节点的 JS 范畴的 property 没有关系。</p><pre><code>var pList = document.querySelectorAll(&apos;p&apos;)var p = pList[0]p.getAttribute(&apos;data-name&apos;)p.setAttribute(&apos;data-name&apos;, &apos;juejin&apos;)p.getAttribute(&apos;style&apos;)p.setAttribute(&apos;style&apos;, &apos;font-size:30px;&apos;)</code></pre><p>复制</p><p>而且，get 和 set attribute 时，还会触发 DOM 的查询或者重绘、重排，频繁操作会影响页面性能。</p><blockquote><p>题目：DOM 操作的基本 API 有哪些？</p></blockquote><h3 id="DOM-树操作"><a href="#DOM-树操作" class="headerlink" title="DOM 树操作"></a><strong>DOM 树操作</strong></h3><p>新增节点</p><pre><code>var div1 = document.getElementById(&apos;div1&apos;)// 添加新节点var p1 = document.createElement(&apos;p&apos;)p1.innerHTML = &apos;this is p1&apos;div1.appendChild(p1) // 添加新创建的元素// 移动已有节点。注意，这里是“移动”，并不是拷贝var p2 = document.getElementById(&apos;p2&apos;)div1.appendChild(p2)</code></pre><p>复制</p><p>获取父元素</p><pre><code>var div1 = document.getElementById(&apos;div1&apos;)var parent = div1.parentElement</code></pre><p>复制</p><p>获取子元素</p><pre><code>var div1 = document.getElementById(&apos;div1&apos;)var child = div1.childNodes</code></pre><p>复制</p><p>删除节点</p><pre><code>var div1 = document.getElementById(&apos;div1&apos;)var child = div1.childNodesdiv1.removeChild(child[0])</code></pre><p>复制</p><p>还有其他操作的API，例如获取前一个节点、获取后一个节点等，但是面试过程中经常考到的就是上面几个。</p><hr><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a><strong>事件</strong></h2><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a><strong>事件绑定</strong></h3><p>普通的事件绑定写法如下：</p><pre><code>var btn = document.getElementById(&apos;btn1&apos;)btn.addEventListener(&apos;click&apos;, function (event) {    // event.preventDefault() // 阻止默认行为    // event.stopPropagation() // 阻止冒泡    console.log(&apos;clicked&apos;)})</code></pre><p>复制</p><p>为了编写简单的事件绑定，可以编写通用的事件绑定函数。这里虽然比较简单，但是会随着后文的讲解，来继续完善和丰富这个函数。</p><pre><code>// 通用的事件绑定函数function bindEvent(elem, type, fn) {    elem.addEventListener(type, fn)}var a = document.getElementById(&apos;link1&apos;)// 写起来更加简单了bindEvent(a, &apos;click&apos;, function(e) {    e.preventDefault() // 阻止默认行为    alert(&apos;clicked&apos;)})</code></pre><p>复制</p><p>最后，<strong>如果面试被问到 IE 低版本兼容性问题，我劝你果断放弃这份工作机会</strong>。现在互联网流量都在 App 上， IE 占比越来越少，再去为 IE 浪费青春不值得，要尽量去做 App 相关的工作。</p><blockquote><p>题目：什么是事件冒泡？</p></blockquote><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a><strong>事件冒泡</strong></h3><pre><code>&lt;body&gt;    &lt;div id=&quot;div1&quot;&gt;        &lt;p id=&quot;p1&quot;&gt;激活&lt;/p&gt;        &lt;p id=&quot;p2&quot;&gt;取消&lt;/p&gt;        &lt;p id=&quot;p3&quot;&gt;取消&lt;/p&gt;        &lt;p id=&quot;p4&quot;&gt;取消&lt;/p&gt;    &lt;/div&gt;    &lt;div id=&quot;div2&quot;&gt;        &lt;p id=&quot;p5&quot;&gt;取消&lt;/p&gt;        &lt;p id=&quot;p6&quot;&gt;取消&lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><p>复制</p><p>对于以上 HTML 代码结构，要求点击<code>p1</code>时候进入激活状态，点击其他任何<code>&lt;p&gt;</code>都取消激活状态，如何实现？代码如下，注意看注释：</p><pre><code>var body = document.bodybindEvent(body, &apos;click&apos;, function (e) {    // 所有 p 的点击都会冒泡到 body 上，因为 DOM 结构中 body 是 p 的上级节点，事件会沿着 DOM 树向上冒泡    alert(&apos;取消&apos;)})var p1 = document.getElementById(&apos;p1&apos;)bindEvent(p1, &apos;click&apos;, function (e) {    e.stopPropagation() // 阻止冒泡    alert(&apos;激活&apos;)})</code></pre><p>复制</p><p>如果我们在<code>p1`</code>div1<code></code>body<code>中都绑定了事件，它是会根据 DOM 的结构来冒泡，从下到上挨个执行的。但是我们使用</code>e.stopPropagation()`就可以阻止冒泡</p><blockquote><p>题目：如何使用事件代理？有何好处？</p></blockquote><h3 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a><strong>事件代理</strong></h3><p>我们设定一种场景，如下代码，一个<code>&lt;div&gt;</code>中包含了若干个<code>&lt;a&gt;</code>，而且还能继续增加。那如何快捷方便地为所有<code>&lt;a&gt;</code>绑定事件呢？</p><pre><code>&lt;div id=&quot;div1&quot;&gt;    &lt;a href=&quot;#&quot;&gt;a1&lt;/a&gt;    &lt;a href=&quot;#&quot;&gt;a2&lt;/a&gt;    &lt;a href=&quot;#&quot;&gt;a3&lt;/a&gt;    &lt;a href=&quot;#&quot;&gt;a4&lt;/a&gt;&lt;/div&gt;&lt;button&gt;点击增加一个 a 标签&lt;/button&gt;</code></pre><p>复制</p><p>这里就会用到事件代理。我们要监听<code>&lt;a&gt;</code>的事件，但要把具体的事件绑定到<code>&lt;div&gt;</code>上，然后看事件的触发点是不是<code>&lt;a&gt;</code>。</p><pre><code>var div1 = document.getElementById(&apos;div1&apos;)div1.addEventListener(&apos;click&apos;, function (e) {    // e.target 可以监听到触发点击事件的元素是哪一个    var target = e.target    if (e.nodeName === &apos;A&apos;) {        // 点击的是 &lt;a&gt; 元素        alert(target.innerHTML)    }})</code></pre><p>复制</p><p>我们现在完善一下之前写的通用事件绑定函数，加上事件代理。</p><pre><code>function bindEvent(elem, type, selector, fn) {    // 这样处理，可接收两种调用方式 bindEvent(div1, &apos;click&apos;, &apos;a&apos;, function () {...}) 和 bindEvent(div1, &apos;click&apos;, function () {...}) 这两种    if (fn == null) {        fn = selector        selector = null    }    // 绑定事件    elem.addEventListener(type, function (e) {        var target        if (selector) {            // 有 selector 说明需要做事件代理            // 获取触发时间的元素，即 e.target            target = e.target            // 看是否符合 selector 这个条件            if (target.matches(selector)) {                fn.call(target, e)            }        } else {            // 无 selector ，说明不需要事件代理            fn(e)        }    })}</code></pre><p>复制</p><p>然后这样使用，简单很多。</p><pre><code>// 使用代理，bindEvent 多一个 &apos;a&apos; 参数var div1 = document.getElementById(&apos;div1&apos;)bindEvent(div1, &apos;click&apos;, &apos;a&apos;, function (e) {    console.log(this.innerHTML)})// 不使用代理var a = document.getElementById(&apos;a1&apos;)bindEvent(div1, &apos;click&apos;, function (e) {    console.log(a.innerHTML)})</code></pre><p>复制</p><p>最后，使用代理的优点如下：</p><ul><li>使代码简洁</li><li>减少浏览器的内存占用</li></ul><hr><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a><strong>Ajax</strong></h2><h3 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a><strong>XMLHttpRequest</strong></h3><blockquote><p>题目：手写 XMLHttpRequest 不借助任何库</p></blockquote><p>这是很多奇葩的、个性的面试官经常用的手段。这种考查方式存在很多争议，但是你不能完全说它是错误的，毕竟也是考查对最基础知识的掌握情况。</p><pre><code>var xhr = new XMLHttpRequest()xhr.open(&quot;GET&quot;, &quot;/api&quot;, false)xhr.onreadystatechange = function () {    // 这里的函数异步执行，可参考之前 JS 基础中的异步模块    if (xhr.readyState == 4) {        if (xhr.status == 200) {            alert(xhr.responseText)        }    }}xhr.send(null)</code></pre><p>复制</p><p>当然，使用 jQuery、Zepto 或 Fetch 等库来写就更加简单了，这里不再赘述。</p><h3 id="状态码说明"><a href="#状态码说明" class="headerlink" title="状态码说明"></a><strong>状态码说明</strong></h3><p>上述代码中，有两处状态码需要说明。<code>xhr.readyState</code>是浏览器判断请求过程中各个阶段的，<code>xhr.status</code>是 HTTP 协议中规定的不同结果的返回状态说明。</p><p><code>xhr.readyState</code>的状态码说明：</p><ul><li>0 - (未初始化）还没有调用<code>send()</code>方法</li><li>1 -（载入）已调用<code>send()</code>方法，正在发送请求</li><li>2 -（载入完成）<code>send()</code>方法执行完成，已经接收到全部响应内容</li><li>3 -（交互）正在解析响应内容</li><li>4 -（完成）响应内容解析完成，可以在客户端调用了</li></ul><blockquote><p>题目：HTTP 协议中，response 的状态码，常见的有哪些？</p></blockquote><p><code>xhr.status</code>即 HTTP 状态码，有 <code>2xx`</code>3xx<code>4xx</code>5xx` 这几种，比较常用的有以下几种：</p><ul><li><code>200</code> 正常</li><li><code>3xx</code><ul><li><code>301</code> 永久重定向。如<code>http://xxx.com</code>这个 GET 请求（最后没有<code>/</code>），就会被<code>301</code>到<code>http://xxx.com/</code>（最后是<code>/</code>）</li><li><code>302</code> 临时重定向。临时的，不是永久的</li><li><code>304</code> 资源找到但是不符合请求条件，不会返回任何主体。如发送 GET 请求时，head 中有<code>If-Modified-Since: xxx</code>（要求返回更新时间是<code>xxx</code>时间之后的资源），如果此时服务器 端资源未更新，则会返回<code>304</code>，即不符合要求</li></ul></li><li><code>404</code> 找不到资源</li><li><code>5xx</code> 服务器端出错了</li></ul><p>看完要明白，为何上述代码中要同时满足<code>xhr.readyState == 4</code>和<code>xhr.status == 200</code>。</p><h3 id="Fetch-API"><a href="#Fetch-API" class="headerlink" title="Fetch API"></a><strong>Fetch API</strong></h3><p>目前已经有一个获取 HTTP 请求更加方便的 API：<code>Fetch</code>，通过<code>Fetch</code>提供的<code>fetch()</code>这个全局函数方法可以很简单地发起异步请求，并且支持<code>Promise</code>的回调。但是 Fetch API 是比较新的 API，具体使用的时候还需要查查 <a href="https://link.juejin.im?target=https%3A%2F%2Fcaniuse.com%2F" target="_blank" rel="noopener">caniuse</a>，看下其浏览器兼容情况。</p><p>看一个简单的例子：</p><pre><code>fetch(&apos;some/api/data.json&apos;, {  method:&apos;POST&apos;, //请求类型 GET、POST  headers:{}, // 请求的头信息，形式为 Headers 对象或 ByteString  body:{}, //请求发送的数据 blob、BufferSource、FormData、URLSearchParams（get 或head 方法中不能包含 body）  mode:&apos;&apos;, //请求的模式，是否跨域等，如 cors、 no-cors 或 same-origin  credentials:&apos;&apos;, //cookie 的跨域策略，如 omit、same-origin 或 include  cache:&apos;&apos;, //请求的 cache 模式: default、no-store、reload、no-cache、 force-cache 或 only-if-cached}).then(function(response) { ... });</code></pre><p>复制</p><p><code>Fetch</code> 支持<code>headers</code>定义，通过<code>headers</code>自定义可以方便地实现多种请求方法（ PUT、GET、POST 等）、请求头（包括跨域）和<code>cache</code>策略等；除此之外还支持 response（返回数据）多种类型，比如支持二进制文件、字符串和<code>formData</code>等。</p><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a><strong>跨域</strong></h3><blockquote><p>题目：如何实现跨域？</p></blockquote><p>浏览器中有 <strong>同源策略</strong> ，即一个域下的页面中，无法通过 Ajax 获取到其他域的接口。例如有一个接口<code>http://m.juejin.com/course/ajaxcourserecom?cid=459</code>，你自己的一个页面<code>http://www.yourname.com/page1.html</code>中的 Ajax 无法获取这个接口。这正是命中了“同源策略”。如果浏览器哪些地方忽略了同源策略，那就是浏览器的安全漏洞，需要紧急修复。</p><p>url 哪些地方不同算作跨域？</p><ul><li>协议</li><li>域名</li><li>端口</li></ul><p>但是 HTML 中几个标签能逃避过同源策略——<code>&lt;script src=&quot;xxx&quot;&gt;</code>、<code>&lt;img src=&quot;xxxx&quot;/&gt;</code>、<code>&lt;link href=&quot;xxxx&quot;&gt;</code>，这三个标签的<code>src/href</code>可以加载其他域的资源，不受同源策略限制。</p><p>因此，这使得这三个标签可以做一些特殊的事情。</p><ul><li><code>&lt;img&gt;</code>可以做打点统计，因为统计方并不一定是同域的，在讲解 JS 基础知识异步的时候有过代码示例。除了能跨域之外，<code>&lt;img&gt;</code>几乎没有浏览器兼容问题，它是一个非常古老的标签。</li><li><code>&lt;script&gt;</code>和<code>&lt;link&gt;</code>可以使用 CDN，CDN 基本都是其他域的链接。</li><li>另外<code>&lt;script&gt;</code>还可以实现 JSONP，能获取其他域接口的信息，接下来马上讲解。</li></ul><p>但是请注意，所有的跨域请求方式，最终都需要信息提供方来做出相应的支持和改动，也就是要经过信息提供方的同意才行，否则接收方是无法得到它们的信息的，浏览器是不允许的。</p><h3 id="解决跨域-JSONP"><a href="#解决跨域-JSONP" class="headerlink" title="解决跨域 - JSONP"></a><strong>解决跨域 - JSONP</strong></h3><p>首先，有一个概念你要明白，例如访问<code>http://coding.m.juejin.com/classindex.html</code>的时候，服务器端就一定有一个<code>classindex.html</code>文件吗？—— 不一定，服务器可以拿到这个请求，动态生成一个文件，然后返回。 同理，<code>&lt;script src=&quot;http://coding.m.juejin.com/api.js&quot;&gt;</code>也不一定加载一个服务器端的静态文件，服务器也可以动态生成文件并返回。OK，接下来正式开始。</p><p>例如我们的网站和掘金网，肯定不是一个域。我们需要掘金网提供一个接口，供我们来获取。首先，我们在自己的页面这样定义</p><pre><code>&lt;script&gt;window.callback = function (data) {    // 这是我们跨域得到信息    console.log(data)}&lt;/script&gt;</code></pre><p>复制</p><p>然后掘金网给我提供了一个<code>http://coding.m.juejin.com/api.js</code>，内容如下（之前说过，服务器可动态生成内容）</p><pre><code>callback({x:100, y:200})</code></pre><p>复制</p><p>最后我们在页面中加入<code>&lt;script src=&quot;http://coding.m.juejin.com/api.js&quot;&gt;&lt;/script&gt;</code>，那么这个js加载之后，就会执行内容，我们就得到内容了。</p><h3 id="解决跨域-服务器端设置-http-header"><a href="#解决跨域-服务器端设置-http-header" class="headerlink" title="解决跨域 - 服务器端设置 http header"></a><strong>解决跨域 - 服务器端设置 http header</strong></h3><p>这是需要在服务器端设置的，作为前端工程师我们不用详细掌握，但是要知道有这么个解决方案。而且，现在推崇的跨域解决方案是这一种，比 JSONP 简单许多。</p><pre><code>response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://m.juejin.com/&quot;);  // 第二个参数填写允许跨域的域名称，不建议直接写 &quot;*&quot;response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;);response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;);// 接收跨域的cookieresponse.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</code></pre><p>复制</p><hr><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a><strong>存储</strong></h2><blockquote><p>题目：cookie 和 localStorage 有何区别？</p></blockquote><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a><strong>cookie</strong></h3><p>cookie 本身不是用来做服务器端存储的（计算机领域有很多这种“狗拿耗子”的例子，例如 CSS 中的 float），它是设计用来在服务器和客户端进行信息传递的，因此我们的每个 HTTP 请求都带着 cookie。但是 cookie 也具备浏览器端存储的能力（例如记住用户名和密码），因此就被开发者用上了。</p><p>使用起来也非常简单，<code>document.cookie = ....</code>即可。</p><p>但是 cookie 有它致命的缺点：</p><ul><li>存储量太小，只有 4KB</li><li>所有 HTTP 请求都带着，会影响获取资源的效率</li><li>API 简单，需要封装才能用</li></ul><h3 id="locationStorage-和-sessionStorage"><a href="#locationStorage-和-sessionStorage" class="headerlink" title="locationStorage 和 sessionStorage"></a><strong>locationStorage 和 sessionStorage</strong></h3><p>后来，HTML5 标准就带来了<code>sessionStorage</code>和<code>localStorage</code>，先拿<code>localStorage</code>来说，它是专门为了浏览器端缓存而设计的。其优点有：</p><ul><li>存储量增大到 5MB</li><li>不会带到 HTTP 请求中</li><li>API 适用于数据存储 <code>localStorage.setItem(key, value)`</code>localStorage.getItem(key)`</li></ul><p><code>sessionStorage</code>的区别就在于它是根据 session 过去时间而实现，而<code>localStorage</code>会永久有效，应用场景不同。例如，一些需要及时失效的重要信息放在<code>sessionStorage</code>中，一些不重要但是不经常设置的信息，放在<code>localStorage</code>中。</p><p>另外告诉大家一个小技巧，针对<code>localStorage.setItem</code>，使用时尽量加入到<code>try-catch</code>中，某些浏览器是禁用这个 API 的，要注意。</p><hr><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>本小节总结了 W3C 标准中 Web-API 部分，面试中常考的知识点，这些也是日常开发中最常用的 API 和知识。</p><p>上一篇：<a href="541671">一面 1：ES 基础知识点与高频考题解析</a>下一篇：<a href="541673">一面 3：CSS-HTML 知识点与高频考题解析</a></p><h1 id="一面-3：CSS-HTML-知识点与高频考题解析"><a href="#一面-3：CSS-HTML-知识点与高频考题解析" class="headerlink" title="一面 3：CSS-HTML 知识点与高频考题解析"></a><strong>一面 3：CSS-HTML 知识点与高频考题解析</strong></h1><p>CSS 和 HTML 是网页开发中布局相关的组成部分，涉及的内容比较多和杂乱，本小节重点介绍下常考的知识点。</p><h2 id="知识点梳理-2"><a href="#知识点梳理-2" class="headerlink" title="知识点梳理"></a><strong>知识点梳理</strong></h2><ul><li>选择器的权重和优先级</li><li>盒模型<ul><li>盒子大小计算</li><li>margin 的重叠计算</li></ul></li><li>浮动<code>float</code><ul><li>浮动布局概念</li><li>清理浮动</li></ul></li><li>定位<code>position</code><ul><li>文档流概念</li><li>定位分类</li><li>fixed 定位特点</li><li>绝对定位计算方式</li></ul></li><li><code>flex</code>布局</li><li>如何实现居中对齐？</li><li>理解语义化</li><li>CSS3 动画</li><li>重绘和回流</li></ul><hr><h2 id="选择器的权重和优先级"><a href="#选择器的权重和优先级" class="headerlink" title="选择器的权重和优先级"></a><strong>选择器的权重和优先级</strong></h2><p>CSS 选择器有很多，不同的选择器的权重和优先级不一样，对于一个元素，如果存在多个选择器，那么就需要根据权重来计算其优先级。</p><p>权重分为四级，分别是：</p><ol><li>代表内联样式，如<code>style=&quot;xxx&quot;</code>，权值为 1000；</li><li>代表 ID 选择器，如<code>#content</code>，权值为 100；</li><li>代表类、伪类和属性选择器，如<code>.content</code>、<code>:hover</code>、<code>[attribute]</code>，权值为 10；</li><li>代表元素选择器和伪元素选择器，如<code>div</code>、<code>p</code>，权值为 1。</li></ol><p><strong>需要注意的是：通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以他们的权值都为 0</strong>。 权重值大的选择器其优先级也高，相同权重的优先级又遵循后定义覆盖前面定义的情况。</p><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a><strong>盒模型</strong></h2><h3 id="什么是“盒子”"><a href="#什么是“盒子”" class="headerlink" title="什么是“盒子”"></a><strong>什么是“盒子”</strong></h3><p>初学 CSS 的朋友，一开始学 CSS 基础知识的时候一定学过<code>padding`</code>border<code>和</code>margin`，即内边距、边框和外边距。它们三者就构成了一个“盒子”。就像我们收到的快递，本来买了一部小小的手机，收到的却是那么大一个盒子。因为手机白色的包装盒和手机机器之间有间隔层（内边距），手机白色盒子有厚度，虽然很薄（边框），盒子和快递箱子之间还有一层泡沫板（外边距）。这就是一个典型的盒子。</p><p>![](data:image/svg+xml;utf8,)</p><p>如上图，真正的内容就是这些文字，文字外围有 10px 的内边距，5px 的边框，10px 的外边距。看到盒子了吧？</p><blockquote><p>题目：盒子模型的宽度如何计算</p></blockquote><h3 id="固定宽度的盒子"><a href="#固定宽度的盒子" class="headerlink" title="固定宽度的盒子"></a><strong>固定宽度的盒子</strong></h3><pre><code>&lt;div style=&quot;padding:10px; border:5px solid blue; margin: 10px; width:300px;&quot;&gt;    之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》，    文章言简意赅的介绍的浏览器的工作过程，web前端&lt;/div&gt;</code></pre><p>复制</p><p>![](data:image/svg+xml;utf8,)</p><p>如上图，得到网页效果之后，我们可以用截图工具来量一下文字内容的宽度。发现，文字内容的宽度刚好是 300px，也就是我们设置的宽度。</p><p>因此，<strong>在盒子模型中，我们设置的宽度都是内容宽度，不是整个盒子的宽度。而整个盒子的宽度是：（内容宽度 + <code>border</code>宽度 + <code>padding</code>宽度 + <code>margin</code>宽度）之和</strong>。这样我们改四个中的其中一个，都会导致盒子宽度的改变。这对我们来说不友好。</p><p>没关系，这个东西不友好早就有人发现了，而且已经解决，下文再说。</p><h3 id="充满父容器的盒子"><a href="#充满父容器的盒子" class="headerlink" title="充满父容器的盒子"></a><strong>充满父容器的盒子</strong></h3><p>默认情况下，<code>div</code>是<code>display:block</code>，宽度会充满整个父容器。如下图：</p><pre><code>&lt;div style=&quot;padding:10px; border:5px solid blue; margin: 10px; width:300px;&quot;&gt;    之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》，    文章言简意赅的介绍的浏览器的工作过程，web前端    之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》，    文章言简意赅的介绍的浏览器的工作过程，web前端&lt;/div&gt;</code></pre><p>复制</p><p>![](data:image/svg+xml;utf8,)</p><p>但是别忘记，这个 div 是个盒子模型，它的整个宽度包括（内容宽度 + <code>border</code>宽度 + <code>padding</code>宽度 + <code>margin</code>宽度），整个的宽度充满父容器。</p><p>问题就在这里。如果父容器宽度不变，我们手动增大<code>margin</code>、<code>border</code>或<code>padding</code>其中一项的宽度值，都会导致内容宽度的减少。极端情况下，如果内容的宽度压缩到不能再压缩了（例如一个字的宽度），那么浏览器会强迫增加父容器的宽度。这可不是我们想要看到的。</p><h3 id="包裹内容的盒子"><a href="#包裹内容的盒子" class="headerlink" title="包裹内容的盒子"></a><strong>包裹内容的盒子</strong></h3><p>这种情况下比较简单，内容的宽度按照内容计算，盒子的宽度将在内容宽度的基础上再增加（<code>padding</code>宽度 + <code>border</code>宽度 + <code>margin</code>宽度）之和。</p><pre><code>&lt;div style=&quot;padding:10px; border:5px solid blue; margin: 10px; width:300px;&quot;&gt;    之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》&lt;/div&gt;</code></pre><p>复制</p><p>![](data:image/svg+xml;utf8,)</p><h3 id="box-sizing-border-box"><a href="#box-sizing-border-box" class="headerlink" title="box-sizing:border-box"></a><code>box-sizing:border-box</code></h3><p>前面提到，为盒子模型设置宽度，结果只是设置了内容的宽度，这个不合理。如何解决这一问题？答案就是为盒子指定样式：<strong><code>box-sizing:border-box</code></strong>。</p><pre><code>&lt;div style=&quot;padding:10px; border:5px solid blue; margin: 10px; width:300px; box-sizing:border-box;&quot;&gt;    之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》&lt;/div&gt;</code></pre><p>复制</p><p>![](data:image/svg+xml;utf8,)</p><p>上图中，为<code>div</code>设置了<code>box-sizing:border-box</code>之后，300px 的<strong>宽度是内容 + <code>border</code> + 边框的宽度（不包括<code>margin</code>）</strong>，这样就比较符合我们的实际要求了。建议大家在为系统写 CSS 时候，第一个样式是：</p><pre><code>* {    box-sizing:border-box;}</code></pre><p>复制</p><p>大名鼎鼎的 Bootstrap 也把<code>box-sizing:border-box</code>加入到它的<code>*</code>选择器中，我们为什么不这样做呢？</p><h3 id="纵向-margin-重叠"><a href="#纵向-margin-重叠" class="headerlink" title="纵向 margin 重叠"></a><strong>纵向 margin 重叠</strong></h3><p>这里提到 margin，就不得不提一下 margin 的这一特性——纵向重叠。如<code>&lt;p&gt;</code>的纵向 margin 是 16px，那么两个<code>&lt;p&gt;</code>之间纵向的距离是多少？—— 按常理来说应该是 16 + 16 = 32px，但是答案仍然是 16px。因为纵向的 margin 是会重叠的，如果两者不一样大的话，大的会把小的“吃掉”。</p><hr><h2 id="浮动float"><a href="#浮动float" class="headerlink" title="浮动float"></a><strong>浮动<code>float</code></strong></h2><p>float 用于网页布局比较多，使用起来也比较简单，这里总结了一些比较重要、需要注意的知识点，供大家参考。</p><h3 id="误解和误用"><a href="#误解和误用" class="headerlink" title="误解和误用"></a><strong>误解和误用</strong></h3><p>float 被设计出来的初衷是用于<strong>文字环绕效果</strong>，即一个图片一段文字，图片<code>float:left</code>之后，文字会环绕图片。</p><pre><code>&lt;div&gt;    &lt;img src=&quot;image/1.png&quot; style=&quot;float:left&quot;&gt;    一段文字一段文字一段文字一段文字一段文字一段文字一段文字一段文字一段文字&lt;/div&gt;</code></pre><p>复制</p><p>但是，后来大家发现结合<code>float + div</code>可以实现之前通过<code>table</code>实现的网页布局，因此就被“误用”于网页布局了。</p><blockquote><p>题目：为何 float 会导致父元素塌陷？</p></blockquote><h3 id="破坏性"><a href="#破坏性" class="headerlink" title="破坏性"></a><strong>破坏性</strong></h3><p>![](data:image/svg+xml;utf8,)</p><p>float 的<strong>破坏性</strong> —— float 破坏了父标签的原本结构，使得父标签出现了坍塌现象。导致这一现象的最根本原因在于：<strong>被设置了 float 的元素会脱离文档流</strong>。其根本原因在于 float 的设计初衷是解决文字环绕图片的问题。大家要记住 float 的这个影响。</p><h3 id="包裹性"><a href="#包裹性" class="headerlink" title="包裹性"></a><strong>包裹性</strong></h3><p><strong>包裹性</strong>也是 float 的一个非常重要的特性，大家用 float 时一定要熟知这一特性。咱们还是先从一个小例子看起：</p><p>![](data:image/svg+xml;utf8,)</p><p>如上图，普通的 div 如果没有设置宽度，它会撑满整个屏幕，在之前的盒子模型那一节也讲到过。而如果给 div 增加<code>float:left</code>之后，它突然变得紧凑了，宽度发生了变化，把内容中的三个字包裹了——这就是包裹性。为 div 设置了 float 之后，其宽度会自动调整为包裹住内容宽度，而不是撑满整个父容器。</p><p>注意，此时 div 虽然体现了包裹性，但是它的 display 样式是没有变化的，还是<code>display: block</code>。</p><p>float 为什么要具有包裹性？其实答案还是得从 float 的设计初衷来寻找，float 是被设计用于实现文字环绕效果的。文字环绕图片比较好理解，但是如果想要让文字环绕一个 div 呢？此时 div 不被“包裹”起来的话，就无法实现环绕效果了。</p><h3 id="清空格"><a href="#清空格" class="headerlink" title="清空格"></a><strong>清空格</strong></h3><p>float 还有一个大家可能不是很熟悉的特性——清空格。按照惯例，咱还是先举例子说明。</p><pre><code>&lt;div style=&quot;border: 2px solid blue; padding:3px;&quot;&gt;    &lt;img src=&quot;image/1.png&quot;/&gt;    &lt;img src=&quot;image/2.png&quot;/&gt;    &lt;img src=&quot;image/3.png&quot;/&gt;    &lt;img src=&quot;image/4.png&quot;/&gt;&lt;/div&gt;</code></pre><p>复制</p><p>![](data:image/svg+xml;utf8,)</p><p>加上<code>float:left</code>之后：</p><p>![](data:image/svg+xml;utf8,)</p><p>上面第一张图中，正常的 img 中间是会有空格的，因为多个 img 标签会有换行，而浏览器识别换行为空格，这也是很正常的。第二张图中，为 img 增加了<code>float:left</code>的样式，这就使得 img 之间没有了空格，4 个 img 紧紧挨着。</p><p>如果大家之前没注意，现在想想之前写过的程序，是不是有这个特性。为什么 float 适合用于网页排版（俗称“砌砖头”）？就是因为 float 排版出来的网页严丝合缝，中间连个苍蝇都飞不进去。</p><p>“清空格”这一特性的根本原因是 float 会导致节点脱离文档流结构。它都不属于文档流结构了，那么它身边的什么换行、空格就都和它没了关系，它就尽量往一边靠拢，能靠多近就靠多近，这就是清空格的本质。</p><blockquote><p>题目：手写 clearfix</p></blockquote><h3 id="clearfix"><a href="#clearfix" class="headerlink" title="clearfix"></a><strong><code>clearfix</code></strong></h3><p>清除浮动的影响，一般使用的样式如下，统称<code>clearfix</code>代码。所有 float 元素的父容器，一般情况下都应该加<code>clearfix</code>这个 class。</p><pre><code>.clearfix:after {    content: &apos;&apos;;    display: table;    clear: both;}.clearfix {    *zoom: 1; /* 兼容 IE 低版本 */}</code></pre><p>复制</p><pre><code>&lt;div class=&quot;clearfix&quot;&gt;    &lt;img src=&quot;image/1.png&quot; style=&quot;float: left&quot;/&gt;    &lt;img src=&quot;image/2.png&quot; style=&quot;float: left&quot;/&gt;&lt;/div&gt;</code></pre><p>复制</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>float 的设计初衷是解决文字环绕图片的问题，后来误打误撞用于做布局，因此有许多不合适或者需要注意的地方，上文基本都讲到了需要的知识点。如果是刚开始接触 float 的同学，学完上面的基础知识之后，还应该做一些练习实战一下 —— 经典的“圣杯布局”和“双飞翼布局”。这里就不再展开讲了，网上资料非常多，例如<a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fentry%2F5a8868cdf265da4e7e10c133%3Futm_source%3Dgold_browser_extension" target="_blank" rel="noopener">浅谈面试中常考的两种经典布局——圣杯与双飞翼</a>（此文的最后两张图清晰地展示了这两种布局）。</p><hr><h2 id="定位position"><a href="#定位position" class="headerlink" title="定位position"></a><strong>定位<code>position</code></strong></h2><p>position 用于网页元素的定位，可设置 static/relative/absolute/fixed 这些值，其中 static 是默认值，不用介绍。</p><blockquote><p>题目：relative 和 absolute 有何区别？</p></blockquote><h3 id="relative"><a href="#relative" class="headerlink" title="relative"></a><strong>relative</strong></h3><p>相对定位 relative 可以用一个例子很轻松地演示出来。例如我们写 4 个<code>&lt;p&gt;</code>，出来的样子大家不用看也能知道。</p><pre><code>&lt;p&gt;第一段文字&lt;/p&gt;&lt;p&gt;第二段文字&lt;/p&gt;&lt;p&gt;第三段文字&lt;/p&gt;&lt;p&gt;第四段文字&lt;/p&gt;</code></pre><p>复制</p><p>![](data:image/svg+xml;utf8,)</p><p>然后我们在第三个<code>&lt;p&gt;</code>上面，加上<code>position:relative</code>并且设置<code>left</code>和<code>top</code>值，看这个<code>&lt;p&gt;</code>有什么变化。</p><pre><code>&lt;p&gt;第一段文字&lt;/p&gt;&lt;p&gt;第二段文字&lt;/p&gt;&lt;p style=&quot;position:relative; top: 10px; left: 10px&quot;&gt;第三段文字&lt;/p&gt;&lt;p&gt;第四段文字&lt;/p&gt;</code></pre><p>复制</p><p>![](data:image/svg+xml;utf8,)</p><p>上图中，大家应该要识别出两个信息（相信大部分人会忽略第二个信息）</p><ul><li>第三个<code>&lt;p&gt;</code>发生了位置变化，分别向右向下移动了10px；</li><li>其他的三个<code>&lt;p&gt;</code>位置没有发生变化，这一点也很重要。</li></ul><p>可见，<strong>relative 会导致自身位置的相对变化，而不会影响其他元素的位置、大小</strong>。这是 relative 的要点之一。还有第二个要点，就是 relative 产生一个新的定位上下文。下文有关于定位上下文的详细介绍，这里可以先通过一个例子来展示一下区别：</p><p>![](data:image/svg+xml;utf8,)</p><p>注意看这两图的区别，下文将有解释。</p><h3 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a><strong>absolute</strong></h3><p>还是先写一个基本的 demo。</p><pre><code>&lt;p&gt;第一段文字&lt;/p&gt;&lt;p&gt;第二段文字&lt;/p&gt;&lt;p style=&quot;background: yellow&quot;&gt;第三段文字&lt;/p&gt;&lt;p&gt;第四段文字&lt;/p&gt;</code></pre><p>复制</p><p>![](data:image/svg+xml;utf8,)</p><p>然后，我们把第三个<code>&lt;p&gt;</code>改为<code>position:absolute;</code>，看看会发生什么变化。</p><p>![](data:image/svg+xml;utf8,)</p><p>从上面的结果中，我们能看出几点信息：</p><ul><li>absolute 元素脱离了文档结构。和 relative 不同，其他三个元素的位置重新排列了。只要元素会脱离文档结构，它就会产生破坏性，导致父元素坍塌。（此时你应该能立刻想起来，float 元素也会脱离文档结构。）</li><li>absolute 元素具有“包裹性”。之前<code>&lt;p&gt;</code>的宽度是撑满整个屏幕的，而此时<code>&lt;p&gt;</code>的宽度刚好是内容的宽度。</li><li>absolute 元素具有“跟随性”。虽然 absolute 元素脱离了文档结构，但是它的位置并没有发生变化，还是老老实实地呆在它原本的位置，因为我们此时没有设置 top、left 的值。</li><li>absolute 元素会悬浮在页面上方，会遮挡住下方的页面内容。</li></ul><p>最后，通过给 absolute元素设置 top、left 值，可自定义其内容，这个都是平时比较常用的了。这里需要注意的是，设置了 top、left 值时，元素是相对于最近的定位上下文来定位的，而不是相对于浏览器定位。</p><h3 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a><strong>fixed</strong></h3><p>其实 fixed 和 absolute 是一样的，唯一的区别在于：absolute 元素是根据最近的定位上下文确定位置，而 fixed 根据浏览器确定位置。</p><blockquote><p>题目：relative、absolute 和 fixed 分别依据谁来定位？</p></blockquote><h3 id="定位上下文"><a href="#定位上下文" class="headerlink" title="定位上下文"></a><strong>定位上下文</strong></h3><p>relative 元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。</p><p>![](data:image/svg+xml;utf8,)</p><p>fixed 元素的定位是相对于浏览器边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。</p><p>![](data:image/svg+xml;utf8,)</p><p>absolute 的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了<code>position:relative/absolute/fixed</code>的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。如下两个图所示：</p><p>![](data:image/svg+xml;utf8,)</p><p>![](data:image/svg+xml;utf8,)</p><hr><h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a><strong><code>flex</code>布局</strong></h2><p>布局的传统解决方案基于盒子模型，依赖 <code>display</code> 属性 + <code>position</code> 属性 + <code>float</code> 属性。它对于那些特殊布局非常不方便，比如，垂直居中（下文会专门讲解）就不容易实现。在目前主流的移动端页面中，使用 flex 布局能更好地完成需求，因此 flex 布局的知识是必须要掌握的。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a><strong>基本使用</strong></h3><p>任何一个容器都可以使用 flex 布局，代码也很简单。</p><pre><code>&lt;style type=&quot;text/css&quot;&gt;    .container {      display: flex;    }    .item {        border: 1px solid #000;        flex: 1;    }&lt;/style&gt;&lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;item&quot;&gt;aaa&lt;/div&gt;    &lt;div class=&quot;item&quot; style=&quot;flex: 2&quot;&gt;bbb&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;ccc&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;ddd&lt;/div&gt;&lt;/div&gt;</code></pre><p>复制</p><p>![](data:image/svg+xml;utf8,)</p><p>注意，第三个<code>&lt;div&gt;</code>的<code>flex: 2</code>，其他的<code>&lt;div&gt;</code>的<code>flex: 1</code>，这样第二个<code>&lt;div&gt;</code>的宽度就是其他的<code>&lt;div&gt;</code>的两倍。</p><h3 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a><strong>设计原理</strong></h3><p>设置了<code>display: flex</code>的元素，我们称为“容器”（flex container），其所有的子节点我们称为“成员”（flex item）。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。</p><p>![](data:image/svg+xml;utf8,)</p><p>将以上文字和图片结合起来，再详细看一遍，这样就能理解 flex 的设计原理，才能更好地实际使用。</p><h3 id="设置主轴的方向"><a href="#设置主轴的方向" class="headerlink" title="设置主轴的方向"></a><strong>设置主轴的方向</strong></h3><p><code>flex-direction</code>可决定主轴的方向，有四个可选值：</p><ul><li>row（默认值）：主轴为水平方向，起点在左端。</li><li>row-reverse：主轴为水平方向，起点在右端。</li><li>column：主轴为垂直方向，起点在上沿。</li><li><p>column-reverse：主轴为垂直方向，起点在下沿。</p><p>.box {<br>  flex-direction: column-reverse| column | row | row-reverse;<br>}</p></li></ul><p>复制</p><p>以上代码设置的主轴方向，将依次对应下图：</p><p>![](data:image/svg+xml;utf8,)</p><h3 id="设置主轴的对齐方式"><a href="#设置主轴的对齐方式" class="headerlink" title="设置主轴的对齐方式"></a><strong>设置主轴的对齐方式</strong></h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式，值如下：</p><ul><li>flex-start（默认值）：向主轴开始方向对齐。</li><li>flex-end：向主轴结束方向对齐。</li><li>center： 居中。</li><li>space-between：两端对齐，项目之间的间隔都相等。</li><li><p>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</p><p>.box {</p><pre><code>justify-content: flex-start | flex-end | center | space-between | space-around;</code></pre><p>}</p></li></ul><p>复制</p><p>![](data:image/svg+xml;utf8,)</p><h3 id="交叉轴的对齐方式"><a href="#交叉轴的对齐方式" class="headerlink" title="交叉轴的对齐方式"></a><strong>交叉轴的对齐方式</strong></h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐，值如下：</p><ul><li>flex-start：交叉轴的起点对齐。</li><li>flex-end：交叉轴的终点对齐。</li><li>center：交叉轴的中点对齐。</li><li>baseline: 项目的第一行文字的基线对齐。</li><li><p>stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。</p><p>.box {</p><pre><code>align-items: flex-start | flex-end | center | baseline | stretch;</code></pre><p>}</p></li></ul><p>复制</p><p>![](data:image/svg+xml;utf8,)</p><hr><h2 id="如何实现居中对齐？"><a href="#如何实现居中对齐？" class="headerlink" title="如何实现居中对齐？"></a><strong>如何实现居中对齐？</strong></h2><blockquote><p>题目：如何实现水平居中？</p></blockquote><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a><strong>水平居中</strong></h3><p>inline 元素用<code>text-align: center;</code>即可，如下：</p><pre><code>.container {   text-align: center;}</code></pre><p>复制</p><p>block 元素可使用<code>margin: auto;</code>，PC 时代的很多网站都这么搞。</p><pre><code>.container {    text-align: center; }.item {    width: 1000px;    margin: auto; }</code></pre><p>复制</p><p>绝对定位元素可结合<code>left</code>和<code>margin</code>实现，但是必须知道宽度。</p><pre><code>.container {    position: relative;    width: 500px;}.item {    width: 300px;    height: 100px;    position: absolute;    left: 50%;    margin: -150px;}</code></pre><p>复制</p><blockquote><p>题目：如何实现垂直居中？</p></blockquote><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a><strong>垂直居中</strong></h3><p>inline 元素可设置<code>line-height</code>的值等于<code>height</code>值，如单行文字垂直居中：</p><pre><code>.container {   height: 50px;   line-height: 50px;}</code></pre><p>复制</p><p>绝对定位元素，可结合<code>left</code>和<code>margin</code>实现，但是必须知道尺寸。</p><ul><li>优点：兼容性好</li><li><p>缺点：需要提前知道尺寸</p><p>.container {</p><pre><code>position: relative;height: 200px;</code></pre><p>}<br>.item {</p><pre><code>width: 80px;height: 40px;position: absolute;left: 50%;top: 50%;margin-top: -20px;margin-left: -40px;</code></pre><p>}</p></li></ul><p>复制</p><p>绝对定位可结合<code>transform</code>实现居中。</p><ul><li>优点：不需要提前知道尺寸</li><li><p>缺点：兼容性不好</p><p>.container {</p><pre><code>position: relative;height: 200px;</code></pre><p>}<br>.item {</p><pre><code>width: 80px;height: 40px;position: absolute;left: 50%;top: 50%;transform: translate(-50%, -50%);background: blue;</code></pre><p>}</p></li></ul><p>复制</p><p>绝对定位结合<code>margin: auto</code>，不需要提前知道尺寸，兼容性好。</p><pre><code>.container {    position: relative;    height: 300px;}.item {    width: 100px;    height: 50px;    position: absolute;    left: 0;    top: 0;    right: 0;    bottom: 0;    margin: auto;}</code></pre><p>复制</p><p>其他的解决方案还有，不过没必要掌握太多，能说出上文的这几个解决方案即可。</p><hr><h2 id="理解语义化"><a href="#理解语义化" class="headerlink" title="理解语义化"></a><strong>理解语义化</strong></h2><blockquote><p>题目：如何理解 HTML 语义化？</p></blockquote><p>所谓“语义”就是为了更易读懂，这要分两部分：</p><ul><li>让人（写程序、读程序）更易读懂</li><li>让机器（浏览器、搜索引擎）更易读懂</li></ul><h3 id="让人更易读懂"><a href="#让人更易读懂" class="headerlink" title="让人更易读懂"></a><strong>让人更易读懂</strong></h3><p>对于人来说，代码可读性、语义化就是一个非常广泛的概念了，例如定义 JS 变量的时候使用更易读懂的名称，定义 CSS class 的时候也一样，例如<code>length`</code>list<code>等，而不是使用</code>a<code></code>b`这种谁都看不懂的名称。</p><p>不过我们平常考查的“语义化”并不会考查这么广义、这么泛的问题，而是考查 HTML 的语义化，是为了更好地让机器读懂 HTML。</p><h3 id="让机器更易读懂"><a href="#让机器更易读懂" class="headerlink" title="让机器更易读懂"></a><strong>让机器更易读懂</strong></h3><p>HTML 符合 XML 标准，但又和 XML 不一样 —— HTML 不允许像 XML 那样自定义标签名称，HTML 有自己规定的标签名称。问题就在这里 —— HTML 为何要自己规定那么多标签名称呢，例如<code>p`</code>div<code>h1</code>ul<code>等 —— 就是为了语义化。其实，如果你精通 CSS 的话，你完全可以全部用</code><div><code>标签来实现所有的网页效果，其他的</code>p<code>h1</code>ul`等标签可以一个都不用。但是我们不推荐这么做，这样做就失去了 HTML 语义化的意义。</div></p><p>拿搜索引擎来说，爬虫下载到我们网页的 HTML 代码，它如何更好地去理解网页的内容呢？—— 就是根据 HTML 既定的标签。<code>h1</code>标签就代表是标题；<code>p</code>里面的就是段落详细内容，权重肯定没有标题高；<code>ul</code>里面就是列表；<code>strong</code>就是加粗的强调的内容 …… 如果我们不按照 HTML 语义化来写，全部都用<code>&lt;div&gt;</code>标签，那搜索引擎将很难理解我们网页的内容。</p><p>为了加强 HTML 语义化，HTML5 标准中又增加了<code>header`</code>section<code></code>artical`等标签。因此，书写 HTML 时，语义化是非常重要的，否则 W3C 也没必要辛辛苦苦制定出这些标准来。</p><hr><h2 id="CSS3-动画"><a href="#CSS3-动画" class="headerlink" title="CSS3 动画"></a><strong>CSS3 动画</strong></h2><p>CSS3 可以实现动画，代替原来的 Flash 和 JavaScript 方案。</p><p>首先，使用<code>@keyframes</code>定义一个动画，名称为<code>testAnimation</code>，如下代码，通过百分比来设置不同的 CSS 样式，规定动画的变化。所有的动画变化都可以这么定义出来。</p><pre><code>@keyframes testAnimation{    0%   {background: red; left:0; top:0;}    25%  {background: yellow; left:200px; top:0;}    50%  {background: blue; left:200px; top:200px;}    75%  {background: green; left:0; top:200px;}    100% {background: red; left:0; top:0;}}</code></pre><p>复制</p><p>然后，针对一个 CSS 选择器来设置动画，例如针对<code>div</code>元素设置动画，如下：</p><pre><code>div {    width: 100px;    height: 50px;    position: absolute;    animation-name: myfirst;    animation-duration: 5s;}</code></pre><p>复制</p><p><code>animation-name</code>对应到动画名称，<code>animation-duration</code>是动画时长，还有其他属性：</p><ul><li><code>animation-timing-function</code>：规定动画的速度曲线。默认是<code>ease</code></li><li><code>animation-delay</code>：规定动画何时开始。默认是 0</li><li><code>animation-iteration-count</code>：规定动画被播放的次数。默认是 1</li><li><code>animation-direction</code>：规定动画是否在下一周期逆向地播放。默认是<code>normal</code></li><li><code>animation-play-state</code> ：规定动画是否正在运行或暂停。默认是<code>running</code></li><li><code>animation-fill-mode</code>：规定动画执行之前和之后如何给动画的目标应用，默认是<code>none</code>，保留在最后一帧可以用<code>forwards</code></li></ul><blockquote><p>题目：CSS 的<code>transition</code>和<code>animation</code>有何区别？</p></blockquote><p>首先<code>transition</code>和<code>animation</code>都可以做动效，从语义上来理解，<code>transition</code>是过渡，由一个状态过渡到另一个状态，比如高度<code>100px</code>过渡到<code>200px</code>；而<code>animation</code>是动画，即更专业做动效的，<code>animation</code>有帧的概念，可以设置关键帧<code>keyframe</code>，一个动画可以由多个关键帧多个状态过渡组成，另外<code>animation</code>也包含上面提到的多个属性。</p><h2 id="重绘和回流"><a href="#重绘和回流" class="headerlink" title="重绘和回流"></a><strong>重绘和回流</strong></h2><p>重绘和回流是面试题经常考的题目，也是性能优化当中应该注意的点，下面笔者简单介绍下。</p><ul><li><strong>重绘</strong>：指的是当页面中的元素不脱离文档流，而简单地进行样式的变化，比如修改颜色、背景等，浏览器重新绘制样式</li><li><strong>回流</strong>：指的是处于文档流中 DOM 的尺寸大小、位置或者某些属性发生变化时，导致浏览器重新渲染部分或全部文档的情况</li></ul><p>相比之下，<strong>回流要比重绘消耗性能开支更大</strong>。另外，一些属性的读取也会引起回流，比如读取某个 DOM 的高度和宽度，或者使用<code>getComputedStyle</code>方法。在写代码的时候要避免回流和重绘。比如在笔试中可能会遇见下面的题目：</p><blockquote><p>题目：找出下面代码的优化点，并且优化它</p></blockquote><pre><code>var data = [&apos;string1&apos;, &apos;string2&apos;, &apos;string3&apos;];for(var i = 0; i &lt; data.length; i++){    var dom = document.getElementById(&apos;list&apos;);    dom.innerHTML += &apos;&lt;li&gt;&apos; + data[i] + &apos;&lt;/li&gt;&apos;;}</code></pre><p>复制</p><p>上面的代码在循环中每次都获取<code>dom</code>，然后对其内部的 HTML 进行累加<code>li</code>，每次都会操作 DOM 结构，可以改成使用<code>documentFragment</code>或者先遍历组成 HTML 的字符串，最后操作一次<code>innerHTML</code>。</p><hr><h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>本小节总结了 CSS 和 HTML 常考的知识点，包括 CSS 中比较重要的定位、布局的知识，也介绍了一些 CSS3 的知识点概念和题目，以及 HTML 的语义化。</p><p>上一篇：<a href="541672">一面 2：JS-Web-API 知识点与高频考题解析</a>下一篇：<a href="541674">一面 4：从容应对算法题目</a></p><h1 id="一面-4：从容应对算法题目"><a href="#一面-4：从容应对算法题目" class="headerlink" title="一面 4：从容应对算法题目"></a><strong>一面 4：从容应对算法题目</strong></h1><p>由冯·诺依曼机组成我们知道：数据存储和运算是计算机工作的主要内容。<code>程序=数据结构+算法</code>，所以计算机类工程师必须掌握一定的数据结构和算法知识。</p><h2 id="知识点梳理-3"><a href="#知识点梳理-3" class="headerlink" title="知识点梳理"></a><strong>知识点梳理</strong></h2><ul><li>常见的数据结构<ul><li>栈、队列、链表</li><li>集合、字典、散列集</li></ul></li><li>常见算法<ul><li>递归</li><li>排序</li><li>枚举</li></ul></li><li>算法复杂度分析</li><li>算法思维<ul><li>分治</li><li>贪心</li><li>动态规划</li></ul></li><li>高级数据结构<ul><li>树、图</li><li>深度优先和广度优先搜索</li></ul></li></ul><p>本小节会带领大家快速过一遍数据结构和算法，重点讲解一些常考、前端会用到的算法和数据结构。</p><hr><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h2><p>数据结构决定了数据存储的空间和时间效率问题，数据的写入和提取速度要求也决定了应该选择怎样的数据结构。</p><p>根据对场景需求的不同，我们设计不同的数据结构，比如：</p><ul><li>读得多的数据结构，应该想办法提高数据的读取效率，比如 IP 数据库，只需要写一次，剩下的都是读取；</li><li>读写都多的数据结构，要兼顾两者的需求平衡，比如 LRU Cache 算法。</li></ul><p>算法是数据加工处理的方式，一定的算法会提升数据的处理效率。比如有序数组的二分查找，要比普通的顺序查找快很多，尤其是在处理大量数据的时候。</p><p>数据结构和算法是程序开发的通用技能，所以在任何面试中都可能会遇见。随着近几年 AI、大数据、小游戏越来越火，Web 前端职位难免会跟数据结构和算法打交道，面试中也会出现越来越多的算法题目。学习数据结构和算法也能够帮助我们打开思路，突破技能瓶颈。</p><h2 id="前端常遇见的数据结构问题"><a href="#前端常遇见的数据结构问题" class="headerlink" title="前端常遇见的数据结构问题"></a><strong>前端常遇见的数据结构问题</strong></h2><p>现在我来梳理下前端常遇见的数据结构：</p><ul><li>简单数据结构（必须理解掌握）<ul><li>有序数据结构：栈、队列、链表，有序数据结构省空间（存储空间小）</li><li>无序数据结构：集合、字典、散列表，无序数据结构省时间（读取时间快）</li></ul></li><li>复杂数据结构<ul><li>树、堆</li><li>图</li></ul></li></ul><p>对于简单数据结构，在 ES 中对应的是数组（<code>Array</code>）和对象（<code>Object</code>）。可以想一下，数组的存储是有序的，对象的存储是无序的，但是我要在对象中根据<code>key</code>找到一个值是立即返回的，数组则需要查找的过程。</p><p>这里我通过一个真实面试题目来说明介绍下数据结构设计。</p><blockquote><p>题目：使用 ECMAScript（JS）代码实现一个事件类<code>Event</code>，包含下面功能：绑定事件、解绑事件和派发事件。</p></blockquote><p>在稍微复杂点的页面中，比如组件化开发的页面，同一个页面由两三个人来开发，为了保证组件的独立性和降低组件间耦合度，我们往往使用「订阅发布模式」，即组件间通信使用事件监听和派发的方式，而不是直接相互调用组件方法，这就是题目要求写的<code>Event</code>类。</p><p>这个题目的核心是一个事件类型对应回调函数的数据设计。为了实现绑定事件，我们需要一个<code>_cache</code>对象来记录绑定了哪些事件。而事件发生的时候，我们需要从<code>_cache</code>中读取出来事件回调，依次执行它们。一般页面中事件派发（读）要比事件绑定（写）多。所以我们设计的数据结构应该尽量地能够在事件发生时，更加快速地找到对应事件的回调函数们，然后执行。</p><p>经过这样一番考虑，我简单写了下代码实现：</p><pre><code>class Event {    constructor() {        // 存储事件的数据结构        // 为了查找迅速，使用了对象（字典）        this._cache = {};    }    // 绑定    on(type, callback) {        // 为了按类查找方便和节省空间，        // 将同一类型事件放到一个数组中        // 这里的数组是队列，遵循先进先出        // 即先绑定的事件先触发        let fns = (this._cache[type] = this._cache[type] || []);        if (fns.indexOf(callback) === -1) {            fns.push(callback);        }        return this;    }    // 触发    trigger(type, data) {        let fns = this._cache[type];        if (Array.isArray(fns)) {            fns.forEach((fn) =&gt; {                fn(data);            });        }        return this;    }    // 解绑    off(type, callback) {        let fns = this._cache[type];        if (Array.isArray(fns)) {            if (callback) {                let index = fns.indexOf(callback);                if (index !== -1) {                    fns.splice(index, 1);                }            } else {                //全部清空                fns.length = 0;            }        }        return this;    }}// 测试用例const event = new Event();event.on(&apos;test&apos;, (a) =&gt; {    console.log(a);});event.trigger(&apos;test&apos;, &apos;hello world&apos;);event.off(&apos;test&apos;);event.trigger(&apos;test&apos;, &apos;hello world&apos;);</code></pre><p>复制</p><p>类似于树、堆、图这些高级数据结构，前端一般也不会考查太多，但是它们的查找方法却常考，后面介绍。高级数据应该平时多积累，好好理解，比如理解了堆是什么样的数据结构，在面试中遇见的「查找最大的 K 个数」这类算法问题，就会迎刃而解。</p><h2 id="算法的效率是通过算法复杂度来衡量的"><a href="#算法的效率是通过算法复杂度来衡量的" class="headerlink" title="算法的效率是通过算法复杂度来衡量的"></a><strong>算法的效率是通过算法复杂度来衡量的</strong></h2><p>算法的好坏可以通过算法复杂度来衡量，算法复杂度包括时间复杂度和空间复杂度两个。时间复杂度由于好估算、好评估等特点，是面试中考查的重点。空间复杂度在面试中考查得不多。</p><p>常见的时间复杂度有：</p><ul><li>常数阶 <code>O(1)</code></li><li>对数阶 <code>O(logN)</code></li><li>线性阶 <code>O(n)</code></li><li>线性对数阶 <code>O(nlogN)</code></li><li>平方阶 <code>O(n^2)</code></li><li>立方阶 <code>O(n^3)</code></li><li>!k次方阶 <code>O(n^k)</code></li><li>指数阶<code>O(2^n)</code></li></ul><p>随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低。</p><p>一般做算法复杂度分析的时候，遵循下面的技巧：</p><ol><li>看看有几重循环，一般来说一重就是<code>O(n)</code>，两重就是 <code>O(n^2)</code>，以此类推</li><li>如果有二分，则为<code>O(logN)</code></li><li>保留最高项，去除常数项</li></ol><blockquote><p>题目：分析下面代码的算法复杂度（为了方便，我已经在注释中加了代码分析）</p></blockquote><pre><code>let i =0; // 语句执行一次 while (i &lt; n) { // 语句执行 n 次   console.log(`Current i is ${i}`); //语句执行 n 次  i++; // 语句执行 n 次}</code></pre><p>复制</p><p>根据注释可以得到，算法复杂度为<code>1 + n + n + n = 1 + 3n</code>，去除常数项，为<code>O(n)</code>。</p><pre><code>let number = 1; // 语句执行一次 while (number &lt; n) { // 语句执行 logN 次  number *= 2; // 语句执行 logN 次}</code></pre><p>复制</p><p>上面代码<code>while</code>的跳出判断条件是<code>number&lt;n</code>，而循环体内<code>number</code>增长速度是<code>(2^n)</code>，所以循环代码实际执行<code>logN</code>次，复杂度为：<code>1 + 2 * logN = O(logN)</code></p><pre><code>for (let i = 0; i &lt; n; i++) {// 语句执行 n 次  for (let j = 0; j &lt; n; j++) {// 语句执行 n^2 次    console.log(&apos;I am here!&apos;); // 语句执行 n^2 次  }}</code></pre><p>复制</p><p>上面代码是两个<code>for</code>循环嵌套，很容易得出复杂度为：<code>O(n^2)</code></p><h2 id="人人都要掌握的基础算法"><a href="#人人都要掌握的基础算法" class="headerlink" title="人人都要掌握的基础算法"></a><strong>人人都要掌握的基础算法</strong></h2><p>枚举和递归是最最简单的算法，也是复杂算法的基础，人人都应该掌握！枚举相对比较简单，我们重点说下递归。</p><p>递归由下面两部分组成：</p><ol><li>递归主体，就是要循环解决问题的代码</li><li>递归的跳出条件，递归不能一直递归下去，需要完成一定条件后跳出</li></ol><p>关于递归有个经典的面试题目是：</p><blockquote><p>实现 JS 对象的深拷贝</p></blockquote><p><strong>什么是深拷贝？</strong></p><p>「深拷贝」就是在拷贝数据的时候，将数据的所有<strong>引用结构</strong>都拷贝一份。简单的说就是，在内存中存在两个数据结构完全相同又相互独立的数据，将引用型类型进行复制，而不是只复制其引用关系。</p><p>分析下怎么做「深拷贝」：</p><ol><li>首先假设深拷贝这个方法已经完成，为 deepClone</li><li><p>要拷贝一个数据，我们肯定要去遍历它的属性，如果这个对象的属性仍是对象，继续使用这个方法，如此往复</p><p>function deepClone(o1, o2) {</p><pre><code>for (let k in o2) {    if (typeof o2[k] === &apos;object&apos;) {        o1[k] = {};        deepClone(o1[k], o2[k]);    } else {        o1[k] = o2[k];    }}</code></pre><p>}<br>// 测试用例<br>let obj = {</p><pre><code>a: 1,b: [1, 2, 3],c: {}</code></pre><p>};<br>let emptyObj = Object.create(null);<br>deepClone(emptyObj, obj);<br>console.log(emptyObj.a == obj.a);<br>console.log(emptyObj.b == obj.b);</p></li></ol><p>复制</p><p>递归容易造成爆栈，尾部调用可以解决递归的这个问题，Chrome 的 V8 引擎做了尾部调用优化，我们在写代码的时候也要注意尾部调用写法。递归的爆栈问题可以通过将递归改写成枚举的方式来解决，就是通过<code>for</code>或者<code>while</code>来代替递归。</p><p>我们在使用递归的时候，要注意做优化，比如下面的题目。</p><blockquote><p>题目：求斐波那契数列（兔子数列） 1,1,2,3,5,8,13,21,34,55,89…中的第 n 项</p></blockquote><p>下面的代码中<code>count</code>记录递归的次数，我们看下两种差异性的代码中的<code>count</code>的值：</p><pre><code>let count = 0;function fn(n) {    let cache = {};    function _fn(n) {        if (cache[n]) {            return cache[n];        }        count++;        if (n == 1 || n == 2) {            return 1;        }        let prev = _fn(n - 1);        cache[n - 1] = prev;        let next = _fn(n - 2);        cache[n - 2] = next;        return prev + next;    }    return _fn(n);}let count2 = 0;function fn2(n) {    count2++;    if (n == 1 || n == 2) {        return 1;    }    return fn2(n - 1) + fn2(n - 2);}console.log(fn(20), count); // 6765 20console.log(fn2(20), count2); // 6765 13529</code></pre><p>复制</p><h2 id="快排和二分查找"><a href="#快排和二分查找" class="headerlink" title="快排和二分查找"></a><strong>快排和二分查找</strong></h2><p>前端中面试排序和查找的可能性比较小，因为 JS 引擎已经把这些常用操作优化得很好了，可能项目中你费劲写的一个排序方法，都不如<code>Array.sort</code>速度快且代码少。因此，掌握快排和二分查找就可以了。</p><p>快排和二分查找都基于一种叫做「分治」的算法思想，通过对数据进行分类处理，不断降低数量级，实现<code>O(logN)</code>（对数级别，比<code>O(n)</code>这种线性复杂度更低的一种）的复杂度。</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><strong>快速排序</strong></h3><p>快排大概的流程是：</p><ol><li>随机选择数组中的一个数 A，以这个数为基准</li><li>其他数字跟这个数进行比较，比这个数小的放在其左边，大的放到其右边</li><li>经过一次循环之后，A 左边为小于 A 的，右边为大于 A 的</li><li>这时候将左边和右边的数再递归上面的过程</li></ol><p>具体代码如下：</p><pre><code>const Arr = [85, 24, 63, 45, 17, 31, 96, 50];function quickSort(arr) {    if (arr.length &lt;= 1) {        return arr;    }    let pivotIndex = Math.floor(arr.length / 2);    let pivot = arr.splice(pivotIndex, 1)[0];    let left = [];    let right = [];    for (let i = 0; i &lt; arr.length; i++) {        if (arr[i] &lt; pivot) {            left.push(arr[i]);        } else {            right.push(arr[i]);        }    }    // 递归    return quickSort(left).concat([pivot], quickSort(right));}console.log(quickSort(Arr));</code></pre><p>复制</p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a><strong>二分查找</strong></h3><p>二分查找法主要是解决「在一堆有序的数中找出指定的数」这类问题，不管这些数是一维数组还是多维数组，只要有序，就可以用二分查找来优化。</p><p>二分查找是一种「分治」思想的算法，大概流程如下：</p><ol><li>数组中排在中间的数字 A，与要找的数字比较大小</li><li>因为数组是有序的，所以： a) A 较大则说明要查找的数字应该从前半部分查找 b) A 较小则说明应该从查找数字的后半部分查找</li><li>这样不断查找缩小数量级（扔掉一半数据），直到找完数组为止</li></ol><blockquote><p>题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><pre><code>function Find(target, array) {    let i = 0;    let j = array[i].length - 1;    while (i &lt; array.length &amp;&amp; j &gt;= 0) {        if (array[i][j] &lt; target) {            i++;        } else if (array[i][j] &gt; target) {            j--;        } else {            return true;        }    }    return false;}//测试用例console.log(Find(10, [    [1, 2, 3, 4],     [5, 9, 10, 11],     [13, 20, 21, 23]    ]));</code></pre><p>复制</p><p>另外笔者在面试中遇见过下面的问题：</p><blockquote><p>题目：现在我有一个 1~1000 区间中的正整数，需要你猜下这个数字是几，你只能问一个问题：大了还是小了？问需要猜几次才能猜对？</p></blockquote><p>拿到这个题目，笔者想到的就是电视上面有个「猜价格」的购物节目，在规定时间内猜对价格就可以把实物抱回家。所以问题就是让面试官不停地回答我猜的数字比这个数字大了还是小了。这就是二分查找！</p><p>猜几次呢？其实这个问题就是个二分查找的算法时间复杂度问题，二分查找的时间复杂度是<code>O(logN)</code>，所以求<code>log1000</code>的解就是猜的次数。我们知道<code>2^10=1024</code>，所以可以快速估算出：<code>log1000</code>约等于 10，最多问 10 次就能得到这个数！</p><h2 id="面试遇见不会的算法问题怎么办"><a href="#面试遇见不会的算法问题怎么办" class="headerlink" title="面试遇见不会的算法问题怎么办"></a><strong>面试遇见不会的算法问题怎么办</strong></h2><p>面试的时候，在遇见算法题目的时候，应该揣摩面试官的意图，听好关键词，比如：有序的数列做查找、要求算法复杂度是<code>O(logN)</code>这类一般就是用二分的思想。</p><p>一般来说算法题目的解题思路分以下四步：</p><ol><li>先降低数量级，拿可以计算出来的情况（数据）来构思解题步骤</li><li>根据解题步骤编写程序，优先将特殊情况做好判断处理，比如一个大数组的问题，如果数组为两个数长度的情况</li><li>检验程序正确性</li><li>是否可以优化（由浅到深），有能力的话可以故意预留优化点，这样可以体现个人技术能力</li></ol><h2 id="正则匹配解题"><a href="#正则匹配解题" class="headerlink" title="正则匹配解题"></a><strong>正则匹配解题</strong></h2><p>很多算法题目利用 ES 语法的特性来回答更加简单，比如正则匹配就是常用的一种方式。笔者简单通过几个真题来汇总下正则的知识点。</p><blockquote><p>题目：字符串中第一个出现一次的字符</p></blockquote><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符「go」时，第一个只出现一次的字符是「g」。当从该字符流中读出前六个字符「google」时，第一个只出现一次的字符是「l」。</p><p>这个如果用纯算法来解答需要遍历字符串，统计每个字符出现的次数，然后按照字符串的顺序来找出第一次出现一次的字符，整个过程比较繁琐，如果用正则就简单多了。</p><pre><code>function find(str){    for (var i = 0; i &lt; str.length; i++) {        let char = str[i]        let reg = new RegExp(char, &apos;g&apos;);        let l = str.match(reg).length        if(l===1){            return char        }    }}</code></pre><p>复制</p><p>当然，使用<code>indexOf/lastIndexOf</code>也是一个取巧的方式。再来看一个千分位问题。</p><blockquote><p>题目：将<code>1234567</code> 变成 <code>1,234,567</code>，即千分位标注</p></blockquote><p>这个题目可以用算法直接来解，如果候选人使用正则来回答，这样主动展现了自己其他方面的优势，即使不是算法解答出来的，面试官一般也不会太难为他。这道题目可以利用正则的「零宽断言」<code>(?=exp)</code>，意思是它断言自身出现的位置的后面能匹配表达式 exp。数字千分位的特点是，第一个逗号后面数字的个数是3的倍数，正则：<code>/(\d{3})+$/</code>；第一个逗号前最多可以有 1~3 个数字，正则：<code>/\d{1,3}/</code>。加起来就是<code>/\d{1,3}(\d{3})+$/</code>，分隔符要从前往后加。</p><p>对于零宽断言的详细介绍可以阅读「<a href="https://link.juejin.im?target=https%3A%2F%2Fdeerchao.net%2Ftutorials%2Fregex%2Fregex.htm%23lookaround" target="_blank" rel="noopener">零宽断言</a>」这篇文章。</p><pre><code>function exchange(num) {    num += &apos;&apos;; //转成字符串    if (num.length &lt;= 3) {        return num;    }    num = num.replace(/\d{1,3}(?=(\d{3})+$)/g, (v) =&gt; {        console.log(v)        return v + &apos;,&apos;;    });    return num;}console.log(exchange(1234567));</code></pre><p>复制</p><p>当然上面讲到的多数是算法题目取巧的方式，下面这个题目是纯正则考查，笔者在面试的过程中碰见过，这里顺便提一下。</p><blockquote><p>题目，请写出下面的代码执行结果</p></blockquote><pre><code>var str = &apos;google&apos;;var reg = /o/g;console.log(reg.test(str))console.log(reg.test(str))console.log(reg.test(str))</code></pre><p>复制</p><p>代码执行后，会发现，最后一个不是为<code>true</code>，而是<code>false</code>，这是因为<code>reg</code>这个正则有个<code>g</code>，即<code>global</code>全局的属性，这种情况下<code>lastIndex</code>就发挥作用了，可以看下面的代码执行结果就明白了。</p><pre><code>console.log(reg.test(str), reg.lastIndex)console.log(reg.test(str), reg.lastIndex)console.log(reg.test(str), reg.lastIndex)</code></pre><p>复制</p><p>实际开发中也会犯这样的错误，比如为了减少变量每次都重新定义，会把用到的变量提前定义好，这样在使用的时候容易掉进坑里，比如下面代码：</p><pre><code>(function(){    const reg = /o/g;    function isHasO(str){        // reg.lastIndex = 0; 这样就可以避免这种情况        return reg.test(str)    }    var str = &apos;google&apos;;    console.log(isHasO(str))    console.log(isHasO(str))    console.log(isHasO(str))}())</code></pre><p>复制</p><h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>本小节介绍了数据结构和算法的关系，作为普通的前端也应该学习数据结构和算法知识，并且顺带介绍了下正则匹配。具体来说，本小节梳理了以下几部分数据结构和算法知识点：</p><ol><li>经常用到的数据结构有哪些，它们的特点有哪些</li><li>递归和枚举是最基础的算法，必须牢牢掌握</li><li>排序里面理解并掌握快速排序算法，其他排序算法可以根据个人实际情况大概了解</li><li>有序查找用二分查找</li><li>遇见不会的算法问题，先缩小数量级，然后分析推导</li></ol><p>当然算法部分还有很多知识，比如动态规划这些算法思想，还有图和树常用到的广度优先搜索和深度优先搜索。这些知识在前端面试和项目中遇见得不多，感兴趣的读者可以在梳理知识点的时候根据个人情况自行决定是否复习。</p><p>上一篇：<a href="541673">一面 3：CSS-HTML 知识点与高频考题解析</a>下一篇：<a href="541675">一面 5：浏览器相关知识点与高频考题解析</a></p><h1 id="一面-5：浏览器相关知识点与高频考题解析"><a href="#一面-5：浏览器相关知识点与高频考题解析" class="headerlink" title="一面 5：浏览器相关知识点与高频考题解析"></a><strong>一面 5：浏览器相关知识点与高频考题解析</strong></h1><p>Web 前端工程师写的页面要跑在浏览器里面，所以面试中也会出现很多跟浏览器相关的面试题目。</p><h2 id="知识点梳理-4"><a href="#知识点梳理-4" class="headerlink" title="知识点梳理****"></a><strong>知识点梳理</strong>****</h2><ul><li>浏览器加载页面和渲染过程</li><li>性能优化</li><li>Web 安全</li></ul><p>本小节会从浏览器的加载过程开始讲解，然后介绍如何进行性能优化，最后介绍下 Web 开发中常见的安全问题和预防。</p><hr><h2 id="加载页面和渲染过程"><a href="#加载页面和渲染过程" class="headerlink" title="加载页面和渲染过程"></a><strong>加载页面和渲染过程</strong></h2><p>可将加载过程和渲染过程分开说。回答问题的时候，关键要抓住核心的要点，把要点说全面，稍加解析即可，简明扼要不拖沓。</p><blockquote><p>题目：浏览器从加载页面到渲染页面的过程</p></blockquote><h3 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a><strong>加载过程</strong></h3><p>要点如下：</p><ul><li>浏览器根据 DNS 服务器得到域名的 IP 地址</li><li>向这个 IP 的机器发送 HTTP 请求</li><li>服务器收到、处理并返回 HTTP 请求</li><li>浏览器得到返回内容</li></ul><p>例如在浏览器输入<code>https://juejin.im/timeline</code>，然后经过 DNS 解析，<code>juejin.im</code>对应的 IP 是<code>36.248.217.149</code>（不同时间、地点对应的 IP 可能会不同）。然后浏览器向该 IP 发送 HTTP 请求。</p><p>server 端接收到 HTTP 请求，然后经过计算（向不同的用户推送不同的内容），返回 HTTP 请求，返回的内容如下：</p><p>![](data:image/svg+xml;utf8,)</p><p>其实就是一堆 HMTL 格式的字符串，因为只有 HTML 格式浏览器才能正确解析，这是 W3C 标准的要求。接下来就是浏览器的渲染过程。</p><h3 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a><strong>渲染过程</strong></h3><p>要点如下：</p><ul><li>根据 HTML 结构生成 DOM 树</li><li>根据 CSS 生成 CSSOM</li><li>将 DOM 和 CSSOM 整合形成 RenderTree</li><li>根据 RenderTree 开始渲染和展示</li><li>遇到<code>&lt;script&gt;</code>时，会执行并阻塞渲染</li></ul><p>上文中，浏览器已经拿到了 server 端返回的 HTML 内容，开始解析并渲染。最初拿到的内容就是一堆字符串，必须先结构化成计算机擅长处理的基本数据结构，因此要把 HTML 字符串转化成 DOM 树 —— 树是最基本的数据结构之一。</p><p>解析过程中，如果遇到<code>&lt;link href=&quot;...&quot;&gt;</code>和<code>&lt;script src=&quot;...&quot;&gt;</code>这种外链加载 CSS 和 JS 的标签，浏览器会异步下载，下载过程和上文中下载 HTML 的流程一样。只不过，这里下载下来的字符串是 CSS 或者 JS 格式的。</p><p>浏览器将 CSS 生成 CSSOM，再将 DOM 和 CSSOM 整合成 RenderTree ，然后针对 RenderTree 即可进行渲染了。大家可以想一下，有 DOM 结构、有样式，此时就能满足渲染的条件了。另外，这里也可以解释一个问题 —— <strong>为何要将 CSS 放在 HTML 头部？</strong>—— 这样会让浏览器尽早拿到 CSS 尽早生成 CSSOM，然后在解析 HTML 之后可一次性生成最终的 RenderTree，渲染一次即可。如果 CSS 放在 HTML 底部，会出现渲染卡顿的情况，影响性能和体验。</p><p>最后，渲染过程中，如果遇到<code>&lt;script&gt;</code>就停止渲染，执行 JS 代码。因为浏览器渲染和 JS 执行共用一个线程，而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。待<code>&lt;script&gt;</code>内容执行完之后，浏览器继续渲染。最后再思考一个问题 —— <strong>为何要将 JS 放在 HTML 底部？</strong>—— JS 放在底部可以保证让浏览器优先渲染完现有的 HTML 内容，让用户先看到内容，体验好。另外，JS 执行如果涉及 DOM 操作，得等待 DOM 解析完成才行，JS 放在底部执行时，HTML 肯定都解析成了 DOM 结构。JS 如果放在 HTML 顶部，JS 执行的时候 HTML 还没来得及转换为 DOM 结构，可能会报错。</p><p>关于浏览器整个流程，百度的多益大神有更加详细的文章，推荐阅读下：《<a href="https://link.juejin.im?target=http%3A%2F%2Ffex.baidu.com%2Fblog%2F2014%2F05%2Fwhat-happen%2F" target="_blank" rel="noopener">从输入 URL 到页面加载完成的过程中都发生了什么事情？</a> 》。</p><hr><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a><strong>性能优化</strong></h2><p>性能优化的题目也是面试常考的，这类题目有很大的扩展性，能够扩展出来很多小细节，而且对个人的技术视野和业务能力有很大的挑战。这部分笔者会重点讲下常用的性能优化方案。</p><blockquote><p>题目：总结前端性能优化的解决方案</p></blockquote><h3 id="优化原则和方向"><a href="#优化原则和方向" class="headerlink" title="优化原则和方向"></a><strong>优化原则和方向</strong></h3><p>性能优化的原则是<strong>以更好的用户体验为标准</strong>，具体就是实现下面的目标：</p><ol><li>多使用内存、缓存或者其他方法</li><li>减少 CPU 和GPU 计算，更快展现</li></ol><p>优化的方向有两个：</p><ul><li><strong>减少页面体积，提升网络加载</strong></li><li><strong>优化页面渲染</strong></li></ul><h3 id="减少页面体积，提升网络加载"><a href="#减少页面体积，提升网络加载" class="headerlink" title="减少页面体积，提升网络加载"></a><strong>减少页面体积，提升网络加载</strong></h3><ul><li>静态资源的压缩合并（JS 代码压缩合并、CSS 代码压缩合并、雪碧图）</li><li>静态资源缓存（资源名称加 MD5 戳）</li><li>使用 CDN 让资源加载更快</li></ul><h3 id="优化页面渲染"><a href="#优化页面渲染" class="headerlink" title="优化页面渲染"></a><strong>优化页面渲染</strong></h3><ul><li>CSS 放前面，JS 放后面</li><li>懒加载（图片懒加载、下拉加载更多）</li><li>减少DOM 查询，对 DOM 查询做缓存</li><li>减少DOM 操作，多个操作尽量合并在一起执行（<code>DocumentFragment</code>）</li><li>事件节流</li><li>尽早执行操作（<code>DOMContentLoaded</code>）</li><li>使用 SSR 后端渲染，数据直接输出到 HTML 中，减少浏览器使用 JS 模板渲染页面 HTML 的时间</li></ul><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a><strong>详细解释</strong></h3><h4 id="静态资源的压缩合并"><a href="#静态资源的压缩合并" class="headerlink" title="静态资源的压缩合并"></a><strong>静态资源的压缩合并</strong></h4><p>如果不合并，每个都会走一遍之前介绍的请求过程</p><pre><code>&lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;b.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;c.js&quot;&gt;&lt;/script&gt;</code></pre><p>复制</p><p>如果合并了，就只走一遍请求过程</p><pre><code>&lt;script src=&quot;abc.js&quot;&gt;&lt;/script&gt;</code></pre><p>复制</p><h4 id="静态资源缓存"><a href="#静态资源缓存" class="headerlink" title="静态资源缓存"></a><strong>静态资源缓存</strong></h4><p>通过链接名称控制缓存</p><pre><code>&lt;script src=&quot;abc_1.js&quot;&gt;&lt;/script&gt;</code></pre><p>复制</p><p>只有内容改变的时候，链接名称才会改变</p><pre><code>&lt;script src=&quot;abc_2.js&quot;&gt;&lt;/script&gt;</code></pre><p>复制</p><p>这个名称不用手动改，可通过前端构建工具根据文件内容，为文件名称添加 MD5 后缀。</p><h4 id="使用-CDN-让资源加载更快"><a href="#使用-CDN-让资源加载更快" class="headerlink" title="使用 CDN 让资源加载更快"></a><strong>使用 CDN 让资源加载更快</strong></h4><p>CDN 会提供专业的加载优化方案，静态资源要尽量放在 CDN 上。例如：</p><pre><code>&lt;script src=&quot;https://cdn.bootcss.com/zepto/1.0rc1/zepto.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>复制</p><h4 id="使用-SSR-后端渲染"><a href="#使用-SSR-后端渲染" class="headerlink" title="使用 SSR 后端渲染"></a><strong>使用 SSR 后端渲染</strong></h4><p>可一次性输出 HTML 内容，不用在页面渲染完成之后，再通过 Ajax 加载数据、再渲染。例如使用 smarty、Vue SSR 等。</p><h4 id="CSS-放前面，JS-放后面"><a href="#CSS-放前面，JS-放后面" class="headerlink" title="CSS 放前面，JS 放后面"></a><strong>CSS 放前面，JS 放后面</strong></h4><p>上文讲述浏览器渲染过程时已经提过，不再赘述。</p><h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a><strong>懒加载</strong></h4><p>一开始先给为 <code>src</code> 赋值成一个通用的预览图，下拉时候再动态赋值成正式的图片。如下，<code>preview.png</code>是预览图片，比较小，加载很快，而且很多图片都共用这个<code>preview.png</code>，加载一次即可。待页面下拉，图片显示出来时，再去替换<code>src</code>为<code>data-realsrc</code>的值。</p><pre><code>&lt;img src=&quot;preview.png&quot; data-realsrc=&quot;abc.png&quot;/&gt;</code></pre><p>复制</p><p>另外，这里为何要用<code>data-</code>开头的属性值？—— 所有 HTML 中自定义的属性，都应该用<code>data-</code>开头，因为<code>data-</code>开头的属性浏览器渲染的时候会忽略掉，提高渲染性能。</p><h4 id="DOM-查询做缓存"><a href="#DOM-查询做缓存" class="headerlink" title="DOM 查询做缓存"></a><strong>DOM 查询做缓存</strong></h4><p>两段代码做一下对比：</p><pre><code>var pList = document.getElementsByTagName(&apos;p&apos;)  // 只查询一个 DOM ，缓存在 pList 中了var ifor (i = 0; i &lt; pList.length; i++) {}</code></pre><p>复制</p><pre><code>var ifor (i = 0; i &lt; document.getElementsByTagName(&apos;p&apos;).length; i++) {  // 每次循环，都会查询 DOM ，耗费性能}</code></pre><p>复制</p><p>总结：DOM 操作，无论查询还是修改，都是非常耗费性能的，应尽量减少。</p><h4 id="合并-DOM-插入"><a href="#合并-DOM-插入" class="headerlink" title="合并 DOM 插入"></a><strong>合并 DOM 插入</strong></h4><p>DOM 操作是非常耗费性能的，因此插入多个标签时，先插入 Fragment 然后再统一插入 DOM。</p><pre><code>var listNode = document.getElementById(&apos;list&apos;)// 要插入 10 个 li 标签var frag = document.createDocumentFragment();var x, li;for(x = 0; x &lt; 10; x++) {    li = document.createElement(&quot;li&quot;);    li.innerHTML = &quot;List item &quot; + x;    frag.appendChild(li);  // 先放在 frag 中，最后一次性插入到 DOM 结构中。}listNode.appendChild(frag);</code></pre><p>复制</p><h4 id="事件节流"><a href="#事件节流" class="headerlink" title="事件节流"></a><strong>事件节流</strong></h4><p>例如要在文字改变时触发一个 change 事件，通过 keyup 来监听。使用节流。</p><pre><code>var textarea = document.getElementById(&apos;text&apos;)var timeoutIdtextarea.addEventListener(&apos;keyup&apos;, function () {    if (timeoutId) {        clearTimeout(timeoutId)    }    timeoutId = setTimeout(function () {        // 触发 change 事件    }, 100)})</code></pre><p>复制</p><h4 id="尽早执行操作"><a href="#尽早执行操作" class="headerlink" title="尽早执行操作"></a><strong>尽早执行操作</strong></h4><pre><code>window.addEventListener(&apos;load&apos;, function () {    // 页面的全部资源加载完才会执行，包括图片、视频等})document.addEventListener(&apos;DOMContentLoaded&apos;, function () {    // DOM 渲染完即可执行，此时图片、视频还可能没有加载完})</code></pre><p>复制</p><h4 id="性能优化怎么做"><a href="#性能优化怎么做" class="headerlink" title="性能优化怎么做"></a><strong>性能优化怎么做</strong></h4><p>上面提到的都是性能优化的单个点，性能优化项目具体实施起来，应该按照下面步骤推进：</p><ol><li>建立性能数据收集平台，摸底当前性能数据，通过性能打点，将上述整个页面打开过程消耗时间记录下来</li><li>分析耗时较长时间段原因，寻找优化点，确定优化目标</li><li>开始优化</li><li>通过数据手机平台记录优化效果</li><li>不断调整优化点和预期目标，循环2~4步骤</li></ol><p>性能优化是个长期的事情，不是一蹴而就的，应该本着先摸底、再分析、后优化的原则逐步来做。</p><hr><h2 id="Web-安全"><a href="#Web-安全" class="headerlink" title="Web 安全"></a><strong>Web 安全</strong></h2><blockquote><p>题目：前端常见的安全问题有哪些？</p></blockquote><p>Web 前端的安全问题，能回答出下文的两个问题，这个题目就能基本过关了。开始之前，先说一个最简单的攻击方式 —— SQL 注入。</p><p>上学的时候就知道有一个「SQL注入」的攻击方式。例如做一个系统的登录界面，输入用户名和密码，提交之后，后端直接拿到数据就拼接 SQL 语句去查询数据库。如果在输入时进行了恶意的 SQL 拼装，那么最后生成的 SQL 就会有问题。但是现在稍微大型一点的系统，都不会这么做，从提交登录信息到最后拿到授权，要经过层层的验证。因此，SQL 注入都只出现在比较低端小型的系统上。</p><h3 id="XSS（Cross-Site-Scripting，跨站脚本攻击）"><a href="#XSS（Cross-Site-Scripting，跨站脚本攻击）" class="headerlink" title="XSS（Cross Site Scripting，跨站脚本攻击）"></a><strong>XSS（Cross Site Scripting，跨站脚本攻击）</strong></h3><p>这是前端最常见的攻击方式，很多大型网站（如 Facebook）都被 XSS 攻击过。</p><p>举一个例子，我在一个博客网站正常发表一篇文章，输入汉字、英文和图片，完全没有问题。但是如果我写的是恶意的 JS 脚本，例如获取到<code>document.cookie</code>然后传输到自己的服务器上，那我这篇博客的每一次浏览都会执行这个脚本，都会把访客 cookie 中的信息偷偷传递到我的服务器上来。</p><p>其实原理上就是黑客通过某种方式（发布文章、发布评论等）将一段特定的 JS 代码隐蔽地输入进去。然后别人再看这篇文章或者评论时，之前注入的这段 JS 代码就执行了。<strong>JS 代码一旦执行，那可就不受控制了，因为它跟网页原有的 JS 有同样的权限</strong>，例如可以获取 server 端数据、可以获取 cookie 等。于是，攻击就这样发生了。</p><h4 id="XSS的危害"><a href="#XSS的危害" class="headerlink" title="XSS的危害"></a><strong>XSS的危害</strong></h4><p>XSS 的危害相当大，如果页面可以随意执行别人不安全的 JS 代码，轻则会让页面错乱、功能缺失，重则会造成用户的信息泄露。</p><p>比如早些年社交网站经常爆出 XSS 蠕虫，通过发布的文章内插入 JS，用户访问了感染不安全 JS 注入的文章，会自动重新发布新的文章，这样的文章会通过推荐系统进入到每个用户的文章列表面前，很快就会造成大规模的感染。</p><p>还有利用获取 cookie 的方式，将 cookie 传入入侵者的服务器上，入侵者就可以模拟 cookie 登录网站，对用户的信息进行篡改。</p><h4 id="XSS的预防"><a href="#XSS的预防" class="headerlink" title="XSS的预防"></a><strong>XSS的预防</strong></h4><p>那么如何预防 XSS 攻击呢？—— 最根本的方式，就是对用户输入的内容进行验证和替换，需要替换的字符有：</p><pre><code>&amp; 替换为：&amp;amp;&lt; 替换为：&amp;lt;&gt; 替换为：&amp;gt;” 替换为：&amp;quot;‘ 替换为：&amp;#x27;/ 替换为：&amp;#x2f;</code></pre><p>复制</p><p>替换了这些字符之后，黑客输入的攻击代码就会失效，XSS 攻击将不会轻易发生。</p><p>除此之外，还可以通过对 cookie 进行较强的控制，比如对敏感的 cookie 增加<code>http-only</code>限制，让 JS 获取不到 cookie 的内容。</p><h3 id="CSRF（Cross-site-request-forgery，跨站请求伪造）"><a href="#CSRF（Cross-site-request-forgery，跨站请求伪造）" class="headerlink" title="CSRF（Cross-site request forgery，跨站请求伪造）"></a><strong>CSRF（Cross-site request forgery，跨站请求伪造）</strong></h3><p>CSRF 是借用了当前操作者的权限来偷偷地完成某个操作，而不是拿到用户的信息。</p><p>例如，一个支付类网站，给他人转账的接口是<code>http://buy.com/pay?touid=999&amp;money=100</code>，而这个接口在使用时没有任何密码或者 token 的验证，只要打开访问就直接给他人转账。一个用户已经登录了<code>http://buy.com</code>，在选择商品时，突然收到一封邮件，而这封邮件正文有这么一行代码<code>&lt;img src=&quot;http://buy.com/pay?touid=999&amp;money=100&quot;/&gt;</code>，他访问了邮件之后，其实就已经完成了购买。</p><p>CSRF 的发生其实是借助了一个 cookie 的特性。我们知道，登录了<code>http://buy.com</code>之后，cookie 就会有登录过的标记了，此时请求<code>http://buy.com/pay?touid=999&amp;money=100</code>是会带着 cookie 的，因此 server 端就知道已经登录了。而如果在<code>http://buy.com</code>去请求其他域名的 API 例如<code>http://abc.com/api</code>时，是不会带 cookie 的，这是浏览器的同源策略的限制。但是 —— <strong>此时在其他域名的页面中，请求<code>http://buy.com/pay?touid=999&amp;money=100</code>，会带着<code>buy.com</code>的 cookie ，这是发生 CSRF 攻击的理论基础。</strong></p><p>预防 CSRF 就是加入各个层级的权限验证，例如现在的购物网站，只要涉及现金交易，肯定要输入密码或者指纹才行。除此之外，敏感的接口使用<code>POST</code>请求而不是<code>GET</code>也是很重要的。</p><hr><h2 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>本小节总结了前端运行环境（即浏览器）的一些常考查知识点，包括页面加载过程、如何性能优化以及需要注意的安全问题。</p><p>上一篇：<a href="541674">一面 4：从容应对算法题目</a>下一篇：<a href="541676">一面 6：开发环境相关知识点与高频考题解析</a></p><h1 id="一面-6：开发环境相关知识点与高频考题解析"><a href="#一面-6：开发环境相关知识点与高频考题解析" class="headerlink" title="一面 6：开发环境相关知识点与高频考题解析"></a><strong>一面 6：开发环境相关知识点与高频考题解析</strong></h1><p>工程师的开发环境决定其开发效率，常用的开发环境配置也是面试考查点之一。</p><h2 id="知识点梳理-5"><a href="#知识点梳理-5" class="headerlink" title="知识点梳理"></a><strong>知识点梳理</strong></h2><ul><li>IDE</li><li>Git</li><li>Linux 基础命令</li><li>前端构建工具</li><li>调试方法</li></ul><p>本小节会重点介绍 Git 的基本用法、代码部署和开发中常用的 Linux 命令，然后以 webpack 为例介绍下前端构建工具，最后介绍怎么抓包解决线上问题。这些都是日常开发和面试中常用到的知识。</p><hr><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a><strong>IDE</strong></h2><blockquote><p>题目：你平时都使用什么 IDE 编程？有何提高效率的方法？</p></blockquote><p>前端最常用的 IDE 有 <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.jetbrains.com%2Fwebstorm%2F" target="_blank" rel="noopener">Webstorm</a>、<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.sublimetext.com%2F" target="_blank" rel="noopener">Sublime</a>、<a href="https://link.juejin.im?target=https%3A%2F%2Fatom.io%2F" target="_blank" rel="noopener">Atom</a> 和 <a href="https://link.juejin.im?target=https%3A%2F%2Fcode.visualstudio.com%2F" target="_blank" rel="noopener">VSCode</a>，我们可以分别去它们的官网看一下。</p><p>Webstorm 是最强大的编辑器，因为它拥有各种强大的插件和功能，但是我没有用过，因为它收费。不是我舍不得花钱，而是因为我觉得免费的 Sublime 已经够我用了。跟面试官聊到 Webstorm 的时候，没用过没事儿，但一定要知道它：第一，强大；第二，收费。</p><p>Sublime 是我日常用的编辑器，第一它免费，第二它轻量、高效，第三它插件非常多。用 Sublime 一定要安装各种插件配合使用，可以去网上搜一下“sublime”常用插件的安装以及用法，还有它的各种快捷键，并且亲自使用它。这里就不一一演示了，网上的教程也很傻瓜式。</p><p>Atom 是 GitHub 出品的编辑器，跟 Sublime 差不多，免费并且插件丰富，而且跟 Sublime 相比风格上还有些小清新。但是我用过几次就不用了，因此它打开的时候会比较慢，卡一下才打开。当然总体来说也是很好用的，只是个人习惯问题。</p><p>VSCode 是微软出品的轻量级（相对于 Visual Studio 来说）编辑器，微软做 IDE 那是出了名的好，出了名的大而全，因此 VSCode 也有上述 Sublime 和 Atom 的各种优点，但是我也是因为个人习惯问题（本人不愿意尝试没有新意的新东西），用过几次就不用了。</p><p>总结一下：</p><ul><li>如果你要走大牛、大咖、逼格的路线，就用 Webstorm</li><li>如果你走普通、屌丝、低调路线，就用 Sublime</li><li>如果你走小清新、个性路线，就用 VSCode 或者 Atom</li><li>如果你面试，最好有一个用的熟悉，其他都会一点</li></ul><p>最后注意：千万不要说你使用 Dreamweaver 或者 notepad++ 写前端代码，会被人鄙视的。如果你不做 .NET 也不要用 Visual Studio ，不做 Java 也不要用 Eclipse。</p><hr><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a><strong>Git</strong></h2><p>你此前做过的项目一定要用过 Git，而且必须是命令行，如果没用过，你自己也得恶补一下。对 Git 的基本应用比较熟悉的同学，可以跳过这一部分了。macOS 自带 Git，Windows 需要安装 Git 客户端，去 <a href="https://link.juejin.im?target=https%3A%2F%2Fgit-scm.com%2Fdownload%2Fwin" target="_blank" rel="noopener">Git 官网</a> 下载即可。</p><p>国内比较好的 Git 服务商有 <a href="http://coding.net" target="_blank" rel="noopener">coding.net</a>，国外有大名鼎鼎的 GitHub，但是有时会有网络问题，因此建议大家注册一个 <a href="http://coding.net" target="_blank" rel="noopener">coding.net</a> 账号然后创建项目，来练练手。</p><blockquote><p>题目：常用的 Git 命令有哪些？如何使用 Git 多人协作开发？</p></blockquote><h3 id="常用的-Git-命令"><a href="#常用的-Git-命令" class="headerlink" title="常用的 Git 命令"></a><strong>常用的 Git 命令</strong></h3><p>首先，通过<code>git clone &lt;项目远程地址&gt;</code>下载下来最新的代码，例如<code>git clone git@git.coding.net:username/project-name.git</code>，默认会下载<code>master</code>分支。</p><p>然后修改代码，修改过程中可以通过<code>git status</code>看到自己的修改情况，通过<code>git diff &lt;文件名&gt;</code>可查阅单个文件的差异。</p><p>最后，将修改的内容提交到远程服务器，做如下操作</p><pre><code>git add .git commit -m &quot;xxx&quot;git push origin master</code></pre><p>复制</p><p>如果别人也提交了代码，你想同步别人提交的内容，执行<code>git pull origin master</code>即可。</p><h3 id="如何多人协作开发"><a href="#如何多人协作开发" class="headerlink" title="如何多人协作开发"></a><strong>如何多人协作开发</strong></h3><p>多人协作开发，就不能使用<code>master</code>分支了，而是要每个开发者单独拉一个分支，使用<code>git checkout -b &lt;branchname&gt;</code>，运行<code>git branch</code>可以看到本地所有的分支名称。</p><p>自己的分支，如果想同步<code>master</code>分支的内容，可运行<code>git merge master</code>。切换分支可使用<code>git checkout &lt;branchname&gt;</code>。</p><p>在自己的分支上修改了内容，可以将自己的分支提交到远程服务器</p><pre><code>git add .git commit -m &quot;xxx&quot;git push origin &lt;branchname&gt;</code></pre><p>复制</p><p>最后，待代码测试没问题，再将自己分支的内容合并到<code>master</code>分支，然后提交到远程服务器。</p><pre><code>git checkout mastergit merge &lt;branchname&gt;git push origin master</code></pre><p>复制</p><h3 id="关于-SVN"><a href="#关于-SVN" class="headerlink" title="关于 SVN"></a><strong>关于 SVN</strong></h3><p>关于 SVN 笔者的态度和针对 IE 低版本浏览器的态度一样，你只需要查询资料简单了解一下。面试的时候可能会问到，但你只要熟悉了 Git 的操作，面试官不会因为你不熟悉 SVN 而难为你。前提是你要知道一点 SVN 的基本命令，自己上网一查就行。</p><p>不过 SVN 和 Git 的区别你得了解。SVN 是每一步操作都离不开服务器，创建分支、提交代码都需要连接服务器。而 Git 就不一样了，你可以在本地创建分支、提交代码，最后再一起 push 到服务器上。因此，Git 拥有 SVN 的所有功能，但是却比 SVN 强大得多。（Git 是 Linux 的创始人 Linus 发明的东西，因此也倍得推崇。）</p><hr><h2 id="Linux-基础命令"><a href="#Linux-基础命令" class="headerlink" title="Linux 基础命令"></a>Linux 基础命令</h2><p>目前互联网公司的线上服务器都使用 Linux 系统，测试环境为了保证和线上一致，肯定也是使用 Linux 系统，而且都是命令行的，没有桌面，不能用鼠标操作。因此，掌握基础的 Linux 命令是非常必要的。下面总结一些最常用的 Linux 命令，建议大家在真实的 Linux 系统下亲自试一下。</p><p>关于如何得到 Linux 系统，有两种选择：第一，在自己电脑的虚拟机中安装一个 Linux 系统，例如 Ubuntu/CentOS 等，下载这些都不用花钱；第二，花钱去阿里云等云服务商租一个最便宜的 Linux 虚拟机。推荐第二种。一般正式入职之后，公司都会给你分配开发机或者测试机，给你账号和密码，你自己可以远程登录。</p><blockquote><p>题目：常见 linux 命令有哪些？</p></blockquote><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a><strong>登录</strong></h3><p>入职之后，一般会有现有的用户名和密码给你，你拿来之后直接登录就行。运行 <code>ssh name@server</code> 然后输入密码即可登录。</p><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a><strong>目录操作</strong></h3><ul><li>创建目录 <code>mkdir &lt;目录名称&gt;</code></li><li>删除目录 <code>rm &lt;目录名称&gt;</code></li><li>定位目录 <code>cd &lt;目录名称&gt;</code></li><li>查看目录文件 <code>ls`</code>ll`</li><li>修改目录名 <code>mv &lt;目录名称&gt; &lt;新目录名称&gt;</code></li><li>拷贝目录 <code>cp &lt;目录名称&gt; &lt;新目录名称&gt;</code></li></ul><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a><strong>文件操作</strong></h3><ul><li>创建文件 <code>touch &lt;文件名称&gt;`</code>vi &lt;文件名称&gt;`</li><li>删除文件 <code>rm &lt;文件名称&gt;</code></li><li>修改文件名 <code>mv &lt;文件名称&gt; &lt;新文件名称&gt;</code></li><li>拷贝文件 <code>cp &lt;文件名称&gt; &lt;新文件名称&gt;</code></li></ul><h3 id="文件内容操作"><a href="#文件内容操作" class="headerlink" title="文件内容操作"></a><strong>文件内容操作</strong></h3><ul><li>查看文件 <code>cat &lt;文件名称&gt;`</code>head &lt;文件名称&gt;<code></code>tail &lt;文件名称&gt;`</li><li>编辑文件内容 <code>vi &lt;文件名称&gt;</code></li><li>查找文件内容 <code>grep &#39;关键字&#39; &lt;文件名称&gt;</code></li></ul><hr><h2 id="前端构建工具"><a href="#前端构建工具" class="headerlink" title="前端构建工具"></a><strong>前端构建工具</strong></h2><p>构建工具是前端工程化中不可缺少的一环，非常重要，而在面试中却有其特殊性 —— <strong>面试官会通过询问构建工具的作用、目的来询问你对构建工具的了解，只要这些你都知道，不会再追问细节</strong>。因为，在实际工作中，真正能让你编写构建工具配置文件的机会非常少，一个项目就配置一次，后面就很少改动了。而且，如果是大众使用的框架（如 React、Vue 等），还会直接有现成的脚手架工具，一键创建开发环境，不用手动配置。</p><blockquote><p>题目：前端为何要使用构建工具？它解决了什么问题？</p></blockquote><h3 id="何为构建工具"><a href="#何为构建工具" class="headerlink" title="何为构建工具"></a><strong>何为构建工具</strong></h3><p>“构建”也可理解为“编译”，就是将开发环境的代码转换成运行环境代码的过程。<strong>开发环境的代码是为了更好地阅读，而运行环境的代码是为了更快地执行，两者目的不一样，因此代码形式也不一样</strong>。例如，开发环境写的 JS 代码，要通过混淆压缩之后才能放在线上运行，因为这样代码体积更小，而且对代码执行不会有任何影响。总结一下需要构建工具处理的几种情况：</p><ul><li><strong>处理模块化</strong>：CSS 和 JS 的模块化语法，目前都无法被浏览器兼容。因此，开发环境可以使用既定的模块化语法，但是需要构建工具将模块化语法编译为浏览器可识别形式。例如，使用 webpack、Rollup 等处理 JS 模块化。</li><li><strong>编译语法</strong>：编写 CSS 时使用 Less、Sass，编写 JS 时使用 ES6、TypeScript 等。这些标准目前也都无法被浏览器兼容，因此需要构建工具编译，例如使用 Babel 编译 ES6 语法。</li><li><strong>代码压缩</strong>：将 CSS、JS 代码混淆压缩，为了让代码体积更小，加载更快。</li></ul><h3 id="构建工具介绍"><a href="#构建工具介绍" class="headerlink" title="构建工具介绍"></a><strong>构建工具介绍</strong></h3><p>最早普及使用的构建工具是 <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.gruntjs.net%2F" target="_blank" rel="noopener">Grunt</a> ，不久又被 <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.gulpjs.com.cn%2F" target="_blank" rel="noopener">Gulp</a> 给追赶上。Gulp 因其简单的配置以及高效的性能而被大家所接受，也是笔者个人比较推荐的构建工具之一。如果你做一些简单的 JS 开发，可以考虑使用。</p><p>如果你的项目比较复杂，而且是多人开发，那么你就需要掌握目前构建工具届的神器 —— webpack 。不过神器也有一个缺点，就是学习成本比较高，需要拿出专门的时间来专心学习，而不是三言两语就能讲完的。我们下面就演示一下 webpack 最简单的使用，全面的学习还得靠大家去认真查阅相关文档，或者参考专门讲解 webpack 的教程。</p><h3 id="webpack-演示"><a href="#webpack-演示" class="headerlink" title="webpack 演示"></a><strong>webpack 演示</strong></h3><p>接下来我们演示一下 webpack 处理模块化和混淆压缩代码这两个基本功能。</p><p>首先，你需要安装 Node.js，没有安装的可以去 <a href="https://link.juejin.im?target=http%3A%2F%2Fnodejs.cn%2Fdownload%2F" target="_blank" rel="noopener">Node.js 官网</a> 下载并安装。安装完成后运行如下命令来验证是否安装成功。</p><pre><code>node -vnpm -v</code></pre><p>复制</p><p>然后，新建一个目录，进入该目录，运行<code>npm init</code>，按照提示输入名称、版本、描述等信息。完成之后，该目录下出现了一个<code>package.json</code>文件，是一个 JSON 文件。</p><p>接下来，安装 wepback，运行<code>npm i --save-dev webpack</code>，网络原因需要耐心等待几分钟。</p><p>接下来，编写源代码，在该目录下创建<code>src</code>文件夹，并在其中创建<code>app.js</code>和<code>dt.js</code>两个文件，文件内容分别是：</p><pre><code>// dt.js 内容module.exports = {    getDateNow: function () {        return Date.now()    }}// app.js 内容var dt = require(&apos;./dt.js&apos;)alert(dt.getDateNow())</code></pre><p>复制</p><p>然后，再返回上一层目录，新建<code>index.html</code>文件（该文件和<code>src</code>属于同一层级），内容是</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;test&lt;/div&gt;    &lt;script src=&apos;./dist/bundle.js&apos;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>复制</p><p>然后，编写 webpack 配置文件，新建<code>webpack.config.js</code>，内容是</p><pre><code>const path = require(&apos;path&apos;);const webpack = require(&apos;webpack&apos;);module.exports = {  context: path.resolve(__dirname, &apos;./src&apos;),  entry: {    app: &apos;./app.js&apos;,  },  output: {    path: path.resolve(__dirname, &apos;./dist&apos;),    filename: &apos;bundle.js&apos;,  },  plugins: [    new webpack.optimize.UglifyJsPlugin({        compress: {          //supresses warnings, usually from module minification          warnings: false        }    }),  ]};</code></pre><p>复制</p><p>总结一下，目前项目的文件目录是：</p><pre><code>src  +-- app.js  +-- dt.jsindex.htmlpackage.jsonwebpack.config.js</code></pre><p>复制</p><p>接下来，打开<code>package.json</code>，然后修改其中<code>scripts</code>的内容为：</p><pre><code>&quot;scripts&quot;: {  &quot;start&quot;: &quot;webpack&quot;}</code></pre><p>复制</p><p>在命令行中运行<code>npm start</code>，即可看到编译的结果，最后在浏览器中打开<code>index.html</code>，即可弹出<code>Date.now()</code>的值。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>最后再次强调，<strong>深刻理解构建工具存在的价值，比你多会一些配置代码更加有意义，特别是对于应对面试来说</strong>。</p><hr><h2 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a><strong>调试方法</strong></h2><p>调试方法这块被考查最多的就是如何进行抓包。</p><blockquote><p>题目：如何抓取数据？如何使用工具来配置代理？</p></blockquote><p>PC 端的网页，我们可以通过 Chrome、Firefox 等浏览器自带的开发者工具来查看网页的所有网络请求，以帮助排查 bug。这种监听、查看网络请求的操作称为<strong>抓包</strong>。</p><p>针对移动端的抓包工具，Mac 系统下推荐使用 Charles 这个工具，首先 <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.charlesproxy.com%2Fdownload%2F" target="_blank" rel="noopener">下载</a> 并安装，打开。Windows 系统推荐使用 <a href="https://link.juejin.im?target=http%3A%2F%2Frj.baidu.com%2Fsoft%2Fdetail%2F10963.html" target="_blank" rel="noopener">Fiddler</a>，下载安装打开。两者使用基本一致，下面以 Charles 为例介绍。</p><p>接下来，将安装好 Charles 的电脑和要抓包的手机，连接到同一个网络（一般为公司统一提供的内网，由专业网络工程师搭建），保证 IP 段相同。然后，将手机设置网络代理（每种不同手机如何设置网络代理，网上都有傻瓜式教程），代理的 IP 为电脑的 IP，代理的端口为<code>8888</code>。然后，Charles 可能会有一个弹框提示是否允许连接代理，这里选择“允许”即可。这样，使用手机端访问的网页或者联网的请求，Charles 就能监听到了。</p><p>在开发过程中，经常用到抓包工具来做代理，将线上的地址代理到测试环境，Charles 和 Fiddler 都可实现这个功能。以 Charles 为例，点击菜单栏中 Tools 菜单，然后二级菜单中点击 Map Remote，会弹出配置框。首先，选中 Enable Map Remote 复选框，然后点击 Add 按钮，添加一个代理项。例如，如果要将线上的<code>https://www.aaa.com/api/getuser?name=xxx</code>这个地址代理到测试地址<code>http://168.1.1.100:8080/api/getuser?name=xxx</code>，配置如下图</p><p>![](data:image/svg+xml;utf8,)</p><hr><h2 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>本小节总结了前端开发环境常考查的知识，这些知识也是前端程序员必须掌握的，否则会影响开发效率。</p><p>上一篇：<a href="541675">一面 5：浏览器相关知识点与高频考题解析</a>下一篇：<a href="541677">二面 1：如何回答常见的软技能问题</a></p><h1 id="二面-1：如何回答常见的软技能问题"><a href="#二面-1：如何回答常见的软技能问题" class="headerlink" title="二面 1：如何回答常见的软技能问题"></a><strong>二面 1：如何回答常见的软技能问题</strong></h1><p>面试是个技术活，不仅仅是技术，各种软技能的面试技巧也是非常重要的，尤其是程序员一般对于自己的软技能不是很看重，其实<strong>软技能才是决定你职场能够走多远的关键</strong>。</p><h2 id="程序员应该具备的软技能"><a href="#程序员应该具备的软技能" class="headerlink" title="程序员应该具备的软技能"></a><strong>程序员应该具备的软技能</strong></h2><p>程序员除了业务技能外，应该具有下面的软技能：</p><ol><li>韧性：抗压能力，在一定项目压力下能够迎难而上，比如勇于主动承担和解决技术难题</li><li>责任心：对于自己做过的项目，能够出现 bug 之类主动解决</li><li>持续学习能力：IT 行业是个需要不断充电的行业，尤其 Web 前端这些年一直在巨变，所以持续学习能力很重要</li><li>团队合作能力：做项目不能个人英雄主义，应该融入团队，跟团队一起打仗</li><li>交流沟通能力：经常会遇见沟通需求和交互设计的工作，应该乐于沟通分享</li></ol><p>另外在《软技能：代码之外的生存指南》这本书里提到了下面一些软技能：</p><ol><li>职业</li><li>自我营销</li><li>学习能力</li><li>提升工作效率</li><li>理财</li><li>健身</li><li>积极的人生观</li></ol><h2 id="常见的软技能问题和提升"><a href="#常见的软技能问题和提升" class="headerlink" title="常见的软技能问题和提升"></a><strong>常见的软技能问题和提升</strong></h2><p>回答软技能类的问题，应该注意在回答过程中体现自己具备的软技能。下面列举几个常见的软技能类的问题。</p><h3 id="回想下你遇见过最难打交道的同事，你是如何跟他沟通的"><a href="#回想下你遇见过最难打交道的同事，你是如何跟他沟通的" class="headerlink" title="回想下你遇见过最难打交道的同事，你是如何跟他沟通的"></a><strong>回想下你遇见过最难打交道的同事，你是如何跟他沟通的</strong></h3><p>一般来说，工作中总会遇见一两个自己不喜欢的人，这种情况应该尽量避免冲突，从自己做起慢慢让对方感觉到自己的合作精神。</p><p>所以，遇见难打交道的同事，不要急于上报领导，应该自己主动多做一些事情，比如规划好工作安排，让他选择自己做的事情，有了结论记得发邮件确认下来，这样你们的领导和其他成员都会了解到工作的安排，在鞭笞对方的同时，也做到了职责明确。在项目当中，多主动检查项目进展，提前发现逾期的问题。</p><p>重点是突出：自己主动沟通解决问题的意识，而不是遇见问题就找领导。</p><h3 id="当你被分配一个几乎不可能完成的任务时，你会怎么做"><a href="#当你被分配一个几乎不可能完成的任务时，你会怎么做" class="headerlink" title="当你被分配一个几乎不可能完成的任务时，你会怎么做"></a><strong>当你被分配一个几乎不可能完成的任务时，你会怎么做</strong></h3><p>这种情况下，一般通过下面方式来解决：</p><ol><li>自己先查找资料，寻找解决方案，评估自己需要怎样的资源来完成，需要多长时间</li><li>能不能借助周围同事来解决问题</li><li>拿着分析结果跟上级反馈，寻求帮助或者资源</li></ol><p>突出的软技能：分析和解决问题，沟通寻求帮助。</p><h3 id="业余时间都做什么？除了写码之外还有什么爱好"><a href="#业余时间都做什么？除了写码之外还有什么爱好" class="headerlink" title="业余时间都做什么？除了写码之外还有什么爱好"></a><strong>业余时间都做什么？除了写码之外还有什么爱好</strong></h3><p>这类问题也是面试官的高频问题，「一个人的业余时间决定了他的未来」，如果回答周末都在追剧打游戏之类的，未免显得太不上进。</p><p>一般来说，推荐下面的回答：</p><blockquote><p>周末一般会有三种状态：</p><ol><li>和朋友一起去做做运动，也会聚会聊天，探讨下新技术之类的；</li><li>也会看一些书籍充充电，比如我最近看的 xx，有什么的想法；</li><li>有时候会闷在家用最近比较火的技术做个小项目或者实现个小功能之类的。</li></ol></blockquote><p>这样的回答，既能表现自己阳光善于社交沟通的一面，又能表现自己的上进心。</p><h2 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>本小节介绍了程序员除了业务技术能力之外应该日常修炼的软技能，在面试中，软技能会被以各种形式问起，候选人应该先了解有哪些软技能可以修炼，才能在回答软技能问题的时候，尽量提到自己具备的软技能。</p><p>上一篇：<a href="541676">一面 6：开发环境相关知识点与高频考题解析</a>下一篇：<a href="541678">二面 2：如何介绍项目及应对项目细节追问</a></p><h1 id="二面-2：如何介绍项目及应对项目细节追问"><a href="#二面-2：如何介绍项目及应对项目细节追问" class="headerlink" title="二面 2：如何介绍项目及应对项目细节追问"></a><strong>二面 2：如何介绍项目及应对项目细节追问</strong></h1><p>一个标准的面试流程中，肯定会在一面二面中问到你具体做过的项目，然后追问项目的细节。这类问题往往会通过下面形式来提问：</p><ol><li>发现你简历的一个项目，直接让你介绍下这个项目</li><li>让你回忆下你做过的项目中，最值得分享（最大型/最困难/最能体现技术能力/最难忘）的</li><li>如果让你设计 xx 系统/项目，你会怎么着手干</li></ol><p>这类跟项目相关的综合性问题，既能体现候选人的技术水平、业务水平和架构能力，也能够辨别候选人是不是真的做过项目，还能够发现候选人的一些软技能。</p><p>下面分享下，遇见这类问题应该怎样回答。</p><h2 id="怎样介绍自己做过的一个项目"><a href="#怎样介绍自己做过的一个项目" class="headerlink" title="怎样介绍自己做过的一个项目"></a><strong>怎样介绍自己做过的一个项目</strong></h2><p>按照第 1 小节说的，简历当中的项目，你要精挑细选，既要体现技术难度，又要想好细节。具体要介绍一个项目（包括梳理一个项目），可以按照下面几个阶段来做。</p><p>###** 1. 介绍项目背景**</p><p>这个项目为什么做，当初大的环境背景是什么？还是为了解决一个什么问题而设立的项目？背景是很重要的，如果不了解背景，一上来就听一个结论性的项目，面试官可能对于项目的技术选型、技术难度会有理解偏差，甚至怀疑是否真的有过这样的项目。</p><blockquote><p>比如一上来就说：我们的项目采用了「backbone」来做框架，然后。。。而「backbone」已经是三四年前比较新鲜的技术，现在会有更好的选择方案，如果不介绍项目的时间背景，面试官肯定一脸懵逼。</p></blockquote><h3 id="2-承担角色"><a href="#2-承担角色" class="headerlink" title="2. 承担角色"></a><strong>2. 承担角色</strong></h3><p>项目涉及的人员角色有哪些，自己在其中扮演的角色是什么？</p><p>这里候选往往人会自己给自己挖坑，比如把自己在项目中起到的作用夸大等。一般来说，面试官细节追问的时候，如果候选人能够把细节或者技术方案等讲明白、讲清楚，不管他是真的做过还是跟别人做过，或者自己认真思考过，都能体现候选人的技术水平和技术视野。前提还是在你能够兜得住的可控范围之内做适当的「美化」。</p><h3 id="3-最终的结果和收益"><a href="#3-最终的结果和收益" class="headerlink" title="3. 最终的结果和收益"></a><strong>3. 最终的结果和收益</strong></h3><p>项目介绍过程中，应该介绍项目最终的结果和收益，比如项目最后经过多久的开发上线了，上线后的数据是怎样的，是否达到预期，还是带来了新的问题，遇见了问题自己后续又是怎样补救的。</p><h3 id="4-有始有终：项目总结和反思"><a href="#4-有始有终：项目总结和反思" class="headerlink" title="4. 有始有终：项目总结和反思"></a>4. 有始有终：项目总结和反思</h3><p>有总结和反思，才会有进步。 项目做完了往往会有一些心得和体会，这时候应该跟面试官说出来。在梳理项目的总结和反思时，可以按照下面的列表来梳理：</p><ul><li>收获有哪些？</li><li>是否有做得不足的地方，怎么改进？</li><li>是否具有可迁移性？</li></ul><p>比如，之前详细介绍了某个项目，这个项目当时看来没有什么问题，但是现在有更好的解决方案了，候选人就应该在这里提出来：现在看来，这个项目还有 xx 的问题，我可以通过 xx 的方式来解决。</p><p>再比如：做这个项目的时候，你做得比较出彩的地方，可以迁移到其他项目中直接使用，小到代码片段，大到解决方案，总会有你值得总结和梳理的地方。</p><p>介绍完项目总结这部分，也可以引导面试官往自己擅长的领域思考。比如上面提到项目中的问题，可以往你擅长的方面引导，即使面试官没有问到，你也介绍到了。</p><p>按照上面的四段体介绍项目，会让面试官感觉候选人有清晰的思路，对整个项目也有理解和想法，还能够总结反思项目的收益和问题，可谓「一箭三雕」。</p><h2 id="没有做过大型项目怎么办"><a href="#没有做过大型项目怎么办" class="headerlink" title="没有做过大型项目怎么办"></a><strong>没有做过大型项目怎么办</strong></h2><p>对于刚刚找工作的应届生，或者面试官让你进行一个大型项目的设计，候选人可能没有类似的经验。这时候不要用「我不会、没做过」一句话就带过。</p><p>如果是实在没有项目可以说，那么可以提自己日常做的练手项目，或者看到一个解决方案的文章/书，提到的某个项目，抒发下自己的想法。</p><p>如果是对于面试官提出来需要你设计的项目/系统，可以按照下面几步思考：</p><ol><li>有没有遇见过类似的项目</li><li>有没有读过类似解决方案的文章</li><li>项目能不能拆解，拆解过程中能不能发现自己做过的项目可以用</li><li>项目解决的问题是什么，这类问题有没有更好的解决方案</li></ol><p>总之，切记不要一句「不知道、没做过」就放弃，每一次提问都是自己表现的机会。</p><h2 id="项目细节和技术点的追问"><a href="#项目细节和技术点的追问" class="headerlink" title="项目细节和技术点的追问"></a><strong>项目细节和技术点的追问</strong></h2><p>介绍项目的过程中，面试官可能会追问技术细节，所以我们在准备面试的时候，应该尽量把技术细节梳理清楚，技术细节包括：</p><ol><li>技术选型方案：当时做技术选型所面临的状况</li><li>技术解决方案：最终确定某种技术方案的原因，比如：选择用 Vue 而没有用 React 是为什么？</li><li>项目数据和收益</li><li>项目中最难的地方</li><li>遇见的坑：如使用某种框架遇见哪些坑</li></ol><p>一般来说，做技术选型的时候需要考虑下面几个因素：</p><ol><li>时代：现在比较火的技术是什么，为什么火起来，解决了什么问题，能否用到我的项目中？</li><li>团队：个人或者团队对某种技术的熟悉程度是怎样的，学习成本又是怎样的？</li><li>业务需求：需求是怎样的，能否套用现在的成熟解决方案/库来快速解决？</li><li>维护成本：一个解决方案的是否再能够 cover 住的范围之内？</li></ol><p>在项目中遇见的数据和收益应该做好跟踪，保证数据的真实性和可信性。另外，遇见的坑可能是面试官问得比较多的，尤其现在比较火的一些技术（Vue、React、webpack），一般团队都在使用，所以一定要提前准备下。</p><h2 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>本小节介绍了面试中关于项目类问题的回答方法，介绍项目要使用四段体的方式，从背景、承担角色、收益效果和总结反思四个部分来介绍项目。</p><p>准备这个面试环节的时候，利用笔者一直提倡的「思维导图」法，好好回顾和梳理自己的项目。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一面-1：ES-基础知识点与高频考题解析&quot;&gt;&lt;a href=&quot;#一面-1：ES-基础知识点与高频考题解析&quot; class=&quot;headerlink&quot; title=&quot;一面 1：ES 基础知识点与高频考题解析&quot;&gt;&lt;/a&gt;&lt;strong&gt;一面 1：ES 基础知识点与高频考题
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>javascript-闭包</title>
    <link href="https://github.com/ZhangQiangQQ/2019/01/10/javascript-%E9%97%AD%E5%8C%85/"/>
    <id>https://github.com/ZhangQiangQQ/2019/01/10/javascript-闭包/</id>
    <published>2019-01-10T02:56:47.000Z</published>
    <updated>2019-07-06T02:28:09.968Z</updated>
    
    <content type="html"><![CDATA[<p>闭包的作用:</p><ul><li>1.封装变量</li><li>2.延续局部变量的寿命</li><li>3.闭包和面向对象设计:实现私有数据和方法的封装(本质还是1,封装变量)</li><li>闭包能使局部变量的生命期延长,这点与全局作用域的变量是一致的,不能算是内存泄漏!</li><li>闭包与内存泄漏有关的部分是:<br>使用闭包容易造成循环引用,如果闭包的作用域中保存着一些DOM节点,这时候有可能造成内存泄漏(互相引用导致内存无法释放)</li></ul><p>举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 例1：</span><br><span class="line">var increment = function () &#123;</span><br><span class="line">    var count = 1;</span><br><span class="line">    return &#123;</span><br><span class="line">        inc: function () &#123;</span><br><span class="line">            return count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(increment.count);   //undefined</span><br><span class="line">var counter = increment();</span><br><span class="line">console.log(counter.inc()); //1</span><br><span class="line">console.log(counter.inc()); //2</span><br><span class="line">console.log(counter.inc()); //3</span><br><span class="line"></span><br><span class="line">var counter2 = increment();</span><br><span class="line">console.log(counter2.inc()); //1</span><br><span class="line">console.log(counter == counter2);  //false,注:闭包每次返回的对象都不一样!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 例2</span><br><span class="line"></span><br><span class="line">var getTypeChecker = function () &#123;</span><br><span class="line">    var types = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    for (var i = 0, type; type = [&apos;String&apos;, &apos;Number&apos;, &apos;Array&apos;][i++];) &#123;</span><br><span class="line">        //使用闭包来封闭每次循环的变量</span><br><span class="line">        (function (type) &#123;</span><br><span class="line">            types[&apos;is&apos; + type] = function (obj) &#123;</span><br><span class="line">                return Object.prototype.toString.call(obj) === &apos;[object &apos; + type + &apos;]&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(type);</span><br><span class="line">    &#125;</span><br><span class="line">    return types;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var checker = getTypeChecker();</span><br><span class="line">console.log(checker.isArray([]));   // true</span><br><span class="line">console.log(checker.isString([]));   //false</span><br><span class="line">console.log(checker.isString(&apos;hello&apos;));  //true</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;闭包的作用:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.封装变量&lt;/li&gt;
&lt;li&gt;2.延续局部变量的寿命&lt;/li&gt;
&lt;li&gt;3.闭包和面向对象设计:实现私有数据和方法的封装(本质还是1,封装变量)&lt;/li&gt;
&lt;li&gt;闭包能使局部变量的生命期延长,这点与全局作用域的变量是一致的,不能算
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>函数柯里化（curry)</title>
    <link href="https://github.com/ZhangQiangQQ/2019/01/10/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%EF%BC%88curry%EF%BC%89/"/>
    <id>https://github.com/ZhangQiangQQ/2019/01/10/函数柯里化（curry）/</id>
    <published>2019-01-10T02:34:05.000Z</published>
    <updated>2019-07-06T02:28:09.972Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>函数柯里化的概念很简单，其实就是只提前接受一部分参数，但不执行结果，而是返回一个可以接受另一部分参数的函数。</p></blockquote><p>你可以像下面一样，一次性的调用curry函数，返回每次只传一次参数，传两次来获得想要的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function MathSumA(x)&#123;</span><br><span class="line">    return function MathSumB(y)&#123;</span><br><span class="line">        return x+y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 先传如一个x=2</span><br><span class="line">let x = MathSumA(2);</span><br><span class="line"></span><br><span class="line">// 再传入一个y=10</span><br><span class="line">let result = x(10); //result = x+y =2+10 =12</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;函数柯里化的概念很简单，其实就是只提前接受一部分参数，但不执行结果，而是返回一个可以接受另一部分参数的函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你可以像下面一样，一次性的调用curry函数，返回每次只传一次参数，传两次来获得想要的结果&lt;/p
      
    
    </summary>
    
    
  </entry>
  
</feed>
