<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> React学习笔记 · HarryPang's Blog</title><meta name="description" content="React学习笔记 - Harry Pang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/ZhangQiangQQ/atom.xml" title="HarryPang's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/2019/01/11/关于我" target="_self" class="nav-list-link">关于我</a></li><li class="nav-list-item"><a href="https://github.com/ZhangQiangQQ/" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">React学习笔记</h1><div class="post-info">2019年2月26日</div><div class="post-content"><ol>
<li><p>React是一种  声明式   高效 灵活 构建用户界面的框架</p>
</li>
<li><p>组件 ：React.Component{}</p>
</li>
<li><p>组件是接受 名为 props的参数 {this.props.name}， 即 当前组件被应用时， 传入的各个数据，包括事件等；</p>
</li>
</ol>
<p>4.render返回的是一个React元素 ：渲染内容的描述   一般使用JSX语法来扩展  ： <div> —–&gt; React.createElement(“div”)</div></p>
<p>5.通过 <shoppinglist> 这样的标签你就可以在 React 当中调用整个 ShoppingList 组件</shoppinglist></p>
<ol start="6">
<li><p>添加样式用  className = “aaaa”,  事件： onClick={ () =&gt; alert(“click”)}</p>
</li>
<li><p>this.state 为自身设置自身的状态数据，  存储变化的数据</p>
</li>
<li><p>this.setState 用于设置 值 ，每次触发时都会开始准备更新组件 跟随数据改变了的内容。</p>
</li>
</ol>
<p>状态提升：</p>
<ol start="9">
<li><p>子组件的state数据提升至共同的 父组件 中保存。然后 父组件 通过Props  将 状态 数据传递到子组件中     ——&gt;  方便状态数据共享交流</p>
</li>
<li><p>key React当中使用的一种特殊的属性，(以及ref属性)，无法通过props获取到key，React会自动判断元素更新时使用key，而组件自己无法获取到key的。<br>组件key值被改变就会被当作新创建的组件处理。<br>组件的 keys 值并不需要在全局都保证唯一，只需要在当前的节点里保证唯一即可</p>
</li>
</ol>
<p>二.Redux<br>概念：<br>（1）Web 应用是一个状态机，视图与状态是一一对应的。</p>
<p>（2）所有的状态，保存在一个对象里面。</p>
<p>Store:<br>保存数据的地方，看成一个容器， 整个应用只能有一个store</p>
<p>提供的方法函数： createStore，用于生成store，接受了另一个函数参数，返回新生成的store对象<br>例：import { createStore } from ‘redux’;<br>   const store = createStore(fn);<br>State：<br>时点的数据集合叫做 State， 如，当前时刻的 State，通过 store.getState() 拿到<br>import { createStore } from ‘redux’;<br>const store = createStore(fn);<br>const state = store.getState();<br>Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。</p>
<p>Action：<br>Action 就是 View 发出的通知，表示 State 应该要发生变化了<br>Action 是一个对象。其中的type属性是必须的。表示Action 的名称。其他属性可以自由设置，<br>const action = {<br>  type: ‘ADD_TODO’,<br>  payload: ‘Learn Redux’<br>};<br>可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。</p>
<p>Action Creator:<br>View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。</p>
<p>例：<br>const ADD_TODO = ‘添加 TODO’;</p>
<p>function addTodo(text) {<br>  return {<br>    type: ADD_TODO,<br>    text<br>  }<br>}</p>
<p>const action =addTodo(‘Learn Redux’);</p>
<p>store.dispatch()：</p>
<p>store.dispatch()是 View 发出 Action 的唯一方法。<br>store.dispatch接受一个 Action 对象作为参数，将它发送出去<br>store.dispatch(addTodo(‘Learn Redux’));</p>
<p>Reducer：<br>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。<br>例：</p>
<p>const defaultState = 0;<br>const reducer = (state = defaultState, action) =&gt; {<br>  switch (action.type) {<br>    case ‘ADD’:<br>      return state + action.payload;<br>    default:<br>      return state;<br>  }};</p>
<p>const state = reducer(1, {<br>  type: ‘ADD’,<br>  payload: 2});</p>
<p>createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。<br>例：</p>
<p>const actions = [<br>  { type: ‘ADD’, payload: 0 },<br>  { type: ‘ADD’, payload: 1 },<br>  { type: ‘ADD’, payload: 2 }];</p>
<p>const total = actions.reduce(reducer, 0); // 3</p>
<p>纯函数： 只要是同样的输入，必定得到同样的输出。</p>
<p>store.subscribe()：<br>方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。<br>例：</p>
<p>import { createStore } from ‘redux’;<br>const store = createStore(reducer);</p>
<p>store.subscribe(listener);</p>
<p>只要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染。<br>store.subscribe方法返回一个函数，调用这个函数就可以解除监听。</p>
<p>Reducer 的拆分：<br>combinReducers:用于 Reducer 的拆分。你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer。<br>例：</p>
<p>import { combineReducers } from ‘redux’;</p>
<p>const chatReducer = combineReducers({<br>  chatLog,<br>  statusMessage,<br>  userName<br>})</p>
<p>export default todoApp;<br>State 的属性名必须与子 Reducer 同名</p>
<p>不同名的写法：</p>
<p>const reducer = combineReducers({<br>  a: doSomethingWithA,<br>  b: processB,<br>  c: c<br>})<br>// 等同于<br>function reducer(state = {}, action) {<br>  return {<br>    a: doSomethingWithA(state.a, action),<br>    b: processB(state.b, action),<br>    c: c(state.c, action)<br>  }}</p>
<p>可以把所有子 Reducer 放在一个文件里面，然后统一引入。</p>
<p>import { combineReducers } from ‘redux’<br>import * as reducers from ‘./reducers’</p>
<p>const reducer = combineReducers(reducers)</p>
<p>Redux流程：<br>1.用户发出Action–&gt; stroe.dispatch(action);<br>2.store自动调用Reducer,传入（当前state，action），返回新的State。<br>例： let nextState = todoApp（previousState，action）；</p>
<p>3.state发生变化，store会调用监听函数。：</p>
<p>例：stroe.subscribe(listener);</p>
<p>listener可以通过 store.getStore() 得到当前状态，react此时会触发重新渲染view； </p>
<p>例：</p>
<p>function listerner() {<br>  let newState = store.getState();<br>  component.setState(newState);<br>}</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/03/01/发布流程/" class="prev">PREV</a><a href="/2019/02/16/常用的一些git命令行/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="https://github.com/ZhangQiangQQ">Harry Pang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>