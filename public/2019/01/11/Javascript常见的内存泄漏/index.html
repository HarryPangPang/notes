<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Javascript常见的内存泄漏 · HarryPang's Blog</title><meta name="description" content="Javascript常见的内存泄漏 - Harry Pang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/ZhangQiangQQ/atom.xml" title="HarryPang's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/2019/01/11/关于我" target="_self" class="nav-list-link">关于我</a></li><li class="nav-list-item"><a href="https://github.com/ZhangQiangQQ/" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Javascript常见的内存泄漏</h1><div class="post-info">2019年1月11日</div><div class="post-content"><blockquote>
<p>什么是内存泄露？<br>程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。<br>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。<br>白话解释就是你写的代码里有些东西不用了，就别在保存再内存中了，不然好比你开了100个迅雷CPU卡不卡？卡，但你其实真正用到的只是其中一个迅雷。这就是内存泄漏</p>
</blockquote>
<p>想要理解JavaScript的内存泄漏，就要先了解一下js的自动垃圾收集机制</p>
<h4 id="js的自动垃圾收集机制"><a href="#js的自动垃圾收集机制" class="headerlink" title="js的自动垃圾收集机制"></a>js的自动垃圾收集机制</h4><p>在编写JS时，我们不用像C++一样要手工跟踪内存的使用情况，JS的内存分配和无用内存的回收完全实现了自动化。</p>
<p>JS常用的垃圾收集机制有两种：1. 标记清除 2. 引用计数</p>
<ol>
<li><p>标记清除<br>在函数声明一个变量的时候，就将这个变量标记为“进入环境”。从逻辑上讲，永远都不能释放进入环境的变量作占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。垃圾回收器在运行时候会给存储在内存中中的所有变量都加上标记。然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。在此之后再被标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清楚工作，销毁那些带标记的值并回收他们所占用的内存空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">function test()&#123; </span><br><span class="line"> var a = 10 ; //被标记 ，进入环境 </span><br><span class="line"> var b = 20 ; //被标记 ，进入环境 </span><br><span class="line">&#125; </span><br><span class="line">test(); //执行完毕 之后 a、b又被标离开环境，被回收。</span><br></pre></td></tr></table></figure>
</li>
<li><p>引用计数（现代浏览器不再使用）<br>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。</p>
<p> 但是很重要的一点是当遇到循环引用的时候，函数的引用次数就不会为0，所以不会被垃圾回收器回收内存，会造成内存泄露。在IE中涉及DOM对象，就会存在循环引用的问题。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line">function test()&#123; </span><br><span class="line"> var a = &#123;&#125; ; //a的引用次数为0 </span><br><span class="line"> </span><br><span class="line"> var b = a ; //a的引用次数加1，为1 </span><br><span class="line"> </span><br><span class="line"> var c =a; //a的引用次数再加1，为2 </span><br><span class="line"> </span><br><span class="line"> var b =&#123;&#125;; //b解除对a的引用，a的引用次数减1，为1 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 循环引用</span><br><span class="line">function cycle() &#123;</span><br><span class="line">    var o1 = &#123;&#125;;</span><br><span class="line">    var o2 = &#123;&#125;;</span><br><span class="line">    o1.a = o2;</span><br><span class="line">    o2.a = o1; </span><br><span class="line"></span><br><span class="line">    return &quot;cycle reference!&quot;</span><br><span class="line">&#125;</span><br><span class="line">cycle();</span><br><span class="line"></span><br><span class="line">//数组</span><br><span class="line">let arr = [1,2,3]</span><br><span class="line"></span><br><span class="line">虽然这里没有引用arr，arr对他的值发生了引用，所以会一直存在内存中，可以采用 arr=null来解除引用</span><br></pre></td></tr></table></figure>
<p>虽然有了自动垃圾收集机制，我们可以不必太过关注一些内存泄漏的问题，但有些情况下还是会发生这种问题</p>
<h4 id="js的常见内存泄漏"><a href="#js的常见内存泄漏" class="headerlink" title="js的常见内存泄漏"></a>js的常见内存泄漏</h4><ol>
<li><p>全局变量引起的内存泄漏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function leaks()&#123;  </span><br><span class="line">    leak = &apos;xxxxxx&apos;;//leak 成为一个全局变量，不会被回收</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>闭包引起的内存泄漏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var leaks = (function()&#123;  </span><br><span class="line">    var leak = &apos;xxxxxx&apos;;// 被闭包所引用，不会被回收</span><br><span class="line">    return function()&#123;</span><br><span class="line">        console.log(leak);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
</li>
<li><p>dom清空或删除时，事件未清除导致的内存泄漏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;  </span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">$(&apos;#container&apos;).bind(&apos;click&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;click&apos;);</span><br><span class="line">&#125;).remove();</span><br><span class="line"></span><br><span class="line">// zepto 和原生 js下，#container dom 元素，还在内存里jquery 的 empty和 remove会帮助开发者避免这个问题</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;container&quot;&gt;  </span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">$(&apos;#container&apos;).bind(&apos;click&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;click&apos;);</span><br><span class="line">&#125;).off(&apos;click&apos;).remove();</span><br><span class="line">//把事件清除了，即可从内存中移除</span><br></pre></td></tr></table></figure>
</li>
<li><p>计时器或回调函数<br>定时器setInterval</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = fun();</span><br><span class="line">setInterval(function()&#123;</span><br><span class="line">  var node = document.getElementById(&apos;node&apos;);</span><br><span class="line">  if(node)&#123;</span><br><span class="line">     node.innerHTML = &apos;test&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;，1000);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>节点node或数据不需要时，定时器setInterval依然指向这些数据，所以即使node节点被溢出，interval仍旧存活并且垃圾回收期没法回收。</p>
<p>解决是终止定时器。</p>
<p>这种循环定时器，是一定要设置关闭条件，然后将其clear并且将timer指向null]</p>
<h4 id="解决方法及性能优化"><a href="#解决方法及性能优化" class="headerlink" title="解决方法及性能优化"></a>解决方法及性能优化</h4><p>发生内存泄漏肯定是不愿看到的，我们可以采取：<br>一旦确定数据不再使用，可以手动将其值设置为null来释放其引用。 —— 解除引用。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/01/11/关于我/" class="prev">PREV</a><a href="/2019/01/11/前端知识点190111/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="https://github.com/ZhangQiangQQ">Harry Pang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>