{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/apollo/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/apollo/source/css/apollo.css","path":"css/apollo.css","modified":0,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","path":"font/sourcesanspro.woff2","modified":0,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff","path":"font/sourcesanspro.woff","modified":0,"renderable":1},{"_id":"themes/apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":0,"renderable":1}],"Cache":[{"_id":"themes/apollo/.gitignore","hash":"d6cc8c2730e89bbee83e01a5a4490f8dbf12c332","modified":1554863509220},{"_id":"themes/apollo/README.md","hash":"bee45e9d6e41f6b9c01bc38f26bc60ba19c825f7","modified":1554863509224},{"_id":"themes/apollo/_config.yml","hash":"1ba33d84b7d9f21a44b2045fb7f9b658700e2903","modified":1554863509228},{"_id":"themes/apollo/gulpfile.js","hash":"3bf61bca569665944cc61ac0483c9d568a4f58d7","modified":1554863509240},{"_id":"themes/apollo/package.json","hash":"2e81f69d66c01a6bfaacbd8bd7324b370acbed88","modified":1554863509297},{"_id":"source/_posts/201901面试题分享.md","hash":"d33e9f9bc58f2120e6eb2e64b946639c93fefe98","modified":1554863509083},{"_id":"source/_posts/HTTP请求的四种方式区别.md","hash":"481f589ea486d803afda4389add858975b5f7e03","modified":1554863509088},{"_id":"source/_posts/JavaScript执行环境-执行栈.md","hash":"8cedd9d215819887de9ad8e12f0a2beaa2b0b528","modified":1554863509092},{"_id":"source/_posts/Javascript常见的内存泄漏.md","hash":"ff78dc73708efd2f3b41e7040429480f4603748a","modified":1554863509096},{"_id":"source/_posts/Javascript设计模式学习1（热身篇）.md","hash":"9a0b054289b488ae44855547c79840c2d5120910","modified":1554863509101},{"_id":"source/_posts/Javascript设计模式学习2（热身篇）.md","hash":"8eaa1037c9f3305804d6fc24099f277d5b4ff469","modified":1554863509106},{"_id":"source/_posts/MySQL8-0-12-secure-file-priv数据导出问题解决.md","hash":"977ce42d4910e8e5984a7406c9e871356c6c436b","modified":1554863509110},{"_id":"source/_posts/React_V16入门手册.md","hash":"2b19f3f892f726bd325a020a4de9b039129ff513","modified":1554863509115},{"_id":"source/_posts/React学习笔记.md","hash":"4ee6a174eeae3533a5ba5379931c6c3407128842","modified":1554864028683},{"_id":"source/_posts/React虚拟dom和diff算法.md","hash":"35c9506e0ba305da4635272b2625c42616e19f39","modified":1554863509121},{"_id":"source/_posts/Vue使用踩坑记录.md","hash":"7e6953fee2f6aec326071fa71d224ad6085a7257","modified":1554863509126},{"_id":"source/_posts/javascript-闭包.md","hash":"86d13912d1eb6357d7f3ed7a2de041e2689d48c4","modified":1554863509129},{"_id":"source/_posts/javascript跨域.md","hash":"1e9e85f727edf4e0384d402216c14bf792e9fdff","modified":1554863509133},{"_id":"source/_posts/react生命周期.md","hash":"c40086b80941b27959a70f203c7933ef241364ff","modified":1554863509139},{"_id":"source/_posts/vue中AsyncAwait的使用示例.md","hash":"5506d99452685cb40a0a1e9f7b783309825f0c7a","modified":1554863509144},{"_id":"source/_posts/webpack下build报错.md","hash":"81153ac0ff5564c90a8a12874928011460c1897a","modified":1554863509148},{"_id":"source/_posts/zabbix平台搭建.md","hash":"56d72ef76c820a462c1bc8f7f68f833d900d1207","modified":1554863509153},{"_id":"source/_posts/关于我.md","hash":"220647a65c3b1bd65a73e55273ed897aa26f8125","modified":1554863509157},{"_id":"source/_posts/函数节流与防抖.md","hash":"8be27c95dcee2a47e6ee6a93edd664c59026f92c","modified":1554863509166},{"_id":"source/_posts/函数柯里化（curry）.md","hash":"14d252619b17aee00b97b205c6a91c29c0db81b1","modified":1554863509160},{"_id":"source/_posts/前端进阶学习路径.md","hash":"f6d29d8f1704f3a2f4b1cfa7871920ed58296af2","modified":1554863509189},{"_id":"source/_posts/发布流程.md","hash":"82dd790b8f6d98ebd27278b601fd99efe2cb95af","modified":1554864135257},{"_id":"source/_posts/十分钟了解ajax.md","hash":"beb6e34ea3945de29d5daeb8b7b06080d0c5a741","modified":1554863509193},{"_id":"source/_posts/如何理解es6中的class以及class中的constructor函数.md","hash":"2dc07b253e35cc11a369e22c6072c0a6092fe534","modified":1554863509200},{"_id":"source/_posts/如何让小孩学习javascript.md","hash":"3425b72cac75063ca25536cdfa50a55408e21120","modified":1554863509204},{"_id":"source/_posts/常用的一些git命令行.md","hash":"7706067e3955fc3e3dec679572f8d435aeb3d529","modified":1554864004211},{"_id":"source/_posts/我从没理解过的Javascript闭包.md","hash":"4fccc0f53b66b03c724d3579ccee1608fc32d6c3","modified":1554863509208},{"_id":"source/_posts/浏览器缓存的了解.md","hash":"d4eb9492b6df0c26f7cc595224937ca46ca5c334","modified":1554864254612},{"_id":"source/_posts/看懂js中this关键字的指向问题.md","hash":"990b668caaaeb1cdea9d7a11b2250c22044be9c0","modified":1554863509212},{"_id":"source/_posts/项目管理师学习-信息化和信息系统1.md","hash":"e6ae099687432293a7c45220c4f3b1bfbc312ed6","modified":1554863509216},{"_id":"themes/apollo/doc/doc-en.md","hash":"d89404bf56d49e76f3129ee9fe4383861823485f","modified":1554863509231},{"_id":"themes/apollo/languages/en.yml","hash":"1080c108dba6b7f69c6f31633d904d85634b7ad6","modified":1554863509248},{"_id":"themes/apollo/languages/zh-cn.yml","hash":"c6a4b8c7aaba51ffc4ea7060dca3e9a5e9f9c88f","modified":1554863509251},{"_id":"themes/apollo/doc/doc-zh.md","hash":"6587cc3d4d826d08b1b4f678f348f08ea09fb006","modified":1554863509236},{"_id":"themes/apollo/layout/index.jade","hash":"fd11746c566d9fb6de1224a2992e3e443a83c139","modified":1554863509258},{"_id":"themes/apollo/layout/archive.jade","hash":"a993dddad0213cfc4adbf5d25597b7effac758b0","modified":1554863509254},{"_id":"themes/apollo/layout/post.jade","hash":"ada9f5f76819ff76d2c37c893431dfdb808e19b7","modified":1554863509293},{"_id":"themes/apollo/source/favicon.png","hash":"bc9f295a86a24eb1676cb2f6420292c6745c4531","modified":1554863509306},{"_id":"source/_posts/前端知识点190111.md","hash":"1c39a0ccd165242a19aafbd9772e68f7013a0b13","modified":1554863509178},{"_id":"themes/apollo/layout/mixins/paginator.jade","hash":"47712f8bb3d84ff6a2742f923626d568779fc45a","modified":1554863509262},{"_id":"themes/apollo/layout/partial/comment.jade","hash":"ada3f92eb6b97263bbe562b56aeb1349a8a81fc4","modified":1554863509270},{"_id":"themes/apollo/layout/mixins/post.jade","hash":"8859dd53fb511e1937179b64fecc82f61eb4b227","modified":1554863509265},{"_id":"themes/apollo/layout/partial/copyright.jade","hash":"185aa2a3f86176b4924adac06ef576b365440c20","modified":1554863509274},{"_id":"themes/apollo/layout/partial/head.jade","hash":"bc1fb13056ea07b3832ed563c680ffe619d44dd9","modified":1554863509278},{"_id":"themes/apollo/layout/partial/layout.jade","hash":"a49c19346dee6886ac8b37a1321ce170e627129a","modified":1554863509282},{"_id":"themes/apollo/layout/partial/scripts.jade","hash":"e309aff22fa5823aa65667cf2f189bd05adeb62a","modified":1554863509289},{"_id":"themes/apollo/layout/partial/nav.jade","hash":"b43b1166601669cd6467bebf343efc1e5a253d64","modified":1554863509285},{"_id":"themes/apollo/source/css/apollo.css","hash":"a9072992f3a03003fb0ada9fb2d6d76386f066ad","modified":1554863509301},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1554863509310},{"_id":"themes/apollo/source/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1554863509307},{"_id":"themes/apollo/source/scss/apollo.scss","hash":"bea961e9c85a0eba26b34d5568f165f48fbc9bdb","modified":1554863509350},{"_id":"themes/apollo/source/scss/_partial/archive-post-list.scss","hash":"3003361c281d7aa1cfed944ad0da180ac05f2c32","modified":1554863509314},{"_id":"themes/apollo/source/scss/_partial/base.scss","hash":"4ede69b12919439b4ae404a1e1d498cb8fd2932a","modified":1554863509317},{"_id":"themes/apollo/source/scss/_partial/copyright.scss","hash":"e87b144a8389eefeab4f50c353eef18c428a761c","modified":1554863509321},{"_id":"themes/apollo/source/scss/_partial/footer.scss","hash":"8cd2631d46be05a9518f1966bd84e1a8b0270857","modified":1554863509325},{"_id":"themes/apollo/source/scss/_partial/header.scss","hash":"a6aeb5177f370f984565f7b6f0a18fe27545d34d","modified":1554863509329},{"_id":"themes/apollo/source/scss/_partial/home-post-list.scss","hash":"658eef39c7cf6f730f784751c2e4701e8eb02e0d","modified":1554863509333},{"_id":"themes/apollo/source/scss/_partial/mq.scss","hash":"25f38fb71ade373416af569558d56e4c2e692700","modified":1554863509336},{"_id":"themes/apollo/source/scss/_partial/normalize.scss","hash":"612b367b0e9a0b9f66d37694ee64ce896c552967","modified":1554863509340},{"_id":"themes/apollo/source/scss/_partial/post.scss","hash":"85e5dded04b7229ab4345e53473d4e9e9cbdbfb5","modified":1554863509346},{"_id":"public/atom.xml","hash":"c15784224e35c460708275139eed3fd1a8d9565e","modified":1554867541465},{"_id":"public/sitemap.xml","hash":"5a0b1270e51bc417c55b7b5ec219513b537d3b7d","modified":1554867541468},{"_id":"public/2019/04/10/浏览器缓存的了解/index.html","hash":"258779f0cbd0466e50005ab97ec0e14aa145eb97","modified":1554867541485},{"_id":"public/2019/03/01/发布流程/index.html","hash":"f5f5264856ef073a2c394aaf2fe7eb7f8f64d6b3","modified":1554867541485},{"_id":"public/2019/02/26/React学习笔记/index.html","hash":"2567ddd8ab298f1799193a9137a2adf161f34e2f","modified":1554867541485},{"_id":"public/2019/02/16/常用的一些git命令行/index.html","hash":"e1e3452db3f330cb0053f91d8c4f2c456018d050","modified":1554867541485},{"_id":"public/2019/02/09/webpack下build报错/index.html","hash":"c07d0c34b03c86f6f9bfd75fa7efd914a2d60acd","modified":1554867541485},{"_id":"public/2019/01/30/React虚拟dom和diff算法/index.html","hash":"63e143ee4d7d0264f7c1810289af08798f2b83fc","modified":1554867541485},{"_id":"public/2019/01/27/react生命周期/index.html","hash":"ab9fb0526c312e5c72b4479d0541a4e6614b14fd","modified":1554867541485},{"_id":"public/2019/01/22/201901面试题分享/index.html","hash":"3ec8435ef6848824189cdb2ac9ccc764daaccd39","modified":1554867541486},{"_id":"public/2019/01/14/Vue使用踩坑记录/index.html","hash":"62e3171b68405ca36d7ea2533a48df5e98e1d6a6","modified":1554867541486},{"_id":"public/2019/01/11/关于我/index.html","hash":"4ecdae26d2bfe36a9d4d7f84b35fd9fcefa85de6","modified":1554867541486},{"_id":"public/2019/01/11/Javascript常见的内存泄漏/index.html","hash":"58ee36a95c340886d836d3e36a9b8a0896ee35f9","modified":1554867541486},{"_id":"public/2019/01/10/javascript-闭包/index.html","hash":"12cfe46a7a03564bc31fd1730d82053a52fa6edd","modified":1554867541486},{"_id":"public/2019/01/10/函数柯里化（curry）/index.html","hash":"c137a6095a1cbb2e8aaf6726186bd352105c9aa1","modified":1554867541486},{"_id":"public/2019/01/09/javascript跨域/index.html","hash":"0bd39a518878d65c8e8b12e604d09dfaa1ca4845","modified":1554867541486},{"_id":"public/2019/01/08/Javascript设计模式学习2（热身篇）/index.html","hash":"2c321e2e90b352e0ec0fea2acbe6c88e675395d8","modified":1554867541486},{"_id":"public/2019/01/03/我从没理解过的Javascript闭包/index.html","hash":"c1cfd07eb128b8d8d2e19365c3dd187a13c8e577","modified":1554867541486},{"_id":"public/2019/01/01/前端进阶学习路径/index.html","hash":"531e52f58a0b6fa5b9fe2fbc6280edef55d42797","modified":1554867541486},{"_id":"public/2019/01/01/JavaScript执行环境-执行栈/index.html","hash":"30ea16cbd41ec07d162d4e5a8d44c0e2c54f5503","modified":1554867541486},{"_id":"public/2018/12/25/vue中AsyncAwait的使用示例/index.html","hash":"20596bdc6b586455a20395cfe4a811c59cdc19b0","modified":1554867541486},{"_id":"public/2018/12/20/MySQL8-0-12-secure-file-priv数据导出问题解决/index.html","hash":"0c991f6070070ce187bfa7700d28be43c505a0af","modified":1554867541487},{"_id":"public/2018/12/07/HTTP请求的四种方式区别/index.html","hash":"ddaf681739bd2229aec6bcc8e1392c43af41aa30","modified":1554867541487},{"_id":"public/2018/11/10/函数节流与防抖/index.html","hash":"d3bfff75deb6f406d52ba0ac9e0bf50d308a19e2","modified":1554867541487},{"_id":"public/2018/11/07/如何让小孩学习javascript/index.html","hash":"da1dc4995f0f630fc70046644181b952a4c533a3","modified":1554867541487},{"_id":"public/2018/06/17/如何理解es6中的class以及class中的constructor函数/index.html","hash":"07ff8b7ac5bb37477a5af92af8dd152d5752f736","modified":1554867541487},{"_id":"public/2018/04/06/看懂js中this关键字的指向问题/index.html","hash":"e43422f34c389ae89ae6b46daa1ef2d572c0d980","modified":1554867541487},{"_id":"public/2016/09/06/十分钟了解ajax/index.html","hash":"892f6d24cf6041dfc8d2b95fef0a2aaa4a2e113b","modified":1554867541487},{"_id":"public/archives/index.html","hash":"a3eb517a5eb666ac893e71c2ae3abf3be1a449e1","modified":1554867541487},{"_id":"public/archives/2016/index.html","hash":"4e642244c358d39ab4aa7a9909cf5cc363bbf14e","modified":1554867541487},{"_id":"public/archives/2016/09/06/index.html","hash":"4e642244c358d39ab4aa7a9909cf5cc363bbf14e","modified":1554867541487},{"_id":"public/archives/2016/09/index.html","hash":"4e642244c358d39ab4aa7a9909cf5cc363bbf14e","modified":1554867541487},{"_id":"public/archives/2018/index.html","hash":"f189a3e6c3d4214693edc3e637c95e997755c4c4","modified":1554867541487},{"_id":"public/archives/2018/03/index.html","hash":"91b163ed967a1bc81b166adbcc2c5591425346e5","modified":1554867541487},{"_id":"public/archives/2018/03/14/index.html","hash":"91b163ed967a1bc81b166adbcc2c5591425346e5","modified":1554867541487},{"_id":"public/archives/2018/04/index.html","hash":"ff4383720a83bcb2670e96c9f4fe0eefbcf2de8e","modified":1554867541487},{"_id":"public/archives/2018/04/06/index.html","hash":"ff4383720a83bcb2670e96c9f4fe0eefbcf2de8e","modified":1554867541487},{"_id":"public/archives/2018/06/index.html","hash":"6fe6ff9b1dce0cfc833066366b3e75d0241bb601","modified":1554867541487},{"_id":"public/archives/2018/06/17/index.html","hash":"6fe6ff9b1dce0cfc833066366b3e75d0241bb601","modified":1554867541487},{"_id":"public/archives/2018/11/index.html","hash":"3a1ac79b4445c1a9d9a6ff0e9ce1301ef841c458","modified":1554867541488},{"_id":"public/archives/2018/11/07/index.html","hash":"dd4663415f0bf2b2e201fb59c1256407f1cb7771","modified":1554867541488},{"_id":"public/archives/2018/12/index.html","hash":"ed5328a2e001920e4594dfa67074d0f713f1451c","modified":1554867541488},{"_id":"public/archives/2018/12/07/index.html","hash":"4bf23d55e53ece98b9d8cfb4621fe931d7543e41","modified":1554867541488},{"_id":"public/archives/2019/index.html","hash":"35436c2ebaddee2d659f62b5f913e0aec1979b34","modified":1554867541488},{"_id":"public/archives/2019/01/01/index.html","hash":"31339c2aa8006885097a3f7c1bf511b7dcdc54f3","modified":1554867541488},{"_id":"public/archives/2019/01/index.html","hash":"3b90a831e7ec495ab6cbc4b21470a6e2f7531e8a","modified":1554867541488},{"_id":"public/archives/2019/01/03/index.html","hash":"55141ddcf2dc4a83b6dab296a5a8a8e5eb5b86f6","modified":1554867541488},{"_id":"public/archives/2019/01/07/index.html","hash":"1131d817f63ca93f14b56bcdf1c2e9356a9683d2","modified":1554867541488},{"_id":"public/archives/2019/01/09/index.html","hash":"abcee88882dd8ced73efc9c2d604bafa3912ea4e","modified":1554867541488},{"_id":"public/archives/2019/01/08/index.html","hash":"dea3feb506664569ef6fedf53917f744fc88e240","modified":1554867541488},{"_id":"public/archives/2019/01/10/index.html","hash":"349682ba98819c260b750e5604bec62358397ff7","modified":1554867541488},{"_id":"public/archives/2019/02/index.html","hash":"10d43f49ba5211e8c003e0de4d89e48fdb97e75a","modified":1554867541488},{"_id":"public/archives/2019/02/09/index.html","hash":"d04a91c93e161f2915c73d87f3dfbab8e1b746cb","modified":1554867541488},{"_id":"public/archives/2019/03/index.html","hash":"b270e5edb2de7b78fcab639cfbaf6b5a9683347b","modified":1554867541488},{"_id":"public/archives/2019/03/01/index.html","hash":"b270e5edb2de7b78fcab639cfbaf6b5a9683347b","modified":1554867541488},{"_id":"public/archives/2019/04/index.html","hash":"2ba6422d76023a5eb7c0ff2415caf867a3cffb29","modified":1554867541488},{"_id":"public/archives/2019/04/10/index.html","hash":"2ba6422d76023a5eb7c0ff2415caf867a3cffb29","modified":1554867541489},{"_id":"public/index.html","hash":"c0e5286c0008d1cecfdfe3b912f5e926a3d6cbc2","modified":1554867541489},{"_id":"public/page/2/index.html","hash":"649cab0be4bcc4e90e1b1bdc59ea26fbf56d867b","modified":1554867541489},{"_id":"public/page/3/index.html","hash":"a368707b837ecdcf64e73c204d74efdbbb98c518","modified":1554867541489},{"_id":"public/page/4/index.html","hash":"69d428113fffd78a48e6c912c4959050bf1ce761","modified":1554867541489},{"_id":"public/tags/Javascript-闭包/index.html","hash":"55141ddcf2dc4a83b6dab296a5a8a8e5eb5b86f6","modified":1554867541489},{"_id":"public/2019/01/18/React_V16入门手册/index.html","hash":"7e4e385a864643b7b9d4f9fa938a77eb72d8608e","modified":1554867541489},{"_id":"public/2019/01/11/前端知识点190111/index.html","hash":"a5c614da640f41b651ba61335aa85a70d1db9710","modified":1554867541489},{"_id":"public/2019/01/07/项目管理师学习-信息化和信息系统1/index.html","hash":"c5b63fc441106ce07760395f64424b500a5888e6","modified":1554867541489},{"_id":"public/2019/01/07/Javascript设计模式学习1（热身篇）/index.html","hash":"6e4e1622feb94bdbb09054e98e3f8cdd629b0b21","modified":1554867541489},{"_id":"public/2018/03/14/zabbix平台搭建/index.html","hash":"42c4ae60e692118f1de4c9d462a85e3e058f35dd","modified":1554867541489},{"_id":"public/favicon.png","hash":"bc9f295a86a24eb1676cb2f6420292c6745c4531","modified":1554867541536},{"_id":"public/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1554867541536},{"_id":"public/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1554867541536},{"_id":"public/scss/apollo.scss","hash":"bea961e9c85a0eba26b34d5568f165f48fbc9bdb","modified":1554867541537},{"_id":"public/css/apollo.css","hash":"e07a11a5da5fc097f023e06a85575356066afd09","modified":1554867541545}],"Category":[],"Data":[],"Page":[],"Post":[{"layout":"postman","title":"HTTP请求的四种方式区别","date":"2018-12-07T05:46:28.000Z","_content":"1：form-data\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf2609a81690a?w=886&h=147&f=png&s=2001)\n此时对应的\n```\nContent-Type:multipart/form-data;\n```\n```\n<form action=\"${pageContext.request.contextPath}/imageUpload_saveOrUpdate.action\" method=\"post\" enctype=\"multipart/form-data\"> \n<div> \n<label>请选择上传图片地址:</label> \n<input type=\"file\" name=\"image\"/> \n</div> \n</div> \n<div> \n<input type=\"submit\" value=\"上传\"/> \n</div> \n</form> \n```\n它会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。当上传的字段是文件时，会有content-type来说明文件类型；content-disposition，用来说明字段的一些信息；由于有boundary隔离，所以multipart/form-data既可以上传文件，也可以上传键值对，它采用了键值对的方式，所以可以上传多个文件。\n\n2：x-www-form-urlencoded\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf2609a9026c8?w=1033&h=90&f=png&s=1795)\n就是**application/x-www-from-urlencoded**,会将表单内的数据转换为键值对，比如,name=Java&age = 23\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf2609adcdcaf?w=658&h=296&f=png&s=25955)\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf2609b0359e9?w=507&h=234&f=png&s=17279)\n\n3：raw\n可以上传任意格式的文本，可以上传text、json、xml、html等\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf2609af8f3cf?w=754&h=419&f=png&s=30029)\n\n4：binary\n相当于Content-Type:application/octet-stream,从字面意思得知，只可以上传二进制数据，通常用来上传文件，由于没有键值，所以，一次只能上传一个文件。\n\n\n\n\n\nmultipart/form-data与x-www-form-urlencoded区别\n\n               multipart/form-data：既可以上传文件等二进制数据，也可以上传表单键值对，只是最后会转化为一条信息；\n\n               x-www-form-urlencoded：只能上传键值对，并且键值对都是间隔分开的。\n参考[]","source":"_posts/HTTP请求的四种方式区别.md","raw":"---\nlayout: postman\ntitle: HTTP请求的四种方式区别\ndate: 2018-12-07 13:46:28\ntags:\n---\n1：form-data\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf2609a81690a?w=886&h=147&f=png&s=2001)\n此时对应的\n```\nContent-Type:multipart/form-data;\n```\n```\n<form action=\"${pageContext.request.contextPath}/imageUpload_saveOrUpdate.action\" method=\"post\" enctype=\"multipart/form-data\"> \n<div> \n<label>请选择上传图片地址:</label> \n<input type=\"file\" name=\"image\"/> \n</div> \n</div> \n<div> \n<input type=\"submit\" value=\"上传\"/> \n</div> \n</form> \n```\n它会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。当上传的字段是文件时，会有content-type来说明文件类型；content-disposition，用来说明字段的一些信息；由于有boundary隔离，所以multipart/form-data既可以上传文件，也可以上传键值对，它采用了键值对的方式，所以可以上传多个文件。\n\n2：x-www-form-urlencoded\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf2609a9026c8?w=1033&h=90&f=png&s=1795)\n就是**application/x-www-from-urlencoded**,会将表单内的数据转换为键值对，比如,name=Java&age = 23\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf2609adcdcaf?w=658&h=296&f=png&s=25955)\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf2609b0359e9?w=507&h=234&f=png&s=17279)\n\n3：raw\n可以上传任意格式的文本，可以上传text、json、xml、html等\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf2609af8f3cf?w=754&h=419&f=png&s=30029)\n\n4：binary\n相当于Content-Type:application/octet-stream,从字面意思得知，只可以上传二进制数据，通常用来上传文件，由于没有键值，所以，一次只能上传一个文件。\n\n\n\n\n\nmultipart/form-data与x-www-form-urlencoded区别\n\n               multipart/form-data：既可以上传文件等二进制数据，也可以上传表单键值对，只是最后会转化为一条信息；\n\n               x-www-form-urlencoded：只能上传键值对，并且键值对都是间隔分开的。\n参考[]","slug":"HTTP请求的四种方式区别","published":1,"updated":"2019-04-10T02:31:49.088Z","comments":1,"photos":[],"link":"","_id":"cjuanzkht0000jgf25trvqtep","content":"<p>1：form-data<br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf2609a81690a?w=886&amp;h=147&amp;f=png&amp;s=2001\" alt=\"image.png\"><br>此时对应的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Type:multipart/form-data;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/imageUpload_saveOrUpdate.action&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; </span><br><span class=\"line\">&lt;div&gt; </span><br><span class=\"line\">&lt;label&gt;请选择上传图片地址:&lt;/label&gt; </span><br><span class=\"line\">&lt;input type=&quot;file&quot; name=&quot;image&quot;/&gt; </span><br><span class=\"line\">&lt;/div&gt; </span><br><span class=\"line\">&lt;/div&gt; </span><br><span class=\"line\">&lt;div&gt; </span><br><span class=\"line\">&lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt; </span><br><span class=\"line\">&lt;/div&gt; </span><br><span class=\"line\">&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n<p>它会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。当上传的字段是文件时，会有content-type来说明文件类型；content-disposition，用来说明字段的一些信息；由于有boundary隔离，所以multipart/form-data既可以上传文件，也可以上传键值对，它采用了键值对的方式，所以可以上传多个文件。</p>\n<p>2：x-www-form-urlencoded<br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf2609a9026c8?w=1033&amp;h=90&amp;f=png&amp;s=1795\" alt=\"image.png\"><br>就是<strong>application/x-www-from-urlencoded</strong>,会将表单内的数据转换为键值对，比如,name=Java&amp;age = 23<br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf2609adcdcaf?w=658&amp;h=296&amp;f=png&amp;s=25955\" alt=\"image.png\"><br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf2609b0359e9?w=507&amp;h=234&amp;f=png&amp;s=17279\" alt=\"image.png\"></p>\n<p>3：raw<br>可以上传任意格式的文本，可以上传text、json、xml、html等<br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf2609af8f3cf?w=754&amp;h=419&amp;f=png&amp;s=30029\" alt=\"image.png\"></p>\n<p>4：binary<br>相当于Content-Type:application/octet-stream,从字面意思得知，只可以上传二进制数据，通常用来上传文件，由于没有键值，所以，一次只能上传一个文件。</p>\n<p>multipart/form-data与x-www-form-urlencoded区别</p>\n<pre><code>multipart/form-data：既可以上传文件等二进制数据，也可以上传表单键值对，只是最后会转化为一条信息；\n\nx-www-form-urlencoded：只能上传键值对，并且键值对都是间隔分开的。\n</code></pre><p>参考[]</p>\n","site":{"data":{}},"excerpt":"","more":"<p>1：form-data<br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf2609a81690a?w=886&amp;h=147&amp;f=png&amp;s=2001\" alt=\"image.png\"><br>此时对应的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Type:multipart/form-data;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/imageUpload_saveOrUpdate.action&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; </span><br><span class=\"line\">&lt;div&gt; </span><br><span class=\"line\">&lt;label&gt;请选择上传图片地址:&lt;/label&gt; </span><br><span class=\"line\">&lt;input type=&quot;file&quot; name=&quot;image&quot;/&gt; </span><br><span class=\"line\">&lt;/div&gt; </span><br><span class=\"line\">&lt;/div&gt; </span><br><span class=\"line\">&lt;div&gt; </span><br><span class=\"line\">&lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt; </span><br><span class=\"line\">&lt;/div&gt; </span><br><span class=\"line\">&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n<p>它会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。当上传的字段是文件时，会有content-type来说明文件类型；content-disposition，用来说明字段的一些信息；由于有boundary隔离，所以multipart/form-data既可以上传文件，也可以上传键值对，它采用了键值对的方式，所以可以上传多个文件。</p>\n<p>2：x-www-form-urlencoded<br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf2609a9026c8?w=1033&amp;h=90&amp;f=png&amp;s=1795\" alt=\"image.png\"><br>就是<strong>application/x-www-from-urlencoded</strong>,会将表单内的数据转换为键值对，比如,name=Java&amp;age = 23<br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf2609adcdcaf?w=658&amp;h=296&amp;f=png&amp;s=25955\" alt=\"image.png\"><br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf2609b0359e9?w=507&amp;h=234&amp;f=png&amp;s=17279\" alt=\"image.png\"></p>\n<p>3：raw<br>可以上传任意格式的文本，可以上传text、json、xml、html等<br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf2609af8f3cf?w=754&amp;h=419&amp;f=png&amp;s=30029\" alt=\"image.png\"></p>\n<p>4：binary<br>相当于Content-Type:application/octet-stream,从字面意思得知，只可以上传二进制数据，通常用来上传文件，由于没有键值，所以，一次只能上传一个文件。</p>\n<p>multipart/form-data与x-www-form-urlencoded区别</p>\n<pre><code>multipart/form-data：既可以上传文件等二进制数据，也可以上传表单键值对，只是最后会转化为一条信息；\n\nx-www-form-urlencoded：只能上传键值对，并且键值对都是间隔分开的。\n</code></pre><p>参考[]</p>\n"},{"title":"201901面试题分享","date":"2019-01-22T03:01:04.000Z","_content":"* vue生命周期\n* vue父子组通信\n* 箭头函数什么情况下不能用\n* 原型原型链介绍一下\n* 闭包是什么\n* 自己有没有写过node中间件\n* webpack有没有用过，都用哪些功能\n* 移动端适配怎么做\n* rem和em的区别\n* css怎么画一个三角形\n* 常规函数，箭头函数的this指向\n* class的super怎么用\n* class如何实现继承的,子类如何使用父类里的方法\n* 数组如何去重（ES5,ES6）\n* let const var 区别\n* call apply bind区别和用法\n* \n```\n1.sayhello()\n2.sayhello()\n怎么都输出1\n```\n* 服务端渲染有没有了解过\n* vue的虚拟dom原理是什么？怎么实现的？\n* vue的beforeCreate和created区别\n* promise怎么实现两个同时执行\n* promise怎么让两个接口，接口1执行完成后执行接口2\n* await怎么知道后面执行的成功还是失败\n* promise遇到错误，catch里会有什么\n* 用一个变量等于await+函数，那这个变量结果是什么\n* 数组里都是数字时怎么排序？有几种方法\n* http请求头里都有什么内容\n* cookie和localstorage的区别\n* node登陆注册怎么做的\n* node token的实现\n* 如何在同一台服务器起多个pm2进程\n* 还有个手写的题目记不起来了，不过考的就是闭包内私有变量和全局变量的区别","source":"_posts/201901面试题分享.md","raw":"---\ntitle: 201901面试题分享\ndate: 2019-01-22 11:01:04\ntags:\n---\n* vue生命周期\n* vue父子组通信\n* 箭头函数什么情况下不能用\n* 原型原型链介绍一下\n* 闭包是什么\n* 自己有没有写过node中间件\n* webpack有没有用过，都用哪些功能\n* 移动端适配怎么做\n* rem和em的区别\n* css怎么画一个三角形\n* 常规函数，箭头函数的this指向\n* class的super怎么用\n* class如何实现继承的,子类如何使用父类里的方法\n* 数组如何去重（ES5,ES6）\n* let const var 区别\n* call apply bind区别和用法\n* \n```\n1.sayhello()\n2.sayhello()\n怎么都输出1\n```\n* 服务端渲染有没有了解过\n* vue的虚拟dom原理是什么？怎么实现的？\n* vue的beforeCreate和created区别\n* promise怎么实现两个同时执行\n* promise怎么让两个接口，接口1执行完成后执行接口2\n* await怎么知道后面执行的成功还是失败\n* promise遇到错误，catch里会有什么\n* 用一个变量等于await+函数，那这个变量结果是什么\n* 数组里都是数字时怎么排序？有几种方法\n* http请求头里都有什么内容\n* cookie和localstorage的区别\n* node登陆注册怎么做的\n* node token的实现\n* 如何在同一台服务器起多个pm2进程\n* 还有个手写的题目记不起来了，不过考的就是闭包内私有变量和全局变量的区别","slug":"201901面试题分享","published":1,"updated":"2019-04-10T02:31:49.083Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzkhx0001jgf27gvano9l","content":"<ul>\n<li>vue生命周期</li>\n<li>vue父子组通信</li>\n<li>箭头函数什么情况下不能用</li>\n<li>原型原型链介绍一下</li>\n<li>闭包是什么</li>\n<li>自己有没有写过node中间件</li>\n<li>webpack有没有用过，都用哪些功能</li>\n<li>移动端适配怎么做</li>\n<li>rem和em的区别</li>\n<li>css怎么画一个三角形</li>\n<li>常规函数，箭头函数的this指向</li>\n<li>class的super怎么用</li>\n<li>class如何实现继承的,子类如何使用父类里的方法</li>\n<li>数组如何去重（ES5,ES6）</li>\n<li>let const var 区别</li>\n<li>call apply bind区别和用法</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.sayhello()</span><br><span class=\"line\">2.sayhello()</span><br><span class=\"line\">怎么都输出1</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>服务端渲染有没有了解过</p>\n</li>\n<li>vue的虚拟dom原理是什么？怎么实现的？</li>\n<li>vue的beforeCreate和created区别</li>\n<li>promise怎么实现两个同时执行</li>\n<li>promise怎么让两个接口，接口1执行完成后执行接口2</li>\n<li>await怎么知道后面执行的成功还是失败</li>\n<li>promise遇到错误，catch里会有什么</li>\n<li>用一个变量等于await+函数，那这个变量结果是什么</li>\n<li>数组里都是数字时怎么排序？有几种方法</li>\n<li>http请求头里都有什么内容</li>\n<li>cookie和localstorage的区别</li>\n<li>node登陆注册怎么做的</li>\n<li>node token的实现</li>\n<li>如何在同一台服务器起多个pm2进程</li>\n<li>还有个手写的题目记不起来了，不过考的就是闭包内私有变量和全局变量的区别</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>vue生命周期</li>\n<li>vue父子组通信</li>\n<li>箭头函数什么情况下不能用</li>\n<li>原型原型链介绍一下</li>\n<li>闭包是什么</li>\n<li>自己有没有写过node中间件</li>\n<li>webpack有没有用过，都用哪些功能</li>\n<li>移动端适配怎么做</li>\n<li>rem和em的区别</li>\n<li>css怎么画一个三角形</li>\n<li>常规函数，箭头函数的this指向</li>\n<li>class的super怎么用</li>\n<li>class如何实现继承的,子类如何使用父类里的方法</li>\n<li>数组如何去重（ES5,ES6）</li>\n<li>let const var 区别</li>\n<li>call apply bind区别和用法</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.sayhello()</span><br><span class=\"line\">2.sayhello()</span><br><span class=\"line\">怎么都输出1</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>服务端渲染有没有了解过</p>\n</li>\n<li>vue的虚拟dom原理是什么？怎么实现的？</li>\n<li>vue的beforeCreate和created区别</li>\n<li>promise怎么实现两个同时执行</li>\n<li>promise怎么让两个接口，接口1执行完成后执行接口2</li>\n<li>await怎么知道后面执行的成功还是失败</li>\n<li>promise遇到错误，catch里会有什么</li>\n<li>用一个变量等于await+函数，那这个变量结果是什么</li>\n<li>数组里都是数字时怎么排序？有几种方法</li>\n<li>http请求头里都有什么内容</li>\n<li>cookie和localstorage的区别</li>\n<li>node登陆注册怎么做的</li>\n<li>node token的实现</li>\n<li>如何在同一台服务器起多个pm2进程</li>\n<li>还有个手写的题目记不起来了，不过考的就是闭包内私有变量和全局变量的区别</li>\n</ul>\n"},{"title":"JavaScript执行环境-执行栈","date":"2019-01-01T05:52:08.000Z","_content":"#####1.1执行环境\n执行环境可以简称为环境，可以理解为JS被解析和执行所在的外部环境。\n#####1.1.1全局执行环境\n全局执行环境是最外层的一个环境，根据宿主环境的不同，全局对象也会有所区别，比如在浏览器中全局环境是window，在node中全局环境就是这个文件的module对象。\n#####1.1.2函数执行环境\n每次调用一个函数时，都会创建一个新的执行环境，在这个函数内的任何声明都无法在该函数之外的地方访问\n#####1.1.3Eval函数执行环境\n在eval()函数中的代码，不建议使用\n\n#####1.1.4 执行栈\n我们先了解一下执行栈内的执行顺序：后进先出，意思就是最早来的最晚走，最后来的最先走（参考下图理解）\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf228b8c8df0f?w=555&h=288&f=png&s=52150)\n>因为JavaScript在浏览器环境中的执行是单线程（就是一次只能做一件事，不能边吃饭边看电视，只能先吃饭再看电视），对于多个任务，只能采用任务队列的方式（就是先吃饭，一定要等吃完饭才能看电视）。\n\n举一个例子（暂时不用去看current execution context这一层，其实就是Execution Context N+1），\n1. 调用 一个函数f1，执行流先进入全局环境\n（Global Execution Context这一层）\n2. f1的环境被推入环境栈中\n（Execution Context N+1这一层按照绿色箭头进入）\n3. 这时候函数f1又调用了函数f2，f2的环境被推入环境栈中\n（Execution Context N+2这一层按照绿色箭头进入）\n4. f2执行完之后就立马离开执行栈\nExecution Context N+2这一层按照红箭头离开\n5. f1执行完之后在f2离开环境栈后再离开环境栈\nExecution Context N+1这一层按照红箭头离开\n6. 全局环境不会消失，除非关闭浏览器或者关闭网页所以Global Execution Context这一层不会消失\n\n>看到这里，我们就能理解另外一个概念：执行环境的两个阶段\n>######1. 创建阶段\n >- 当函数被调用，但是为执行内部代码之前:\n>- 创建一个作用域链\n>- 创建变量，函数和参数。\n>- 确定this的值。\n>######2, 执行阶段\n>- 赋值，引用函数，解释/执行代码。\n","source":"_posts/JavaScript执行环境-执行栈.md","raw":"---\ntitle: JavaScript执行环境-执行栈\ndate: 2019-01-01 13:52:08\ntags:\n---\n#####1.1执行环境\n执行环境可以简称为环境，可以理解为JS被解析和执行所在的外部环境。\n#####1.1.1全局执行环境\n全局执行环境是最外层的一个环境，根据宿主环境的不同，全局对象也会有所区别，比如在浏览器中全局环境是window，在node中全局环境就是这个文件的module对象。\n#####1.1.2函数执行环境\n每次调用一个函数时，都会创建一个新的执行环境，在这个函数内的任何声明都无法在该函数之外的地方访问\n#####1.1.3Eval函数执行环境\n在eval()函数中的代码，不建议使用\n\n#####1.1.4 执行栈\n我们先了解一下执行栈内的执行顺序：后进先出，意思就是最早来的最晚走，最后来的最先走（参考下图理解）\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf228b8c8df0f?w=555&h=288&f=png&s=52150)\n>因为JavaScript在浏览器环境中的执行是单线程（就是一次只能做一件事，不能边吃饭边看电视，只能先吃饭再看电视），对于多个任务，只能采用任务队列的方式（就是先吃饭，一定要等吃完饭才能看电视）。\n\n举一个例子（暂时不用去看current execution context这一层，其实就是Execution Context N+1），\n1. 调用 一个函数f1，执行流先进入全局环境\n（Global Execution Context这一层）\n2. f1的环境被推入环境栈中\n（Execution Context N+1这一层按照绿色箭头进入）\n3. 这时候函数f1又调用了函数f2，f2的环境被推入环境栈中\n（Execution Context N+2这一层按照绿色箭头进入）\n4. f2执行完之后就立马离开执行栈\nExecution Context N+2这一层按照红箭头离开\n5. f1执行完之后在f2离开环境栈后再离开环境栈\nExecution Context N+1这一层按照红箭头离开\n6. 全局环境不会消失，除非关闭浏览器或者关闭网页所以Global Execution Context这一层不会消失\n\n>看到这里，我们就能理解另外一个概念：执行环境的两个阶段\n>######1. 创建阶段\n >- 当函数被调用，但是为执行内部代码之前:\n>- 创建一个作用域链\n>- 创建变量，函数和参数。\n>- 确定this的值。\n>######2, 执行阶段\n>- 赋值，引用函数，解释/执行代码。\n","slug":"JavaScript执行环境-执行栈","published":1,"updated":"2019-04-10T02:31:49.092Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzkhz0002jgf26usd9f54","content":"<p>#####1.1执行环境<br>执行环境可以简称为环境，可以理解为JS被解析和执行所在的外部环境。</p>\n<p>#####1.1.1全局执行环境<br>全局执行环境是最外层的一个环境，根据宿主环境的不同，全局对象也会有所区别，比如在浏览器中全局环境是window，在node中全局环境就是这个文件的module对象。</p>\n<p>#####1.1.2函数执行环境<br>每次调用一个函数时，都会创建一个新的执行环境，在这个函数内的任何声明都无法在该函数之外的地方访问</p>\n<p>#####1.1.3Eval函数执行环境<br>在eval()函数中的代码，不建议使用</p>\n<p>#####1.1.4 执行栈<br>我们先了解一下执行栈内的执行顺序：后进先出，意思就是最早来的最晚走，最后来的最先走（参考下图理解）<br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf228b8c8df0f?w=555&amp;h=288&amp;f=png&amp;s=52150\" alt=\"image.png\"></p>\n<blockquote>\n<p>因为JavaScript在浏览器环境中的执行是单线程（就是一次只能做一件事，不能边吃饭边看电视，只能先吃饭再看电视），对于多个任务，只能采用任务队列的方式（就是先吃饭，一定要等吃完饭才能看电视）。</p>\n</blockquote>\n<p>举一个例子（暂时不用去看current execution context这一层，其实就是Execution Context N+1），</p>\n<ol>\n<li>调用 一个函数f1，执行流先进入全局环境<br>（Global Execution Context这一层）</li>\n<li>f1的环境被推入环境栈中<br>（Execution Context N+1这一层按照绿色箭头进入）</li>\n<li>这时候函数f1又调用了函数f2，f2的环境被推入环境栈中<br>（Execution Context N+2这一层按照绿色箭头进入）</li>\n<li>f2执行完之后就立马离开执行栈<br>Execution Context N+2这一层按照红箭头离开</li>\n<li>f1执行完之后在f2离开环境栈后再离开环境栈<br>Execution Context N+1这一层按照红箭头离开</li>\n<li>全局环境不会消失，除非关闭浏览器或者关闭网页所以Global Execution Context这一层不会消失</li>\n</ol>\n<blockquote>\n<p>看到这里，我们就能理解另外一个概念：执行环境的两个阶段</p>\n<p>######1. 创建阶段</p>\n<ul>\n<li>当函数被调用，但是为执行内部代码之前:</li>\n<li>创建一个作用域链</li>\n<li>创建变量，函数和参数。</li>\n<li>确定this的值。<br>######2, 执行阶段</li>\n<li>赋值，引用函数，解释/执行代码。</li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>#####1.1执行环境<br>执行环境可以简称为环境，可以理解为JS被解析和执行所在的外部环境。</p>\n<p>#####1.1.1全局执行环境<br>全局执行环境是最外层的一个环境，根据宿主环境的不同，全局对象也会有所区别，比如在浏览器中全局环境是window，在node中全局环境就是这个文件的module对象。</p>\n<p>#####1.1.2函数执行环境<br>每次调用一个函数时，都会创建一个新的执行环境，在这个函数内的任何声明都无法在该函数之外的地方访问</p>\n<p>#####1.1.3Eval函数执行环境<br>在eval()函数中的代码，不建议使用</p>\n<p>#####1.1.4 执行栈<br>我们先了解一下执行栈内的执行顺序：后进先出，意思就是最早来的最晚走，最后来的最先走（参考下图理解）<br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf228b8c8df0f?w=555&amp;h=288&amp;f=png&amp;s=52150\" alt=\"image.png\"></p>\n<blockquote>\n<p>因为JavaScript在浏览器环境中的执行是单线程（就是一次只能做一件事，不能边吃饭边看电视，只能先吃饭再看电视），对于多个任务，只能采用任务队列的方式（就是先吃饭，一定要等吃完饭才能看电视）。</p>\n</blockquote>\n<p>举一个例子（暂时不用去看current execution context这一层，其实就是Execution Context N+1），</p>\n<ol>\n<li>调用 一个函数f1，执行流先进入全局环境<br>（Global Execution Context这一层）</li>\n<li>f1的环境被推入环境栈中<br>（Execution Context N+1这一层按照绿色箭头进入）</li>\n<li>这时候函数f1又调用了函数f2，f2的环境被推入环境栈中<br>（Execution Context N+2这一层按照绿色箭头进入）</li>\n<li>f2执行完之后就立马离开执行栈<br>Execution Context N+2这一层按照红箭头离开</li>\n<li>f1执行完之后在f2离开环境栈后再离开环境栈<br>Execution Context N+1这一层按照红箭头离开</li>\n<li>全局环境不会消失，除非关闭浏览器或者关闭网页所以Global Execution Context这一层不会消失</li>\n</ol>\n<blockquote>\n<p>看到这里，我们就能理解另外一个概念：执行环境的两个阶段</p>\n<p>######1. 创建阶段</p>\n<ul>\n<li>当函数被调用，但是为执行内部代码之前:</li>\n<li>创建一个作用域链</li>\n<li>创建变量，函数和参数。</li>\n<li>确定this的值。<br>######2, 执行阶段</li>\n<li>赋值，引用函数，解释/执行代码。</li>\n</ul>\n</blockquote>\n"},{"title":"Javascript常见的内存泄漏","date":"2019-01-11T07:42:13.000Z","_content":"> 什么是内存泄露？\n> 程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。\n对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。\n> 白话解释就是你写的代码里有些东西不用了，就别在保存再内存中了，不然好比你开了100个迅雷CPU卡不卡？卡，但你其实真正用到的只是其中一个迅雷。这就是内存泄漏\n\n想要理解JavaScript的内存泄漏，就要先了解一下js的自动垃圾收集机制\n#### js的自动垃圾收集机制\n在编写JS时，我们不用像C++一样要手工跟踪内存的使用情况，JS的内存分配和无用内存的回收完全实现了自动化。\n\nJS常用的垃圾收集机制有两种：1. 标记清除 2. 引用计数\n1. 标记清除\n 在函数声明一个变量的时候，就将这个变量标记为“进入环境”。从逻辑上讲，永远都不能释放进入环境的变量作占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。垃圾回收器在运行时候会给存储在内存中中的所有变量都加上标记。然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。在此之后再被标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清楚工作，销毁那些带标记的值并回收他们所占用的内存空间\n```\n \nfunction test(){ \n var a = 10 ; //被标记 ，进入环境 \n var b = 20 ; //被标记 ，进入环境 \n} \ntest(); //执行完毕 之后 a、b又被标离开环境，被回收。\n\n\n \n```\n\n2. 引用计数（现代浏览器不再使用）\n  引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。\n\n    但是很重要的一点是当遇到循环引用的时候，函数的引用次数就不会为0，所以不会被垃圾回收器回收内存，会造成内存泄露。在IE中涉及DOM对象，就会存在循环引用的问题。\n\n```\n\n \nfunction test(){ \n var a = {} ; //a的引用次数为0 \n \n var b = a ; //a的引用次数加1，为1 \n \n var c =a; //a的引用次数再加1，为2 \n \n var b ={}; //b解除对a的引用，a的引用次数减1，为1 \n}\n\n// 循环引用\nfunction cycle() {\n    var o1 = {};\n    var o2 = {};\n    o1.a = o2;\n    o2.a = o1; \n\n    return \"cycle reference!\"\n}\ncycle();\n\n//数组\nlet arr = [1,2,3]\n\n虽然这里没有引用arr，arr对他的值发生了引用，所以会一直存在内存中，可以采用 arr=null来解除引用\n```\n虽然有了自动垃圾收集机制，我们可以不必太过关注一些内存泄漏的问题，但有些情况下还是会发生这种问题\n\n#### js的常见内存泄漏\n1. 全局变量引起的内存泄漏\n```\nfunction leaks(){  \n    leak = 'xxxxxx';//leak 成为一个全局变量，不会被回收\n}\n```\n2. 闭包引起的内存泄漏\n```\nvar leaks = (function(){  \n    var leak = 'xxxxxx';// 被闭包所引用，不会被回收\n    return function(){\n        console.log(leak);\n    }\n})()\n```\n3. dom清空或删除时，事件未清除导致的内存泄漏\n```\n<div id=\"container\">  \n</div>\n\n$('#container').bind('click', function(){\n    console.log('click');\n}).remove();\n\n// zepto 和原生 js下，#container dom 元素，还在内存里jquery 的 empty和 remove会帮助开发者避免这个问题\n\n<div id=\"container\">  \n</div>\n\n$('#container').bind('click', function(){\n    console.log('click');\n}).off('click').remove();\n//把事件清除了，即可从内存中移除\n```\n4. 计时器或回调函数\n定时器setInterval\n```\nvar a = fun();\nsetInterval(function(){\n  var node = document.getElementById('node');\n  if(node){\n     node.innerHTML = 'test';\n  }\n}，1000);\n```\n节点node或数据不需要时，定时器setInterval依然指向这些数据，所以即使node节点被溢出，interval仍旧存活并且垃圾回收期没法回收。\n\n解决是终止定时器。\n\n这种循环定时器，是一定要设置关闭条件，然后将其clear并且将timer指向null]\n\n#### 解决方法及性能优化\n发生内存泄漏肯定是不愿看到的，我们可以采取：\n一旦确定数据不再使用，可以手动将其值设置为null来释放其引用。 —— 解除引用。","source":"_posts/Javascript常见的内存泄漏.md","raw":"---\ntitle: Javascript常见的内存泄漏\ndate: 2019-01-11 15:42:13\ntags:\n---\n> 什么是内存泄露？\n> 程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。\n对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。\n> 白话解释就是你写的代码里有些东西不用了，就别在保存再内存中了，不然好比你开了100个迅雷CPU卡不卡？卡，但你其实真正用到的只是其中一个迅雷。这就是内存泄漏\n\n想要理解JavaScript的内存泄漏，就要先了解一下js的自动垃圾收集机制\n#### js的自动垃圾收集机制\n在编写JS时，我们不用像C++一样要手工跟踪内存的使用情况，JS的内存分配和无用内存的回收完全实现了自动化。\n\nJS常用的垃圾收集机制有两种：1. 标记清除 2. 引用计数\n1. 标记清除\n 在函数声明一个变量的时候，就将这个变量标记为“进入环境”。从逻辑上讲，永远都不能释放进入环境的变量作占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。垃圾回收器在运行时候会给存储在内存中中的所有变量都加上标记。然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。在此之后再被标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清楚工作，销毁那些带标记的值并回收他们所占用的内存空间\n```\n \nfunction test(){ \n var a = 10 ; //被标记 ，进入环境 \n var b = 20 ; //被标记 ，进入环境 \n} \ntest(); //执行完毕 之后 a、b又被标离开环境，被回收。\n\n\n \n```\n\n2. 引用计数（现代浏览器不再使用）\n  引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。\n\n    但是很重要的一点是当遇到循环引用的时候，函数的引用次数就不会为0，所以不会被垃圾回收器回收内存，会造成内存泄露。在IE中涉及DOM对象，就会存在循环引用的问题。\n\n```\n\n \nfunction test(){ \n var a = {} ; //a的引用次数为0 \n \n var b = a ; //a的引用次数加1，为1 \n \n var c =a; //a的引用次数再加1，为2 \n \n var b ={}; //b解除对a的引用，a的引用次数减1，为1 \n}\n\n// 循环引用\nfunction cycle() {\n    var o1 = {};\n    var o2 = {};\n    o1.a = o2;\n    o2.a = o1; \n\n    return \"cycle reference!\"\n}\ncycle();\n\n//数组\nlet arr = [1,2,3]\n\n虽然这里没有引用arr，arr对他的值发生了引用，所以会一直存在内存中，可以采用 arr=null来解除引用\n```\n虽然有了自动垃圾收集机制，我们可以不必太过关注一些内存泄漏的问题，但有些情况下还是会发生这种问题\n\n#### js的常见内存泄漏\n1. 全局变量引起的内存泄漏\n```\nfunction leaks(){  \n    leak = 'xxxxxx';//leak 成为一个全局变量，不会被回收\n}\n```\n2. 闭包引起的内存泄漏\n```\nvar leaks = (function(){  \n    var leak = 'xxxxxx';// 被闭包所引用，不会被回收\n    return function(){\n        console.log(leak);\n    }\n})()\n```\n3. dom清空或删除时，事件未清除导致的内存泄漏\n```\n<div id=\"container\">  \n</div>\n\n$('#container').bind('click', function(){\n    console.log('click');\n}).remove();\n\n// zepto 和原生 js下，#container dom 元素，还在内存里jquery 的 empty和 remove会帮助开发者避免这个问题\n\n<div id=\"container\">  \n</div>\n\n$('#container').bind('click', function(){\n    console.log('click');\n}).off('click').remove();\n//把事件清除了，即可从内存中移除\n```\n4. 计时器或回调函数\n定时器setInterval\n```\nvar a = fun();\nsetInterval(function(){\n  var node = document.getElementById('node');\n  if(node){\n     node.innerHTML = 'test';\n  }\n}，1000);\n```\n节点node或数据不需要时，定时器setInterval依然指向这些数据，所以即使node节点被溢出，interval仍旧存活并且垃圾回收期没法回收。\n\n解决是终止定时器。\n\n这种循环定时器，是一定要设置关闭条件，然后将其clear并且将timer指向null]\n\n#### 解决方法及性能优化\n发生内存泄漏肯定是不愿看到的，我们可以采取：\n一旦确定数据不再使用，可以手动将其值设置为null来释放其引用。 —— 解除引用。","slug":"Javascript常见的内存泄漏","published":1,"updated":"2019-04-10T02:31:49.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzki00003jgf2soic7la9","content":"<blockquote>\n<p>什么是内存泄露？<br>程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。<br>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。<br>白话解释就是你写的代码里有些东西不用了，就别在保存再内存中了，不然好比你开了100个迅雷CPU卡不卡？卡，但你其实真正用到的只是其中一个迅雷。这就是内存泄漏</p>\n</blockquote>\n<p>想要理解JavaScript的内存泄漏，就要先了解一下js的自动垃圾收集机制</p>\n<h4 id=\"js的自动垃圾收集机制\"><a href=\"#js的自动垃圾收集机制\" class=\"headerlink\" title=\"js的自动垃圾收集机制\"></a>js的自动垃圾收集机制</h4><p>在编写JS时，我们不用像C++一样要手工跟踪内存的使用情况，JS的内存分配和无用内存的回收完全实现了自动化。</p>\n<p>JS常用的垃圾收集机制有两种：1. 标记清除 2. 引用计数</p>\n<ol>\n<li><p>标记清除<br>在函数声明一个变量的时候，就将这个变量标记为“进入环境”。从逻辑上讲，永远都不能释放进入环境的变量作占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。垃圾回收器在运行时候会给存储在内存中中的所有变量都加上标记。然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。在此之后再被标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清楚工作，销毁那些带标记的值并回收他们所占用的内存空间</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">function test()&#123; </span><br><span class=\"line\"> var a = 10 ; //被标记 ，进入环境 </span><br><span class=\"line\"> var b = 20 ; //被标记 ，进入环境 </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">test(); //执行完毕 之后 a、b又被标离开环境，被回收。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>引用计数（现代浏览器不再使用）<br>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。</p>\n<p> 但是很重要的一点是当遇到循环引用的时候，函数的引用次数就不会为0，所以不会被垃圾回收器回收内存，会造成内存泄露。在IE中涉及DOM对象，就会存在循环引用的问题。</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\">function test()&#123; </span><br><span class=\"line\"> var a = &#123;&#125; ; //a的引用次数为0 </span><br><span class=\"line\"> </span><br><span class=\"line\"> var b = a ; //a的引用次数加1，为1 </span><br><span class=\"line\"> </span><br><span class=\"line\"> var c =a; //a的引用次数再加1，为2 </span><br><span class=\"line\"> </span><br><span class=\"line\"> var b =&#123;&#125;; //b解除对a的引用，a的引用次数减1，为1 </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 循环引用</span><br><span class=\"line\">function cycle() &#123;</span><br><span class=\"line\">    var o1 = &#123;&#125;;</span><br><span class=\"line\">    var o2 = &#123;&#125;;</span><br><span class=\"line\">    o1.a = o2;</span><br><span class=\"line\">    o2.a = o1; </span><br><span class=\"line\"></span><br><span class=\"line\">    return &quot;cycle reference!&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">cycle();</span><br><span class=\"line\"></span><br><span class=\"line\">//数组</span><br><span class=\"line\">let arr = [1,2,3]</span><br><span class=\"line\"></span><br><span class=\"line\">虽然这里没有引用arr，arr对他的值发生了引用，所以会一直存在内存中，可以采用 arr=null来解除引用</span><br></pre></td></tr></table></figure>\n<p>虽然有了自动垃圾收集机制，我们可以不必太过关注一些内存泄漏的问题，但有些情况下还是会发生这种问题</p>\n<h4 id=\"js的常见内存泄漏\"><a href=\"#js的常见内存泄漏\" class=\"headerlink\" title=\"js的常见内存泄漏\"></a>js的常见内存泄漏</h4><ol>\n<li><p>全局变量引起的内存泄漏</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function leaks()&#123;  </span><br><span class=\"line\">    leak = &apos;xxxxxx&apos;;//leak 成为一个全局变量，不会被回收</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>闭包引起的内存泄漏</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var leaks = (function()&#123;  </span><br><span class=\"line\">    var leak = &apos;xxxxxx&apos;;// 被闭包所引用，不会被回收</span><br><span class=\"line\">    return function()&#123;</span><br><span class=\"line\">        console.log(leak);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>dom清空或删除时，事件未清除导致的内存泄漏</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;container&quot;&gt;  </span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">$(&apos;#container&apos;).bind(&apos;click&apos;, function()&#123;</span><br><span class=\"line\">    console.log(&apos;click&apos;);</span><br><span class=\"line\">&#125;).remove();</span><br><span class=\"line\"></span><br><span class=\"line\">// zepto 和原生 js下，#container dom 元素，还在内存里jquery 的 empty和 remove会帮助开发者避免这个问题</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id=&quot;container&quot;&gt;  </span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">$(&apos;#container&apos;).bind(&apos;click&apos;, function()&#123;</span><br><span class=\"line\">    console.log(&apos;click&apos;);</span><br><span class=\"line\">&#125;).off(&apos;click&apos;).remove();</span><br><span class=\"line\">//把事件清除了，即可从内存中移除</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>计时器或回调函数<br>定时器setInterval</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = fun();</span><br><span class=\"line\">setInterval(function()&#123;</span><br><span class=\"line\">  var node = document.getElementById(&apos;node&apos;);</span><br><span class=\"line\">  if(node)&#123;</span><br><span class=\"line\">     node.innerHTML = &apos;test&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;，1000);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>节点node或数据不需要时，定时器setInterval依然指向这些数据，所以即使node节点被溢出，interval仍旧存活并且垃圾回收期没法回收。</p>\n<p>解决是终止定时器。</p>\n<p>这种循环定时器，是一定要设置关闭条件，然后将其clear并且将timer指向null]</p>\n<h4 id=\"解决方法及性能优化\"><a href=\"#解决方法及性能优化\" class=\"headerlink\" title=\"解决方法及性能优化\"></a>解决方法及性能优化</h4><p>发生内存泄漏肯定是不愿看到的，我们可以采取：<br>一旦确定数据不再使用，可以手动将其值设置为null来释放其引用。 —— 解除引用。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>什么是内存泄露？<br>程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。<br>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。<br>白话解释就是你写的代码里有些东西不用了，就别在保存再内存中了，不然好比你开了100个迅雷CPU卡不卡？卡，但你其实真正用到的只是其中一个迅雷。这就是内存泄漏</p>\n</blockquote>\n<p>想要理解JavaScript的内存泄漏，就要先了解一下js的自动垃圾收集机制</p>\n<h4 id=\"js的自动垃圾收集机制\"><a href=\"#js的自动垃圾收集机制\" class=\"headerlink\" title=\"js的自动垃圾收集机制\"></a>js的自动垃圾收集机制</h4><p>在编写JS时，我们不用像C++一样要手工跟踪内存的使用情况，JS的内存分配和无用内存的回收完全实现了自动化。</p>\n<p>JS常用的垃圾收集机制有两种：1. 标记清除 2. 引用计数</p>\n<ol>\n<li><p>标记清除<br>在函数声明一个变量的时候，就将这个变量标记为“进入环境”。从逻辑上讲，永远都不能释放进入环境的变量作占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。垃圾回收器在运行时候会给存储在内存中中的所有变量都加上标记。然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。在此之后再被标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清楚工作，销毁那些带标记的值并回收他们所占用的内存空间</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">function test()&#123; </span><br><span class=\"line\"> var a = 10 ; //被标记 ，进入环境 </span><br><span class=\"line\"> var b = 20 ; //被标记 ，进入环境 </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">test(); //执行完毕 之后 a、b又被标离开环境，被回收。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>引用计数（现代浏览器不再使用）<br>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。</p>\n<p> 但是很重要的一点是当遇到循环引用的时候，函数的引用次数就不会为0，所以不会被垃圾回收器回收内存，会造成内存泄露。在IE中涉及DOM对象，就会存在循环引用的问题。</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\">function test()&#123; </span><br><span class=\"line\"> var a = &#123;&#125; ; //a的引用次数为0 </span><br><span class=\"line\"> </span><br><span class=\"line\"> var b = a ; //a的引用次数加1，为1 </span><br><span class=\"line\"> </span><br><span class=\"line\"> var c =a; //a的引用次数再加1，为2 </span><br><span class=\"line\"> </span><br><span class=\"line\"> var b =&#123;&#125;; //b解除对a的引用，a的引用次数减1，为1 </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 循环引用</span><br><span class=\"line\">function cycle() &#123;</span><br><span class=\"line\">    var o1 = &#123;&#125;;</span><br><span class=\"line\">    var o2 = &#123;&#125;;</span><br><span class=\"line\">    o1.a = o2;</span><br><span class=\"line\">    o2.a = o1; </span><br><span class=\"line\"></span><br><span class=\"line\">    return &quot;cycle reference!&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">cycle();</span><br><span class=\"line\"></span><br><span class=\"line\">//数组</span><br><span class=\"line\">let arr = [1,2,3]</span><br><span class=\"line\"></span><br><span class=\"line\">虽然这里没有引用arr，arr对他的值发生了引用，所以会一直存在内存中，可以采用 arr=null来解除引用</span><br></pre></td></tr></table></figure>\n<p>虽然有了自动垃圾收集机制，我们可以不必太过关注一些内存泄漏的问题，但有些情况下还是会发生这种问题</p>\n<h4 id=\"js的常见内存泄漏\"><a href=\"#js的常见内存泄漏\" class=\"headerlink\" title=\"js的常见内存泄漏\"></a>js的常见内存泄漏</h4><ol>\n<li><p>全局变量引起的内存泄漏</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function leaks()&#123;  </span><br><span class=\"line\">    leak = &apos;xxxxxx&apos;;//leak 成为一个全局变量，不会被回收</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>闭包引起的内存泄漏</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var leaks = (function()&#123;  </span><br><span class=\"line\">    var leak = &apos;xxxxxx&apos;;// 被闭包所引用，不会被回收</span><br><span class=\"line\">    return function()&#123;</span><br><span class=\"line\">        console.log(leak);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>dom清空或删除时，事件未清除导致的内存泄漏</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;container&quot;&gt;  </span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">$(&apos;#container&apos;).bind(&apos;click&apos;, function()&#123;</span><br><span class=\"line\">    console.log(&apos;click&apos;);</span><br><span class=\"line\">&#125;).remove();</span><br><span class=\"line\"></span><br><span class=\"line\">// zepto 和原生 js下，#container dom 元素，还在内存里jquery 的 empty和 remove会帮助开发者避免这个问题</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id=&quot;container&quot;&gt;  </span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">$(&apos;#container&apos;).bind(&apos;click&apos;, function()&#123;</span><br><span class=\"line\">    console.log(&apos;click&apos;);</span><br><span class=\"line\">&#125;).off(&apos;click&apos;).remove();</span><br><span class=\"line\">//把事件清除了，即可从内存中移除</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>计时器或回调函数<br>定时器setInterval</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = fun();</span><br><span class=\"line\">setInterval(function()&#123;</span><br><span class=\"line\">  var node = document.getElementById(&apos;node&apos;);</span><br><span class=\"line\">  if(node)&#123;</span><br><span class=\"line\">     node.innerHTML = &apos;test&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;，1000);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>节点node或数据不需要时，定时器setInterval依然指向这些数据，所以即使node节点被溢出，interval仍旧存活并且垃圾回收期没法回收。</p>\n<p>解决是终止定时器。</p>\n<p>这种循环定时器，是一定要设置关闭条件，然后将其clear并且将timer指向null]</p>\n<h4 id=\"解决方法及性能优化\"><a href=\"#解决方法及性能优化\" class=\"headerlink\" title=\"解决方法及性能优化\"></a>解决方法及性能优化</h4><p>发生内存泄漏肯定是不愿看到的，我们可以采取：<br>一旦确定数据不再使用，可以手动将其值设置为null来释放其引用。 —— 解除引用。</p>\n"},{"title":"Javascript设计模式学习1（热身篇）","date":"2019-01-07T06:27:39.000Z","_content":"#### 从创建一个函数开始\n\n函数的创建有很多形式，通常我们会采用以下做法\n\n```javascript\nfunction getName(){\n    //get name here\n}\nfunction getAge(){\n //get age here\n}\n\nvar getName = function(){\n    //get name here\n}\nvar getAge= function(){\n //get age here\n}\n```\n\n但是这种做法有个弊端，这类函数因为都是全局变量，所以在团队合作，或者项目函数很多时就会出现函数命名重复的问题，那就糟糕了，会出现函数被覆盖，导致不必要的工作量。所以可以采用下面的方式（用对象来收编方法，变量）\n\n```javascript\nvar GetUserInfo= {\n    getName:function(){\n        //get name here\n    },\n    getAge :function(){\n        //get age here\n    }\n}\n//或者像下面这样\nvar GetUserInfo= function(){};\nGetUserInfo.getName = function(){\n //get name here\n},\nGetUserInfo.getAge = function(){\n //get age here\n }\n\n```\n\n但是上面方法，还有个问题，就是这个对象不能复制，比如我只想使用里面的getUserInfo.getAge()这个方法，但是没有办法复制一个这样的对象来给自己使用，除非代码全部拷贝一遍，这无疑徒增了代码量，所以我们可以采用return来返回一个新的函数对象，如下\n\n```javascript\nvar GetUserInfo= function(){\n return {\n     getName :function(){\n         //get name here\n     },\n     getAge : function(){\n         //get age here\n     }\n }\n}\n```\n\n这样我们就可以安心复制getUserInfo其中的某个方法来为自己所用了,使用方法如下\n\n```javascript\nvar getUserInfo_myself = GetUserInfo()\ngetUserInfo_myself.getName()\n```\n\n上面的方法虽然可以完美达到我们的要求，但是编程最重要的是什么？当然时面向对象！我们来回顾一下面向对象的三个基本特征：封装、继承、多态。\n\n封装：类其实就是保存了一个函数的变量，这个函数有自己的属性和方法。将属性和方法组成一个类的过程就是封装。\n\n所以要实现封装，我们就得用JS实现一个类\n\n```javascript\n//ES5\nvar GetUserInfo= function(){\n    this.getName = function(){\n         //get name here\n     },\n     this.getAge = function(){\n         //get age here\n     },\n}\n//this的指向简单理解就是函数被调用时的执行环境，也可以说时谁调用该函数，this就指向谁\n//这里this就指向getUserInfo_myself\n\n```\n\n上面的代码（构造函数）就实现了一个类（函数，有自己的属性，有自己的方法）\n\n调用时，我们就不能var getUserInfo_myself = GetUserInfo()这样来用了。要像下面这样\n\n```javascript\nvar getUserInfo_myself = new GetUserInfo()\ngetUserInfo_myself()\n```\n\n以为这样就结束？这还不算是最好的方案，因为通过new来创建新对象的时候，新创建的对象都会复制一次this的属性，用多了就会造成很多消耗，我们可以避免吗？可以！通过原型的方式来实现，看下面\n\n```javascript\n//ES5方法一\nvar GetUserInfo=function(){};\nGetUserInfo.prototype.getName={\n    //get name here\n}\nGetUserInfo.prototype.getAge={\n  //get age here\n}\n//ES5方法二\nvar GetUserInfo=function(){};\nGetUserInfo.prototype={\n    getName(){\n     //get name here\n    }\n    getAge(){\n     //get agehere\n     }\n}\n\n//用ES6的语法\nclass GetUserInfo{\n constructor(){}\n getName(){\n //get name here\n }\n getAge(){\n //get age here\n }\n}\n\n```\n\n使用方法如下\n\n```javascript\nvar getUserInfo_myself = new GetUserInfo()\n// class方法必须使用new，否则会报错\ngetUserInfo_myself.getName()\ngetUserInfo_myself.getAge()\n```\n\n之前的例子中我们想要执行getName和getAge方法都要将对象getUserInfo_myself写两次，那我们就可以用链式调用来优化一下，那我们应该怎么做？看下面\n\n```javascript\n//创建对象的方式实现\nvar GetUserInfo= {\n getName: function(){\n console.log('getName')\n console.log(this)\n return this\n },\n getAge: function(){\n console.log('getAge')\n console.log(this)\n return this\n }\n}\nGetUserInfo.getName().getAge()\n//这里的this指向GetUserInfo，所以GetUserInfo.getName().getAge()其实就是这样执行的\n//1. GetUserInfo.getName() 返回this,this指向GetUserInfo，GetUserInfo有两个方法getName()和getAge()\n//2. this.getAge() 也就是 GetUserInfo.getAge()\n\n//原型的方式实现\nvar GetUserInfo = function(){}\nGetUserInfo.prototype={\n    getName(){\n         //get name here\n         return this\n     }\n     getAge(){\n         //get agehere\n         return this\n     }\n}\n```\n>我是Harry,Destiny is all\n\n\n\n","source":"_posts/Javascript设计模式学习1（热身篇）.md","raw":"---\ntitle: Javascript设计模式学习1（热身篇）\ndate: 2019-01-07 14:27:39\ntags:\n---\n#### 从创建一个函数开始\n\n函数的创建有很多形式，通常我们会采用以下做法\n\n```javascript\nfunction getName(){\n    //get name here\n}\nfunction getAge(){\n //get age here\n}\n\nvar getName = function(){\n    //get name here\n}\nvar getAge= function(){\n //get age here\n}\n```\n\n但是这种做法有个弊端，这类函数因为都是全局变量，所以在团队合作，或者项目函数很多时就会出现函数命名重复的问题，那就糟糕了，会出现函数被覆盖，导致不必要的工作量。所以可以采用下面的方式（用对象来收编方法，变量）\n\n```javascript\nvar GetUserInfo= {\n    getName:function(){\n        //get name here\n    },\n    getAge :function(){\n        //get age here\n    }\n}\n//或者像下面这样\nvar GetUserInfo= function(){};\nGetUserInfo.getName = function(){\n //get name here\n},\nGetUserInfo.getAge = function(){\n //get age here\n }\n\n```\n\n但是上面方法，还有个问题，就是这个对象不能复制，比如我只想使用里面的getUserInfo.getAge()这个方法，但是没有办法复制一个这样的对象来给自己使用，除非代码全部拷贝一遍，这无疑徒增了代码量，所以我们可以采用return来返回一个新的函数对象，如下\n\n```javascript\nvar GetUserInfo= function(){\n return {\n     getName :function(){\n         //get name here\n     },\n     getAge : function(){\n         //get age here\n     }\n }\n}\n```\n\n这样我们就可以安心复制getUserInfo其中的某个方法来为自己所用了,使用方法如下\n\n```javascript\nvar getUserInfo_myself = GetUserInfo()\ngetUserInfo_myself.getName()\n```\n\n上面的方法虽然可以完美达到我们的要求，但是编程最重要的是什么？当然时面向对象！我们来回顾一下面向对象的三个基本特征：封装、继承、多态。\n\n封装：类其实就是保存了一个函数的变量，这个函数有自己的属性和方法。将属性和方法组成一个类的过程就是封装。\n\n所以要实现封装，我们就得用JS实现一个类\n\n```javascript\n//ES5\nvar GetUserInfo= function(){\n    this.getName = function(){\n         //get name here\n     },\n     this.getAge = function(){\n         //get age here\n     },\n}\n//this的指向简单理解就是函数被调用时的执行环境，也可以说时谁调用该函数，this就指向谁\n//这里this就指向getUserInfo_myself\n\n```\n\n上面的代码（构造函数）就实现了一个类（函数，有自己的属性，有自己的方法）\n\n调用时，我们就不能var getUserInfo_myself = GetUserInfo()这样来用了。要像下面这样\n\n```javascript\nvar getUserInfo_myself = new GetUserInfo()\ngetUserInfo_myself()\n```\n\n以为这样就结束？这还不算是最好的方案，因为通过new来创建新对象的时候，新创建的对象都会复制一次this的属性，用多了就会造成很多消耗，我们可以避免吗？可以！通过原型的方式来实现，看下面\n\n```javascript\n//ES5方法一\nvar GetUserInfo=function(){};\nGetUserInfo.prototype.getName={\n    //get name here\n}\nGetUserInfo.prototype.getAge={\n  //get age here\n}\n//ES5方法二\nvar GetUserInfo=function(){};\nGetUserInfo.prototype={\n    getName(){\n     //get name here\n    }\n    getAge(){\n     //get agehere\n     }\n}\n\n//用ES6的语法\nclass GetUserInfo{\n constructor(){}\n getName(){\n //get name here\n }\n getAge(){\n //get age here\n }\n}\n\n```\n\n使用方法如下\n\n```javascript\nvar getUserInfo_myself = new GetUserInfo()\n// class方法必须使用new，否则会报错\ngetUserInfo_myself.getName()\ngetUserInfo_myself.getAge()\n```\n\n之前的例子中我们想要执行getName和getAge方法都要将对象getUserInfo_myself写两次，那我们就可以用链式调用来优化一下，那我们应该怎么做？看下面\n\n```javascript\n//创建对象的方式实现\nvar GetUserInfo= {\n getName: function(){\n console.log('getName')\n console.log(this)\n return this\n },\n getAge: function(){\n console.log('getAge')\n console.log(this)\n return this\n }\n}\nGetUserInfo.getName().getAge()\n//这里的this指向GetUserInfo，所以GetUserInfo.getName().getAge()其实就是这样执行的\n//1. GetUserInfo.getName() 返回this,this指向GetUserInfo，GetUserInfo有两个方法getName()和getAge()\n//2. this.getAge() 也就是 GetUserInfo.getAge()\n\n//原型的方式实现\nvar GetUserInfo = function(){}\nGetUserInfo.prototype={\n    getName(){\n         //get name here\n         return this\n     }\n     getAge(){\n         //get agehere\n         return this\n     }\n}\n```\n>我是Harry,Destiny is all\n\n\n\n","slug":"Javascript设计模式学习1（热身篇）","published":1,"updated":"2019-04-10T02:31:49.101Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzki10004jgf2f0egjuki","content":"<h4 id=\"从创建一个函数开始\"><a href=\"#从创建一个函数开始\" class=\"headerlink\" title=\"从创建一个函数开始\"></a>从创建一个函数开始</h4><p>函数的创建有很多形式，通常我们会采用以下做法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getName</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//get name here</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAge</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">//get age here</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//get name here</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> getAge= <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">//get age here</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是这种做法有个弊端，这类函数因为都是全局变量，所以在团队合作，或者项目函数很多时就会出现函数命名重复的问题，那就糟糕了，会出现函数被覆盖，导致不必要的工作量。所以可以采用下面的方式（用对象来收编方法，变量）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> GetUserInfo= &#123;</span><br><span class=\"line\">    getName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//get name here</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getAge :<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//get age here</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//或者像下面这样</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> GetUserInfo= <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">GetUserInfo.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">//get name here</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">GetUserInfo.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">//get age here</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>但是上面方法，还有个问题，就是这个对象不能复制，比如我只想使用里面的getUserInfo.getAge()这个方法，但是没有办法复制一个这样的对象来给自己使用，除非代码全部拷贝一遍，这无疑徒增了代码量，所以我们可以采用return来返回一个新的函数对象，如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> GetUserInfo= <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">     getName :<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">//get name here</span></span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     getAge : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">//get age here</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们就可以安心复制getUserInfo其中的某个方法来为自己所用了,使用方法如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getUserInfo_myself = GetUserInfo()</span><br><span class=\"line\">getUserInfo_myself.getName()</span><br></pre></td></tr></table></figure>\n<p>上面的方法虽然可以完美达到我们的要求，但是编程最重要的是什么？当然时面向对象！我们来回顾一下面向对象的三个基本特征：封装、继承、多态。</p>\n<p>封装：类其实就是保存了一个函数的变量，这个函数有自己的属性和方法。将属性和方法组成一个类的过程就是封装。</p>\n<p>所以要实现封装，我们就得用JS实现一个类</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ES5</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> GetUserInfo= <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">//get name here</span></span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">//get age here</span></span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//this的指向简单理解就是函数被调用时的执行环境，也可以说时谁调用该函数，this就指向谁</span></span><br><span class=\"line\"><span class=\"comment\">//这里this就指向getUserInfo_myself</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码（构造函数）就实现了一个类（函数，有自己的属性，有自己的方法）</p>\n<p>调用时，我们就不能var getUserInfo_myself = GetUserInfo()这样来用了。要像下面这样</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getUserInfo_myself = <span class=\"keyword\">new</span> GetUserInfo()</span><br><span class=\"line\">getUserInfo_myself()</span><br></pre></td></tr></table></figure>\n<p>以为这样就结束？这还不算是最好的方案，因为通过new来创建新对象的时候，新创建的对象都会复制一次this的属性，用多了就会造成很多消耗，我们可以避免吗？可以！通过原型的方式来实现，看下面</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ES5方法一</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> GetUserInfo=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">GetUserInfo.prototype.getName=&#123;</span><br><span class=\"line\">    <span class=\"comment\">//get name here</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">GetUserInfo.prototype.getAge=&#123;</span><br><span class=\"line\">  <span class=\"comment\">//get age here</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//ES5方法二</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> GetUserInfo=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">GetUserInfo.prototype=&#123;</span><br><span class=\"line\">    getName()&#123;</span><br><span class=\"line\">     <span class=\"comment\">//get name here</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getAge()&#123;</span><br><span class=\"line\">     <span class=\"comment\">//get agehere</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用ES6的语法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GetUserInfo</span></span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">constructor</span>()&#123;&#125;</span><br><span class=\"line\"> getName()&#123;</span><br><span class=\"line\"> <span class=\"comment\">//get name here</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> getAge()&#123;</span><br><span class=\"line\"> <span class=\"comment\">//get age here</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用方法如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getUserInfo_myself = <span class=\"keyword\">new</span> GetUserInfo()</span><br><span class=\"line\"><span class=\"comment\">// class方法必须使用new，否则会报错</span></span><br><span class=\"line\">getUserInfo_myself.getName()</span><br><span class=\"line\">getUserInfo_myself.getAge()</span><br></pre></td></tr></table></figure>\n<p>之前的例子中我们想要执行getName和getAge方法都要将对象getUserInfo_myself写两次，那我们就可以用链式调用来优化一下，那我们应该怎么做？看下面</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建对象的方式实现</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> GetUserInfo= &#123;</span><br><span class=\"line\"> getName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'getName'</span>)</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> getAge: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'getAge'</span>)</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">GetUserInfo.getName().getAge()</span><br><span class=\"line\"><span class=\"comment\">//这里的this指向GetUserInfo，所以GetUserInfo.getName().getAge()其实就是这样执行的</span></span><br><span class=\"line\"><span class=\"comment\">//1. GetUserInfo.getName() 返回this,this指向GetUserInfo，GetUserInfo有两个方法getName()和getAge()</span></span><br><span class=\"line\"><span class=\"comment\">//2. this.getAge() 也就是 GetUserInfo.getAge()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//原型的方式实现</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> GetUserInfo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">GetUserInfo.prototype=&#123;</span><br><span class=\"line\">    getName()&#123;</span><br><span class=\"line\">         <span class=\"comment\">//get name here</span></span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     getAge()&#123;</span><br><span class=\"line\">         <span class=\"comment\">//get agehere</span></span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>我是Harry,Destiny is all</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"从创建一个函数开始\"><a href=\"#从创建一个函数开始\" class=\"headerlink\" title=\"从创建一个函数开始\"></a>从创建一个函数开始</h4><p>函数的创建有很多形式，通常我们会采用以下做法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getName</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//get name here</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAge</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">//get age here</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//get name here</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> getAge= <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">//get age here</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是这种做法有个弊端，这类函数因为都是全局变量，所以在团队合作，或者项目函数很多时就会出现函数命名重复的问题，那就糟糕了，会出现函数被覆盖，导致不必要的工作量。所以可以采用下面的方式（用对象来收编方法，变量）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> GetUserInfo= &#123;</span><br><span class=\"line\">    getName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//get name here</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getAge :<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//get age here</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//或者像下面这样</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> GetUserInfo= <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">GetUserInfo.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">//get name here</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">GetUserInfo.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">//get age here</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>但是上面方法，还有个问题，就是这个对象不能复制，比如我只想使用里面的getUserInfo.getAge()这个方法，但是没有办法复制一个这样的对象来给自己使用，除非代码全部拷贝一遍，这无疑徒增了代码量，所以我们可以采用return来返回一个新的函数对象，如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> GetUserInfo= <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">     getName :<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">//get name here</span></span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     getAge : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">//get age here</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们就可以安心复制getUserInfo其中的某个方法来为自己所用了,使用方法如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getUserInfo_myself = GetUserInfo()</span><br><span class=\"line\">getUserInfo_myself.getName()</span><br></pre></td></tr></table></figure>\n<p>上面的方法虽然可以完美达到我们的要求，但是编程最重要的是什么？当然时面向对象！我们来回顾一下面向对象的三个基本特征：封装、继承、多态。</p>\n<p>封装：类其实就是保存了一个函数的变量，这个函数有自己的属性和方法。将属性和方法组成一个类的过程就是封装。</p>\n<p>所以要实现封装，我们就得用JS实现一个类</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ES5</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> GetUserInfo= <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">//get name here</span></span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">//get age here</span></span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//this的指向简单理解就是函数被调用时的执行环境，也可以说时谁调用该函数，this就指向谁</span></span><br><span class=\"line\"><span class=\"comment\">//这里this就指向getUserInfo_myself</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码（构造函数）就实现了一个类（函数，有自己的属性，有自己的方法）</p>\n<p>调用时，我们就不能var getUserInfo_myself = GetUserInfo()这样来用了。要像下面这样</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getUserInfo_myself = <span class=\"keyword\">new</span> GetUserInfo()</span><br><span class=\"line\">getUserInfo_myself()</span><br></pre></td></tr></table></figure>\n<p>以为这样就结束？这还不算是最好的方案，因为通过new来创建新对象的时候，新创建的对象都会复制一次this的属性，用多了就会造成很多消耗，我们可以避免吗？可以！通过原型的方式来实现，看下面</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ES5方法一</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> GetUserInfo=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">GetUserInfo.prototype.getName=&#123;</span><br><span class=\"line\">    <span class=\"comment\">//get name here</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">GetUserInfo.prototype.getAge=&#123;</span><br><span class=\"line\">  <span class=\"comment\">//get age here</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//ES5方法二</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> GetUserInfo=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">GetUserInfo.prototype=&#123;</span><br><span class=\"line\">    getName()&#123;</span><br><span class=\"line\">     <span class=\"comment\">//get name here</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getAge()&#123;</span><br><span class=\"line\">     <span class=\"comment\">//get agehere</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用ES6的语法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GetUserInfo</span></span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">constructor</span>()&#123;&#125;</span><br><span class=\"line\"> getName()&#123;</span><br><span class=\"line\"> <span class=\"comment\">//get name here</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> getAge()&#123;</span><br><span class=\"line\"> <span class=\"comment\">//get age here</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用方法如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getUserInfo_myself = <span class=\"keyword\">new</span> GetUserInfo()</span><br><span class=\"line\"><span class=\"comment\">// class方法必须使用new，否则会报错</span></span><br><span class=\"line\">getUserInfo_myself.getName()</span><br><span class=\"line\">getUserInfo_myself.getAge()</span><br></pre></td></tr></table></figure>\n<p>之前的例子中我们想要执行getName和getAge方法都要将对象getUserInfo_myself写两次，那我们就可以用链式调用来优化一下，那我们应该怎么做？看下面</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建对象的方式实现</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> GetUserInfo= &#123;</span><br><span class=\"line\"> getName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'getName'</span>)</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> getAge: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'getAge'</span>)</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">GetUserInfo.getName().getAge()</span><br><span class=\"line\"><span class=\"comment\">//这里的this指向GetUserInfo，所以GetUserInfo.getName().getAge()其实就是这样执行的</span></span><br><span class=\"line\"><span class=\"comment\">//1. GetUserInfo.getName() 返回this,this指向GetUserInfo，GetUserInfo有两个方法getName()和getAge()</span></span><br><span class=\"line\"><span class=\"comment\">//2. this.getAge() 也就是 GetUserInfo.getAge()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//原型的方式实现</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> GetUserInfo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">GetUserInfo.prototype=&#123;</span><br><span class=\"line\">    getName()&#123;</span><br><span class=\"line\">         <span class=\"comment\">//get name here</span></span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     getAge()&#123;</span><br><span class=\"line\">         <span class=\"comment\">//get agehere</span></span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>我是Harry,Destiny is all</p>\n</blockquote>\n"},{"title":"Javascript设计模式学习2（热身篇）","date":"2019-01-08T06:19:27.000Z","_content":"### 面向对象编程\n\n","source":"_posts/Javascript设计模式学习2（热身篇）.md","raw":"---\ntitle: Javascript设计模式学习2（热身篇）\ndate: 2019-01-08 14:19:27\ntags:\n---\n### 面向对象编程\n\n","slug":"Javascript设计模式学习2（热身篇）","published":1,"updated":"2019-04-10T02:31:49.106Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzki20005jgf2je6os9ql","content":"<h3 id=\"面向对象编程\"><a href=\"#面向对象编程\" class=\"headerlink\" title=\"面向对象编程\"></a>面向对象编程</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"面向对象编程\"><a href=\"#面向对象编程\" class=\"headerlink\" title=\"面向对象编程\"></a>面向对象编程</h3>"},{"title":"MySQL8.0.12--secure-file-priv数据导出问题解决","date":"2018-12-20T06:10:03.000Z","_content":"想在mysql里导入和导出数据，因为navicat在万条以上数据导出时有概率会出现卡死，重启的状况，所有只能采用命令窗口里操作，但是苍天没饶过我\n\n在mysql shell里面导入和导出时提示以下错误\n\n![](https://user-gold-cdn.xitu.io/2018/12/21/167cf3288e3368ef?w=956&h=88&f=png&s=9526)\n```\n The MySQL server is running with the --secure-file-priv option so it cannot execute this statement\n```\n别慌，我们能赢，在百度了诸多方案，在被像皮球一样踢来踢去中，我！终于找到了解决方案。下面开始：\n\n1. 进入mysql，输入\n```\nshow global variables like '%secure%';\n```\n\n2. 看到如下\n![](https://user-gold-cdn.xitu.io/2018/12/21/167cf34fe44d3924?w=370&h=123&f=png&s=4823)\n就是介个Null在不让我们导出数据\n\n3. 找到my.ini（我是windows.linux或者其他可能时my.conf）文件，新增一条\n```\nsecure_file_priv=\n```\n记住，等于后后面别加东西比较稳\n4.执行语句\n```\n select * into outfile 'C:\\aaa.xlsx' FROM table1 WHERE name is null;\n```\n5. 下个everything去寻找aaa.xlsx这个文件吧","source":"_posts/MySQL8-0-12-secure-file-priv数据导出问题解决.md","raw":"---\ntitle: MySQL8.0.12--secure-file-priv数据导出问题解决\ndate: 2018-12-20 14:10:03\ntags:\n---\n想在mysql里导入和导出数据，因为navicat在万条以上数据导出时有概率会出现卡死，重启的状况，所有只能采用命令窗口里操作，但是苍天没饶过我\n\n在mysql shell里面导入和导出时提示以下错误\n\n![](https://user-gold-cdn.xitu.io/2018/12/21/167cf3288e3368ef?w=956&h=88&f=png&s=9526)\n```\n The MySQL server is running with the --secure-file-priv option so it cannot execute this statement\n```\n别慌，我们能赢，在百度了诸多方案，在被像皮球一样踢来踢去中，我！终于找到了解决方案。下面开始：\n\n1. 进入mysql，输入\n```\nshow global variables like '%secure%';\n```\n\n2. 看到如下\n![](https://user-gold-cdn.xitu.io/2018/12/21/167cf34fe44d3924?w=370&h=123&f=png&s=4823)\n就是介个Null在不让我们导出数据\n\n3. 找到my.ini（我是windows.linux或者其他可能时my.conf）文件，新增一条\n```\nsecure_file_priv=\n```\n记住，等于后后面别加东西比较稳\n4.执行语句\n```\n select * into outfile 'C:\\aaa.xlsx' FROM table1 WHERE name is null;\n```\n5. 下个everything去寻找aaa.xlsx这个文件吧","slug":"MySQL8-0-12-secure-file-priv数据导出问题解决","published":1,"updated":"2019-04-10T02:31:49.110Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzki30006jgf2almfwdf0","content":"<p>想在mysql里导入和导出数据，因为navicat在万条以上数据导出时有概率会出现卡死，重启的状况，所有只能采用命令窗口里操作，但是苍天没饶过我</p>\n<p>在mysql shell里面导入和导出时提示以下错误</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf3288e3368ef?w=956&amp;h=88&amp;f=png&amp;s=9526\" alt=\"\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The MySQL server is running with the --secure-file-priv option so it cannot execute this statement</span><br></pre></td></tr></table></figure></p>\n<p>别慌，我们能赢，在百度了诸多方案，在被像皮球一样踢来踢去中，我！终于找到了解决方案。下面开始：</p>\n<ol>\n<li><p>进入mysql，输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show global variables like &apos;%secure%&apos;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>看到如下<br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf34fe44d3924?w=370&amp;h=123&amp;f=png&amp;s=4823\" alt=\"\"><br>就是介个Null在不让我们导出数据</p>\n</li>\n<li><p>找到my.ini（我是windows.linux或者其他可能时my.conf）文件，新增一条</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">secure_file_priv=</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>记住，等于后后面别加东西比较稳<br>4.执行语句<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * into outfile &apos;C:\\aaa.xlsx&apos; FROM table1 WHERE name is null;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"5\">\n<li>下个everything去寻找aaa.xlsx这个文件吧</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>想在mysql里导入和导出数据，因为navicat在万条以上数据导出时有概率会出现卡死，重启的状况，所有只能采用命令窗口里操作，但是苍天没饶过我</p>\n<p>在mysql shell里面导入和导出时提示以下错误</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf3288e3368ef?w=956&amp;h=88&amp;f=png&amp;s=9526\" alt=\"\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The MySQL server is running with the --secure-file-priv option so it cannot execute this statement</span><br></pre></td></tr></table></figure></p>\n<p>别慌，我们能赢，在百度了诸多方案，在被像皮球一样踢来踢去中，我！终于找到了解决方案。下面开始：</p>\n<ol>\n<li><p>进入mysql，输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show global variables like &apos;%secure%&apos;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>看到如下<br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf34fe44d3924?w=370&amp;h=123&amp;f=png&amp;s=4823\" alt=\"\"><br>就是介个Null在不让我们导出数据</p>\n</li>\n<li><p>找到my.ini（我是windows.linux或者其他可能时my.conf）文件，新增一条</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">secure_file_priv=</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>记住，等于后后面别加东西比较稳<br>4.执行语句<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * into outfile &apos;C:\\aaa.xlsx&apos; FROM table1 WHERE name is null;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"5\">\n<li>下个everything去寻找aaa.xlsx这个文件吧</li>\n</ol>\n"},{"title":"React学习笔记","date":"2019-02-26T06:39:32.000Z","_content":"1. React是一种  声明式   高效 灵活 构建用户界面的框架\n\n2. 组件 ：React.Component{}\n\n3. 组件是接受 名为 props的参数 {this.props.name}， 即 当前组件被应用时， 传入的各个数据，包括事件等；\n\n4.render返回的是一个React元素 ：渲染内容的描述   一般使用JSX语法来扩展  ： <div /> -----> React.createElement(\"div\")\n\n5.通过 <ShoppingList /> 这样的标签你就可以在 React 当中调用整个 ShoppingList 组件\n\n6. 添加样式用  className = \"aaaa\",  事件： onClick={ () => alert(\"click\")}\n\n7.  this.state 为自身设置自身的状态数据，  存储变化的数据\n\n8. this.setState 用于设置 值 ，每次触发时都会开始准备更新组件 跟随数据改变了的内容。\n\n状态提升：\n\n9.  子组件的state数据提升至共同的 父组件 中保存。然后 父组件 通过Props  将 状态 数据传递到子组件中     ------>  方便状态数据共享交流\n\n10.  key React当中使用的一种特殊的属性，(以及ref属性)，无法通过props获取到key，React会自动判断元素更新时使用key，而组件自己无法获取到key的。\n组件key值被改变就会被当作新创建的组件处理。 \n组件的 keys 值并不需要在全局都保证唯一，只需要在当前的节点里保证唯一即可\n\n\n二.Redux\n概念：\n（1）Web 应用是一个状态机，视图与状态是一一对应的。\n\n（2）所有的状态，保存在一个对象里面。\n\nStore:\n保存数据的地方，看成一个容器， 整个应用只能有一个store\n\n提供的方法函数： createStore，用于生成store，接受了另一个函数参数，返回新生成的store对象\n例：import { createStore } from 'redux';\n   const store = createStore(fn);\nState：\n时点的数据集合叫做 State， 如，当前时刻的 State，通过 store.getState() 拿到\nimport { createStore } from 'redux';\nconst store = createStore(fn);\nconst state = store.getState();\nRedux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。\n\n\nAction：\nAction 就是 View 发出的通知，表示 State 应该要发生变化了\nAction 是一个对象。其中的type属性是必须的。表示Action 的名称。其他属性可以自由设置，\nconst action = {\n  type: 'ADD_TODO',\n  payload: 'Learn Redux'\n};\n可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。\n\n\nAction Creator:\nView 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。\n\n例：\nconst ADD_TODO = '添加 TODO';\n\nfunction addTodo(text) {\n  return {\n    type: ADD_TODO,\n    text\n  }\n}\n\nconst action =addTodo('Learn Redux');\n\n\n\nstore.dispatch()：\n\nstore.dispatch()是 View 发出 Action 的唯一方法。\nstore.dispatch接受一个 Action 对象作为参数，将它发送出去\nstore.dispatch(addTodo('Learn Redux'));\n\n\nReducer：\nStore 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。\n例：\n\nconst defaultState = 0;\nconst reducer = (state = defaultState, action) => {\n  switch (action.type) {\n    case 'ADD':\n      return state + action.payload;\n    default: \n      return state;\n  }};\n\nconst state = reducer(1, {\n  type: 'ADD',\n  payload: 2});\n\n\ncreateStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。\n例：\n\nconst actions = [\n  { type: 'ADD', payload: 0 },\n  { type: 'ADD', payload: 1 },\n  { type: 'ADD', payload: 2 }];\n\nconst total = actions.reduce(reducer, 0); // 3\n\n\n纯函数： 只要是同样的输入，必定得到同样的输出。\n\n\nstore.subscribe()：\n方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。\n例：\n\nimport { createStore } from 'redux';\nconst store = createStore(reducer);\n\nstore.subscribe(listener);\n\n\n只要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染。\nstore.subscribe方法返回一个函数，调用这个函数就可以解除监听。\n\n\nReducer 的拆分：\ncombinReducers:用于 Reducer 的拆分。你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer。\n例：\n\nimport { combineReducers } from 'redux';\n\nconst chatReducer = combineReducers({\n  chatLog,\n  statusMessage,\n  userName\n})\n\nexport default todoApp;\nState 的属性名必须与子 Reducer 同名\n\n\n不同名的写法：\n\nconst reducer = combineReducers({\n  a: doSomethingWithA,\n  b: processB,\n  c: c\n})\n// 等同于\nfunction reducer(state = {}, action) {\n  return {\n    a: doSomethingWithA(state.a, action),\n    b: processB(state.b, action),\n    c: c(state.c, action)\n  }}\n\n\n可以把所有子 Reducer 放在一个文件里面，然后统一引入。\n\n\n\n\n\nimport { combineReducers } from 'redux'\nimport * as reducers from './reducers'\n\nconst reducer = combineReducers(reducers)\n\n\nRedux流程：\n1.用户发出Action--> stroe.dispatch(action);\n2.store自动调用Reducer,传入（当前state，action），返回新的State。\n例： let nextState = todoApp（previousState，action）；\n\n3.state发生变化，store会调用监听函数。：\n\n例：stroe.subscribe(listener);\n\nlistener可以通过 store.getStore() 得到当前状态，react此时会触发重新渲染view； \n\n例：\n\n\n\nfunction listerner() {\n  let newState = store.getState();\n  component.setState(newState);   \n}\n\n","source":"_posts/React学习笔记.md","raw":"---\ntitle: React学习笔记\ndate: 2019-02-26 14:39:32\ntags:\n---\n1. React是一种  声明式   高效 灵活 构建用户界面的框架\n\n2. 组件 ：React.Component{}\n\n3. 组件是接受 名为 props的参数 {this.props.name}， 即 当前组件被应用时， 传入的各个数据，包括事件等；\n\n4.render返回的是一个React元素 ：渲染内容的描述   一般使用JSX语法来扩展  ： <div /> -----> React.createElement(\"div\")\n\n5.通过 <ShoppingList /> 这样的标签你就可以在 React 当中调用整个 ShoppingList 组件\n\n6. 添加样式用  className = \"aaaa\",  事件： onClick={ () => alert(\"click\")}\n\n7.  this.state 为自身设置自身的状态数据，  存储变化的数据\n\n8. this.setState 用于设置 值 ，每次触发时都会开始准备更新组件 跟随数据改变了的内容。\n\n状态提升：\n\n9.  子组件的state数据提升至共同的 父组件 中保存。然后 父组件 通过Props  将 状态 数据传递到子组件中     ------>  方便状态数据共享交流\n\n10.  key React当中使用的一种特殊的属性，(以及ref属性)，无法通过props获取到key，React会自动判断元素更新时使用key，而组件自己无法获取到key的。\n组件key值被改变就会被当作新创建的组件处理。 \n组件的 keys 值并不需要在全局都保证唯一，只需要在当前的节点里保证唯一即可\n\n\n二.Redux\n概念：\n（1）Web 应用是一个状态机，视图与状态是一一对应的。\n\n（2）所有的状态，保存在一个对象里面。\n\nStore:\n保存数据的地方，看成一个容器， 整个应用只能有一个store\n\n提供的方法函数： createStore，用于生成store，接受了另一个函数参数，返回新生成的store对象\n例：import { createStore } from 'redux';\n   const store = createStore(fn);\nState：\n时点的数据集合叫做 State， 如，当前时刻的 State，通过 store.getState() 拿到\nimport { createStore } from 'redux';\nconst store = createStore(fn);\nconst state = store.getState();\nRedux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。\n\n\nAction：\nAction 就是 View 发出的通知，表示 State 应该要发生变化了\nAction 是一个对象。其中的type属性是必须的。表示Action 的名称。其他属性可以自由设置，\nconst action = {\n  type: 'ADD_TODO',\n  payload: 'Learn Redux'\n};\n可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。\n\n\nAction Creator:\nView 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。\n\n例：\nconst ADD_TODO = '添加 TODO';\n\nfunction addTodo(text) {\n  return {\n    type: ADD_TODO,\n    text\n  }\n}\n\nconst action =addTodo('Learn Redux');\n\n\n\nstore.dispatch()：\n\nstore.dispatch()是 View 发出 Action 的唯一方法。\nstore.dispatch接受一个 Action 对象作为参数，将它发送出去\nstore.dispatch(addTodo('Learn Redux'));\n\n\nReducer：\nStore 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。\n例：\n\nconst defaultState = 0;\nconst reducer = (state = defaultState, action) => {\n  switch (action.type) {\n    case 'ADD':\n      return state + action.payload;\n    default: \n      return state;\n  }};\n\nconst state = reducer(1, {\n  type: 'ADD',\n  payload: 2});\n\n\ncreateStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。\n例：\n\nconst actions = [\n  { type: 'ADD', payload: 0 },\n  { type: 'ADD', payload: 1 },\n  { type: 'ADD', payload: 2 }];\n\nconst total = actions.reduce(reducer, 0); // 3\n\n\n纯函数： 只要是同样的输入，必定得到同样的输出。\n\n\nstore.subscribe()：\n方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。\n例：\n\nimport { createStore } from 'redux';\nconst store = createStore(reducer);\n\nstore.subscribe(listener);\n\n\n只要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染。\nstore.subscribe方法返回一个函数，调用这个函数就可以解除监听。\n\n\nReducer 的拆分：\ncombinReducers:用于 Reducer 的拆分。你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer。\n例：\n\nimport { combineReducers } from 'redux';\n\nconst chatReducer = combineReducers({\n  chatLog,\n  statusMessage,\n  userName\n})\n\nexport default todoApp;\nState 的属性名必须与子 Reducer 同名\n\n\n不同名的写法：\n\nconst reducer = combineReducers({\n  a: doSomethingWithA,\n  b: processB,\n  c: c\n})\n// 等同于\nfunction reducer(state = {}, action) {\n  return {\n    a: doSomethingWithA(state.a, action),\n    b: processB(state.b, action),\n    c: c(state.c, action)\n  }}\n\n\n可以把所有子 Reducer 放在一个文件里面，然后统一引入。\n\n\n\n\n\nimport { combineReducers } from 'redux'\nimport * as reducers from './reducers'\n\nconst reducer = combineReducers(reducers)\n\n\nRedux流程：\n1.用户发出Action--> stroe.dispatch(action);\n2.store自动调用Reducer,传入（当前state，action），返回新的State。\n例： let nextState = todoApp（previousState，action）；\n\n3.state发生变化，store会调用监听函数。：\n\n例：stroe.subscribe(listener);\n\nlistener可以通过 store.getStore() 得到当前状态，react此时会触发重新渲染view； \n\n例：\n\n\n\nfunction listerner() {\n  let newState = store.getState();\n  component.setState(newState);   \n}\n\n","slug":"React学习笔记","published":1,"updated":"2019-04-10T02:40:28.683Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzki40007jgf2k5tzt9gs","content":"<ol>\n<li><p>React是一种  声明式   高效 灵活 构建用户界面的框架</p>\n</li>\n<li><p>组件 ：React.Component{}</p>\n</li>\n<li><p>组件是接受 名为 props的参数 {this.props.name}， 即 当前组件被应用时， 传入的各个数据，包括事件等；</p>\n</li>\n</ol>\n<p>4.render返回的是一个React元素 ：渲染内容的描述   一般使用JSX语法来扩展  ： <div> —–&gt; React.createElement(“div”)</div></p>\n<p>5.通过 <shoppinglist> 这样的标签你就可以在 React 当中调用整个 ShoppingList 组件</shoppinglist></p>\n<ol start=\"6\">\n<li><p>添加样式用  className = “aaaa”,  事件： onClick={ () =&gt; alert(“click”)}</p>\n</li>\n<li><p>this.state 为自身设置自身的状态数据，  存储变化的数据</p>\n</li>\n<li><p>this.setState 用于设置 值 ，每次触发时都会开始准备更新组件 跟随数据改变了的内容。</p>\n</li>\n</ol>\n<p>状态提升：</p>\n<ol start=\"9\">\n<li><p>子组件的state数据提升至共同的 父组件 中保存。然后 父组件 通过Props  将 状态 数据传递到子组件中     ——&gt;  方便状态数据共享交流</p>\n</li>\n<li><p>key React当中使用的一种特殊的属性，(以及ref属性)，无法通过props获取到key，React会自动判断元素更新时使用key，而组件自己无法获取到key的。<br>组件key值被改变就会被当作新创建的组件处理。<br>组件的 keys 值并不需要在全局都保证唯一，只需要在当前的节点里保证唯一即可</p>\n</li>\n</ol>\n<p>二.Redux<br>概念：<br>（1）Web 应用是一个状态机，视图与状态是一一对应的。</p>\n<p>（2）所有的状态，保存在一个对象里面。</p>\n<p>Store:<br>保存数据的地方，看成一个容器， 整个应用只能有一个store</p>\n<p>提供的方法函数： createStore，用于生成store，接受了另一个函数参数，返回新生成的store对象<br>例：import { createStore } from ‘redux’;<br>   const store = createStore(fn);<br>State：<br>时点的数据集合叫做 State， 如，当前时刻的 State，通过 store.getState() 拿到<br>import { createStore } from ‘redux’;<br>const store = createStore(fn);<br>const state = store.getState();<br>Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。</p>\n<p>Action：<br>Action 就是 View 发出的通知，表示 State 应该要发生变化了<br>Action 是一个对象。其中的type属性是必须的。表示Action 的名称。其他属性可以自由设置，<br>const action = {<br>  type: ‘ADD_TODO’,<br>  payload: ‘Learn Redux’<br>};<br>可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。</p>\n<p>Action Creator:<br>View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。</p>\n<p>例：<br>const ADD_TODO = ‘添加 TODO’;</p>\n<p>function addTodo(text) {<br>  return {<br>    type: ADD_TODO,<br>    text<br>  }<br>}</p>\n<p>const action =addTodo(‘Learn Redux’);</p>\n<p>store.dispatch()：</p>\n<p>store.dispatch()是 View 发出 Action 的唯一方法。<br>store.dispatch接受一个 Action 对象作为参数，将它发送出去<br>store.dispatch(addTodo(‘Learn Redux’));</p>\n<p>Reducer：<br>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。<br>例：</p>\n<p>const defaultState = 0;<br>const reducer = (state = defaultState, action) =&gt; {<br>  switch (action.type) {<br>    case ‘ADD’:<br>      return state + action.payload;<br>    default:<br>      return state;<br>  }};</p>\n<p>const state = reducer(1, {<br>  type: ‘ADD’,<br>  payload: 2});</p>\n<p>createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。<br>例：</p>\n<p>const actions = [<br>  { type: ‘ADD’, payload: 0 },<br>  { type: ‘ADD’, payload: 1 },<br>  { type: ‘ADD’, payload: 2 }];</p>\n<p>const total = actions.reduce(reducer, 0); // 3</p>\n<p>纯函数： 只要是同样的输入，必定得到同样的输出。</p>\n<p>store.subscribe()：<br>方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。<br>例：</p>\n<p>import { createStore } from ‘redux’;<br>const store = createStore(reducer);</p>\n<p>store.subscribe(listener);</p>\n<p>只要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染。<br>store.subscribe方法返回一个函数，调用这个函数就可以解除监听。</p>\n<p>Reducer 的拆分：<br>combinReducers:用于 Reducer 的拆分。你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer。<br>例：</p>\n<p>import { combineReducers } from ‘redux’;</p>\n<p>const chatReducer = combineReducers({<br>  chatLog,<br>  statusMessage,<br>  userName<br>})</p>\n<p>export default todoApp;<br>State 的属性名必须与子 Reducer 同名</p>\n<p>不同名的写法：</p>\n<p>const reducer = combineReducers({<br>  a: doSomethingWithA,<br>  b: processB,<br>  c: c<br>})<br>// 等同于<br>function reducer(state = {}, action) {<br>  return {<br>    a: doSomethingWithA(state.a, action),<br>    b: processB(state.b, action),<br>    c: c(state.c, action)<br>  }}</p>\n<p>可以把所有子 Reducer 放在一个文件里面，然后统一引入。</p>\n<p>import { combineReducers } from ‘redux’<br>import * as reducers from ‘./reducers’</p>\n<p>const reducer = combineReducers(reducers)</p>\n<p>Redux流程：<br>1.用户发出Action–&gt; stroe.dispatch(action);<br>2.store自动调用Reducer,传入（当前state，action），返回新的State。<br>例： let nextState = todoApp（previousState，action）；</p>\n<p>3.state发生变化，store会调用监听函数。：</p>\n<p>例：stroe.subscribe(listener);</p>\n<p>listener可以通过 store.getStore() 得到当前状态，react此时会触发重新渲染view； </p>\n<p>例：</p>\n<p>function listerner() {<br>  let newState = store.getState();<br>  component.setState(newState);<br>}</p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>React是一种  声明式   高效 灵活 构建用户界面的框架</p>\n</li>\n<li><p>组件 ：React.Component{}</p>\n</li>\n<li><p>组件是接受 名为 props的参数 {this.props.name}， 即 当前组件被应用时， 传入的各个数据，包括事件等；</p>\n</li>\n</ol>\n<p>4.render返回的是一个React元素 ：渲染内容的描述   一般使用JSX语法来扩展  ： <div> —–&gt; React.createElement(“div”)</div></p>\n<p>5.通过 <shoppinglist> 这样的标签你就可以在 React 当中调用整个 ShoppingList 组件</shoppinglist></p>\n<ol start=\"6\">\n<li><p>添加样式用  className = “aaaa”,  事件： onClick={ () =&gt; alert(“click”)}</p>\n</li>\n<li><p>this.state 为自身设置自身的状态数据，  存储变化的数据</p>\n</li>\n<li><p>this.setState 用于设置 值 ，每次触发时都会开始准备更新组件 跟随数据改变了的内容。</p>\n</li>\n</ol>\n<p>状态提升：</p>\n<ol start=\"9\">\n<li><p>子组件的state数据提升至共同的 父组件 中保存。然后 父组件 通过Props  将 状态 数据传递到子组件中     ——&gt;  方便状态数据共享交流</p>\n</li>\n<li><p>key React当中使用的一种特殊的属性，(以及ref属性)，无法通过props获取到key，React会自动判断元素更新时使用key，而组件自己无法获取到key的。<br>组件key值被改变就会被当作新创建的组件处理。<br>组件的 keys 值并不需要在全局都保证唯一，只需要在当前的节点里保证唯一即可</p>\n</li>\n</ol>\n<p>二.Redux<br>概念：<br>（1）Web 应用是一个状态机，视图与状态是一一对应的。</p>\n<p>（2）所有的状态，保存在一个对象里面。</p>\n<p>Store:<br>保存数据的地方，看成一个容器， 整个应用只能有一个store</p>\n<p>提供的方法函数： createStore，用于生成store，接受了另一个函数参数，返回新生成的store对象<br>例：import { createStore } from ‘redux’;<br>   const store = createStore(fn);<br>State：<br>时点的数据集合叫做 State， 如，当前时刻的 State，通过 store.getState() 拿到<br>import { createStore } from ‘redux’;<br>const store = createStore(fn);<br>const state = store.getState();<br>Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。</p>\n<p>Action：<br>Action 就是 View 发出的通知，表示 State 应该要发生变化了<br>Action 是一个对象。其中的type属性是必须的。表示Action 的名称。其他属性可以自由设置，<br>const action = {<br>  type: ‘ADD_TODO’,<br>  payload: ‘Learn Redux’<br>};<br>可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。</p>\n<p>Action Creator:<br>View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。</p>\n<p>例：<br>const ADD_TODO = ‘添加 TODO’;</p>\n<p>function addTodo(text) {<br>  return {<br>    type: ADD_TODO,<br>    text<br>  }<br>}</p>\n<p>const action =addTodo(‘Learn Redux’);</p>\n<p>store.dispatch()：</p>\n<p>store.dispatch()是 View 发出 Action 的唯一方法。<br>store.dispatch接受一个 Action 对象作为参数，将它发送出去<br>store.dispatch(addTodo(‘Learn Redux’));</p>\n<p>Reducer：<br>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。<br>例：</p>\n<p>const defaultState = 0;<br>const reducer = (state = defaultState, action) =&gt; {<br>  switch (action.type) {<br>    case ‘ADD’:<br>      return state + action.payload;<br>    default:<br>      return state;<br>  }};</p>\n<p>const state = reducer(1, {<br>  type: ‘ADD’,<br>  payload: 2});</p>\n<p>createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。<br>例：</p>\n<p>const actions = [<br>  { type: ‘ADD’, payload: 0 },<br>  { type: ‘ADD’, payload: 1 },<br>  { type: ‘ADD’, payload: 2 }];</p>\n<p>const total = actions.reduce(reducer, 0); // 3</p>\n<p>纯函数： 只要是同样的输入，必定得到同样的输出。</p>\n<p>store.subscribe()：<br>方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。<br>例：</p>\n<p>import { createStore } from ‘redux’;<br>const store = createStore(reducer);</p>\n<p>store.subscribe(listener);</p>\n<p>只要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染。<br>store.subscribe方法返回一个函数，调用这个函数就可以解除监听。</p>\n<p>Reducer 的拆分：<br>combinReducers:用于 Reducer 的拆分。你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer。<br>例：</p>\n<p>import { combineReducers } from ‘redux’;</p>\n<p>const chatReducer = combineReducers({<br>  chatLog,<br>  statusMessage,<br>  userName<br>})</p>\n<p>export default todoApp;<br>State 的属性名必须与子 Reducer 同名</p>\n<p>不同名的写法：</p>\n<p>const reducer = combineReducers({<br>  a: doSomethingWithA,<br>  b: processB,<br>  c: c<br>})<br>// 等同于<br>function reducer(state = {}, action) {<br>  return {<br>    a: doSomethingWithA(state.a, action),<br>    b: processB(state.b, action),<br>    c: c(state.c, action)<br>  }}</p>\n<p>可以把所有子 Reducer 放在一个文件里面，然后统一引入。</p>\n<p>import { combineReducers } from ‘redux’<br>import * as reducers from ‘./reducers’</p>\n<p>const reducer = combineReducers(reducers)</p>\n<p>Redux流程：<br>1.用户发出Action–&gt; stroe.dispatch(action);<br>2.store自动调用Reducer,传入（当前state，action），返回新的State。<br>例： let nextState = todoApp（previousState，action）；</p>\n<p>3.state发生变化，store会调用监听函数。：</p>\n<p>例：stroe.subscribe(listener);</p>\n<p>listener可以通过 store.getStore() 得到当前状态，react此时会触发重新渲染view； </p>\n<p>例：</p>\n<p>function listerner() {<br>  let newState = store.getState();<br>  component.setState(newState);<br>}</p>\n"},{"layout":"react","title":"React_V16入门手册","date":"2019-01-18T09:09:19.000Z","_content":"原文[https://medium.freecodecamp.org/the-react-handbook-b71c27b0a795]()\n\n开始着手学习React，就看到大佬推荐的这篇文章，因为是英文，就尽自己能力翻译一下有错的烦请指正。原文一共220页A4纸，内容有点多，所以会分期更新，见谅\n## 介绍\n这本React手册遵循二八原则：用20%的时间学习80%的内容\n\n在本手册里使用了React Hooks，所以你需要使用高于等于 16.7.0-alpha.2 版本的React和ReactDom.\n\n如果你使用create-react-app初始化项目时，在初始化项目之后运行``` npm install react@16.7.0-alpha.2 react-dom@16.7.0-\nalpha.2 ```\n\n我希望你能在你阅读完本手册后能达到一个目标：学会React的基础\n\n## React介绍\n先来介绍一下React库\n####  什么是React\nReact是一个旨在简化开发可视化界面的Javascript库。它由Facebook开发，并于2013年向世界发布，并支持着很多被广泛使用的App，包括Facebook和Instagram等无数应用程序。\n它的主要目标是通过将UI划分为一组组件，使得在任何时间点都可以轻松地构建界面及其状态。\n#### 为什么React这么流行？\nReact席卷了整个前端开发领域，为什么？\n\n#### 比其他框架更低的复杂性\n在React出道之前，Ember.js和Angular1.X是主流框架。这两种方法在代码上强加了太多的约定，以至于移植现有的应用程序一点都不方便。React选择了非常容易集成到现有项目中的方式，因为Facebook必须实现这一点，这样才能将其引入现有代码库。另外，这两个框架本身包含的内容太多了，而React只选择实现视图层而不是完整的MVC技术栈。\n#### 完美的时间\n当谷歌宣布Angular2.X时，宣称Angular1.X并不能平滑升级到Angular2.X，这两个就像不同的框架一样，所以想要从Angular1.X升级到Angular2.X就得重构项目。因为这一点，再加上React承诺说能带来执行速度的提升，所以很多程序员就迫不及待的尝试。\n#### Facebook的支持\n如果一个项目最终成功，得到Facebook的支持显然也会让它受益。Facebook目前对React非常感兴趣，并看到了它开源的价值，这对所有在自己项目中使用React的开发者来说都是一个巨大的优势。\n\n#### React学起来容易吗？\n虽然我说React要比其他框架简单，但是深入学习React的话还是挺有难度的，难的主要原因是要与React搭配使用的技术，比如Redux,GraphQL等等。\n\nReact本身有一个非常小的API，你至少需要理解4个概念才能开始:\n* Components\n* JSX\n* State\n* Props\n\n上面这些（甚至更多）都会在手册中一一解释\n\n## 如何安装React\n#### 如何在你的电脑上安装React?\nReact是一个库，所以说安装这个词会有点奇怪，倒不如说“设置”更贴切。在你的app或者网页中有很多方式可以设置React\n\n#### 直接在网页里引入\n最简单的方法是直接将React JavaScript文件添加到页面中。当React应用与单个页面上的元素进行交互，而不是实际控制整个导航时，这是最好的选择。\n\n下面的例子中，你在body的最后添加了两个script标签\n\n```\n<html>\n...\n    <body>\n    ...\n        <script\n        src=\"https://cdnjs.cloudflare.com/ajax/libs/react/16.7.0-alpha.2/umd/react.development.js\" \n        crossorigin>\n        </script>\n        <script\n        src=\"https://cdnjs.cloudflare.com/ajax/libs/react-dom/16.7.0-alpha.2/umd/react-dom.production.min.js\"\n        crossorigin>\n        </script>\n    </body>\n</html>\n```\n在这里我们引入两个库（React和React Dom），是为什么呢？因为React是百分之的独立于浏览器的，你也可以在浏览器之外使用React（比如用React Native开发移动应用时，也能用React），因此需要React Dom来操作dom。\n\n在引入Javascript文件后，你需要为react，在html里添加script标签，才能使用JSX语法，下面两种方式都可以\n```\n//在app.js里写JSX\n<script src=\"app.js\"></script>\n<!-- or -->\n\n//直接在标签内写JSX\n<script>\n//my app\n</script>\n\n```\n如果要使用JSX，你还需要引入Babel\n\n```\n<script src=\"https://unpkg.com/babel-standalone@6/babel.min.js\"></script>\n```\n引入后要在之前写的script标签里添加type=\"text/babel\"才会生效，如下：\n```\n<script src=\"app.js\" type=\"text/babel\"></script>\n\n```\n现在你可以在你的app.js里写JSX的代码了。\n\n```\nconst Button = () => {\nreturn <button>Click me!</button>\n}\nReactDOM.render(<Button />, document.getElementById('root'))\n\n```\n演示代码地址：\n[https://glitch.com/edit/#!/react-example-inline-jsx?path=index.html:21:19](演示代码)\n#### 用官方脚手架create-react-app（推荐）\ncreate-react-app旨在让你能快速构建一个React项目，任何React应用都可以使用create-react-app来生成一个单页页面。\n\n首先你需要安装npm和node （地址：[https://nodejs.org/en/]()）就不多说了\n然后执行\n\n```\nnpx create-react-app todolist\n```\nnpx是npm 5.2之后才有的工具，npx会下载create-react-app，然后解压安装，然后执行```create-react-app todolist```,然后再把create-react-app从系统中删除。这样你就永远能够使用最新的create-react-app，不会在电脑里存放着过时的create-react-app。\n\n执行完之后你能看到下面的界面\n\n![](https://user-gold-cdn.xitu.io/2019/1/18/168602568623fb3a?w=741&h=677&f=png&s=36167)\n\ncreate-react-app会在文件夹内创建相应的文件结构，文件名就是todolist（自己取的）\npackage.json也同样生成了，只需要安装指示，进入相应的文件夹，执行npm start就可以启动项目了\n\n如图\n\n![](https://user-gold-cdn.xitu.io/2019/1/18/168602a792310119?w=454&h=260&f=png&s=12615)\n\n打开浏览器进入http://localhost:3000/就能看到最开始的界面了。\n\n除了 npm start , create-react-app这两个命令之外，还有下面一些命令\n* npm run build ：要在构建文件夹中构建准备部署到服务器的React应用程序文件\n* npm test：运行Jest测试包\n* npm eject ：弹出配置文件 \n何时用npm eject？create-react-app已经做了很多工作了，但你想要完成更多的工作时，就要弹出配置文件来自己配置。\n\n\n因为create-react-app 是为了满足大部分人的需求和有限的配置，当你有一些独特的需求时，就需要自己来配置一些内容了。\n\n当你使用npm eject时，你的页面就不会自动更新了，但你可以在Babel和Webpack配置中获得更大的灵活性。\n\neject时是不可逆的，当你执行后你会获得两个新的文件夹，配置和脚本。你就可以开始自由的编辑他们了。\n\n> 下节预告：下节我们将学习在学习React之前需要了解的JS语法及一些知识\n\n## 使用React需要什么样的JS能力\n#### 在深入学习React之前找到你必须要掌握的内容\n如果你想学习React时，首先你需要做一些事情。您必须熟悉一些必要的技术，特别是你将在React中反复使用的一些最新JavaScript特性相关的技术。\n\n有些人以为一些功能是React提供的一些特定的功能，实际上它们只是Javascript最新的语法。\n\n立即掌握这些新语法，成为这方面的专家是不可能的，也没必要。但你如果想要深入研究React，那你就需要熟练掌握他们了。\n\n我会把它们列举下来让你快速了解一下。\n\n## 变量\n变量是分配给标识符的文字，因此您可以引用它并在后面的程序里使用它。学习如何用JavaScript声明一个。\n\nJavaScript中的变量没有附加任何类型。将特定的文字类型分配给变量后，可以稍后再给这个变量分配类型，而不会出现类型错误或任何问题。\n\n所以这就是为什么有时候Javascript会报'untyped'这样的问题。\n\n一个变量必须在你使用之前就声明。有三种方法可以做到这一点，使用var、let或const，这三种方法在以后与变量的交互方式上有所不同。\n\n#### 用Var\n知道ES2015，var一直都是定义变量的唯一方法。\n```\nvar a = 0\n```\n如果你忘了添加var，你给未声明的变量赋值，结果可能会有所不同，在严格模式下，会得到一个错误，在旧的环境，或者禁用严格模式下，就会使得该变量成为一个全局变量，赋值也自然会赋值给一个全局变量。\n\n如果你没有将变量初始化，那他的值就是undefined\n\n```\nvar a //typeof a === 'undefined'\n\n```\n你可以多次声明变量\n\n```\nvar a = 1\nvar a = 2\n```\n最重要的，你可以一次就声明多个变量\n\n```\nvar a = 1, b = 2\n```\n作用域是代码中变量可见的部分（有效）。在函数外部声明一个变量，变量就是全局的，所有的函数都可以获得该变量的值，但在函数内部声明一个变量，变量就是局部的，只有在该函数内才能获得该变量的值，就像函数的一个参数。\n\n在与全局变量同名的函数中定义的任何变量都优先于全局变量，并对其进行跟踪。\n\n重要的是要理解一个块(由一对花括号标识)没有定义一个新的作用域。新作用域只在创建函数时创建，因为var没有块作用域，而是函数作用域。\n\n函数内部,在函数的所有代码中，变量在任何位置都是可见的,即使函数的变量声明在函数最后仍然可以引用。,因为JavaScript执行代码之前将所有变量提升。但为了避免混淆，总是在函数的开头声明变量。\n\n#### 用Let\n\nlet是ES2015中引入的一个新特性，它本质上是var的块范围版本。它的作用域仅限于定义它的块、语句或表达式以及所有包含的内部块。\n\n现代JavaScript开发人员可能选择只使用let，而完全放弃使用var。\n\n> 如果let看起来是一个模糊的术语，只要看let color = 'red'就是让颜色是红色，这就更容易理解了\n\n与var相反，在任何函数外部定义let都不会创建全局变量。\n#### 用Const\n\n用var或let声明的变量可以稍后在程序中更改并重新分配。一旦const被初始化，它的值就再也不会被更改，也不能被重新分配到不同的值。\n\n```\nconst a = 'test'\n```\n我们不能给a常量定义不同的文字了。但是，如果对象提供了改变其内容的方法，我们可以对它进行变异。\nconst 定义了就不能修改或重新赋值\n\nconst和let一样都有块级作用域\n\n现代JavaScript开发人员可能会选择始终对不需要在程序中稍后重新分配的变量使用const。\n\n> 为什么?因为我们应该总是使用最简单的结构来避免将来犯错误。\n\n## 箭头函数\n\n箭头函数是在ES6 / ECMAScript 2015中引入的，自从引入以来，它们彻底改变了JavaScript代码的外观(和工作方式)。\n\n在我看来，这种变化非常受欢迎，以至于你现在很少看到在现代代码库中使用function关键字。\n\n从视觉上看，这是一个简单而受欢迎的改变，它允许你用更短的语法编写函数，从:\n```\nconst myFunction = function() {\n//...\n}\n```\n到\n\n```\nconst myFunction = () => {\n//...\n}\n```\n如果函数体只包含一条语句，则可以省略括号，并将所有内容写在一行中:\n\n```\nconst myFunction = () => doSomething()\n```\n参数在括号中传递:\n\n```\nconst myFunction = (param1, param2) => doSomething(param1, param2)\n```\n如果有一个(且只有一个)参数，可以完全省略括号:\n\n```\nconst myFunction = param => doSomething(param)\n```\n由于这种简短的语法，箭头函数让我们能使用小体积的函数。\n\n#### 隐式返回\n\n箭头函数允许你使用隐式返回：返回的值不需要使用return关键字。\n\n当函数体中有一行语句时，它就可以工作:\n\n```\nconst myFunction = () => 'test'\nmyFunction() //'test'\n```\n另一个例子，当返回一个对象时，记得将大括号括起来，以避免它被认为是括起来的函数的括号:\n\n```\nconst myFunction = () => ({ value: 'test' })\nmyFunction() //{value: 'test'}\n```\n#### this在箭头函数里如何工作\nthis是一个很难理解的概念。因为它会根据上下文和JavaScript的模式(严格模式或非严格模式)产生不同的含义。\n\n澄清这个概念很重要，因为在箭头函数中的this与常规函数中的this非常不同。\n\n当定义一个对象的方法时，在常规函数中的this指向这个对象，案例如下：\n\n```\nconst car = {\n    model: 'Fiesta',\n    manufacturer: 'Ford',\n    fullName: function() {\n        return `${this.manufacturer} ${this.model}`\n    }\n}\ncar.fullName() //\"Ford Fiesta\"\n```\n执行car.fullName()时会返回\"Ford Fiesta\"\n\n带有箭头函数的this作用域是从执行上下文中继承的。箭头函数根本不绑定this，因此它的值将在调用堆栈中查找。因此在这个代码car.fullName()中不起作用，并将返回字符串“undefined undefined”:\n\n```\nconst car = {\n    model: 'Fiesta',\n    manufacturer: 'Ford',\n    fullName: () => {\n        return `${this.manufacturer} ${this.model}`\n    }\n}\ncar.fullName() //\"undefined undefined\"\n```\n参考上面两个例子，可以看出，箭头函数并不适用于对象的方法。\n\n箭头函数也不能用作构造函数，因为实例化对象时将报错TypeError。当不需要动态上下文时，应该在这里使用箭头函数来代替常规函数。\n\n在处理事件时还有一个问题，DOM事件侦听器将this设置为目标元素，如果在事件处理程序中依赖于此元素，则需要一个常规函数:\n\n```\nconst link = document.querySelector('#link')\nlink.addEventListener('click', () => {\n    // this === window\n})\n```\n\n```\nconst link = document.querySelector('#link')\nlink.addEventListener('click', function() {\n    // this === link\n})\n```\n## 使用Rest和Spread处理对象和数组\n#### 学习使用JavaScript处理数组和对象的两种现代技术\n您可以使用spread操作符展开数组、对象或字符串  ...\n\n看下面的例子：\n\n```\nconst a = [1, 2, 3]\n```\n你可以像下面一样创建一个新数组\n\n```\nconst b = [...a, 4, 5, 6]\n```\n还可以像下面一样创建一个数组的副本\n```\nconst b = [...a]\n```\n也能用这种方式拷贝一个对象\n\n```\nconst newObj = { ...oldObj }\n```\n使用字符串时，spread操作符创建一个数组，数组内是每个字符:\n\n```\nconst hey = 'hey'\nconst arrayized = [...hey] // ['h', 'e', 'y']\n```\n这个操作符有一些非常有用的应用。最重要的是能够以一种非常简单的方式将数组作为函数参数:\n\n```\nconst f = (foo, bar) => {}\nconst a = [1, 2]\nf(...a)\n```\n(在过去，你可以用f.apply(null, a) 来做这个但是这样做不太好，可读性也不好)\n\nrest元素和spread元素在使用数组解构赋值时非常有用:\n\n```\nconst numbers = [1, 2, 3, 4, 5]\n[first, second, ...others] = numbers\n\nconst numbers = [1, 2, 3, 4, 5]\nconst sum = (a, b, c, d, e) => a + b + c + d + e\nconst sum = sum(...numbers)\n```\n\nES2018引入了rest属性，它们是相同的，但是是用于对象。\n\nRest属性\n\n```\nconst { first, second, ...others } = {\n    first: 1,\n    second: 2,\n    third: 3,\n    fourth: 4,\n    fifth: 5\n}\nfirst // 1\nsecond // 2\nothers // { third: 3, fourth: 4, fifth: 5 }\n```\n\n扩展属性允许通过合并在扩展操作符之后传递的对象属性来创建一个新对象:\n\n```\nconst items = { first, second, ...others }\nitems //{ first: 1, second: 2, third: 3, fourth: 4, fifth: 5 }\n```\n## 数组和对象的解构赋值\n#### 学习如何使用解构赋值语法来处理JavaScript中的数组和对象\n给定一个对象，使用解构赋值语法，您可以提取一些值，并将它们放入命名变量:\n\n```\nconst person = {\nfirstName: 'Tom',\nlastName: 'Cruise',\nactor: true,\nage: 54 //made up\n}\nconst { firstName: name, age } = person //name: Tom, age: 54\n```\nname和age包含了所需要的值。\n\n这个语法也可以在数组上使用\n\n```\nconst a = [1, 2, 3, 4, 5]\nconst [first, second] = a\n```\n该语句通过从数组a中获取索引0、1、4的项来创建3个新变量（first，second，fifth）\n\n```\nconst [first, second, , , fifth] = a\n```\n## 模板字符串\n在ES2015(又名ES6)中引入的模板字符串提供了一种声明字符串的新方法，也提供了一些已经非常流行的有趣的新构造方法。\n\n#### 模板字符串介绍\n\n模板文字是ES2015 / ES6的新特性，与ES5及以下版本相比，它允许你以一种新颖的方式处理字符串。\n语法乍一看非常简单，只需使用反引号而不是单引号或双引号:\n\n```\nconst a_string = `something`\n```\n它们是很独特的的，因为它们提供了许多用引号构建的普通字符串所没有的特性，特别是:\n* 它们提供了一个很好的语法来定义多行字符串\n* 它们提供了一种简单的方法在字符串中用变量和表达式插值\n* 它们允许您使用模板标记创建DSL (DSL意味着特定于领域的语言，例如在React by style组件中使用DSL为组件定义CSS)\n\n#### 让我们详细研究上面三个东西\n#### 多行字符串\n在es6之前，要创建一个跨越两行的字符串，您必须在一行末尾使用\\字符\n\n```\nconst string =\n  'first part \\\nsecond part'\n```\n这允许在两行创建一个字符串，但它只呈现在一行:\n\n```\nfirst part second part\n```\n要在多行渲染字符串，你需要显式地在每行末尾添加\\n，如下所示:\n\n```\nconst string =\n  'first line\\n \\\nsecond line'\n\n//或者\nconst string = 'first line\\n' + 'second line'\n```\n用模板字符串就简单多了\n\n一旦模板文字使用回车，你只需按回车键来创建一个没有特殊字符的新行，它就会按原样呈现:\n\n```\nconst string = `Hey\nthis\n\nstring\nis awesome!`\n\n//结果如下\nHey\nthis\n\nstring\nis awesome!\n```\n记住，模板字符串的空格是有意义的，所以这样做:\n\n```\nconst string = `First\n                Second`\n                \n                \n//结果如下\nFirst\n                Second\n```\n解决这个问题的一种简单方法是，在第一行中设置一个空行，并在结束后加上trim()方法，这将消除第一个字符之前的任何空格:\n\n```\nconst string = `\nFirst\nSecond`.trim()\n```\n#### 模板字符串插值\n模板字符串提供了一种将变量和表达式插入字符串的简单方法。\n你可以用这样的语法```${...}```：\n\n```\nconst var = 'test'\nconst string = `something ${var}` //something test\n```\n在```${...}```里你可以插入任何东西，甚至是表达式\n\n```\nconst string = `something ${1 + 2 + 3}`\nconst string2 = `something ${foo() ? 'x' : 'y'}`\n```\n## Class（类）\n2015年，ECMAScript 6 (ES6)标准引入了类。\n\nJavaScript有一种非常少见的实现继承的方法:原型继承。虽然原型继承在我看来很好，但它不同于大多数其他流行编程语言的继承实现，后者是基于类的。\n\n来自Java、Python或其他语言的人很难理解原型继承的复杂性，所以ECMAScript委员会决定在原型继承的基础上添加语法糖，这样就像其他流行实现中的基于类的继承一样。\n\n这一点很重要:底层的JavaScript仍然是相同的，您还是可以用常规的方式访问对象原型。\n\n#### 一个class类的定义\n一个类长下面这样\n\n```\nclass Person {\n  constructor(name) {\n    this.name = name\n  }\n  hello() {\n    return 'Hello, I am ' + this.name + '.'\n  }\n}\n```\n类有一个标识符，我们可以使用它来使用new ClassIdentifier()创建新对象\n\n初始化对象时，调用constructor方法，并传递任意参数。\n\n一个类也有它所需要的所有方法。在这种情况下，hello是一个方法，这个类派生的所有对象都可以调用这个方法:\n\n```\nconst flavio = new Person('Flavio')\nflavio.hello()\n```\n#### 类的实例\n\n类可以扩展另一个类，使用该类初始化的对象继承父类的所有方法。\n\n如果继承的类的方法与层次结构中较高层的类的名称相同，则最近的方法优先:\n\n\n```\nclass Programmer extends Person {\n  hello() {\n    return super.hello() + ' I am a programmer.'\n  }\n}\nconst flavio = new Programmer('Flavio')\nflavio.hello()\n//输出 Hello, I am Flavio. I am a programmer.\n```\n类没有显式的类变量声明，但是必须初始化构造函数中的任何变量\n\n在类中，可以用super()来引用父类。\n\n#### 静态方法\n通用方法是在实例上定义的，而不是在类上定义的。\n静态方法在类上执行:\n\n```\nclass Person {\n  static genericHello() {\n    return 'Hello'\n  }\n}\nPerson.genericHello() //Hello\n```\n#### 私有方法\nJavaScript没有内置的方法来定义私有或受保护的方法。（可以参考闭包等概念）\n\n有一些变通方法，但我不会在这里描述它们。\n#### Getters 和 setters\n你可以添加以get或set为前缀的方法来创建getter和setter，这是根据您正在做的事情执行两段不同的代码:访问变量或修改其值。\n\n```\nclass Person {\n  constructor(name) {\n    this._name = name\n  }\n  set name(value) {\n    this._name = value\n  }\n  get name() {\n    return this._name\n  }\n}\n```\n如果您只有一个getter，则无法设置该属性，并且任何这样做的尝试都将被忽略:\n\n```\nclass Person {\n  constructor(name) {\n    this.name = name\n  }\n  get name() {\n    return this.name\n  }\n}\n```\n如果你只有一个setter，你可以改变值，但不能从外部访问它:\n\n```\nclass Person {\n  constructor(name) {\n    this.name = name\n  }\n  set name(value) {\n    this.name = value\n  }\n}\n```\n## 回调\n计算机在设计上是异步的。\n\n异步意味着事情可以独立于主程序流发生。\n\n在当前的客户端计算机中，每个程序都运行一个特定的时间段，然后停止执行，让另一个程序继续执行。这个东西以一种无法察觉的速度循环运行，我们认为计算机同时运行许多程序，但这是一种错觉(多处理器机器除外)。\n\n程序在内部使用中断——这是一种向处理器发出的信号，以引起系统的注意。\n\n我不会深入讨论它的内部原理，但是要记住，程序是异步的是很正常的，在它们需要注意的时候停止它们的执行，而计算机可以同时执行其他事情。当程序正在等待来自网络的响应时，它不能在请求完成之前停止处理器。\n\n通常，编程语言是同步的，有些语言提供了一种方法来管理语言或库中的异步性。C, Java, c#， PHP, Go, Ruby, Swift, Python，它们默认都是同步的。其中一些通过使用线程处理异步，生成一个新进程。\n\nJavaScript默认是同步的，并且是单线程的。这意味着代码不能创建新线程并并行运行。\n\n一行接一行的执行代码，例如:\n\n\n```\nconst a = 1\nconst b = 2\nconst c = a * b\nconsole.log(c)\ndoSomething()\n```\n但是JavaScript是在浏览器中诞生的，它最初的主要工作是响应用户操作，比如onClick、onMouseOver、onChange、onSubmit等等。它如何使用同步编程模型实现这一点呢?\n\n答案就在它所处的环境中。浏览器提供了一种方法，它提供了一组api来处理这种功能。\n\n最近，NodeJS引入了一个非阻塞I/O环境，将这个概念扩展到文件访问、网络调用等。\n\n你不知道用户什么时候会点击按钮，所以你要做的是，为点击事件定义一个事件处理器。此事件处理程序接受一个函数，该函数将在事件触发时被调用:\n\n\n```\ndocument.getElementById('button').addEventListener('click', () => {\n  //item clicked\n})\n```\n这就是回调（callback)\n\n回调是一个简单的函数，它作为一个值传递给另一个函数，只在事件发生时执行。我们可以这样做，因为JavaScript具有一流的函数，可以将其分配给变量并传递给其他函数(称为高阶函数)\n\n将所有代码包装在windows对象上的load事件监听器中是很常见的，它只在页面准备好时才运行回调函数:\n\n\n```\nwindow.addEventListener('load', () => {\n  //window loaded\n  //do what you want\n})\n```\n\n回调可以用在任何地方，不只是dom事件上\n\n一个常用的定时器例子：\n\n```\nsetTimeout(() => {\n  // runs after 2 seconds\n}, 2000)\n```\n\nXHR请求也接受回调，在本例中，它将一个函数分配给一个属性，该属性将在特定事件发生时被调用(在本例中，请求状态发生变化):\n\n```\nconst xhr = new XMLHttpRequest()\nxhr.onreadystatechange = () => {\n  if (xhr.readyState === 4) {\n    xhr.status === 200 ? console.log(xhr.responseText) : console.error('error')\n  }\n}\nxhr.open('GET', 'https://yoursite.com')\nxhr.send()\n```\n\n#### 处理回调中的错误\n\n如何在回调处理错误?一个非常常见的策略是使用Node所采用的方法:任何回调函数中的第一个参数都是error对象:error-first回调\n\n如果没有错误，则对象为null。如果有错误，它包含错误的一些描述和其他信息。\n\n\n```\nfs.readFile('/file.json', (err, data) => {\n  if (err !== null) {\n    //handle error\n    console.log(err)\n    return\n  }\n  //no errors, process data\n  console.log(data)\n})\n```\n\n#### 回调存在的问题\n\n回调对于简单的情况非常有用\n\n然而，每个回调都会增加一个嵌套级别，当你有很多回调时，代码开始变得非常复杂:\n\n\n```\nwindow.addEventListener('load', () => {\n  document.getElementById('button').addEventListener('click', () => {\n    setTimeout(() => {\n      items.forEach(item => {\n        //your code here\n      })\n    }, 2000)\n  })\n})\n```\n\n这只是一个简单的4层代码，但我见过更多级别的嵌套，这并不有趣。\n怎么解呢?\n\n## 回调的替代品\n从ES6开始，JavaScript引入了几个特性，帮助我们处理不涉及回调的异步代码:\n\n* Promises (ES6)\n* Async/Await (ES8)\n## Promise\nPromise是处理异步代码的一种方法，无需在代码中编写太多回调。\n\n尽管它们已经存在多年，但是在ES2015中已经被标准化并引入，现在在ES2017中已经被异步函数所取代。\n\nAsync函数使用promise API作为它们的构建块，因此理解它们是非常重要的，即使在较新的代码中您可能会使用Async函数而不是promise。\n\n#### 简而言之，Promise是如何工作的\n一旦Promise被调用，它将以pending状态启动。这意味着调用方函数将继续执行，同时等待Promise自己进行处理，并给调用方函数一些反馈。\n\n此时，调用方函数等待它以resolved状态或rejected状态返回承诺，但如您所知，JavaScript是异步的，因此函数在Promise工作时继续执行。\n\n#### 哪个JS API使用Promise?\n除了您自己的代码和库代码之外，Promises还被标准的现代Web api(如Fetch或Service Workers)使用。\n\n在现代JavaScript中，您不太可能不使用承诺，所以让我们开始深入研究它们。\n\n#### 创建一个promise\n\nPromise API公开了一个Promise构造函数，您可以使用它进行初始化```new Promise()```：\n\n```\nlet done = true\nconst isItDoneYet = new Promise((resolve, reject) => {\n  if (done) {\n    const workDone = 'Here is the thing I built'\n    resolve(workDone)\n  } else {\n    const why = 'Still working on something else'\n    reject(why)\n  }\n})\n```\n正如您所看到的，promise检查done全局常量，如果它为真，则返回一个resolve的promise，否则返回一个 reject的promise。\n\n使用resolve和reject，我们可以返回一个值，在上面的例子中，我们只返回一个字符串，但它也可以是一个对象。\n\n#### 使用promise\n在上一节中，我们介绍了如何创建承诺。\n现在让我们看看如何使用承诺。\n\n```\nconst isItDoneYet = new Promise()\n//...\nconst checkIfItsDone = () => {\n  isItDoneYet\n    .then(ok => {\n      console.log(ok)\n    })\n    .catch(err => {\n      console.error(err)\n    })\n}\n```\n运行checkIfItsDone()将执行isItDoneYet() promise，并使用then回调等待它解决，如果出现错误，它将在catch回调中处理它。\n\n#### promise链\n\n一个promise可以返回给另一个promise，创建一个promise链。\n\nFetch API是链接承诺的一个很好的例子，它是XMLHttpRequest API之上的一层，我们可以使用它来获取资源，并在获取资源时对要执行的promise链进行排队。\n\nFetch API是一种基于promise的机制，调用Fetch()相当于使用new promise()定义我们自己的promise。\n\n例子：\n\n```\nconst status = response => {\n  if (response.status >= 200 && response.status < 300) {\n    return Promise.resolve(response)\n  }\n  return Promise.reject(new Error(response.statusText))\n}\nconst json = response => response.json()\nfetch('/todos.json')\n  .then(status)\n  .then(json)\n  .then(data => {\n    console.log('Request succeeded with JSON response', data)\n  })\n  .catch(error => {\n    console.log('Request failed', error)\n  })\n```\n\n在本例中，我们调用fetch()从TODO中获取TODO项的列表。在域根目录中找到json文件，然后创建promise链。\n\n运行 fetch()后返回一个响应，它有很多属性，在这些属性中我们引用:\n* status表示HTTP状态代码的数值\n* statusText状态消息，如果是OK就是请求成功\n\nresponse也有一个json()方法，它返回一个promise，该promise将解析处理并转换为JSON的主体内容。\n\n在这些前提下，会发生这样的情况:链中的第一个promise是我们定义的一个函数status()，它检查响应状态，如果它不是一个成功响应(在200到299之间)，则拒绝该promise。\n\n此操作将导致promise链跳过列出的所有链接的promise，并直接跳到底部的catch()语句，记录请求失败的文本和错误消息。\n\n如果成功，则调用我们定义的json()函数。由于上一个promise成功时返回响应对象，所以我们将它作为第二个promise的输入。\n\n在这种情况下，我们返回JSON处理过的数据，所以第三个promise直接接收JSON:\n\n\n```\n.then((data) => {\n  console.log('Request succeeded with JSON response', data)\n})\n```\n我们只需将其打印到控制台\n\n#### 处理错误\n在上面的例子中，在上一节中，我们有一个catch，它被附加到promise链中。\n\n当promise链中的任何内容失败并引发错误或拒绝promise时，该控件将转到链中最近的catch()语句。\n\n\n```\nnew Promise((resolve, reject) => {\n  throw new Error('Error')\n}).catch(err => {\n  console.error(err)\n})\n// or\nnew Promise((resolve, reject) => {\n  reject('Error')\n}).catch(err => {\n  console.error(err)\n})\n```\n#### 串联错误\n如果在catch()中引发错误，可以附加第二个catch()来处理它，依此类推。\n\n```\nnew Promise((resolve, reject) => {\n  throw new Error('Error')\n})\n  .catch(err => {\n    throw new Error('Error')\n  })\n  .catch(err => {\n    console.error(err)\n  })\n```\n#### 用 Promise.all()来编排promise\n如果您需要同步执行不同的promise，Promise.all()可以帮助您定义一个promise列表，并在所有promise都得到解析时执行某些操作。\n\n例子：\n\n```\nconst f1 = fetch('/something.json')\nconst f2 = fetch('/something2.json')\nPromise.all([f1, f2])\n  .then(res => {\n    console.log('Array of results', res)\n  })\n  .catch(err => {\n    console.error(err)\n  })\n```\n\nES2015析构赋值语法也允许您这样做\n\n\n```\nPromise.all([f1, f2]).then(([res1, res2]) => {\n  console.log('Results', res1, res2)\n})\n```\n\n当然你不局限于使用fetch，任何promise都是好的。\n#### 用Promise.race()编排promise\n\nPromise.race()在您传递给它的某个promise解析时立即运行，并且在解析第一个promise的结果时，它只运行附加的回调一次（最先执行成功的promise后就返回该promise，其他的promise就不管了）。\n\n例子：\n\n\n```\nconst promiseOne = new Promise((resolve, reject) => {\n  setTimeout(resolve, 500, 'one')\n})\nconst promiseTwo = new Promise((resolve, reject) => {\n  setTimeout(resolve, 100, 'two')\n})\nPromise.race([promiseOne, promiseTwo]).then(result => {\n  console.log(result) // 'two'\n})\n```\n## Async/Await\nJavaScript在很短的时间内从回调发展到了promise (ES2015)，而且由于ES2017异步JavaScript使用async/ wait语法更加简单。\n\n异步函数是 promise和generate的组合，基本上，它们是比promise更高层次的抽象。让我重复一遍:async/ wait基于promise。\n\n#### 为什么要Async/Await\n\n这种方式减少了promise的使用，和‘不打破promise链’的限制\n\n当promise在ES2015中引入时，它们是为了解决异步代码的问题，它们确实解决了这个问题，但是在ES2015和ES2017分开的两年时间里，很明显promise并不是最终的解决方案。\n\n引入promise是为了解决著名的回调地狱问题，但它们本身也带来了复杂性，以及语法复杂性。\n\n它们语义化更好，可以向开发人员提供更好的语法，因此当时机成熟时，我们就可以使用async函数。\n\n它们使代码看起来是同步的，但在幕后它是异步的，非阻塞的。\n\n#### async如何工作的\n\n一个async函数返回一个promise，就像这个例子:\n\n```\nconst doSomethingAsync = () => {\n  return new Promise(resolve => {\n    setTimeout(() => resolve('I did something'), 3000)\n  })\n}\n```\n当您想要调用这个函数时，您需要预先等待，调用代码将停止，直到promise被resolve或reject。一个警告:函数必须定义为async的。这里有一个例子:\n\n\n```\nconst doSomething = async () => {\n  console.log(await doSomethingAsync())\n}\n```\n#### 一个快速的案例\n这是一个简单的async/await 的例子，用于异步运行一个函数:\n\n```\nconst doSomethingAsync = () => {\n  return new Promise(resolve => {\n    setTimeout(() => resolve('I did something'), 3000)\n  })\n}\nconst doSomething = async () => {\n  console.log(await doSomethingAsync())\n}\nconsole.log('Before')\ndoSomething()\nconsole.log('After')\n```\n以上代码将打印以下内容到浏览器控制台:\n\n```\nBefore\nAfter\nI did something //after 3s\n```\n#### 所有的事都是promise\n在任何函数前面加上async关键字意味着函数将返回一个promise。\n\n即使它没有显式地返回promise，它也会在内部让它返回一个promise。\n\n这就是为什么这个代码是有效的:\n\n```\nconst aFunction = async () => {\n  return 'test'\n}\naFunction().then(alert) // This will alert 'test'\n```\n上面也和下面一样\n\n```\nconst aFunction = async () => {\n  return Promise.resolve('test')\n}\naFunction().then(alert) // This will alert 'test'\n```\n#### 代码更易读\n正如您在上面的示例中看到的，我们的代码看起来非常简单。将其与使用纯promise(带有链接和回调函数)的代码进行比较。\n\n这是一个非常简单的例子，当代码更加复杂时，主要的好处就会显现出来。\n\n例如，下面是如何获得JSON资源，并使用promise对其进行解析:\n\n```\nconst getFirstUserData = () => {\n  return fetch('/users.json') // get users list\n    .then(response => response.json()) // parse JSON\n    .then(users => users[0]) // pick first user\n    .then(user => fetch(`/users/${user.name}`)) // get user data\n    .then(userResponse => response.json()) // parse JSON\n}\ngetFirstUserData()\n```\n用await/async来实现上面的功能时\n\n```\nconst getFirstUserData = async () => {\n  const response = await fetch('/users.json') // get users list\n  const users = await response.json() // parse JSON\n  const user = users[0] // pick first user\n  const userResponse = await fetch(`/users/${user.name}`) // get user data\n  const userData = await user.json() // parse JSON\n  return userData\n}\ngetFirstUserData()\n```\n#### 串联多个异步函数\n异步函数可以很容易地链接起来，而且语法比普通的承诺更易读\n\n```\nconst promiseToDoSomething = () => {\n  return new Promise(resolve => {\n    setTimeout(() => resolve('I did something'), 10000)\n  })\n}\nconst watchOverSomeoneDoingSomething = async () => {\n  const something = await promiseToDoSomething()\n  return something + ' and I watched'\n}\nconst watchOverSomeoneWatchingSomeoneDoingSomething = async () => {\n  const something = await watchOverSomeoneDoingSomething()\n  return something + ' and I watched as well'\n}\nwatchOverSomeoneWatchingSomeoneDoingSomething().then(res => {\n  console.log(res)\n})\n\n//输出\nI did something and I watched and I watched as well\n```\n#### 更好debug\n调试promise很困难，因为调试器不会跳过异步代码。\n\nAsync/ wait使这一切变得非常简单，因为对于编译器来说，它就像同步代码一样。\n\n## ES 模块\nES模块是用于处理模块的ECMAScript标准。\n\nnodeJS多年来一直使用CommonJS标准，浏览器从来没有模块系统，因为每一个重大决策，比如模块系统，都必须首先由ECMAScript标准化，然后由浏览器实现。\n\n这个标准化过程用ES6完成，浏览器开始实现这个标准，试图保持一切正常运行，以相同的方式工作，现在在Chrome、Safari、Edge和Firefox(从版本60开始)中都支持ES模块。\n\n模块非常酷，因为它们允许您封装各种功能，并将这些功能作为库公开给其他JavaScript文件。\n\n#### ES模块语法\n导入模块的语法是:\n\n```\nimport package from 'module-name'\n```\n用CommonJS 时：\n\n```\nconst package = require('module-name')\n```\n模块是一个JavaScript文件，它使用export关键字导出一个或多个值(对象、函数或变量)。例如，这个模块导出一个函数，返回一个大写字符串:\n> uppercase.js\n\n```\nexport default str => str.toUpperCase()\n```\n\n在本例中，模块定义了一个default export，因此它可以是一个匿名函数。否则，它需要一个名称来将其与其他导出区分开。\n\n现在，通过导入这个文件，任何其他JavaScript模块都可以用导入的uppercase.js提供的功能。\nHTML页面可以使用\n```<script>``` 标记添加模块，该标记具有特殊的```type=\"module\"```属性:\n```\n<script type=\"module\" src=\"index.js\"></script>\n```\n> 注意:此模块导入的行为类似于defer脚本加载。\n\n需要注意的是，使用```type=\"module\"```加载的任何脚本都是在严格模式下加载的。\n\n在这个例子中，uppercase.js 模块定义了一个 default export,所以当我们导入它的时候，我们可以给它分配一个我们喜欢的名字:\n\n\n```\nimport toUpperCase from './uppercase.js'\n```\n\n我们可以这样使用\n\n```\ntoUpperCase('test') //'TEST'\n```\n您还可以使用模块导入的绝对路径，来引用在另一个域中定义的模块:\n\n```\nimport toUpperCase from 'https://flavio-es-modules-example.glitch.me/uppercase.js'\n```\n这也是有效的导入语法:\n\n```\nimport { foo } from '/uppercase.js'\nimport { foo } from '../uppercase.js'\n```\n下面是不对的：\n\n```\nimport { foo } from 'uppercase.js'\nimport { foo } from 'utils/uppercase.js'\n```\n它要么是绝对的，要么在名字前有一个./或者/。\n\n## 其他 import/export方法\n我们看到上面的例子:\n\n```\nexport default str => str.toUpperCase()\n```\n这将创建一个默认导出。在一个文件中，你可以导出多个东西，通过使用以下语法:\n\n\n```\nconst a = 1\nconst b = 2\nconst c = 3\nexport { a, b, c }\n```\n另一个模块可以使用import *来导入所有这些export的内容\n\n```\nimport * from 'module'\n```\n你可以只导入其中的几个导出，使用析构赋值:\n\n```\nimport { a } from 'module'\nimport { a, b } from 'module'\n```\n为了方便，可以使用as重命名任何导入\n\n```\nimport { a, b as two } from 'module'\n```\n您可以按名称导入默认导出和任何非默认导出，如以下常见的React导入:\n\n\n```\nimport React, { Component } from 'react'\n```\n## CORS(跨域)\n使用CORS获取模块。这意味着如果您引用来自其他域的脚本，它们必须具有允许跨站点加载的有效CORS头（比如Access-Control-Allow-Origin: *）\n#### 那么不支持模块的浏览器呢?\n结合使用```type=\"module\"``` 和```nomodule```\n\n```\n<script type=\"module\" src=\"module.js\"></script>\n<script nomodule src=\"fallback.js\"></script>\n```\nES模块是现代浏览器中引入的最大特性之一。它们是ES6的一部分，但实现它们的道路是漫长的。\n\n我们现在可以使用它们了!但是我们还必须记住，如果有多个模块，那么页面的性能将受到影响，因为这是浏览器在运行时必须执行更多一个步骤。\n\n即使ES模块在浏览器里能用了，Webpack可能仍然是一个巨大的玩家，但是直接在语言中构建这样的特性对于统一模块在客户端和nodeJS的工作方式是非常重要的。\n\n> 下节预告：React的概念\n","source":"_posts/React_V16入门手册.md","raw":"---\nlayout: react\ntitle: React_V16入门手册\ndate: 2019-01-18 17:09:19\ntags:\n---\n原文[https://medium.freecodecamp.org/the-react-handbook-b71c27b0a795]()\n\n开始着手学习React，就看到大佬推荐的这篇文章，因为是英文，就尽自己能力翻译一下有错的烦请指正。原文一共220页A4纸，内容有点多，所以会分期更新，见谅\n## 介绍\n这本React手册遵循二八原则：用20%的时间学习80%的内容\n\n在本手册里使用了React Hooks，所以你需要使用高于等于 16.7.0-alpha.2 版本的React和ReactDom.\n\n如果你使用create-react-app初始化项目时，在初始化项目之后运行``` npm install react@16.7.0-alpha.2 react-dom@16.7.0-\nalpha.2 ```\n\n我希望你能在你阅读完本手册后能达到一个目标：学会React的基础\n\n## React介绍\n先来介绍一下React库\n####  什么是React\nReact是一个旨在简化开发可视化界面的Javascript库。它由Facebook开发，并于2013年向世界发布，并支持着很多被广泛使用的App，包括Facebook和Instagram等无数应用程序。\n它的主要目标是通过将UI划分为一组组件，使得在任何时间点都可以轻松地构建界面及其状态。\n#### 为什么React这么流行？\nReact席卷了整个前端开发领域，为什么？\n\n#### 比其他框架更低的复杂性\n在React出道之前，Ember.js和Angular1.X是主流框架。这两种方法在代码上强加了太多的约定，以至于移植现有的应用程序一点都不方便。React选择了非常容易集成到现有项目中的方式，因为Facebook必须实现这一点，这样才能将其引入现有代码库。另外，这两个框架本身包含的内容太多了，而React只选择实现视图层而不是完整的MVC技术栈。\n#### 完美的时间\n当谷歌宣布Angular2.X时，宣称Angular1.X并不能平滑升级到Angular2.X，这两个就像不同的框架一样，所以想要从Angular1.X升级到Angular2.X就得重构项目。因为这一点，再加上React承诺说能带来执行速度的提升，所以很多程序员就迫不及待的尝试。\n#### Facebook的支持\n如果一个项目最终成功，得到Facebook的支持显然也会让它受益。Facebook目前对React非常感兴趣，并看到了它开源的价值，这对所有在自己项目中使用React的开发者来说都是一个巨大的优势。\n\n#### React学起来容易吗？\n虽然我说React要比其他框架简单，但是深入学习React的话还是挺有难度的，难的主要原因是要与React搭配使用的技术，比如Redux,GraphQL等等。\n\nReact本身有一个非常小的API，你至少需要理解4个概念才能开始:\n* Components\n* JSX\n* State\n* Props\n\n上面这些（甚至更多）都会在手册中一一解释\n\n## 如何安装React\n#### 如何在你的电脑上安装React?\nReact是一个库，所以说安装这个词会有点奇怪，倒不如说“设置”更贴切。在你的app或者网页中有很多方式可以设置React\n\n#### 直接在网页里引入\n最简单的方法是直接将React JavaScript文件添加到页面中。当React应用与单个页面上的元素进行交互，而不是实际控制整个导航时，这是最好的选择。\n\n下面的例子中，你在body的最后添加了两个script标签\n\n```\n<html>\n...\n    <body>\n    ...\n        <script\n        src=\"https://cdnjs.cloudflare.com/ajax/libs/react/16.7.0-alpha.2/umd/react.development.js\" \n        crossorigin>\n        </script>\n        <script\n        src=\"https://cdnjs.cloudflare.com/ajax/libs/react-dom/16.7.0-alpha.2/umd/react-dom.production.min.js\"\n        crossorigin>\n        </script>\n    </body>\n</html>\n```\n在这里我们引入两个库（React和React Dom），是为什么呢？因为React是百分之的独立于浏览器的，你也可以在浏览器之外使用React（比如用React Native开发移动应用时，也能用React），因此需要React Dom来操作dom。\n\n在引入Javascript文件后，你需要为react，在html里添加script标签，才能使用JSX语法，下面两种方式都可以\n```\n//在app.js里写JSX\n<script src=\"app.js\"></script>\n<!-- or -->\n\n//直接在标签内写JSX\n<script>\n//my app\n</script>\n\n```\n如果要使用JSX，你还需要引入Babel\n\n```\n<script src=\"https://unpkg.com/babel-standalone@6/babel.min.js\"></script>\n```\n引入后要在之前写的script标签里添加type=\"text/babel\"才会生效，如下：\n```\n<script src=\"app.js\" type=\"text/babel\"></script>\n\n```\n现在你可以在你的app.js里写JSX的代码了。\n\n```\nconst Button = () => {\nreturn <button>Click me!</button>\n}\nReactDOM.render(<Button />, document.getElementById('root'))\n\n```\n演示代码地址：\n[https://glitch.com/edit/#!/react-example-inline-jsx?path=index.html:21:19](演示代码)\n#### 用官方脚手架create-react-app（推荐）\ncreate-react-app旨在让你能快速构建一个React项目，任何React应用都可以使用create-react-app来生成一个单页页面。\n\n首先你需要安装npm和node （地址：[https://nodejs.org/en/]()）就不多说了\n然后执行\n\n```\nnpx create-react-app todolist\n```\nnpx是npm 5.2之后才有的工具，npx会下载create-react-app，然后解压安装，然后执行```create-react-app todolist```,然后再把create-react-app从系统中删除。这样你就永远能够使用最新的create-react-app，不会在电脑里存放着过时的create-react-app。\n\n执行完之后你能看到下面的界面\n\n![](https://user-gold-cdn.xitu.io/2019/1/18/168602568623fb3a?w=741&h=677&f=png&s=36167)\n\ncreate-react-app会在文件夹内创建相应的文件结构，文件名就是todolist（自己取的）\npackage.json也同样生成了，只需要安装指示，进入相应的文件夹，执行npm start就可以启动项目了\n\n如图\n\n![](https://user-gold-cdn.xitu.io/2019/1/18/168602a792310119?w=454&h=260&f=png&s=12615)\n\n打开浏览器进入http://localhost:3000/就能看到最开始的界面了。\n\n除了 npm start , create-react-app这两个命令之外，还有下面一些命令\n* npm run build ：要在构建文件夹中构建准备部署到服务器的React应用程序文件\n* npm test：运行Jest测试包\n* npm eject ：弹出配置文件 \n何时用npm eject？create-react-app已经做了很多工作了，但你想要完成更多的工作时，就要弹出配置文件来自己配置。\n\n\n因为create-react-app 是为了满足大部分人的需求和有限的配置，当你有一些独特的需求时，就需要自己来配置一些内容了。\n\n当你使用npm eject时，你的页面就不会自动更新了，但你可以在Babel和Webpack配置中获得更大的灵活性。\n\neject时是不可逆的，当你执行后你会获得两个新的文件夹，配置和脚本。你就可以开始自由的编辑他们了。\n\n> 下节预告：下节我们将学习在学习React之前需要了解的JS语法及一些知识\n\n## 使用React需要什么样的JS能力\n#### 在深入学习React之前找到你必须要掌握的内容\n如果你想学习React时，首先你需要做一些事情。您必须熟悉一些必要的技术，特别是你将在React中反复使用的一些最新JavaScript特性相关的技术。\n\n有些人以为一些功能是React提供的一些特定的功能，实际上它们只是Javascript最新的语法。\n\n立即掌握这些新语法，成为这方面的专家是不可能的，也没必要。但你如果想要深入研究React，那你就需要熟练掌握他们了。\n\n我会把它们列举下来让你快速了解一下。\n\n## 变量\n变量是分配给标识符的文字，因此您可以引用它并在后面的程序里使用它。学习如何用JavaScript声明一个。\n\nJavaScript中的变量没有附加任何类型。将特定的文字类型分配给变量后，可以稍后再给这个变量分配类型，而不会出现类型错误或任何问题。\n\n所以这就是为什么有时候Javascript会报'untyped'这样的问题。\n\n一个变量必须在你使用之前就声明。有三种方法可以做到这一点，使用var、let或const，这三种方法在以后与变量的交互方式上有所不同。\n\n#### 用Var\n知道ES2015，var一直都是定义变量的唯一方法。\n```\nvar a = 0\n```\n如果你忘了添加var，你给未声明的变量赋值，结果可能会有所不同，在严格模式下，会得到一个错误，在旧的环境，或者禁用严格模式下，就会使得该变量成为一个全局变量，赋值也自然会赋值给一个全局变量。\n\n如果你没有将变量初始化，那他的值就是undefined\n\n```\nvar a //typeof a === 'undefined'\n\n```\n你可以多次声明变量\n\n```\nvar a = 1\nvar a = 2\n```\n最重要的，你可以一次就声明多个变量\n\n```\nvar a = 1, b = 2\n```\n作用域是代码中变量可见的部分（有效）。在函数外部声明一个变量，变量就是全局的，所有的函数都可以获得该变量的值，但在函数内部声明一个变量，变量就是局部的，只有在该函数内才能获得该变量的值，就像函数的一个参数。\n\n在与全局变量同名的函数中定义的任何变量都优先于全局变量，并对其进行跟踪。\n\n重要的是要理解一个块(由一对花括号标识)没有定义一个新的作用域。新作用域只在创建函数时创建，因为var没有块作用域，而是函数作用域。\n\n函数内部,在函数的所有代码中，变量在任何位置都是可见的,即使函数的变量声明在函数最后仍然可以引用。,因为JavaScript执行代码之前将所有变量提升。但为了避免混淆，总是在函数的开头声明变量。\n\n#### 用Let\n\nlet是ES2015中引入的一个新特性，它本质上是var的块范围版本。它的作用域仅限于定义它的块、语句或表达式以及所有包含的内部块。\n\n现代JavaScript开发人员可能选择只使用let，而完全放弃使用var。\n\n> 如果let看起来是一个模糊的术语，只要看let color = 'red'就是让颜色是红色，这就更容易理解了\n\n与var相反，在任何函数外部定义let都不会创建全局变量。\n#### 用Const\n\n用var或let声明的变量可以稍后在程序中更改并重新分配。一旦const被初始化，它的值就再也不会被更改，也不能被重新分配到不同的值。\n\n```\nconst a = 'test'\n```\n我们不能给a常量定义不同的文字了。但是，如果对象提供了改变其内容的方法，我们可以对它进行变异。\nconst 定义了就不能修改或重新赋值\n\nconst和let一样都有块级作用域\n\n现代JavaScript开发人员可能会选择始终对不需要在程序中稍后重新分配的变量使用const。\n\n> 为什么?因为我们应该总是使用最简单的结构来避免将来犯错误。\n\n## 箭头函数\n\n箭头函数是在ES6 / ECMAScript 2015中引入的，自从引入以来，它们彻底改变了JavaScript代码的外观(和工作方式)。\n\n在我看来，这种变化非常受欢迎，以至于你现在很少看到在现代代码库中使用function关键字。\n\n从视觉上看，这是一个简单而受欢迎的改变，它允许你用更短的语法编写函数，从:\n```\nconst myFunction = function() {\n//...\n}\n```\n到\n\n```\nconst myFunction = () => {\n//...\n}\n```\n如果函数体只包含一条语句，则可以省略括号，并将所有内容写在一行中:\n\n```\nconst myFunction = () => doSomething()\n```\n参数在括号中传递:\n\n```\nconst myFunction = (param1, param2) => doSomething(param1, param2)\n```\n如果有一个(且只有一个)参数，可以完全省略括号:\n\n```\nconst myFunction = param => doSomething(param)\n```\n由于这种简短的语法，箭头函数让我们能使用小体积的函数。\n\n#### 隐式返回\n\n箭头函数允许你使用隐式返回：返回的值不需要使用return关键字。\n\n当函数体中有一行语句时，它就可以工作:\n\n```\nconst myFunction = () => 'test'\nmyFunction() //'test'\n```\n另一个例子，当返回一个对象时，记得将大括号括起来，以避免它被认为是括起来的函数的括号:\n\n```\nconst myFunction = () => ({ value: 'test' })\nmyFunction() //{value: 'test'}\n```\n#### this在箭头函数里如何工作\nthis是一个很难理解的概念。因为它会根据上下文和JavaScript的模式(严格模式或非严格模式)产生不同的含义。\n\n澄清这个概念很重要，因为在箭头函数中的this与常规函数中的this非常不同。\n\n当定义一个对象的方法时，在常规函数中的this指向这个对象，案例如下：\n\n```\nconst car = {\n    model: 'Fiesta',\n    manufacturer: 'Ford',\n    fullName: function() {\n        return `${this.manufacturer} ${this.model}`\n    }\n}\ncar.fullName() //\"Ford Fiesta\"\n```\n执行car.fullName()时会返回\"Ford Fiesta\"\n\n带有箭头函数的this作用域是从执行上下文中继承的。箭头函数根本不绑定this，因此它的值将在调用堆栈中查找。因此在这个代码car.fullName()中不起作用，并将返回字符串“undefined undefined”:\n\n```\nconst car = {\n    model: 'Fiesta',\n    manufacturer: 'Ford',\n    fullName: () => {\n        return `${this.manufacturer} ${this.model}`\n    }\n}\ncar.fullName() //\"undefined undefined\"\n```\n参考上面两个例子，可以看出，箭头函数并不适用于对象的方法。\n\n箭头函数也不能用作构造函数，因为实例化对象时将报错TypeError。当不需要动态上下文时，应该在这里使用箭头函数来代替常规函数。\n\n在处理事件时还有一个问题，DOM事件侦听器将this设置为目标元素，如果在事件处理程序中依赖于此元素，则需要一个常规函数:\n\n```\nconst link = document.querySelector('#link')\nlink.addEventListener('click', () => {\n    // this === window\n})\n```\n\n```\nconst link = document.querySelector('#link')\nlink.addEventListener('click', function() {\n    // this === link\n})\n```\n## 使用Rest和Spread处理对象和数组\n#### 学习使用JavaScript处理数组和对象的两种现代技术\n您可以使用spread操作符展开数组、对象或字符串  ...\n\n看下面的例子：\n\n```\nconst a = [1, 2, 3]\n```\n你可以像下面一样创建一个新数组\n\n```\nconst b = [...a, 4, 5, 6]\n```\n还可以像下面一样创建一个数组的副本\n```\nconst b = [...a]\n```\n也能用这种方式拷贝一个对象\n\n```\nconst newObj = { ...oldObj }\n```\n使用字符串时，spread操作符创建一个数组，数组内是每个字符:\n\n```\nconst hey = 'hey'\nconst arrayized = [...hey] // ['h', 'e', 'y']\n```\n这个操作符有一些非常有用的应用。最重要的是能够以一种非常简单的方式将数组作为函数参数:\n\n```\nconst f = (foo, bar) => {}\nconst a = [1, 2]\nf(...a)\n```\n(在过去，你可以用f.apply(null, a) 来做这个但是这样做不太好，可读性也不好)\n\nrest元素和spread元素在使用数组解构赋值时非常有用:\n\n```\nconst numbers = [1, 2, 3, 4, 5]\n[first, second, ...others] = numbers\n\nconst numbers = [1, 2, 3, 4, 5]\nconst sum = (a, b, c, d, e) => a + b + c + d + e\nconst sum = sum(...numbers)\n```\n\nES2018引入了rest属性，它们是相同的，但是是用于对象。\n\nRest属性\n\n```\nconst { first, second, ...others } = {\n    first: 1,\n    second: 2,\n    third: 3,\n    fourth: 4,\n    fifth: 5\n}\nfirst // 1\nsecond // 2\nothers // { third: 3, fourth: 4, fifth: 5 }\n```\n\n扩展属性允许通过合并在扩展操作符之后传递的对象属性来创建一个新对象:\n\n```\nconst items = { first, second, ...others }\nitems //{ first: 1, second: 2, third: 3, fourth: 4, fifth: 5 }\n```\n## 数组和对象的解构赋值\n#### 学习如何使用解构赋值语法来处理JavaScript中的数组和对象\n给定一个对象，使用解构赋值语法，您可以提取一些值，并将它们放入命名变量:\n\n```\nconst person = {\nfirstName: 'Tom',\nlastName: 'Cruise',\nactor: true,\nage: 54 //made up\n}\nconst { firstName: name, age } = person //name: Tom, age: 54\n```\nname和age包含了所需要的值。\n\n这个语法也可以在数组上使用\n\n```\nconst a = [1, 2, 3, 4, 5]\nconst [first, second] = a\n```\n该语句通过从数组a中获取索引0、1、4的项来创建3个新变量（first，second，fifth）\n\n```\nconst [first, second, , , fifth] = a\n```\n## 模板字符串\n在ES2015(又名ES6)中引入的模板字符串提供了一种声明字符串的新方法，也提供了一些已经非常流行的有趣的新构造方法。\n\n#### 模板字符串介绍\n\n模板文字是ES2015 / ES6的新特性，与ES5及以下版本相比，它允许你以一种新颖的方式处理字符串。\n语法乍一看非常简单，只需使用反引号而不是单引号或双引号:\n\n```\nconst a_string = `something`\n```\n它们是很独特的的，因为它们提供了许多用引号构建的普通字符串所没有的特性，特别是:\n* 它们提供了一个很好的语法来定义多行字符串\n* 它们提供了一种简单的方法在字符串中用变量和表达式插值\n* 它们允许您使用模板标记创建DSL (DSL意味着特定于领域的语言，例如在React by style组件中使用DSL为组件定义CSS)\n\n#### 让我们详细研究上面三个东西\n#### 多行字符串\n在es6之前，要创建一个跨越两行的字符串，您必须在一行末尾使用\\字符\n\n```\nconst string =\n  'first part \\\nsecond part'\n```\n这允许在两行创建一个字符串，但它只呈现在一行:\n\n```\nfirst part second part\n```\n要在多行渲染字符串，你需要显式地在每行末尾添加\\n，如下所示:\n\n```\nconst string =\n  'first line\\n \\\nsecond line'\n\n//或者\nconst string = 'first line\\n' + 'second line'\n```\n用模板字符串就简单多了\n\n一旦模板文字使用回车，你只需按回车键来创建一个没有特殊字符的新行，它就会按原样呈现:\n\n```\nconst string = `Hey\nthis\n\nstring\nis awesome!`\n\n//结果如下\nHey\nthis\n\nstring\nis awesome!\n```\n记住，模板字符串的空格是有意义的，所以这样做:\n\n```\nconst string = `First\n                Second`\n                \n                \n//结果如下\nFirst\n                Second\n```\n解决这个问题的一种简单方法是，在第一行中设置一个空行，并在结束后加上trim()方法，这将消除第一个字符之前的任何空格:\n\n```\nconst string = `\nFirst\nSecond`.trim()\n```\n#### 模板字符串插值\n模板字符串提供了一种将变量和表达式插入字符串的简单方法。\n你可以用这样的语法```${...}```：\n\n```\nconst var = 'test'\nconst string = `something ${var}` //something test\n```\n在```${...}```里你可以插入任何东西，甚至是表达式\n\n```\nconst string = `something ${1 + 2 + 3}`\nconst string2 = `something ${foo() ? 'x' : 'y'}`\n```\n## Class（类）\n2015年，ECMAScript 6 (ES6)标准引入了类。\n\nJavaScript有一种非常少见的实现继承的方法:原型继承。虽然原型继承在我看来很好，但它不同于大多数其他流行编程语言的继承实现，后者是基于类的。\n\n来自Java、Python或其他语言的人很难理解原型继承的复杂性，所以ECMAScript委员会决定在原型继承的基础上添加语法糖，这样就像其他流行实现中的基于类的继承一样。\n\n这一点很重要:底层的JavaScript仍然是相同的，您还是可以用常规的方式访问对象原型。\n\n#### 一个class类的定义\n一个类长下面这样\n\n```\nclass Person {\n  constructor(name) {\n    this.name = name\n  }\n  hello() {\n    return 'Hello, I am ' + this.name + '.'\n  }\n}\n```\n类有一个标识符，我们可以使用它来使用new ClassIdentifier()创建新对象\n\n初始化对象时，调用constructor方法，并传递任意参数。\n\n一个类也有它所需要的所有方法。在这种情况下，hello是一个方法，这个类派生的所有对象都可以调用这个方法:\n\n```\nconst flavio = new Person('Flavio')\nflavio.hello()\n```\n#### 类的实例\n\n类可以扩展另一个类，使用该类初始化的对象继承父类的所有方法。\n\n如果继承的类的方法与层次结构中较高层的类的名称相同，则最近的方法优先:\n\n\n```\nclass Programmer extends Person {\n  hello() {\n    return super.hello() + ' I am a programmer.'\n  }\n}\nconst flavio = new Programmer('Flavio')\nflavio.hello()\n//输出 Hello, I am Flavio. I am a programmer.\n```\n类没有显式的类变量声明，但是必须初始化构造函数中的任何变量\n\n在类中，可以用super()来引用父类。\n\n#### 静态方法\n通用方法是在实例上定义的，而不是在类上定义的。\n静态方法在类上执行:\n\n```\nclass Person {\n  static genericHello() {\n    return 'Hello'\n  }\n}\nPerson.genericHello() //Hello\n```\n#### 私有方法\nJavaScript没有内置的方法来定义私有或受保护的方法。（可以参考闭包等概念）\n\n有一些变通方法，但我不会在这里描述它们。\n#### Getters 和 setters\n你可以添加以get或set为前缀的方法来创建getter和setter，这是根据您正在做的事情执行两段不同的代码:访问变量或修改其值。\n\n```\nclass Person {\n  constructor(name) {\n    this._name = name\n  }\n  set name(value) {\n    this._name = value\n  }\n  get name() {\n    return this._name\n  }\n}\n```\n如果您只有一个getter，则无法设置该属性，并且任何这样做的尝试都将被忽略:\n\n```\nclass Person {\n  constructor(name) {\n    this.name = name\n  }\n  get name() {\n    return this.name\n  }\n}\n```\n如果你只有一个setter，你可以改变值，但不能从外部访问它:\n\n```\nclass Person {\n  constructor(name) {\n    this.name = name\n  }\n  set name(value) {\n    this.name = value\n  }\n}\n```\n## 回调\n计算机在设计上是异步的。\n\n异步意味着事情可以独立于主程序流发生。\n\n在当前的客户端计算机中，每个程序都运行一个特定的时间段，然后停止执行，让另一个程序继续执行。这个东西以一种无法察觉的速度循环运行，我们认为计算机同时运行许多程序，但这是一种错觉(多处理器机器除外)。\n\n程序在内部使用中断——这是一种向处理器发出的信号，以引起系统的注意。\n\n我不会深入讨论它的内部原理，但是要记住，程序是异步的是很正常的，在它们需要注意的时候停止它们的执行，而计算机可以同时执行其他事情。当程序正在等待来自网络的响应时，它不能在请求完成之前停止处理器。\n\n通常，编程语言是同步的，有些语言提供了一种方法来管理语言或库中的异步性。C, Java, c#， PHP, Go, Ruby, Swift, Python，它们默认都是同步的。其中一些通过使用线程处理异步，生成一个新进程。\n\nJavaScript默认是同步的，并且是单线程的。这意味着代码不能创建新线程并并行运行。\n\n一行接一行的执行代码，例如:\n\n\n```\nconst a = 1\nconst b = 2\nconst c = a * b\nconsole.log(c)\ndoSomething()\n```\n但是JavaScript是在浏览器中诞生的，它最初的主要工作是响应用户操作，比如onClick、onMouseOver、onChange、onSubmit等等。它如何使用同步编程模型实现这一点呢?\n\n答案就在它所处的环境中。浏览器提供了一种方法，它提供了一组api来处理这种功能。\n\n最近，NodeJS引入了一个非阻塞I/O环境，将这个概念扩展到文件访问、网络调用等。\n\n你不知道用户什么时候会点击按钮，所以你要做的是，为点击事件定义一个事件处理器。此事件处理程序接受一个函数，该函数将在事件触发时被调用:\n\n\n```\ndocument.getElementById('button').addEventListener('click', () => {\n  //item clicked\n})\n```\n这就是回调（callback)\n\n回调是一个简单的函数，它作为一个值传递给另一个函数，只在事件发生时执行。我们可以这样做，因为JavaScript具有一流的函数，可以将其分配给变量并传递给其他函数(称为高阶函数)\n\n将所有代码包装在windows对象上的load事件监听器中是很常见的，它只在页面准备好时才运行回调函数:\n\n\n```\nwindow.addEventListener('load', () => {\n  //window loaded\n  //do what you want\n})\n```\n\n回调可以用在任何地方，不只是dom事件上\n\n一个常用的定时器例子：\n\n```\nsetTimeout(() => {\n  // runs after 2 seconds\n}, 2000)\n```\n\nXHR请求也接受回调，在本例中，它将一个函数分配给一个属性，该属性将在特定事件发生时被调用(在本例中，请求状态发生变化):\n\n```\nconst xhr = new XMLHttpRequest()\nxhr.onreadystatechange = () => {\n  if (xhr.readyState === 4) {\n    xhr.status === 200 ? console.log(xhr.responseText) : console.error('error')\n  }\n}\nxhr.open('GET', 'https://yoursite.com')\nxhr.send()\n```\n\n#### 处理回调中的错误\n\n如何在回调处理错误?一个非常常见的策略是使用Node所采用的方法:任何回调函数中的第一个参数都是error对象:error-first回调\n\n如果没有错误，则对象为null。如果有错误，它包含错误的一些描述和其他信息。\n\n\n```\nfs.readFile('/file.json', (err, data) => {\n  if (err !== null) {\n    //handle error\n    console.log(err)\n    return\n  }\n  //no errors, process data\n  console.log(data)\n})\n```\n\n#### 回调存在的问题\n\n回调对于简单的情况非常有用\n\n然而，每个回调都会增加一个嵌套级别，当你有很多回调时，代码开始变得非常复杂:\n\n\n```\nwindow.addEventListener('load', () => {\n  document.getElementById('button').addEventListener('click', () => {\n    setTimeout(() => {\n      items.forEach(item => {\n        //your code here\n      })\n    }, 2000)\n  })\n})\n```\n\n这只是一个简单的4层代码，但我见过更多级别的嵌套，这并不有趣。\n怎么解呢?\n\n## 回调的替代品\n从ES6开始，JavaScript引入了几个特性，帮助我们处理不涉及回调的异步代码:\n\n* Promises (ES6)\n* Async/Await (ES8)\n## Promise\nPromise是处理异步代码的一种方法，无需在代码中编写太多回调。\n\n尽管它们已经存在多年，但是在ES2015中已经被标准化并引入，现在在ES2017中已经被异步函数所取代。\n\nAsync函数使用promise API作为它们的构建块，因此理解它们是非常重要的，即使在较新的代码中您可能会使用Async函数而不是promise。\n\n#### 简而言之，Promise是如何工作的\n一旦Promise被调用，它将以pending状态启动。这意味着调用方函数将继续执行，同时等待Promise自己进行处理，并给调用方函数一些反馈。\n\n此时，调用方函数等待它以resolved状态或rejected状态返回承诺，但如您所知，JavaScript是异步的，因此函数在Promise工作时继续执行。\n\n#### 哪个JS API使用Promise?\n除了您自己的代码和库代码之外，Promises还被标准的现代Web api(如Fetch或Service Workers)使用。\n\n在现代JavaScript中，您不太可能不使用承诺，所以让我们开始深入研究它们。\n\n#### 创建一个promise\n\nPromise API公开了一个Promise构造函数，您可以使用它进行初始化```new Promise()```：\n\n```\nlet done = true\nconst isItDoneYet = new Promise((resolve, reject) => {\n  if (done) {\n    const workDone = 'Here is the thing I built'\n    resolve(workDone)\n  } else {\n    const why = 'Still working on something else'\n    reject(why)\n  }\n})\n```\n正如您所看到的，promise检查done全局常量，如果它为真，则返回一个resolve的promise，否则返回一个 reject的promise。\n\n使用resolve和reject，我们可以返回一个值，在上面的例子中，我们只返回一个字符串，但它也可以是一个对象。\n\n#### 使用promise\n在上一节中，我们介绍了如何创建承诺。\n现在让我们看看如何使用承诺。\n\n```\nconst isItDoneYet = new Promise()\n//...\nconst checkIfItsDone = () => {\n  isItDoneYet\n    .then(ok => {\n      console.log(ok)\n    })\n    .catch(err => {\n      console.error(err)\n    })\n}\n```\n运行checkIfItsDone()将执行isItDoneYet() promise，并使用then回调等待它解决，如果出现错误，它将在catch回调中处理它。\n\n#### promise链\n\n一个promise可以返回给另一个promise，创建一个promise链。\n\nFetch API是链接承诺的一个很好的例子，它是XMLHttpRequest API之上的一层，我们可以使用它来获取资源，并在获取资源时对要执行的promise链进行排队。\n\nFetch API是一种基于promise的机制，调用Fetch()相当于使用new promise()定义我们自己的promise。\n\n例子：\n\n```\nconst status = response => {\n  if (response.status >= 200 && response.status < 300) {\n    return Promise.resolve(response)\n  }\n  return Promise.reject(new Error(response.statusText))\n}\nconst json = response => response.json()\nfetch('/todos.json')\n  .then(status)\n  .then(json)\n  .then(data => {\n    console.log('Request succeeded with JSON response', data)\n  })\n  .catch(error => {\n    console.log('Request failed', error)\n  })\n```\n\n在本例中，我们调用fetch()从TODO中获取TODO项的列表。在域根目录中找到json文件，然后创建promise链。\n\n运行 fetch()后返回一个响应，它有很多属性，在这些属性中我们引用:\n* status表示HTTP状态代码的数值\n* statusText状态消息，如果是OK就是请求成功\n\nresponse也有一个json()方法，它返回一个promise，该promise将解析处理并转换为JSON的主体内容。\n\n在这些前提下，会发生这样的情况:链中的第一个promise是我们定义的一个函数status()，它检查响应状态，如果它不是一个成功响应(在200到299之间)，则拒绝该promise。\n\n此操作将导致promise链跳过列出的所有链接的promise，并直接跳到底部的catch()语句，记录请求失败的文本和错误消息。\n\n如果成功，则调用我们定义的json()函数。由于上一个promise成功时返回响应对象，所以我们将它作为第二个promise的输入。\n\n在这种情况下，我们返回JSON处理过的数据，所以第三个promise直接接收JSON:\n\n\n```\n.then((data) => {\n  console.log('Request succeeded with JSON response', data)\n})\n```\n我们只需将其打印到控制台\n\n#### 处理错误\n在上面的例子中，在上一节中，我们有一个catch，它被附加到promise链中。\n\n当promise链中的任何内容失败并引发错误或拒绝promise时，该控件将转到链中最近的catch()语句。\n\n\n```\nnew Promise((resolve, reject) => {\n  throw new Error('Error')\n}).catch(err => {\n  console.error(err)\n})\n// or\nnew Promise((resolve, reject) => {\n  reject('Error')\n}).catch(err => {\n  console.error(err)\n})\n```\n#### 串联错误\n如果在catch()中引发错误，可以附加第二个catch()来处理它，依此类推。\n\n```\nnew Promise((resolve, reject) => {\n  throw new Error('Error')\n})\n  .catch(err => {\n    throw new Error('Error')\n  })\n  .catch(err => {\n    console.error(err)\n  })\n```\n#### 用 Promise.all()来编排promise\n如果您需要同步执行不同的promise，Promise.all()可以帮助您定义一个promise列表，并在所有promise都得到解析时执行某些操作。\n\n例子：\n\n```\nconst f1 = fetch('/something.json')\nconst f2 = fetch('/something2.json')\nPromise.all([f1, f2])\n  .then(res => {\n    console.log('Array of results', res)\n  })\n  .catch(err => {\n    console.error(err)\n  })\n```\n\nES2015析构赋值语法也允许您这样做\n\n\n```\nPromise.all([f1, f2]).then(([res1, res2]) => {\n  console.log('Results', res1, res2)\n})\n```\n\n当然你不局限于使用fetch，任何promise都是好的。\n#### 用Promise.race()编排promise\n\nPromise.race()在您传递给它的某个promise解析时立即运行，并且在解析第一个promise的结果时，它只运行附加的回调一次（最先执行成功的promise后就返回该promise，其他的promise就不管了）。\n\n例子：\n\n\n```\nconst promiseOne = new Promise((resolve, reject) => {\n  setTimeout(resolve, 500, 'one')\n})\nconst promiseTwo = new Promise((resolve, reject) => {\n  setTimeout(resolve, 100, 'two')\n})\nPromise.race([promiseOne, promiseTwo]).then(result => {\n  console.log(result) // 'two'\n})\n```\n## Async/Await\nJavaScript在很短的时间内从回调发展到了promise (ES2015)，而且由于ES2017异步JavaScript使用async/ wait语法更加简单。\n\n异步函数是 promise和generate的组合，基本上，它们是比promise更高层次的抽象。让我重复一遍:async/ wait基于promise。\n\n#### 为什么要Async/Await\n\n这种方式减少了promise的使用，和‘不打破promise链’的限制\n\n当promise在ES2015中引入时，它们是为了解决异步代码的问题，它们确实解决了这个问题，但是在ES2015和ES2017分开的两年时间里，很明显promise并不是最终的解决方案。\n\n引入promise是为了解决著名的回调地狱问题，但它们本身也带来了复杂性，以及语法复杂性。\n\n它们语义化更好，可以向开发人员提供更好的语法，因此当时机成熟时，我们就可以使用async函数。\n\n它们使代码看起来是同步的，但在幕后它是异步的，非阻塞的。\n\n#### async如何工作的\n\n一个async函数返回一个promise，就像这个例子:\n\n```\nconst doSomethingAsync = () => {\n  return new Promise(resolve => {\n    setTimeout(() => resolve('I did something'), 3000)\n  })\n}\n```\n当您想要调用这个函数时，您需要预先等待，调用代码将停止，直到promise被resolve或reject。一个警告:函数必须定义为async的。这里有一个例子:\n\n\n```\nconst doSomething = async () => {\n  console.log(await doSomethingAsync())\n}\n```\n#### 一个快速的案例\n这是一个简单的async/await 的例子，用于异步运行一个函数:\n\n```\nconst doSomethingAsync = () => {\n  return new Promise(resolve => {\n    setTimeout(() => resolve('I did something'), 3000)\n  })\n}\nconst doSomething = async () => {\n  console.log(await doSomethingAsync())\n}\nconsole.log('Before')\ndoSomething()\nconsole.log('After')\n```\n以上代码将打印以下内容到浏览器控制台:\n\n```\nBefore\nAfter\nI did something //after 3s\n```\n#### 所有的事都是promise\n在任何函数前面加上async关键字意味着函数将返回一个promise。\n\n即使它没有显式地返回promise，它也会在内部让它返回一个promise。\n\n这就是为什么这个代码是有效的:\n\n```\nconst aFunction = async () => {\n  return 'test'\n}\naFunction().then(alert) // This will alert 'test'\n```\n上面也和下面一样\n\n```\nconst aFunction = async () => {\n  return Promise.resolve('test')\n}\naFunction().then(alert) // This will alert 'test'\n```\n#### 代码更易读\n正如您在上面的示例中看到的，我们的代码看起来非常简单。将其与使用纯promise(带有链接和回调函数)的代码进行比较。\n\n这是一个非常简单的例子，当代码更加复杂时，主要的好处就会显现出来。\n\n例如，下面是如何获得JSON资源，并使用promise对其进行解析:\n\n```\nconst getFirstUserData = () => {\n  return fetch('/users.json') // get users list\n    .then(response => response.json()) // parse JSON\n    .then(users => users[0]) // pick first user\n    .then(user => fetch(`/users/${user.name}`)) // get user data\n    .then(userResponse => response.json()) // parse JSON\n}\ngetFirstUserData()\n```\n用await/async来实现上面的功能时\n\n```\nconst getFirstUserData = async () => {\n  const response = await fetch('/users.json') // get users list\n  const users = await response.json() // parse JSON\n  const user = users[0] // pick first user\n  const userResponse = await fetch(`/users/${user.name}`) // get user data\n  const userData = await user.json() // parse JSON\n  return userData\n}\ngetFirstUserData()\n```\n#### 串联多个异步函数\n异步函数可以很容易地链接起来，而且语法比普通的承诺更易读\n\n```\nconst promiseToDoSomething = () => {\n  return new Promise(resolve => {\n    setTimeout(() => resolve('I did something'), 10000)\n  })\n}\nconst watchOverSomeoneDoingSomething = async () => {\n  const something = await promiseToDoSomething()\n  return something + ' and I watched'\n}\nconst watchOverSomeoneWatchingSomeoneDoingSomething = async () => {\n  const something = await watchOverSomeoneDoingSomething()\n  return something + ' and I watched as well'\n}\nwatchOverSomeoneWatchingSomeoneDoingSomething().then(res => {\n  console.log(res)\n})\n\n//输出\nI did something and I watched and I watched as well\n```\n#### 更好debug\n调试promise很困难，因为调试器不会跳过异步代码。\n\nAsync/ wait使这一切变得非常简单，因为对于编译器来说，它就像同步代码一样。\n\n## ES 模块\nES模块是用于处理模块的ECMAScript标准。\n\nnodeJS多年来一直使用CommonJS标准，浏览器从来没有模块系统，因为每一个重大决策，比如模块系统，都必须首先由ECMAScript标准化，然后由浏览器实现。\n\n这个标准化过程用ES6完成，浏览器开始实现这个标准，试图保持一切正常运行，以相同的方式工作，现在在Chrome、Safari、Edge和Firefox(从版本60开始)中都支持ES模块。\n\n模块非常酷，因为它们允许您封装各种功能，并将这些功能作为库公开给其他JavaScript文件。\n\n#### ES模块语法\n导入模块的语法是:\n\n```\nimport package from 'module-name'\n```\n用CommonJS 时：\n\n```\nconst package = require('module-name')\n```\n模块是一个JavaScript文件，它使用export关键字导出一个或多个值(对象、函数或变量)。例如，这个模块导出一个函数，返回一个大写字符串:\n> uppercase.js\n\n```\nexport default str => str.toUpperCase()\n```\n\n在本例中，模块定义了一个default export，因此它可以是一个匿名函数。否则，它需要一个名称来将其与其他导出区分开。\n\n现在，通过导入这个文件，任何其他JavaScript模块都可以用导入的uppercase.js提供的功能。\nHTML页面可以使用\n```<script>``` 标记添加模块，该标记具有特殊的```type=\"module\"```属性:\n```\n<script type=\"module\" src=\"index.js\"></script>\n```\n> 注意:此模块导入的行为类似于defer脚本加载。\n\n需要注意的是，使用```type=\"module\"```加载的任何脚本都是在严格模式下加载的。\n\n在这个例子中，uppercase.js 模块定义了一个 default export,所以当我们导入它的时候，我们可以给它分配一个我们喜欢的名字:\n\n\n```\nimport toUpperCase from './uppercase.js'\n```\n\n我们可以这样使用\n\n```\ntoUpperCase('test') //'TEST'\n```\n您还可以使用模块导入的绝对路径，来引用在另一个域中定义的模块:\n\n```\nimport toUpperCase from 'https://flavio-es-modules-example.glitch.me/uppercase.js'\n```\n这也是有效的导入语法:\n\n```\nimport { foo } from '/uppercase.js'\nimport { foo } from '../uppercase.js'\n```\n下面是不对的：\n\n```\nimport { foo } from 'uppercase.js'\nimport { foo } from 'utils/uppercase.js'\n```\n它要么是绝对的，要么在名字前有一个./或者/。\n\n## 其他 import/export方法\n我们看到上面的例子:\n\n```\nexport default str => str.toUpperCase()\n```\n这将创建一个默认导出。在一个文件中，你可以导出多个东西，通过使用以下语法:\n\n\n```\nconst a = 1\nconst b = 2\nconst c = 3\nexport { a, b, c }\n```\n另一个模块可以使用import *来导入所有这些export的内容\n\n```\nimport * from 'module'\n```\n你可以只导入其中的几个导出，使用析构赋值:\n\n```\nimport { a } from 'module'\nimport { a, b } from 'module'\n```\n为了方便，可以使用as重命名任何导入\n\n```\nimport { a, b as two } from 'module'\n```\n您可以按名称导入默认导出和任何非默认导出，如以下常见的React导入:\n\n\n```\nimport React, { Component } from 'react'\n```\n## CORS(跨域)\n使用CORS获取模块。这意味着如果您引用来自其他域的脚本，它们必须具有允许跨站点加载的有效CORS头（比如Access-Control-Allow-Origin: *）\n#### 那么不支持模块的浏览器呢?\n结合使用```type=\"module\"``` 和```nomodule```\n\n```\n<script type=\"module\" src=\"module.js\"></script>\n<script nomodule src=\"fallback.js\"></script>\n```\nES模块是现代浏览器中引入的最大特性之一。它们是ES6的一部分，但实现它们的道路是漫长的。\n\n我们现在可以使用它们了!但是我们还必须记住，如果有多个模块，那么页面的性能将受到影响，因为这是浏览器在运行时必须执行更多一个步骤。\n\n即使ES模块在浏览器里能用了，Webpack可能仍然是一个巨大的玩家，但是直接在语言中构建这样的特性对于统一模块在客户端和nodeJS的工作方式是非常重要的。\n\n> 下节预告：React的概念\n","slug":"React_V16入门手册","published":1,"updated":"2019-04-10T02:31:49.115Z","comments":1,"photos":[],"link":"","_id":"cjuanzki50008jgf2os0zljsn","content":"<p>原文<a href=\"\">https://medium.freecodecamp.org/the-react-handbook-b71c27b0a795</a></p>\n<p>开始着手学习React，就看到大佬推荐的这篇文章，因为是英文，就尽自己能力翻译一下有错的烦请指正。原文一共220页A4纸，内容有点多，所以会分期更新，见谅</p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>这本React手册遵循二八原则：用20%的时间学习80%的内容</p>\n<p>在本手册里使用了React Hooks，所以你需要使用高于等于 16.7.0-alpha.2 版本的React和ReactDom.</p>\n<p>如果你使用create-react-app初始化项目时，在初始化项目之后运行<figure class=\"highlight plain\"><figcaption><span>install react@16.7.0-alpha.2 react-dom@16.7.0-</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alpha.2</span><br></pre></td></tr></table></figure></p>\n<p>我希望你能在你阅读完本手册后能达到一个目标：学会React的基础</p>\n<h2 id=\"React介绍\"><a href=\"#React介绍\" class=\"headerlink\" title=\"React介绍\"></a>React介绍</h2><p>先来介绍一下React库</p>\n<h4 id=\"什么是React\"><a href=\"#什么是React\" class=\"headerlink\" title=\"什么是React\"></a>什么是React</h4><p>React是一个旨在简化开发可视化界面的Javascript库。它由Facebook开发，并于2013年向世界发布，并支持着很多被广泛使用的App，包括Facebook和Instagram等无数应用程序。<br>它的主要目标是通过将UI划分为一组组件，使得在任何时间点都可以轻松地构建界面及其状态。</p>\n<h4 id=\"为什么React这么流行？\"><a href=\"#为什么React这么流行？\" class=\"headerlink\" title=\"为什么React这么流行？\"></a>为什么React这么流行？</h4><p>React席卷了整个前端开发领域，为什么？</p>\n<h4 id=\"比其他框架更低的复杂性\"><a href=\"#比其他框架更低的复杂性\" class=\"headerlink\" title=\"比其他框架更低的复杂性\"></a>比其他框架更低的复杂性</h4><p>在React出道之前，Ember.js和Angular1.X是主流框架。这两种方法在代码上强加了太多的约定，以至于移植现有的应用程序一点都不方便。React选择了非常容易集成到现有项目中的方式，因为Facebook必须实现这一点，这样才能将其引入现有代码库。另外，这两个框架本身包含的内容太多了，而React只选择实现视图层而不是完整的MVC技术栈。</p>\n<h4 id=\"完美的时间\"><a href=\"#完美的时间\" class=\"headerlink\" title=\"完美的时间\"></a>完美的时间</h4><p>当谷歌宣布Angular2.X时，宣称Angular1.X并不能平滑升级到Angular2.X，这两个就像不同的框架一样，所以想要从Angular1.X升级到Angular2.X就得重构项目。因为这一点，再加上React承诺说能带来执行速度的提升，所以很多程序员就迫不及待的尝试。</p>\n<h4 id=\"Facebook的支持\"><a href=\"#Facebook的支持\" class=\"headerlink\" title=\"Facebook的支持\"></a>Facebook的支持</h4><p>如果一个项目最终成功，得到Facebook的支持显然也会让它受益。Facebook目前对React非常感兴趣，并看到了它开源的价值，这对所有在自己项目中使用React的开发者来说都是一个巨大的优势。</p>\n<h4 id=\"React学起来容易吗？\"><a href=\"#React学起来容易吗？\" class=\"headerlink\" title=\"React学起来容易吗？\"></a>React学起来容易吗？</h4><p>虽然我说React要比其他框架简单，但是深入学习React的话还是挺有难度的，难的主要原因是要与React搭配使用的技术，比如Redux,GraphQL等等。</p>\n<p>React本身有一个非常小的API，你至少需要理解4个概念才能开始:</p>\n<ul>\n<li>Components</li>\n<li>JSX</li>\n<li>State</li>\n<li>Props</li>\n</ul>\n<p>上面这些（甚至更多）都会在手册中一一解释</p>\n<h2 id=\"如何安装React\"><a href=\"#如何安装React\" class=\"headerlink\" title=\"如何安装React\"></a>如何安装React</h2><h4 id=\"如何在你的电脑上安装React\"><a href=\"#如何在你的电脑上安装React\" class=\"headerlink\" title=\"如何在你的电脑上安装React?\"></a>如何在你的电脑上安装React?</h4><p>React是一个库，所以说安装这个词会有点奇怪，倒不如说“设置”更贴切。在你的app或者网页中有很多方式可以设置React</p>\n<h4 id=\"直接在网页里引入\"><a href=\"#直接在网页里引入\" class=\"headerlink\" title=\"直接在网页里引入\"></a>直接在网页里引入</h4><p>最简单的方法是直接将React JavaScript文件添加到页面中。当React应用与单个页面上的元素进行交互，而不是实际控制整个导航时，这是最好的选择。</p>\n<p>下面的例子中，你在body的最后添加了两个script标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">    &lt;body&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">        &lt;script</span><br><span class=\"line\">        src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/16.7.0-alpha.2/umd/react.development.js&quot; </span><br><span class=\"line\">        crossorigin&gt;</span><br><span class=\"line\">        &lt;/script&gt;</span><br><span class=\"line\">        &lt;script</span><br><span class=\"line\">        src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react-dom/16.7.0-alpha.2/umd/react-dom.production.min.js&quot;</span><br><span class=\"line\">        crossorigin&gt;</span><br><span class=\"line\">        &lt;/script&gt;</span><br><span class=\"line\">    &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>在这里我们引入两个库（React和React Dom），是为什么呢？因为React是百分之的独立于浏览器的，你也可以在浏览器之外使用React（比如用React Native开发移动应用时，也能用React），因此需要React Dom来操作dom。</p>\n<p>在引入Javascript文件后，你需要为react，在html里添加script标签，才能使用JSX语法，下面两种方式都可以<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//在app.js里写JSX</span><br><span class=\"line\">&lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;!-- or --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">//直接在标签内写JSX</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">//my app</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如果要使用JSX，你还需要引入Babel</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>引入后要在之前写的script标签里添加type=”text/babel”才会生效，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;app.js&quot; type=&quot;text/babel&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>现在你可以在你的app.js里写JSX的代码了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Button = () =&gt; &#123;</span><br><span class=\"line\">return &lt;button&gt;Click me!&lt;/button&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ReactDOM.render(&lt;Button /&gt;, document.getElementById(&apos;root&apos;))</span><br></pre></td></tr></table></figure>\n<p>演示代码地址：<br><a href=\"演示代码\">https://glitch.com/edit/#!/react-example-inline-jsx?path=index.html:21:19</a></p>\n<h4 id=\"用官方脚手架create-react-app（推荐）\"><a href=\"#用官方脚手架create-react-app（推荐）\" class=\"headerlink\" title=\"用官方脚手架create-react-app（推荐）\"></a>用官方脚手架create-react-app（推荐）</h4><p>create-react-app旨在让你能快速构建一个React项目，任何React应用都可以使用create-react-app来生成一个单页页面。</p>\n<p>首先你需要安装npm和node （地址：<a href=\"\">https://nodejs.org/en/</a>）就不多说了<br>然后执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx create-react-app todolist</span><br></pre></td></tr></table></figure>\n<p>npx是npm 5.2之后才有的工具，npx会下载create-react-app，然后解压安装，然后执行<figure class=\"highlight plain\"><figcaption><span>todolist```,然后再把create-react-app从系统中删除。这样你就永远能够使用最新的create-react-app，不会在电脑里存放着过时的create-react-app。</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">执行完之后你能看到下面的界面</span><br><span class=\"line\"></span><br><span class=\"line\">![](https://user-gold-cdn.xitu.io/2019/1/18/168602568623fb3a?w=741&amp;h=677&amp;f=png&amp;s=36167)</span><br><span class=\"line\"></span><br><span class=\"line\">create-react-app会在文件夹内创建相应的文件结构，文件名就是todolist（自己取的）</span><br><span class=\"line\">package.json也同样生成了，只需要安装指示，进入相应的文件夹，执行npm start就可以启动项目了</span><br><span class=\"line\"></span><br><span class=\"line\">如图</span><br><span class=\"line\"></span><br><span class=\"line\">![](https://user-gold-cdn.xitu.io/2019/1/18/168602a792310119?w=454&amp;h=260&amp;f=png&amp;s=12615)</span><br><span class=\"line\"></span><br><span class=\"line\">打开浏览器进入http://localhost:3000/就能看到最开始的界面了。</span><br><span class=\"line\"></span><br><span class=\"line\">除了 npm start , create-react-app这两个命令之外，还有下面一些命令</span><br><span class=\"line\">* npm run build ：要在构建文件夹中构建准备部署到服务器的React应用程序文件</span><br><span class=\"line\">* npm test：运行Jest测试包</span><br><span class=\"line\">* npm eject ：弹出配置文件 </span><br><span class=\"line\">何时用npm eject？create-react-app已经做了很多工作了，但你想要完成更多的工作时，就要弹出配置文件来自己配置。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">因为create-react-app 是为了满足大部分人的需求和有限的配置，当你有一些独特的需求时，就需要自己来配置一些内容了。</span><br><span class=\"line\"></span><br><span class=\"line\">当你使用npm eject时，你的页面就不会自动更新了，但你可以在Babel和Webpack配置中获得更大的灵活性。</span><br><span class=\"line\"></span><br><span class=\"line\">eject时是不可逆的，当你执行后你会获得两个新的文件夹，配置和脚本。你就可以开始自由的编辑他们了。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 下节预告：下节我们将学习在学习React之前需要了解的JS语法及一些知识</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用React需要什么样的JS能力</span><br><span class=\"line\">#### 在深入学习React之前找到你必须要掌握的内容</span><br><span class=\"line\">如果你想学习React时，首先你需要做一些事情。您必须熟悉一些必要的技术，特别是你将在React中反复使用的一些最新JavaScript特性相关的技术。</span><br><span class=\"line\"></span><br><span class=\"line\">有些人以为一些功能是React提供的一些特定的功能，实际上它们只是Javascript最新的语法。</span><br><span class=\"line\"></span><br><span class=\"line\">立即掌握这些新语法，成为这方面的专家是不可能的，也没必要。但你如果想要深入研究React，那你就需要熟练掌握他们了。</span><br><span class=\"line\"></span><br><span class=\"line\">我会把它们列举下来让你快速了解一下。</span><br><span class=\"line\"></span><br><span class=\"line\">## 变量</span><br><span class=\"line\">变量是分配给标识符的文字，因此您可以引用它并在后面的程序里使用它。学习如何用JavaScript声明一个。</span><br><span class=\"line\"></span><br><span class=\"line\">JavaScript中的变量没有附加任何类型。将特定的文字类型分配给变量后，可以稍后再给这个变量分配类型，而不会出现类型错误或任何问题。</span><br><span class=\"line\"></span><br><span class=\"line\">所以这就是为什么有时候Javascript会报&apos;untyped&apos;这样的问题。</span><br><span class=\"line\"></span><br><span class=\"line\">一个变量必须在你使用之前就声明。有三种方法可以做到这一点，使用var、let或const，这三种方法在以后与变量的交互方式上有所不同。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 用Var</span><br><span class=\"line\">知道ES2015，var一直都是定义变量的唯一方法。</span><br></pre></td></tr></table></figure></p>\n<p>var a = 0<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果你忘了添加var，你给未声明的变量赋值，结果可能会有所不同，在严格模式下，会得到一个错误，在旧的环境，或者禁用严格模式下，就会使得该变量成为一个全局变量，赋值也自然会赋值给一个全局变量。</span><br><span class=\"line\"></span><br><span class=\"line\">如果你没有将变量初始化，那他的值就是undefined</span><br></pre></td></tr></table></figure></p>\n<p>var a //typeof a === ‘undefined’</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">你可以多次声明变量</span><br></pre></td></tr></table></figure>\n<p>var a = 1<br>var a = 2<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最重要的，你可以一次就声明多个变量</span><br></pre></td></tr></table></figure></p>\n<p>var a = 1, b = 2<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用域是代码中变量可见的部分（有效）。在函数外部声明一个变量，变量就是全局的，所有的函数都可以获得该变量的值，但在函数内部声明一个变量，变量就是局部的，只有在该函数内才能获得该变量的值，就像函数的一个参数。</span><br><span class=\"line\"></span><br><span class=\"line\">在与全局变量同名的函数中定义的任何变量都优先于全局变量，并对其进行跟踪。</span><br><span class=\"line\"></span><br><span class=\"line\">重要的是要理解一个块(由一对花括号标识)没有定义一个新的作用域。新作用域只在创建函数时创建，因为var没有块作用域，而是函数作用域。</span><br><span class=\"line\"></span><br><span class=\"line\">函数内部,在函数的所有代码中，变量在任何位置都是可见的,即使函数的变量声明在函数最后仍然可以引用。,因为JavaScript执行代码之前将所有变量提升。但为了避免混淆，总是在函数的开头声明变量。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 用Let</span><br><span class=\"line\"></span><br><span class=\"line\">let是ES2015中引入的一个新特性，它本质上是var的块范围版本。它的作用域仅限于定义它的块、语句或表达式以及所有包含的内部块。</span><br><span class=\"line\"></span><br><span class=\"line\">现代JavaScript开发人员可能选择只使用let，而完全放弃使用var。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 如果let看起来是一个模糊的术语，只要看let color = &apos;red&apos;就是让颜色是红色，这就更容易理解了</span><br><span class=\"line\"></span><br><span class=\"line\">与var相反，在任何函数外部定义let都不会创建全局变量。</span><br><span class=\"line\">#### 用Const</span><br><span class=\"line\"></span><br><span class=\"line\">用var或let声明的变量可以稍后在程序中更改并重新分配。一旦const被初始化，它的值就再也不会被更改，也不能被重新分配到不同的值。</span><br></pre></td></tr></table></figure></p>\n<p>const a = ‘test’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们不能给a常量定义不同的文字了。但是，如果对象提供了改变其内容的方法，我们可以对它进行变异。</span><br><span class=\"line\">const 定义了就不能修改或重新赋值</span><br><span class=\"line\"></span><br><span class=\"line\">const和let一样都有块级作用域</span><br><span class=\"line\"></span><br><span class=\"line\">现代JavaScript开发人员可能会选择始终对不需要在程序中稍后重新分配的变量使用const。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 为什么?因为我们应该总是使用最简单的结构来避免将来犯错误。</span><br><span class=\"line\"></span><br><span class=\"line\">## 箭头函数</span><br><span class=\"line\"></span><br><span class=\"line\">箭头函数是在ES6 / ECMAScript 2015中引入的，自从引入以来，它们彻底改变了JavaScript代码的外观(和工作方式)。</span><br><span class=\"line\"></span><br><span class=\"line\">在我看来，这种变化非常受欢迎，以至于你现在很少看到在现代代码库中使用function关键字。</span><br><span class=\"line\"></span><br><span class=\"line\">从视觉上看，这是一个简单而受欢迎的改变，它允许你用更短的语法编写函数，从:</span><br></pre></td></tr></table></figure></p>\n<p>const myFunction = function() {<br>//…<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">到</span><br></pre></td></tr></table></figure></p>\n<p>const myFunction = () =&gt; {<br>//…<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果函数体只包含一条语句，则可以省略括号，并将所有内容写在一行中:</span><br></pre></td></tr></table></figure></p>\n<p>const myFunction = () =&gt; doSomething()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参数在括号中传递:</span><br></pre></td></tr></table></figure></p>\n<p>const myFunction = (param1, param2) =&gt; doSomething(param1, param2)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果有一个(且只有一个)参数，可以完全省略括号:</span><br></pre></td></tr></table></figure></p>\n<p>const myFunction = param =&gt; doSomething(param)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">由于这种简短的语法，箭头函数让我们能使用小体积的函数。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 隐式返回</span><br><span class=\"line\"></span><br><span class=\"line\">箭头函数允许你使用隐式返回：返回的值不需要使用return关键字。</span><br><span class=\"line\"></span><br><span class=\"line\">当函数体中有一行语句时，它就可以工作:</span><br></pre></td></tr></table></figure></p>\n<p>const myFunction = () =&gt; ‘test’<br>myFunction() //‘test’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">另一个例子，当返回一个对象时，记得将大括号括起来，以避免它被认为是括起来的函数的括号:</span><br></pre></td></tr></table></figure></p>\n<p>const myFunction = () =&gt; ({ value: ‘test’ })<br>myFunction() //{value: ‘test’}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### this在箭头函数里如何工作</span><br><span class=\"line\">this是一个很难理解的概念。因为它会根据上下文和JavaScript的模式(严格模式或非严格模式)产生不同的含义。</span><br><span class=\"line\"></span><br><span class=\"line\">澄清这个概念很重要，因为在箭头函数中的this与常规函数中的this非常不同。</span><br><span class=\"line\"></span><br><span class=\"line\">当定义一个对象的方法时，在常规函数中的this指向这个对象，案例如下：</span><br></pre></td></tr></table></figure></p>\n<p>const car = {<br>    model: ‘Fiesta’,<br>    manufacturer: ‘Ford’,<br>    fullName: function() {<br>        return <code>${this.manufacturer} ${this.model}</code><br>    }<br>}<br>car.fullName() //“Ford Fiesta”<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行car.fullName()时会返回&quot;Ford Fiesta&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">带有箭头函数的this作用域是从执行上下文中继承的。箭头函数根本不绑定this，因此它的值将在调用堆栈中查找。因此在这个代码car.fullName()中不起作用，并将返回字符串“undefined undefined”:</span><br></pre></td></tr></table></figure></p>\n<p>const car = {<br>    model: ‘Fiesta’,<br>    manufacturer: ‘Ford’,<br>    fullName: () =&gt; {<br>        return <code>${this.manufacturer} ${this.model}</code><br>    }<br>}<br>car.fullName() //“undefined undefined”<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参考上面两个例子，可以看出，箭头函数并不适用于对象的方法。</span><br><span class=\"line\"></span><br><span class=\"line\">箭头函数也不能用作构造函数，因为实例化对象时将报错TypeError。当不需要动态上下文时，应该在这里使用箭头函数来代替常规函数。</span><br><span class=\"line\"></span><br><span class=\"line\">在处理事件时还有一个问题，DOM事件侦听器将this设置为目标元素，如果在事件处理程序中依赖于此元素，则需要一个常规函数:</span><br></pre></td></tr></table></figure></p>\n<p>const link = document.querySelector(‘#link’)<br>link.addEventListener(‘click’, () =&gt; {<br>    // this === window<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>const link = document.querySelector(‘#link’)<br>link.addEventListener(‘click’, function() {<br>    // this === link<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 使用Rest和Spread处理对象和数组</span><br><span class=\"line\">#### 学习使用JavaScript处理数组和对象的两种现代技术</span><br><span class=\"line\">您可以使用spread操作符展开数组、对象或字符串  ...</span><br><span class=\"line\"></span><br><span class=\"line\">看下面的例子：</span><br></pre></td></tr></table></figure></p>\n<p>const a = [1, 2, 3]<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">你可以像下面一样创建一个新数组</span><br></pre></td></tr></table></figure></p>\n<p>const b = […a, 4, 5, 6]<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">还可以像下面一样创建一个数组的副本</span><br></pre></td></tr></table></figure></p>\n<p>const b = […a]<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">也能用这种方式拷贝一个对象</span><br></pre></td></tr></table></figure></p>\n<p>const newObj = { …oldObj }<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用字符串时，spread操作符创建一个数组，数组内是每个字符:</span><br></pre></td></tr></table></figure></p>\n<p>const hey = ‘hey’<br>const arrayized = […hey] // [‘h’, ‘e’, ‘y’]<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这个操作符有一些非常有用的应用。最重要的是能够以一种非常简单的方式将数组作为函数参数:</span><br></pre></td></tr></table></figure></p>\n<p>const f = (foo, bar) =&gt; {}<br>const a = [1, 2]<br>f(…a)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(在过去，你可以用f.apply(null, a) 来做这个但是这样做不太好，可读性也不好)</span><br><span class=\"line\"></span><br><span class=\"line\">rest元素和spread元素在使用数组解构赋值时非常有用:</span><br></pre></td></tr></table></figure></p>\n<p>const numbers = [1, 2, 3, 4, 5]<br>[first, second, …others] = numbers</p>\n<p>const numbers = [1, 2, 3, 4, 5]<br>const sum = (a, b, c, d, e) =&gt; a + b + c + d + e<br>const sum = sum(…numbers)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ES2018引入了rest属性，它们是相同的，但是是用于对象。</span><br><span class=\"line\"></span><br><span class=\"line\">Rest属性</span><br></pre></td></tr></table></figure></p>\n<p>const { first, second, …others } = {<br>    first: 1,<br>    second: 2,<br>    third: 3,<br>    fourth: 4,<br>    fifth: 5<br>}<br>first // 1<br>second // 2<br>others // { third: 3, fourth: 4, fifth: 5 }<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">扩展属性允许通过合并在扩展操作符之后传递的对象属性来创建一个新对象:</span><br></pre></td></tr></table></figure></p>\n<p>const items = { first, second, …others }<br>items //{ first: 1, second: 2, third: 3, fourth: 4, fifth: 5 }<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 数组和对象的解构赋值</span><br><span class=\"line\">#### 学习如何使用解构赋值语法来处理JavaScript中的数组和对象</span><br><span class=\"line\">给定一个对象，使用解构赋值语法，您可以提取一些值，并将它们放入命名变量:</span><br></pre></td></tr></table></figure></p>\n<p>const person = {<br>firstName: ‘Tom’,<br>lastName: ‘Cruise’,<br>actor: true,<br>age: 54 //made up<br>}<br>const { firstName: name, age } = person //name: Tom, age: 54<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name和age包含了所需要的值。</span><br><span class=\"line\"></span><br><span class=\"line\">这个语法也可以在数组上使用</span><br></pre></td></tr></table></figure></p>\n<p>const a = [1, 2, 3, 4, 5]<br>const [first, second] = a<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">该语句通过从数组a中获取索引0、1、4的项来创建3个新变量（first，second，fifth）</span><br></pre></td></tr></table></figure></p>\n<p>const [first, second, , , fifth] = a<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 模板字符串</span><br><span class=\"line\">在ES2015(又名ES6)中引入的模板字符串提供了一种声明字符串的新方法，也提供了一些已经非常流行的有趣的新构造方法。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 模板字符串介绍</span><br><span class=\"line\"></span><br><span class=\"line\">模板文字是ES2015 / ES6的新特性，与ES5及以下版本相比，它允许你以一种新颖的方式处理字符串。</span><br><span class=\"line\">语法乍一看非常简单，只需使用反引号而不是单引号或双引号:</span><br></pre></td></tr></table></figure></p>\n<p>const a_string = <code>something</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">它们是很独特的的，因为它们提供了许多用引号构建的普通字符串所没有的特性，特别是:</span><br><span class=\"line\">* 它们提供了一个很好的语法来定义多行字符串</span><br><span class=\"line\">* 它们提供了一种简单的方法在字符串中用变量和表达式插值</span><br><span class=\"line\">* 它们允许您使用模板标记创建DSL (DSL意味着特定于领域的语言，例如在React by style组件中使用DSL为组件定义CSS)</span><br><span class=\"line\"></span><br><span class=\"line\">#### 让我们详细研究上面三个东西</span><br><span class=\"line\">#### 多行字符串</span><br><span class=\"line\">在es6之前，要创建一个跨越两行的字符串，您必须在一行末尾使用\\字符</span><br></pre></td></tr></table></figure></p>\n<p>const string =<br>  ‘first part \\<br>second part’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这允许在两行创建一个字符串，但它只呈现在一行:</span><br></pre></td></tr></table></figure></p>\n<p>first part second part<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">要在多行渲染字符串，你需要显式地在每行末尾添加\\n，如下所示:</span><br></pre></td></tr></table></figure></p>\n<p>const string =<br>  ‘first line\\n \\<br>second line’</p>\n<p>//或者<br>const string = ‘first line\\n’ + ‘second line’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用模板字符串就简单多了</span><br><span class=\"line\"></span><br><span class=\"line\">一旦模板文字使用回车，你只需按回车键来创建一个没有特殊字符的新行，它就会按原样呈现:</span><br></pre></td></tr></table></figure></p>\n<p>const string = `Hey<br>this</p>\n<p>string<br>is awesome!`</p>\n<p>//结果如下<br>Hey<br>this</p>\n<p>string<br>is awesome!<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">记住，模板字符串的空格是有意义的，所以这样做:</span><br></pre></td></tr></table></figure></p>\n<p>const string = <code>First\n                Second</code></p>\n<p>//结果如下<br>First<br>                Second<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">解决这个问题的一种简单方法是，在第一行中设置一个空行，并在结束后加上trim()方法，这将消除第一个字符之前的任何空格:</span><br></pre></td></tr></table></figure></p>\n<p>const string = <code>First\nSecond</code>.trim()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 模板字符串插值</span><br><span class=\"line\">模板字符串提供了一种将变量和表达式插入字符串的简单方法。</span><br><span class=\"line\">你可以用这样的语法```$&#123;...&#125;```：</span><br></pre></td></tr></table></figure></p>\n<p>const var = ‘test’<br>const string = <code>something ${var}</code> //something test<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在```$&#123;...&#125;```里你可以插入任何东西，甚至是表达式</span><br></pre></td></tr></table></figure></p>\n<p>const string = <code>something ${1 + 2 + 3}</code><br>const string2 = <code>something ${foo() ? &#39;x&#39; : &#39;y&#39;}</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## Class（类）</span><br><span class=\"line\">2015年，ECMAScript 6 (ES6)标准引入了类。</span><br><span class=\"line\"></span><br><span class=\"line\">JavaScript有一种非常少见的实现继承的方法:原型继承。虽然原型继承在我看来很好，但它不同于大多数其他流行编程语言的继承实现，后者是基于类的。</span><br><span class=\"line\"></span><br><span class=\"line\">来自Java、Python或其他语言的人很难理解原型继承的复杂性，所以ECMAScript委员会决定在原型继承的基础上添加语法糖，这样就像其他流行实现中的基于类的继承一样。</span><br><span class=\"line\"></span><br><span class=\"line\">这一点很重要:底层的JavaScript仍然是相同的，您还是可以用常规的方式访问对象原型。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 一个class类的定义</span><br><span class=\"line\">一个类长下面这样</span><br></pre></td></tr></table></figure></p>\n<p>class Person {<br>  constructor(name) {<br>    this.name = name<br>  }<br>  hello() {<br>    return ‘Hello, I am ‘ + this.name + ‘.’<br>  }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类有一个标识符，我们可以使用它来使用new ClassIdentifier()创建新对象</span><br><span class=\"line\"></span><br><span class=\"line\">初始化对象时，调用constructor方法，并传递任意参数。</span><br><span class=\"line\"></span><br><span class=\"line\">一个类也有它所需要的所有方法。在这种情况下，hello是一个方法，这个类派生的所有对象都可以调用这个方法:</span><br></pre></td></tr></table></figure></p>\n<p>const flavio = new Person(‘Flavio’)<br>flavio.hello()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 类的实例</span><br><span class=\"line\"></span><br><span class=\"line\">类可以扩展另一个类，使用该类初始化的对象继承父类的所有方法。</span><br><span class=\"line\"></span><br><span class=\"line\">如果继承的类的方法与层次结构中较高层的类的名称相同，则最近的方法优先:</span><br></pre></td></tr></table></figure></p>\n<p>class Programmer extends Person {<br>  hello() {<br>    return super.hello() + ‘ I am a programmer.’<br>  }<br>}<br>const flavio = new Programmer(‘Flavio’)<br>flavio.hello()<br>//输出 Hello, I am Flavio. I am a programmer.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类没有显式的类变量声明，但是必须初始化构造函数中的任何变量</span><br><span class=\"line\"></span><br><span class=\"line\">在类中，可以用super()来引用父类。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 静态方法</span><br><span class=\"line\">通用方法是在实例上定义的，而不是在类上定义的。</span><br><span class=\"line\">静态方法在类上执行:</span><br></pre></td></tr></table></figure></p>\n<p>class Person {<br>  static genericHello() {<br>    return ‘Hello’<br>  }<br>}<br>Person.genericHello() //Hello<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 私有方法</span><br><span class=\"line\">JavaScript没有内置的方法来定义私有或受保护的方法。（可以参考闭包等概念）</span><br><span class=\"line\"></span><br><span class=\"line\">有一些变通方法，但我不会在这里描述它们。</span><br><span class=\"line\">#### Getters 和 setters</span><br><span class=\"line\">你可以添加以get或set为前缀的方法来创建getter和setter，这是根据您正在做的事情执行两段不同的代码:访问变量或修改其值。</span><br></pre></td></tr></table></figure></p>\n<p>class Person {<br>  constructor(name) {<br>    this._name = name<br>  }<br>  set name(value) {<br>    this._name = value<br>  }<br>  get name() {<br>    return this._name<br>  }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果您只有一个getter，则无法设置该属性，并且任何这样做的尝试都将被忽略:</span><br></pre></td></tr></table></figure></p>\n<p>class Person {<br>  constructor(name) {<br>    this.name = name<br>  }<br>  get name() {<br>    return this.name<br>  }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果你只有一个setter，你可以改变值，但不能从外部访问它:</span><br></pre></td></tr></table></figure></p>\n<p>class Person {<br>  constructor(name) {<br>    this.name = name<br>  }<br>  set name(value) {<br>    this.name = value<br>  }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 回调</span><br><span class=\"line\">计算机在设计上是异步的。</span><br><span class=\"line\"></span><br><span class=\"line\">异步意味着事情可以独立于主程序流发生。</span><br><span class=\"line\"></span><br><span class=\"line\">在当前的客户端计算机中，每个程序都运行一个特定的时间段，然后停止执行，让另一个程序继续执行。这个东西以一种无法察觉的速度循环运行，我们认为计算机同时运行许多程序，但这是一种错觉(多处理器机器除外)。</span><br><span class=\"line\"></span><br><span class=\"line\">程序在内部使用中断——这是一种向处理器发出的信号，以引起系统的注意。</span><br><span class=\"line\"></span><br><span class=\"line\">我不会深入讨论它的内部原理，但是要记住，程序是异步的是很正常的，在它们需要注意的时候停止它们的执行，而计算机可以同时执行其他事情。当程序正在等待来自网络的响应时，它不能在请求完成之前停止处理器。</span><br><span class=\"line\"></span><br><span class=\"line\">通常，编程语言是同步的，有些语言提供了一种方法来管理语言或库中的异步性。C, Java, c#， PHP, Go, Ruby, Swift, Python，它们默认都是同步的。其中一些通过使用线程处理异步，生成一个新进程。</span><br><span class=\"line\"></span><br><span class=\"line\">JavaScript默认是同步的，并且是单线程的。这意味着代码不能创建新线程并并行运行。</span><br><span class=\"line\"></span><br><span class=\"line\">一行接一行的执行代码，例如:</span><br></pre></td></tr></table></figure></p>\n<p>const a = 1<br>const b = 2<br>const c = a * b<br>console.log(c)<br>doSomething()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">但是JavaScript是在浏览器中诞生的，它最初的主要工作是响应用户操作，比如onClick、onMouseOver、onChange、onSubmit等等。它如何使用同步编程模型实现这一点呢?</span><br><span class=\"line\"></span><br><span class=\"line\">答案就在它所处的环境中。浏览器提供了一种方法，它提供了一组api来处理这种功能。</span><br><span class=\"line\"></span><br><span class=\"line\">最近，NodeJS引入了一个非阻塞I/O环境，将这个概念扩展到文件访问、网络调用等。</span><br><span class=\"line\"></span><br><span class=\"line\">你不知道用户什么时候会点击按钮，所以你要做的是，为点击事件定义一个事件处理器。此事件处理程序接受一个函数，该函数将在事件触发时被调用:</span><br></pre></td></tr></table></figure></p>\n<p>document.getElementById(‘button’).addEventListener(‘click’, () =&gt; {<br>  //item clicked<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这就是回调（callback)</span><br><span class=\"line\"></span><br><span class=\"line\">回调是一个简单的函数，它作为一个值传递给另一个函数，只在事件发生时执行。我们可以这样做，因为JavaScript具有一流的函数，可以将其分配给变量并传递给其他函数(称为高阶函数)</span><br><span class=\"line\"></span><br><span class=\"line\">将所有代码包装在windows对象上的load事件监听器中是很常见的，它只在页面准备好时才运行回调函数:</span><br></pre></td></tr></table></figure></p>\n<p>window.addEventListener(‘load’, () =&gt; {<br>  //window loaded<br>  //do what you want<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">回调可以用在任何地方，不只是dom事件上</span><br><span class=\"line\"></span><br><span class=\"line\">一个常用的定时器例子：</span><br></pre></td></tr></table></figure></p>\n<p>setTimeout(() =&gt; {<br>  // runs after 2 seconds<br>}, 2000)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">XHR请求也接受回调，在本例中，它将一个函数分配给一个属性，该属性将在特定事件发生时被调用(在本例中，请求状态发生变化):</span><br></pre></td></tr></table></figure></p>\n<p>const xhr = new XMLHttpRequest()<br>xhr.onreadystatechange = () =&gt; {<br>  if (xhr.readyState === 4) {<br>    xhr.status === 200 ? console.log(xhr.responseText) : console.error(‘error’)<br>  }<br>}<br>xhr.open(‘GET’, ‘<a href=\"https://yoursite.com&#39;\" target=\"_blank\" rel=\"noopener\">https://yoursite.com&#39;</a>)<br>xhr.send()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### 处理回调中的错误</span><br><span class=\"line\"></span><br><span class=\"line\">如何在回调处理错误?一个非常常见的策略是使用Node所采用的方法:任何回调函数中的第一个参数都是error对象:error-first回调</span><br><span class=\"line\"></span><br><span class=\"line\">如果没有错误，则对象为null。如果有错误，它包含错误的一些描述和其他信息。</span><br></pre></td></tr></table></figure></p>\n<p>fs.readFile(‘/file.json’, (err, data) =&gt; {<br>  if (err !== null) {<br>    //handle error<br>    console.log(err)<br>    return<br>  }<br>  //no errors, process data<br>  console.log(data)<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### 回调存在的问题</span><br><span class=\"line\"></span><br><span class=\"line\">回调对于简单的情况非常有用</span><br><span class=\"line\"></span><br><span class=\"line\">然而，每个回调都会增加一个嵌套级别，当你有很多回调时，代码开始变得非常复杂:</span><br></pre></td></tr></table></figure></p>\n<p>window.addEventListener(‘load’, () =&gt; {<br>  document.getElementById(‘button’).addEventListener(‘click’, () =&gt; {<br>    setTimeout(() =&gt; {<br>      items.forEach(item =&gt; {<br>        //your code here<br>      })<br>    }, 2000)<br>  })<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这只是一个简单的4层代码，但我见过更多级别的嵌套，这并不有趣。</span><br><span class=\"line\">怎么解呢?</span><br><span class=\"line\"></span><br><span class=\"line\">## 回调的替代品</span><br><span class=\"line\">从ES6开始，JavaScript引入了几个特性，帮助我们处理不涉及回调的异步代码:</span><br><span class=\"line\"></span><br><span class=\"line\">* Promises (ES6)</span><br><span class=\"line\">* Async/Await (ES8)</span><br><span class=\"line\">## Promise</span><br><span class=\"line\">Promise是处理异步代码的一种方法，无需在代码中编写太多回调。</span><br><span class=\"line\"></span><br><span class=\"line\">尽管它们已经存在多年，但是在ES2015中已经被标准化并引入，现在在ES2017中已经被异步函数所取代。</span><br><span class=\"line\"></span><br><span class=\"line\">Async函数使用promise API作为它们的构建块，因此理解它们是非常重要的，即使在较新的代码中您可能会使用Async函数而不是promise。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 简而言之，Promise是如何工作的</span><br><span class=\"line\">一旦Promise被调用，它将以pending状态启动。这意味着调用方函数将继续执行，同时等待Promise自己进行处理，并给调用方函数一些反馈。</span><br><span class=\"line\"></span><br><span class=\"line\">此时，调用方函数等待它以resolved状态或rejected状态返回承诺，但如您所知，JavaScript是异步的，因此函数在Promise工作时继续执行。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 哪个JS API使用Promise?</span><br><span class=\"line\">除了您自己的代码和库代码之外，Promises还被标准的现代Web api(如Fetch或Service Workers)使用。</span><br><span class=\"line\"></span><br><span class=\"line\">在现代JavaScript中，您不太可能不使用承诺，所以让我们开始深入研究它们。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 创建一个promise</span><br><span class=\"line\"></span><br><span class=\"line\">Promise API公开了一个Promise构造函数，您可以使用它进行初始化```new Promise()```：</span><br></pre></td></tr></table></figure></p>\n<p>let done = true<br>const isItDoneYet = new Promise((resolve, reject) =&gt; {<br>  if (done) {<br>    const workDone = ‘Here is the thing I built’<br>    resolve(workDone)<br>  } else {<br>    const why = ‘Still working on something else’<br>    reject(why)<br>  }<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">正如您所看到的，promise检查done全局常量，如果它为真，则返回一个resolve的promise，否则返回一个 reject的promise。</span><br><span class=\"line\"></span><br><span class=\"line\">使用resolve和reject，我们可以返回一个值，在上面的例子中，我们只返回一个字符串，但它也可以是一个对象。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 使用promise</span><br><span class=\"line\">在上一节中，我们介绍了如何创建承诺。</span><br><span class=\"line\">现在让我们看看如何使用承诺。</span><br></pre></td></tr></table></figure></p>\n<p>const isItDoneYet = new Promise()<br>//…<br>const checkIfItsDone = () =&gt; {<br>  isItDoneYet<br>    .then(ok =&gt; {<br>      console.log(ok)<br>    })<br>    .catch(err =&gt; {<br>      console.error(err)<br>    })<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行checkIfItsDone()将执行isItDoneYet() promise，并使用then回调等待它解决，如果出现错误，它将在catch回调中处理它。</span><br><span class=\"line\"></span><br><span class=\"line\">#### promise链</span><br><span class=\"line\"></span><br><span class=\"line\">一个promise可以返回给另一个promise，创建一个promise链。</span><br><span class=\"line\"></span><br><span class=\"line\">Fetch API是链接承诺的一个很好的例子，它是XMLHttpRequest API之上的一层，我们可以使用它来获取资源，并在获取资源时对要执行的promise链进行排队。</span><br><span class=\"line\"></span><br><span class=\"line\">Fetch API是一种基于promise的机制，调用Fetch()相当于使用new promise()定义我们自己的promise。</span><br><span class=\"line\"></span><br><span class=\"line\">例子：</span><br></pre></td></tr></table></figure></p>\n<p>const status = response =&gt; {<br>  if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) {<br>    return Promise.resolve(response)<br>  }<br>  return Promise.reject(new Error(response.statusText))<br>}<br>const json = response =&gt; response.json()<br>fetch(‘/todos.json’)<br>  .then(status)<br>  .then(json)<br>  .then(data =&gt; {<br>    console.log(‘Request succeeded with JSON response’, data)<br>  })<br>  .catch(error =&gt; {<br>    console.log(‘Request failed’, error)<br>  })<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在本例中，我们调用fetch()从TODO中获取TODO项的列表。在域根目录中找到json文件，然后创建promise链。</span><br><span class=\"line\"></span><br><span class=\"line\">运行 fetch()后返回一个响应，它有很多属性，在这些属性中我们引用:</span><br><span class=\"line\">* status表示HTTP状态代码的数值</span><br><span class=\"line\">* statusText状态消息，如果是OK就是请求成功</span><br><span class=\"line\"></span><br><span class=\"line\">response也有一个json()方法，它返回一个promise，该promise将解析处理并转换为JSON的主体内容。</span><br><span class=\"line\"></span><br><span class=\"line\">在这些前提下，会发生这样的情况:链中的第一个promise是我们定义的一个函数status()，它检查响应状态，如果它不是一个成功响应(在200到299之间)，则拒绝该promise。</span><br><span class=\"line\"></span><br><span class=\"line\">此操作将导致promise链跳过列出的所有链接的promise，并直接跳到底部的catch()语句，记录请求失败的文本和错误消息。</span><br><span class=\"line\"></span><br><span class=\"line\">如果成功，则调用我们定义的json()函数。由于上一个promise成功时返回响应对象，所以我们将它作为第二个promise的输入。</span><br><span class=\"line\"></span><br><span class=\"line\">在这种情况下，我们返回JSON处理过的数据，所以第三个promise直接接收JSON:</span><br></pre></td></tr></table></figure></p>\n<p>.then((data) =&gt; {<br>  console.log(‘Request succeeded with JSON response’, data)<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们只需将其打印到控制台</span><br><span class=\"line\"></span><br><span class=\"line\">#### 处理错误</span><br><span class=\"line\">在上面的例子中，在上一节中，我们有一个catch，它被附加到promise链中。</span><br><span class=\"line\"></span><br><span class=\"line\">当promise链中的任何内容失败并引发错误或拒绝promise时，该控件将转到链中最近的catch()语句。</span><br></pre></td></tr></table></figure></p>\n<p>new Promise((resolve, reject) =&gt; {<br>  throw new Error(‘Error’)<br>}).catch(err =&gt; {<br>  console.error(err)<br>})<br>// or<br>new Promise((resolve, reject) =&gt; {<br>  reject(‘Error’)<br>}).catch(err =&gt; {<br>  console.error(err)<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 串联错误</span><br><span class=\"line\">如果在catch()中引发错误，可以附加第二个catch()来处理它，依此类推。</span><br></pre></td></tr></table></figure></p>\n<p>new Promise((resolve, reject) =&gt; {<br>  throw new Error(‘Error’)<br>})<br>  .catch(err =&gt; {<br>    throw new Error(‘Error’)<br>  })<br>  .catch(err =&gt; {<br>    console.error(err)<br>  })<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 用 Promise.all()来编排promise</span><br><span class=\"line\">如果您需要同步执行不同的promise，Promise.all()可以帮助您定义一个promise列表，并在所有promise都得到解析时执行某些操作。</span><br><span class=\"line\"></span><br><span class=\"line\">例子：</span><br></pre></td></tr></table></figure></p>\n<p>const f1 = fetch(‘/something.json’)<br>const f2 = fetch(‘/something2.json’)<br>Promise.all([f1, f2])<br>  .then(res =&gt; {<br>    console.log(‘Array of results’, res)<br>  })<br>  .catch(err =&gt; {<br>    console.error(err)<br>  })<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ES2015析构赋值语法也允许您这样做</span><br></pre></td></tr></table></figure></p>\n<p>Promise.all([f1, f2]).then(([res1, res2]) =&gt; {<br>  console.log(‘Results’, res1, res2)<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">当然你不局限于使用fetch，任何promise都是好的。</span><br><span class=\"line\">#### 用Promise.race()编排promise</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.race()在您传递给它的某个promise解析时立即运行，并且在解析第一个promise的结果时，它只运行附加的回调一次（最先执行成功的promise后就返回该promise，其他的promise就不管了）。</span><br><span class=\"line\"></span><br><span class=\"line\">例子：</span><br></pre></td></tr></table></figure></p>\n<p>const promiseOne = new Promise((resolve, reject) =&gt; {<br>  setTimeout(resolve, 500, ‘one’)<br>})<br>const promiseTwo = new Promise((resolve, reject) =&gt; {<br>  setTimeout(resolve, 100, ‘two’)<br>})<br>Promise.race([promiseOne, promiseTwo]).then(result =&gt; {<br>  console.log(result) // ‘two’<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## Async/Await</span><br><span class=\"line\">JavaScript在很短的时间内从回调发展到了promise (ES2015)，而且由于ES2017异步JavaScript使用async/ wait语法更加简单。</span><br><span class=\"line\"></span><br><span class=\"line\">异步函数是 promise和generate的组合，基本上，它们是比promise更高层次的抽象。让我重复一遍:async/ wait基于promise。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 为什么要Async/Await</span><br><span class=\"line\"></span><br><span class=\"line\">这种方式减少了promise的使用，和‘不打破promise链’的限制</span><br><span class=\"line\"></span><br><span class=\"line\">当promise在ES2015中引入时，它们是为了解决异步代码的问题，它们确实解决了这个问题，但是在ES2015和ES2017分开的两年时间里，很明显promise并不是最终的解决方案。</span><br><span class=\"line\"></span><br><span class=\"line\">引入promise是为了解决著名的回调地狱问题，但它们本身也带来了复杂性，以及语法复杂性。</span><br><span class=\"line\"></span><br><span class=\"line\">它们语义化更好，可以向开发人员提供更好的语法，因此当时机成熟时，我们就可以使用async函数。</span><br><span class=\"line\"></span><br><span class=\"line\">它们使代码看起来是同步的，但在幕后它是异步的，非阻塞的。</span><br><span class=\"line\"></span><br><span class=\"line\">#### async如何工作的</span><br><span class=\"line\"></span><br><span class=\"line\">一个async函数返回一个promise，就像这个例子:</span><br></pre></td></tr></table></figure></p>\n<p>const doSomethingAsync = () =&gt; {<br>  return new Promise(resolve =&gt; {<br>    setTimeout(() =&gt; resolve(‘I did something’), 3000)<br>  })<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当您想要调用这个函数时，您需要预先等待，调用代码将停止，直到promise被resolve或reject。一个警告:函数必须定义为async的。这里有一个例子:</span><br></pre></td></tr></table></figure></p>\n<p>const doSomething = async () =&gt; {<br>  console.log(await doSomethingAsync())<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 一个快速的案例</span><br><span class=\"line\">这是一个简单的async/await 的例子，用于异步运行一个函数:</span><br></pre></td></tr></table></figure></p>\n<p>const doSomethingAsync = () =&gt; {<br>  return new Promise(resolve =&gt; {<br>    setTimeout(() =&gt; resolve(‘I did something’), 3000)<br>  })<br>}<br>const doSomething = async () =&gt; {<br>  console.log(await doSomethingAsync())<br>}<br>console.log(‘Before’)<br>doSomething()<br>console.log(‘After’)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">以上代码将打印以下内容到浏览器控制台:</span><br></pre></td></tr></table></figure></p>\n<p>Before<br>After<br>I did something //after 3s<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 所有的事都是promise</span><br><span class=\"line\">在任何函数前面加上async关键字意味着函数将返回一个promise。</span><br><span class=\"line\"></span><br><span class=\"line\">即使它没有显式地返回promise，它也会在内部让它返回一个promise。</span><br><span class=\"line\"></span><br><span class=\"line\">这就是为什么这个代码是有效的:</span><br></pre></td></tr></table></figure></p>\n<p>const aFunction = async () =&gt; {<br>  return ‘test’<br>}<br>aFunction().then(alert) // This will alert ‘test’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">上面也和下面一样</span><br></pre></td></tr></table></figure></p>\n<p>const aFunction = async () =&gt; {<br>  return Promise.resolve(‘test’)<br>}<br>aFunction().then(alert) // This will alert ‘test’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 代码更易读</span><br><span class=\"line\">正如您在上面的示例中看到的，我们的代码看起来非常简单。将其与使用纯promise(带有链接和回调函数)的代码进行比较。</span><br><span class=\"line\"></span><br><span class=\"line\">这是一个非常简单的例子，当代码更加复杂时，主要的好处就会显现出来。</span><br><span class=\"line\"></span><br><span class=\"line\">例如，下面是如何获得JSON资源，并使用promise对其进行解析:</span><br></pre></td></tr></table></figure></p>\n<p>const getFirstUserData = () =&gt; {<br>  return fetch(‘/users.json’) // get users list<br>    .then(response =&gt; response.json()) // parse JSON<br>    .then(users =&gt; users[0]) // pick first user<br>    .then(user =&gt; fetch(<code>/users/${user.name}</code>)) // get user data<br>    .then(userResponse =&gt; response.json()) // parse JSON<br>}<br>getFirstUserData()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用await/async来实现上面的功能时</span><br></pre></td></tr></table></figure></p>\n<p>const getFirstUserData = async () =&gt; {<br>  const response = await fetch(‘/users.json’) // get users list<br>  const users = await response.json() // parse JSON<br>  const user = users[0] // pick first user<br>  const userResponse = await fetch(<code>/users/${user.name}</code>) // get user data<br>  const userData = await user.json() // parse JSON<br>  return userData<br>}<br>getFirstUserData()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 串联多个异步函数</span><br><span class=\"line\">异步函数可以很容易地链接起来，而且语法比普通的承诺更易读</span><br></pre></td></tr></table></figure></p>\n<p>const promiseToDoSomething = () =&gt; {<br>  return new Promise(resolve =&gt; {<br>    setTimeout(() =&gt; resolve(‘I did something’), 10000)<br>  })<br>}<br>const watchOverSomeoneDoingSomething = async () =&gt; {<br>  const something = await promiseToDoSomething()<br>  return something + ‘ and I watched’<br>}<br>const watchOverSomeoneWatchingSomeoneDoingSomething = async () =&gt; {<br>  const something = await watchOverSomeoneDoingSomething()<br>  return something + ‘ and I watched as well’<br>}<br>watchOverSomeoneWatchingSomeoneDoingSomething().then(res =&gt; {<br>  console.log(res)<br>})</p>\n<p>//输出<br>I did something and I watched and I watched as well<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 更好debug</span><br><span class=\"line\">调试promise很困难，因为调试器不会跳过异步代码。</span><br><span class=\"line\"></span><br><span class=\"line\">Async/ wait使这一切变得非常简单，因为对于编译器来说，它就像同步代码一样。</span><br><span class=\"line\"></span><br><span class=\"line\">## ES 模块</span><br><span class=\"line\">ES模块是用于处理模块的ECMAScript标准。</span><br><span class=\"line\"></span><br><span class=\"line\">nodeJS多年来一直使用CommonJS标准，浏览器从来没有模块系统，因为每一个重大决策，比如模块系统，都必须首先由ECMAScript标准化，然后由浏览器实现。</span><br><span class=\"line\"></span><br><span class=\"line\">这个标准化过程用ES6完成，浏览器开始实现这个标准，试图保持一切正常运行，以相同的方式工作，现在在Chrome、Safari、Edge和Firefox(从版本60开始)中都支持ES模块。</span><br><span class=\"line\"></span><br><span class=\"line\">模块非常酷，因为它们允许您封装各种功能，并将这些功能作为库公开给其他JavaScript文件。</span><br><span class=\"line\"></span><br><span class=\"line\">#### ES模块语法</span><br><span class=\"line\">导入模块的语法是:</span><br></pre></td></tr></table></figure></p>\n<p>import package from ‘module-name’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用CommonJS 时：</span><br></pre></td></tr></table></figure></p>\n<p>const package = require(‘module-name’)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">模块是一个JavaScript文件，它使用export关键字导出一个或多个值(对象、函数或变量)。例如，这个模块导出一个函数，返回一个大写字符串:</span><br><span class=\"line\">&gt; uppercase.js</span><br></pre></td></tr></table></figure></p>\n<p>export default str =&gt; str.toUpperCase()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在本例中，模块定义了一个default export，因此它可以是一个匿名函数。否则，它需要一个名称来将其与其他导出区分开。</span><br><span class=\"line\"></span><br><span class=\"line\">现在，通过导入这个文件，任何其他JavaScript模块都可以用导入的uppercase.js提供的功能。</span><br><span class=\"line\">HTML页面可以使用</span><br><span class=\"line\">```&lt;script&gt;``` 标记添加模块，该标记具有特殊的```type=&quot;module&quot;```属性:</span><br></pre></td></tr></table></figure></p>\n<p><script type=\"module\" src=\"index.js\"></script><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 注意:此模块导入的行为类似于defer脚本加载。</span><br><span class=\"line\"></span><br><span class=\"line\">需要注意的是，使用```type=&quot;module&quot;```加载的任何脚本都是在严格模式下加载的。</span><br><span class=\"line\"></span><br><span class=\"line\">在这个例子中，uppercase.js 模块定义了一个 default export,所以当我们导入它的时候，我们可以给它分配一个我们喜欢的名字:</span><br></pre></td></tr></table></figure></p>\n<p>import toUpperCase from ‘./uppercase.js’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">我们可以这样使用</span><br></pre></td></tr></table></figure></p>\n<p>toUpperCase(‘test’) //‘TEST’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">您还可以使用模块导入的绝对路径，来引用在另一个域中定义的模块:</span><br></pre></td></tr></table></figure></p>\n<p>import toUpperCase from ‘<a href=\"https://flavio-es-modules-example.glitch.me/uppercase.js&#39;\" target=\"_blank\" rel=\"noopener\">https://flavio-es-modules-example.glitch.me/uppercase.js&#39;</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这也是有效的导入语法:</span><br></pre></td></tr></table></figure></p>\n<p>import { foo } from ‘/uppercase.js’<br>import { foo } from ‘../uppercase.js’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">下面是不对的：</span><br></pre></td></tr></table></figure></p>\n<p>import { foo } from ‘uppercase.js’<br>import { foo } from ‘utils/uppercase.js’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">它要么是绝对的，要么在名字前有一个./或者/。</span><br><span class=\"line\"></span><br><span class=\"line\">## 其他 import/export方法</span><br><span class=\"line\">我们看到上面的例子:</span><br></pre></td></tr></table></figure></p>\n<p>export default str =&gt; str.toUpperCase()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这将创建一个默认导出。在一个文件中，你可以导出多个东西，通过使用以下语法:</span><br></pre></td></tr></table></figure></p>\n<p>const a = 1<br>const b = 2<br>const c = 3<br>export { a, b, c }<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">另一个模块可以使用import *来导入所有这些export的内容</span><br></pre></td></tr></table></figure></p>\n<p>import * from ‘module’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">你可以只导入其中的几个导出，使用析构赋值:</span><br></pre></td></tr></table></figure></p>\n<p>import { a } from ‘module’<br>import { a, b } from ‘module’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为了方便，可以使用as重命名任何导入</span><br></pre></td></tr></table></figure></p>\n<p>import { a, b as two } from ‘module’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">您可以按名称导入默认导出和任何非默认导出，如以下常见的React导入:</span><br></pre></td></tr></table></figure></p>\n<p>import React, { Component } from ‘react’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## CORS(跨域)</span><br><span class=\"line\">使用CORS获取模块。这意味着如果您引用来自其他域的脚本，它们必须具有允许跨站点加载的有效CORS头（比如Access-Control-Allow-Origin: *）</span><br><span class=\"line\">#### 那么不支持模块的浏览器呢?</span><br><span class=\"line\">结合使用```type=&quot;module&quot;``` 和```nomodule</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;module&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script nomodule src=&quot;fallback.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>ES模块是现代浏览器中引入的最大特性之一。它们是ES6的一部分，但实现它们的道路是漫长的。</p>\n<p>我们现在可以使用它们了!但是我们还必须记住，如果有多个模块，那么页面的性能将受到影响，因为这是浏览器在运行时必须执行更多一个步骤。</p>\n<p>即使ES模块在浏览器里能用了，Webpack可能仍然是一个巨大的玩家，但是直接在语言中构建这样的特性对于统一模块在客户端和nodeJS的工作方式是非常重要的。</p>\n<blockquote>\n<p>下节预告：React的概念</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>原文<a href=\"\">https://medium.freecodecamp.org/the-react-handbook-b71c27b0a795</a></p>\n<p>开始着手学习React，就看到大佬推荐的这篇文章，因为是英文，就尽自己能力翻译一下有错的烦请指正。原文一共220页A4纸，内容有点多，所以会分期更新，见谅</p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>这本React手册遵循二八原则：用20%的时间学习80%的内容</p>\n<p>在本手册里使用了React Hooks，所以你需要使用高于等于 16.7.0-alpha.2 版本的React和ReactDom.</p>\n<p>如果你使用create-react-app初始化项目时，在初始化项目之后运行<figure class=\"highlight plain\"><figcaption><span>install react@16.7.0-alpha.2 react-dom@16.7.0-</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alpha.2</span><br></pre></td></tr></table></figure></p>\n<p>我希望你能在你阅读完本手册后能达到一个目标：学会React的基础</p>\n<h2 id=\"React介绍\"><a href=\"#React介绍\" class=\"headerlink\" title=\"React介绍\"></a>React介绍</h2><p>先来介绍一下React库</p>\n<h4 id=\"什么是React\"><a href=\"#什么是React\" class=\"headerlink\" title=\"什么是React\"></a>什么是React</h4><p>React是一个旨在简化开发可视化界面的Javascript库。它由Facebook开发，并于2013年向世界发布，并支持着很多被广泛使用的App，包括Facebook和Instagram等无数应用程序。<br>它的主要目标是通过将UI划分为一组组件，使得在任何时间点都可以轻松地构建界面及其状态。</p>\n<h4 id=\"为什么React这么流行？\"><a href=\"#为什么React这么流行？\" class=\"headerlink\" title=\"为什么React这么流行？\"></a>为什么React这么流行？</h4><p>React席卷了整个前端开发领域，为什么？</p>\n<h4 id=\"比其他框架更低的复杂性\"><a href=\"#比其他框架更低的复杂性\" class=\"headerlink\" title=\"比其他框架更低的复杂性\"></a>比其他框架更低的复杂性</h4><p>在React出道之前，Ember.js和Angular1.X是主流框架。这两种方法在代码上强加了太多的约定，以至于移植现有的应用程序一点都不方便。React选择了非常容易集成到现有项目中的方式，因为Facebook必须实现这一点，这样才能将其引入现有代码库。另外，这两个框架本身包含的内容太多了，而React只选择实现视图层而不是完整的MVC技术栈。</p>\n<h4 id=\"完美的时间\"><a href=\"#完美的时间\" class=\"headerlink\" title=\"完美的时间\"></a>完美的时间</h4><p>当谷歌宣布Angular2.X时，宣称Angular1.X并不能平滑升级到Angular2.X，这两个就像不同的框架一样，所以想要从Angular1.X升级到Angular2.X就得重构项目。因为这一点，再加上React承诺说能带来执行速度的提升，所以很多程序员就迫不及待的尝试。</p>\n<h4 id=\"Facebook的支持\"><a href=\"#Facebook的支持\" class=\"headerlink\" title=\"Facebook的支持\"></a>Facebook的支持</h4><p>如果一个项目最终成功，得到Facebook的支持显然也会让它受益。Facebook目前对React非常感兴趣，并看到了它开源的价值，这对所有在自己项目中使用React的开发者来说都是一个巨大的优势。</p>\n<h4 id=\"React学起来容易吗？\"><a href=\"#React学起来容易吗？\" class=\"headerlink\" title=\"React学起来容易吗？\"></a>React学起来容易吗？</h4><p>虽然我说React要比其他框架简单，但是深入学习React的话还是挺有难度的，难的主要原因是要与React搭配使用的技术，比如Redux,GraphQL等等。</p>\n<p>React本身有一个非常小的API，你至少需要理解4个概念才能开始:</p>\n<ul>\n<li>Components</li>\n<li>JSX</li>\n<li>State</li>\n<li>Props</li>\n</ul>\n<p>上面这些（甚至更多）都会在手册中一一解释</p>\n<h2 id=\"如何安装React\"><a href=\"#如何安装React\" class=\"headerlink\" title=\"如何安装React\"></a>如何安装React</h2><h4 id=\"如何在你的电脑上安装React\"><a href=\"#如何在你的电脑上安装React\" class=\"headerlink\" title=\"如何在你的电脑上安装React?\"></a>如何在你的电脑上安装React?</h4><p>React是一个库，所以说安装这个词会有点奇怪，倒不如说“设置”更贴切。在你的app或者网页中有很多方式可以设置React</p>\n<h4 id=\"直接在网页里引入\"><a href=\"#直接在网页里引入\" class=\"headerlink\" title=\"直接在网页里引入\"></a>直接在网页里引入</h4><p>最简单的方法是直接将React JavaScript文件添加到页面中。当React应用与单个页面上的元素进行交互，而不是实际控制整个导航时，这是最好的选择。</p>\n<p>下面的例子中，你在body的最后添加了两个script标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">    &lt;body&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">        &lt;script</span><br><span class=\"line\">        src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/16.7.0-alpha.2/umd/react.development.js&quot; </span><br><span class=\"line\">        crossorigin&gt;</span><br><span class=\"line\">        &lt;/script&gt;</span><br><span class=\"line\">        &lt;script</span><br><span class=\"line\">        src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react-dom/16.7.0-alpha.2/umd/react-dom.production.min.js&quot;</span><br><span class=\"line\">        crossorigin&gt;</span><br><span class=\"line\">        &lt;/script&gt;</span><br><span class=\"line\">    &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>在这里我们引入两个库（React和React Dom），是为什么呢？因为React是百分之的独立于浏览器的，你也可以在浏览器之外使用React（比如用React Native开发移动应用时，也能用React），因此需要React Dom来操作dom。</p>\n<p>在引入Javascript文件后，你需要为react，在html里添加script标签，才能使用JSX语法，下面两种方式都可以<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//在app.js里写JSX</span><br><span class=\"line\">&lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;!-- or --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">//直接在标签内写JSX</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">//my app</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如果要使用JSX，你还需要引入Babel</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>引入后要在之前写的script标签里添加type=”text/babel”才会生效，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;app.js&quot; type=&quot;text/babel&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>现在你可以在你的app.js里写JSX的代码了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Button = () =&gt; &#123;</span><br><span class=\"line\">return &lt;button&gt;Click me!&lt;/button&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ReactDOM.render(&lt;Button /&gt;, document.getElementById(&apos;root&apos;))</span><br></pre></td></tr></table></figure>\n<p>演示代码地址：<br><a href=\"演示代码\">https://glitch.com/edit/#!/react-example-inline-jsx?path=index.html:21:19</a></p>\n<h4 id=\"用官方脚手架create-react-app（推荐）\"><a href=\"#用官方脚手架create-react-app（推荐）\" class=\"headerlink\" title=\"用官方脚手架create-react-app（推荐）\"></a>用官方脚手架create-react-app（推荐）</h4><p>create-react-app旨在让你能快速构建一个React项目，任何React应用都可以使用create-react-app来生成一个单页页面。</p>\n<p>首先你需要安装npm和node （地址：<a href=\"\">https://nodejs.org/en/</a>）就不多说了<br>然后执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx create-react-app todolist</span><br></pre></td></tr></table></figure>\n<p>npx是npm 5.2之后才有的工具，npx会下载create-react-app，然后解压安装，然后执行<figure class=\"highlight plain\"><figcaption><span>todolist```,然后再把create-react-app从系统中删除。这样你就永远能够使用最新的create-react-app，不会在电脑里存放着过时的create-react-app。</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">执行完之后你能看到下面的界面</span><br><span class=\"line\"></span><br><span class=\"line\">![](https://user-gold-cdn.xitu.io/2019/1/18/168602568623fb3a?w=741&amp;h=677&amp;f=png&amp;s=36167)</span><br><span class=\"line\"></span><br><span class=\"line\">create-react-app会在文件夹内创建相应的文件结构，文件名就是todolist（自己取的）</span><br><span class=\"line\">package.json也同样生成了，只需要安装指示，进入相应的文件夹，执行npm start就可以启动项目了</span><br><span class=\"line\"></span><br><span class=\"line\">如图</span><br><span class=\"line\"></span><br><span class=\"line\">![](https://user-gold-cdn.xitu.io/2019/1/18/168602a792310119?w=454&amp;h=260&amp;f=png&amp;s=12615)</span><br><span class=\"line\"></span><br><span class=\"line\">打开浏览器进入http://localhost:3000/就能看到最开始的界面了。</span><br><span class=\"line\"></span><br><span class=\"line\">除了 npm start , create-react-app这两个命令之外，还有下面一些命令</span><br><span class=\"line\">* npm run build ：要在构建文件夹中构建准备部署到服务器的React应用程序文件</span><br><span class=\"line\">* npm test：运行Jest测试包</span><br><span class=\"line\">* npm eject ：弹出配置文件 </span><br><span class=\"line\">何时用npm eject？create-react-app已经做了很多工作了，但你想要完成更多的工作时，就要弹出配置文件来自己配置。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">因为create-react-app 是为了满足大部分人的需求和有限的配置，当你有一些独特的需求时，就需要自己来配置一些内容了。</span><br><span class=\"line\"></span><br><span class=\"line\">当你使用npm eject时，你的页面就不会自动更新了，但你可以在Babel和Webpack配置中获得更大的灵活性。</span><br><span class=\"line\"></span><br><span class=\"line\">eject时是不可逆的，当你执行后你会获得两个新的文件夹，配置和脚本。你就可以开始自由的编辑他们了。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 下节预告：下节我们将学习在学习React之前需要了解的JS语法及一些知识</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用React需要什么样的JS能力</span><br><span class=\"line\">#### 在深入学习React之前找到你必须要掌握的内容</span><br><span class=\"line\">如果你想学习React时，首先你需要做一些事情。您必须熟悉一些必要的技术，特别是你将在React中反复使用的一些最新JavaScript特性相关的技术。</span><br><span class=\"line\"></span><br><span class=\"line\">有些人以为一些功能是React提供的一些特定的功能，实际上它们只是Javascript最新的语法。</span><br><span class=\"line\"></span><br><span class=\"line\">立即掌握这些新语法，成为这方面的专家是不可能的，也没必要。但你如果想要深入研究React，那你就需要熟练掌握他们了。</span><br><span class=\"line\"></span><br><span class=\"line\">我会把它们列举下来让你快速了解一下。</span><br><span class=\"line\"></span><br><span class=\"line\">## 变量</span><br><span class=\"line\">变量是分配给标识符的文字，因此您可以引用它并在后面的程序里使用它。学习如何用JavaScript声明一个。</span><br><span class=\"line\"></span><br><span class=\"line\">JavaScript中的变量没有附加任何类型。将特定的文字类型分配给变量后，可以稍后再给这个变量分配类型，而不会出现类型错误或任何问题。</span><br><span class=\"line\"></span><br><span class=\"line\">所以这就是为什么有时候Javascript会报&apos;untyped&apos;这样的问题。</span><br><span class=\"line\"></span><br><span class=\"line\">一个变量必须在你使用之前就声明。有三种方法可以做到这一点，使用var、let或const，这三种方法在以后与变量的交互方式上有所不同。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 用Var</span><br><span class=\"line\">知道ES2015，var一直都是定义变量的唯一方法。</span><br></pre></td></tr></table></figure></p>\n<p>var a = 0<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果你忘了添加var，你给未声明的变量赋值，结果可能会有所不同，在严格模式下，会得到一个错误，在旧的环境，或者禁用严格模式下，就会使得该变量成为一个全局变量，赋值也自然会赋值给一个全局变量。</span><br><span class=\"line\"></span><br><span class=\"line\">如果你没有将变量初始化，那他的值就是undefined</span><br></pre></td></tr></table></figure></p>\n<p>var a //typeof a === ‘undefined’</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">你可以多次声明变量</span><br></pre></td></tr></table></figure>\n<p>var a = 1<br>var a = 2<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最重要的，你可以一次就声明多个变量</span><br></pre></td></tr></table></figure></p>\n<p>var a = 1, b = 2<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用域是代码中变量可见的部分（有效）。在函数外部声明一个变量，变量就是全局的，所有的函数都可以获得该变量的值，但在函数内部声明一个变量，变量就是局部的，只有在该函数内才能获得该变量的值，就像函数的一个参数。</span><br><span class=\"line\"></span><br><span class=\"line\">在与全局变量同名的函数中定义的任何变量都优先于全局变量，并对其进行跟踪。</span><br><span class=\"line\"></span><br><span class=\"line\">重要的是要理解一个块(由一对花括号标识)没有定义一个新的作用域。新作用域只在创建函数时创建，因为var没有块作用域，而是函数作用域。</span><br><span class=\"line\"></span><br><span class=\"line\">函数内部,在函数的所有代码中，变量在任何位置都是可见的,即使函数的变量声明在函数最后仍然可以引用。,因为JavaScript执行代码之前将所有变量提升。但为了避免混淆，总是在函数的开头声明变量。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 用Let</span><br><span class=\"line\"></span><br><span class=\"line\">let是ES2015中引入的一个新特性，它本质上是var的块范围版本。它的作用域仅限于定义它的块、语句或表达式以及所有包含的内部块。</span><br><span class=\"line\"></span><br><span class=\"line\">现代JavaScript开发人员可能选择只使用let，而完全放弃使用var。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 如果let看起来是一个模糊的术语，只要看let color = &apos;red&apos;就是让颜色是红色，这就更容易理解了</span><br><span class=\"line\"></span><br><span class=\"line\">与var相反，在任何函数外部定义let都不会创建全局变量。</span><br><span class=\"line\">#### 用Const</span><br><span class=\"line\"></span><br><span class=\"line\">用var或let声明的变量可以稍后在程序中更改并重新分配。一旦const被初始化，它的值就再也不会被更改，也不能被重新分配到不同的值。</span><br></pre></td></tr></table></figure></p>\n<p>const a = ‘test’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们不能给a常量定义不同的文字了。但是，如果对象提供了改变其内容的方法，我们可以对它进行变异。</span><br><span class=\"line\">const 定义了就不能修改或重新赋值</span><br><span class=\"line\"></span><br><span class=\"line\">const和let一样都有块级作用域</span><br><span class=\"line\"></span><br><span class=\"line\">现代JavaScript开发人员可能会选择始终对不需要在程序中稍后重新分配的变量使用const。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 为什么?因为我们应该总是使用最简单的结构来避免将来犯错误。</span><br><span class=\"line\"></span><br><span class=\"line\">## 箭头函数</span><br><span class=\"line\"></span><br><span class=\"line\">箭头函数是在ES6 / ECMAScript 2015中引入的，自从引入以来，它们彻底改变了JavaScript代码的外观(和工作方式)。</span><br><span class=\"line\"></span><br><span class=\"line\">在我看来，这种变化非常受欢迎，以至于你现在很少看到在现代代码库中使用function关键字。</span><br><span class=\"line\"></span><br><span class=\"line\">从视觉上看，这是一个简单而受欢迎的改变，它允许你用更短的语法编写函数，从:</span><br></pre></td></tr></table></figure></p>\n<p>const myFunction = function() {<br>//…<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">到</span><br></pre></td></tr></table></figure></p>\n<p>const myFunction = () =&gt; {<br>//…<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果函数体只包含一条语句，则可以省略括号，并将所有内容写在一行中:</span><br></pre></td></tr></table></figure></p>\n<p>const myFunction = () =&gt; doSomething()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参数在括号中传递:</span><br></pre></td></tr></table></figure></p>\n<p>const myFunction = (param1, param2) =&gt; doSomething(param1, param2)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果有一个(且只有一个)参数，可以完全省略括号:</span><br></pre></td></tr></table></figure></p>\n<p>const myFunction = param =&gt; doSomething(param)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">由于这种简短的语法，箭头函数让我们能使用小体积的函数。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 隐式返回</span><br><span class=\"line\"></span><br><span class=\"line\">箭头函数允许你使用隐式返回：返回的值不需要使用return关键字。</span><br><span class=\"line\"></span><br><span class=\"line\">当函数体中有一行语句时，它就可以工作:</span><br></pre></td></tr></table></figure></p>\n<p>const myFunction = () =&gt; ‘test’<br>myFunction() //‘test’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">另一个例子，当返回一个对象时，记得将大括号括起来，以避免它被认为是括起来的函数的括号:</span><br></pre></td></tr></table></figure></p>\n<p>const myFunction = () =&gt; ({ value: ‘test’ })<br>myFunction() //{value: ‘test’}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### this在箭头函数里如何工作</span><br><span class=\"line\">this是一个很难理解的概念。因为它会根据上下文和JavaScript的模式(严格模式或非严格模式)产生不同的含义。</span><br><span class=\"line\"></span><br><span class=\"line\">澄清这个概念很重要，因为在箭头函数中的this与常规函数中的this非常不同。</span><br><span class=\"line\"></span><br><span class=\"line\">当定义一个对象的方法时，在常规函数中的this指向这个对象，案例如下：</span><br></pre></td></tr></table></figure></p>\n<p>const car = {<br>    model: ‘Fiesta’,<br>    manufacturer: ‘Ford’,<br>    fullName: function() {<br>        return <code>${this.manufacturer} ${this.model}</code><br>    }<br>}<br>car.fullName() //“Ford Fiesta”<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行car.fullName()时会返回&quot;Ford Fiesta&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">带有箭头函数的this作用域是从执行上下文中继承的。箭头函数根本不绑定this，因此它的值将在调用堆栈中查找。因此在这个代码car.fullName()中不起作用，并将返回字符串“undefined undefined”:</span><br></pre></td></tr></table></figure></p>\n<p>const car = {<br>    model: ‘Fiesta’,<br>    manufacturer: ‘Ford’,<br>    fullName: () =&gt; {<br>        return <code>${this.manufacturer} ${this.model}</code><br>    }<br>}<br>car.fullName() //“undefined undefined”<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参考上面两个例子，可以看出，箭头函数并不适用于对象的方法。</span><br><span class=\"line\"></span><br><span class=\"line\">箭头函数也不能用作构造函数，因为实例化对象时将报错TypeError。当不需要动态上下文时，应该在这里使用箭头函数来代替常规函数。</span><br><span class=\"line\"></span><br><span class=\"line\">在处理事件时还有一个问题，DOM事件侦听器将this设置为目标元素，如果在事件处理程序中依赖于此元素，则需要一个常规函数:</span><br></pre></td></tr></table></figure></p>\n<p>const link = document.querySelector(‘#link’)<br>link.addEventListener(‘click’, () =&gt; {<br>    // this === window<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>const link = document.querySelector(‘#link’)<br>link.addEventListener(‘click’, function() {<br>    // this === link<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 使用Rest和Spread处理对象和数组</span><br><span class=\"line\">#### 学习使用JavaScript处理数组和对象的两种现代技术</span><br><span class=\"line\">您可以使用spread操作符展开数组、对象或字符串  ...</span><br><span class=\"line\"></span><br><span class=\"line\">看下面的例子：</span><br></pre></td></tr></table></figure></p>\n<p>const a = [1, 2, 3]<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">你可以像下面一样创建一个新数组</span><br></pre></td></tr></table></figure></p>\n<p>const b = […a, 4, 5, 6]<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">还可以像下面一样创建一个数组的副本</span><br></pre></td></tr></table></figure></p>\n<p>const b = […a]<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">也能用这种方式拷贝一个对象</span><br></pre></td></tr></table></figure></p>\n<p>const newObj = { …oldObj }<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用字符串时，spread操作符创建一个数组，数组内是每个字符:</span><br></pre></td></tr></table></figure></p>\n<p>const hey = ‘hey’<br>const arrayized = […hey] // [‘h’, ‘e’, ‘y’]<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这个操作符有一些非常有用的应用。最重要的是能够以一种非常简单的方式将数组作为函数参数:</span><br></pre></td></tr></table></figure></p>\n<p>const f = (foo, bar) =&gt; {}<br>const a = [1, 2]<br>f(…a)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(在过去，你可以用f.apply(null, a) 来做这个但是这样做不太好，可读性也不好)</span><br><span class=\"line\"></span><br><span class=\"line\">rest元素和spread元素在使用数组解构赋值时非常有用:</span><br></pre></td></tr></table></figure></p>\n<p>const numbers = [1, 2, 3, 4, 5]<br>[first, second, …others] = numbers</p>\n<p>const numbers = [1, 2, 3, 4, 5]<br>const sum = (a, b, c, d, e) =&gt; a + b + c + d + e<br>const sum = sum(…numbers)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ES2018引入了rest属性，它们是相同的，但是是用于对象。</span><br><span class=\"line\"></span><br><span class=\"line\">Rest属性</span><br></pre></td></tr></table></figure></p>\n<p>const { first, second, …others } = {<br>    first: 1,<br>    second: 2,<br>    third: 3,<br>    fourth: 4,<br>    fifth: 5<br>}<br>first // 1<br>second // 2<br>others // { third: 3, fourth: 4, fifth: 5 }<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">扩展属性允许通过合并在扩展操作符之后传递的对象属性来创建一个新对象:</span><br></pre></td></tr></table></figure></p>\n<p>const items = { first, second, …others }<br>items //{ first: 1, second: 2, third: 3, fourth: 4, fifth: 5 }<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 数组和对象的解构赋值</span><br><span class=\"line\">#### 学习如何使用解构赋值语法来处理JavaScript中的数组和对象</span><br><span class=\"line\">给定一个对象，使用解构赋值语法，您可以提取一些值，并将它们放入命名变量:</span><br></pre></td></tr></table></figure></p>\n<p>const person = {<br>firstName: ‘Tom’,<br>lastName: ‘Cruise’,<br>actor: true,<br>age: 54 //made up<br>}<br>const { firstName: name, age } = person //name: Tom, age: 54<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name和age包含了所需要的值。</span><br><span class=\"line\"></span><br><span class=\"line\">这个语法也可以在数组上使用</span><br></pre></td></tr></table></figure></p>\n<p>const a = [1, 2, 3, 4, 5]<br>const [first, second] = a<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">该语句通过从数组a中获取索引0、1、4的项来创建3个新变量（first，second，fifth）</span><br></pre></td></tr></table></figure></p>\n<p>const [first, second, , , fifth] = a<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 模板字符串</span><br><span class=\"line\">在ES2015(又名ES6)中引入的模板字符串提供了一种声明字符串的新方法，也提供了一些已经非常流行的有趣的新构造方法。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 模板字符串介绍</span><br><span class=\"line\"></span><br><span class=\"line\">模板文字是ES2015 / ES6的新特性，与ES5及以下版本相比，它允许你以一种新颖的方式处理字符串。</span><br><span class=\"line\">语法乍一看非常简单，只需使用反引号而不是单引号或双引号:</span><br></pre></td></tr></table></figure></p>\n<p>const a_string = <code>something</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">它们是很独特的的，因为它们提供了许多用引号构建的普通字符串所没有的特性，特别是:</span><br><span class=\"line\">* 它们提供了一个很好的语法来定义多行字符串</span><br><span class=\"line\">* 它们提供了一种简单的方法在字符串中用变量和表达式插值</span><br><span class=\"line\">* 它们允许您使用模板标记创建DSL (DSL意味着特定于领域的语言，例如在React by style组件中使用DSL为组件定义CSS)</span><br><span class=\"line\"></span><br><span class=\"line\">#### 让我们详细研究上面三个东西</span><br><span class=\"line\">#### 多行字符串</span><br><span class=\"line\">在es6之前，要创建一个跨越两行的字符串，您必须在一行末尾使用\\字符</span><br></pre></td></tr></table></figure></p>\n<p>const string =<br>  ‘first part \\<br>second part’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这允许在两行创建一个字符串，但它只呈现在一行:</span><br></pre></td></tr></table></figure></p>\n<p>first part second part<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">要在多行渲染字符串，你需要显式地在每行末尾添加\\n，如下所示:</span><br></pre></td></tr></table></figure></p>\n<p>const string =<br>  ‘first line\\n \\<br>second line’</p>\n<p>//或者<br>const string = ‘first line\\n’ + ‘second line’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用模板字符串就简单多了</span><br><span class=\"line\"></span><br><span class=\"line\">一旦模板文字使用回车，你只需按回车键来创建一个没有特殊字符的新行，它就会按原样呈现:</span><br></pre></td></tr></table></figure></p>\n<p>const string = `Hey<br>this</p>\n<p>string<br>is awesome!`</p>\n<p>//结果如下<br>Hey<br>this</p>\n<p>string<br>is awesome!<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">记住，模板字符串的空格是有意义的，所以这样做:</span><br></pre></td></tr></table></figure></p>\n<p>const string = <code>First\n                Second</code></p>\n<p>//结果如下<br>First<br>                Second<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">解决这个问题的一种简单方法是，在第一行中设置一个空行，并在结束后加上trim()方法，这将消除第一个字符之前的任何空格:</span><br></pre></td></tr></table></figure></p>\n<p>const string = <code>First\nSecond</code>.trim()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 模板字符串插值</span><br><span class=\"line\">模板字符串提供了一种将变量和表达式插入字符串的简单方法。</span><br><span class=\"line\">你可以用这样的语法```$&#123;...&#125;```：</span><br></pre></td></tr></table></figure></p>\n<p>const var = ‘test’<br>const string = <code>something ${var}</code> //something test<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在```$&#123;...&#125;```里你可以插入任何东西，甚至是表达式</span><br></pre></td></tr></table></figure></p>\n<p>const string = <code>something ${1 + 2 + 3}</code><br>const string2 = <code>something ${foo() ? &#39;x&#39; : &#39;y&#39;}</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## Class（类）</span><br><span class=\"line\">2015年，ECMAScript 6 (ES6)标准引入了类。</span><br><span class=\"line\"></span><br><span class=\"line\">JavaScript有一种非常少见的实现继承的方法:原型继承。虽然原型继承在我看来很好，但它不同于大多数其他流行编程语言的继承实现，后者是基于类的。</span><br><span class=\"line\"></span><br><span class=\"line\">来自Java、Python或其他语言的人很难理解原型继承的复杂性，所以ECMAScript委员会决定在原型继承的基础上添加语法糖，这样就像其他流行实现中的基于类的继承一样。</span><br><span class=\"line\"></span><br><span class=\"line\">这一点很重要:底层的JavaScript仍然是相同的，您还是可以用常规的方式访问对象原型。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 一个class类的定义</span><br><span class=\"line\">一个类长下面这样</span><br></pre></td></tr></table></figure></p>\n<p>class Person {<br>  constructor(name) {<br>    this.name = name<br>  }<br>  hello() {<br>    return ‘Hello, I am ‘ + this.name + ‘.’<br>  }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类有一个标识符，我们可以使用它来使用new ClassIdentifier()创建新对象</span><br><span class=\"line\"></span><br><span class=\"line\">初始化对象时，调用constructor方法，并传递任意参数。</span><br><span class=\"line\"></span><br><span class=\"line\">一个类也有它所需要的所有方法。在这种情况下，hello是一个方法，这个类派生的所有对象都可以调用这个方法:</span><br></pre></td></tr></table></figure></p>\n<p>const flavio = new Person(‘Flavio’)<br>flavio.hello()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 类的实例</span><br><span class=\"line\"></span><br><span class=\"line\">类可以扩展另一个类，使用该类初始化的对象继承父类的所有方法。</span><br><span class=\"line\"></span><br><span class=\"line\">如果继承的类的方法与层次结构中较高层的类的名称相同，则最近的方法优先:</span><br></pre></td></tr></table></figure></p>\n<p>class Programmer extends Person {<br>  hello() {<br>    return super.hello() + ‘ I am a programmer.’<br>  }<br>}<br>const flavio = new Programmer(‘Flavio’)<br>flavio.hello()<br>//输出 Hello, I am Flavio. I am a programmer.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类没有显式的类变量声明，但是必须初始化构造函数中的任何变量</span><br><span class=\"line\"></span><br><span class=\"line\">在类中，可以用super()来引用父类。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 静态方法</span><br><span class=\"line\">通用方法是在实例上定义的，而不是在类上定义的。</span><br><span class=\"line\">静态方法在类上执行:</span><br></pre></td></tr></table></figure></p>\n<p>class Person {<br>  static genericHello() {<br>    return ‘Hello’<br>  }<br>}<br>Person.genericHello() //Hello<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 私有方法</span><br><span class=\"line\">JavaScript没有内置的方法来定义私有或受保护的方法。（可以参考闭包等概念）</span><br><span class=\"line\"></span><br><span class=\"line\">有一些变通方法，但我不会在这里描述它们。</span><br><span class=\"line\">#### Getters 和 setters</span><br><span class=\"line\">你可以添加以get或set为前缀的方法来创建getter和setter，这是根据您正在做的事情执行两段不同的代码:访问变量或修改其值。</span><br></pre></td></tr></table></figure></p>\n<p>class Person {<br>  constructor(name) {<br>    this._name = name<br>  }<br>  set name(value) {<br>    this._name = value<br>  }<br>  get name() {<br>    return this._name<br>  }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果您只有一个getter，则无法设置该属性，并且任何这样做的尝试都将被忽略:</span><br></pre></td></tr></table></figure></p>\n<p>class Person {<br>  constructor(name) {<br>    this.name = name<br>  }<br>  get name() {<br>    return this.name<br>  }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果你只有一个setter，你可以改变值，但不能从外部访问它:</span><br></pre></td></tr></table></figure></p>\n<p>class Person {<br>  constructor(name) {<br>    this.name = name<br>  }<br>  set name(value) {<br>    this.name = value<br>  }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 回调</span><br><span class=\"line\">计算机在设计上是异步的。</span><br><span class=\"line\"></span><br><span class=\"line\">异步意味着事情可以独立于主程序流发生。</span><br><span class=\"line\"></span><br><span class=\"line\">在当前的客户端计算机中，每个程序都运行一个特定的时间段，然后停止执行，让另一个程序继续执行。这个东西以一种无法察觉的速度循环运行，我们认为计算机同时运行许多程序，但这是一种错觉(多处理器机器除外)。</span><br><span class=\"line\"></span><br><span class=\"line\">程序在内部使用中断——这是一种向处理器发出的信号，以引起系统的注意。</span><br><span class=\"line\"></span><br><span class=\"line\">我不会深入讨论它的内部原理，但是要记住，程序是异步的是很正常的，在它们需要注意的时候停止它们的执行，而计算机可以同时执行其他事情。当程序正在等待来自网络的响应时，它不能在请求完成之前停止处理器。</span><br><span class=\"line\"></span><br><span class=\"line\">通常，编程语言是同步的，有些语言提供了一种方法来管理语言或库中的异步性。C, Java, c#， PHP, Go, Ruby, Swift, Python，它们默认都是同步的。其中一些通过使用线程处理异步，生成一个新进程。</span><br><span class=\"line\"></span><br><span class=\"line\">JavaScript默认是同步的，并且是单线程的。这意味着代码不能创建新线程并并行运行。</span><br><span class=\"line\"></span><br><span class=\"line\">一行接一行的执行代码，例如:</span><br></pre></td></tr></table></figure></p>\n<p>const a = 1<br>const b = 2<br>const c = a * b<br>console.log(c)<br>doSomething()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">但是JavaScript是在浏览器中诞生的，它最初的主要工作是响应用户操作，比如onClick、onMouseOver、onChange、onSubmit等等。它如何使用同步编程模型实现这一点呢?</span><br><span class=\"line\"></span><br><span class=\"line\">答案就在它所处的环境中。浏览器提供了一种方法，它提供了一组api来处理这种功能。</span><br><span class=\"line\"></span><br><span class=\"line\">最近，NodeJS引入了一个非阻塞I/O环境，将这个概念扩展到文件访问、网络调用等。</span><br><span class=\"line\"></span><br><span class=\"line\">你不知道用户什么时候会点击按钮，所以你要做的是，为点击事件定义一个事件处理器。此事件处理程序接受一个函数，该函数将在事件触发时被调用:</span><br></pre></td></tr></table></figure></p>\n<p>document.getElementById(‘button’).addEventListener(‘click’, () =&gt; {<br>  //item clicked<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这就是回调（callback)</span><br><span class=\"line\"></span><br><span class=\"line\">回调是一个简单的函数，它作为一个值传递给另一个函数，只在事件发生时执行。我们可以这样做，因为JavaScript具有一流的函数，可以将其分配给变量并传递给其他函数(称为高阶函数)</span><br><span class=\"line\"></span><br><span class=\"line\">将所有代码包装在windows对象上的load事件监听器中是很常见的，它只在页面准备好时才运行回调函数:</span><br></pre></td></tr></table></figure></p>\n<p>window.addEventListener(‘load’, () =&gt; {<br>  //window loaded<br>  //do what you want<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">回调可以用在任何地方，不只是dom事件上</span><br><span class=\"line\"></span><br><span class=\"line\">一个常用的定时器例子：</span><br></pre></td></tr></table></figure></p>\n<p>setTimeout(() =&gt; {<br>  // runs after 2 seconds<br>}, 2000)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">XHR请求也接受回调，在本例中，它将一个函数分配给一个属性，该属性将在特定事件发生时被调用(在本例中，请求状态发生变化):</span><br></pre></td></tr></table></figure></p>\n<p>const xhr = new XMLHttpRequest()<br>xhr.onreadystatechange = () =&gt; {<br>  if (xhr.readyState === 4) {<br>    xhr.status === 200 ? console.log(xhr.responseText) : console.error(‘error’)<br>  }<br>}<br>xhr.open(‘GET’, ‘<a href=\"https://yoursite.com&#39;\" target=\"_blank\" rel=\"noopener\">https://yoursite.com&#39;</a>)<br>xhr.send()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### 处理回调中的错误</span><br><span class=\"line\"></span><br><span class=\"line\">如何在回调处理错误?一个非常常见的策略是使用Node所采用的方法:任何回调函数中的第一个参数都是error对象:error-first回调</span><br><span class=\"line\"></span><br><span class=\"line\">如果没有错误，则对象为null。如果有错误，它包含错误的一些描述和其他信息。</span><br></pre></td></tr></table></figure></p>\n<p>fs.readFile(‘/file.json’, (err, data) =&gt; {<br>  if (err !== null) {<br>    //handle error<br>    console.log(err)<br>    return<br>  }<br>  //no errors, process data<br>  console.log(data)<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### 回调存在的问题</span><br><span class=\"line\"></span><br><span class=\"line\">回调对于简单的情况非常有用</span><br><span class=\"line\"></span><br><span class=\"line\">然而，每个回调都会增加一个嵌套级别，当你有很多回调时，代码开始变得非常复杂:</span><br></pre></td></tr></table></figure></p>\n<p>window.addEventListener(‘load’, () =&gt; {<br>  document.getElementById(‘button’).addEventListener(‘click’, () =&gt; {<br>    setTimeout(() =&gt; {<br>      items.forEach(item =&gt; {<br>        //your code here<br>      })<br>    }, 2000)<br>  })<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这只是一个简单的4层代码，但我见过更多级别的嵌套，这并不有趣。</span><br><span class=\"line\">怎么解呢?</span><br><span class=\"line\"></span><br><span class=\"line\">## 回调的替代品</span><br><span class=\"line\">从ES6开始，JavaScript引入了几个特性，帮助我们处理不涉及回调的异步代码:</span><br><span class=\"line\"></span><br><span class=\"line\">* Promises (ES6)</span><br><span class=\"line\">* Async/Await (ES8)</span><br><span class=\"line\">## Promise</span><br><span class=\"line\">Promise是处理异步代码的一种方法，无需在代码中编写太多回调。</span><br><span class=\"line\"></span><br><span class=\"line\">尽管它们已经存在多年，但是在ES2015中已经被标准化并引入，现在在ES2017中已经被异步函数所取代。</span><br><span class=\"line\"></span><br><span class=\"line\">Async函数使用promise API作为它们的构建块，因此理解它们是非常重要的，即使在较新的代码中您可能会使用Async函数而不是promise。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 简而言之，Promise是如何工作的</span><br><span class=\"line\">一旦Promise被调用，它将以pending状态启动。这意味着调用方函数将继续执行，同时等待Promise自己进行处理，并给调用方函数一些反馈。</span><br><span class=\"line\"></span><br><span class=\"line\">此时，调用方函数等待它以resolved状态或rejected状态返回承诺，但如您所知，JavaScript是异步的，因此函数在Promise工作时继续执行。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 哪个JS API使用Promise?</span><br><span class=\"line\">除了您自己的代码和库代码之外，Promises还被标准的现代Web api(如Fetch或Service Workers)使用。</span><br><span class=\"line\"></span><br><span class=\"line\">在现代JavaScript中，您不太可能不使用承诺，所以让我们开始深入研究它们。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 创建一个promise</span><br><span class=\"line\"></span><br><span class=\"line\">Promise API公开了一个Promise构造函数，您可以使用它进行初始化```new Promise()```：</span><br></pre></td></tr></table></figure></p>\n<p>let done = true<br>const isItDoneYet = new Promise((resolve, reject) =&gt; {<br>  if (done) {<br>    const workDone = ‘Here is the thing I built’<br>    resolve(workDone)<br>  } else {<br>    const why = ‘Still working on something else’<br>    reject(why)<br>  }<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">正如您所看到的，promise检查done全局常量，如果它为真，则返回一个resolve的promise，否则返回一个 reject的promise。</span><br><span class=\"line\"></span><br><span class=\"line\">使用resolve和reject，我们可以返回一个值，在上面的例子中，我们只返回一个字符串，但它也可以是一个对象。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 使用promise</span><br><span class=\"line\">在上一节中，我们介绍了如何创建承诺。</span><br><span class=\"line\">现在让我们看看如何使用承诺。</span><br></pre></td></tr></table></figure></p>\n<p>const isItDoneYet = new Promise()<br>//…<br>const checkIfItsDone = () =&gt; {<br>  isItDoneYet<br>    .then(ok =&gt; {<br>      console.log(ok)<br>    })<br>    .catch(err =&gt; {<br>      console.error(err)<br>    })<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行checkIfItsDone()将执行isItDoneYet() promise，并使用then回调等待它解决，如果出现错误，它将在catch回调中处理它。</span><br><span class=\"line\"></span><br><span class=\"line\">#### promise链</span><br><span class=\"line\"></span><br><span class=\"line\">一个promise可以返回给另一个promise，创建一个promise链。</span><br><span class=\"line\"></span><br><span class=\"line\">Fetch API是链接承诺的一个很好的例子，它是XMLHttpRequest API之上的一层，我们可以使用它来获取资源，并在获取资源时对要执行的promise链进行排队。</span><br><span class=\"line\"></span><br><span class=\"line\">Fetch API是一种基于promise的机制，调用Fetch()相当于使用new promise()定义我们自己的promise。</span><br><span class=\"line\"></span><br><span class=\"line\">例子：</span><br></pre></td></tr></table></figure></p>\n<p>const status = response =&gt; {<br>  if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) {<br>    return Promise.resolve(response)<br>  }<br>  return Promise.reject(new Error(response.statusText))<br>}<br>const json = response =&gt; response.json()<br>fetch(‘/todos.json’)<br>  .then(status)<br>  .then(json)<br>  .then(data =&gt; {<br>    console.log(‘Request succeeded with JSON response’, data)<br>  })<br>  .catch(error =&gt; {<br>    console.log(‘Request failed’, error)<br>  })<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在本例中，我们调用fetch()从TODO中获取TODO项的列表。在域根目录中找到json文件，然后创建promise链。</span><br><span class=\"line\"></span><br><span class=\"line\">运行 fetch()后返回一个响应，它有很多属性，在这些属性中我们引用:</span><br><span class=\"line\">* status表示HTTP状态代码的数值</span><br><span class=\"line\">* statusText状态消息，如果是OK就是请求成功</span><br><span class=\"line\"></span><br><span class=\"line\">response也有一个json()方法，它返回一个promise，该promise将解析处理并转换为JSON的主体内容。</span><br><span class=\"line\"></span><br><span class=\"line\">在这些前提下，会发生这样的情况:链中的第一个promise是我们定义的一个函数status()，它检查响应状态，如果它不是一个成功响应(在200到299之间)，则拒绝该promise。</span><br><span class=\"line\"></span><br><span class=\"line\">此操作将导致promise链跳过列出的所有链接的promise，并直接跳到底部的catch()语句，记录请求失败的文本和错误消息。</span><br><span class=\"line\"></span><br><span class=\"line\">如果成功，则调用我们定义的json()函数。由于上一个promise成功时返回响应对象，所以我们将它作为第二个promise的输入。</span><br><span class=\"line\"></span><br><span class=\"line\">在这种情况下，我们返回JSON处理过的数据，所以第三个promise直接接收JSON:</span><br></pre></td></tr></table></figure></p>\n<p>.then((data) =&gt; {<br>  console.log(‘Request succeeded with JSON response’, data)<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们只需将其打印到控制台</span><br><span class=\"line\"></span><br><span class=\"line\">#### 处理错误</span><br><span class=\"line\">在上面的例子中，在上一节中，我们有一个catch，它被附加到promise链中。</span><br><span class=\"line\"></span><br><span class=\"line\">当promise链中的任何内容失败并引发错误或拒绝promise时，该控件将转到链中最近的catch()语句。</span><br></pre></td></tr></table></figure></p>\n<p>new Promise((resolve, reject) =&gt; {<br>  throw new Error(‘Error’)<br>}).catch(err =&gt; {<br>  console.error(err)<br>})<br>// or<br>new Promise((resolve, reject) =&gt; {<br>  reject(‘Error’)<br>}).catch(err =&gt; {<br>  console.error(err)<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 串联错误</span><br><span class=\"line\">如果在catch()中引发错误，可以附加第二个catch()来处理它，依此类推。</span><br></pre></td></tr></table></figure></p>\n<p>new Promise((resolve, reject) =&gt; {<br>  throw new Error(‘Error’)<br>})<br>  .catch(err =&gt; {<br>    throw new Error(‘Error’)<br>  })<br>  .catch(err =&gt; {<br>    console.error(err)<br>  })<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 用 Promise.all()来编排promise</span><br><span class=\"line\">如果您需要同步执行不同的promise，Promise.all()可以帮助您定义一个promise列表，并在所有promise都得到解析时执行某些操作。</span><br><span class=\"line\"></span><br><span class=\"line\">例子：</span><br></pre></td></tr></table></figure></p>\n<p>const f1 = fetch(‘/something.json’)<br>const f2 = fetch(‘/something2.json’)<br>Promise.all([f1, f2])<br>  .then(res =&gt; {<br>    console.log(‘Array of results’, res)<br>  })<br>  .catch(err =&gt; {<br>    console.error(err)<br>  })<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ES2015析构赋值语法也允许您这样做</span><br></pre></td></tr></table></figure></p>\n<p>Promise.all([f1, f2]).then(([res1, res2]) =&gt; {<br>  console.log(‘Results’, res1, res2)<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">当然你不局限于使用fetch，任何promise都是好的。</span><br><span class=\"line\">#### 用Promise.race()编排promise</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.race()在您传递给它的某个promise解析时立即运行，并且在解析第一个promise的结果时，它只运行附加的回调一次（最先执行成功的promise后就返回该promise，其他的promise就不管了）。</span><br><span class=\"line\"></span><br><span class=\"line\">例子：</span><br></pre></td></tr></table></figure></p>\n<p>const promiseOne = new Promise((resolve, reject) =&gt; {<br>  setTimeout(resolve, 500, ‘one’)<br>})<br>const promiseTwo = new Promise((resolve, reject) =&gt; {<br>  setTimeout(resolve, 100, ‘two’)<br>})<br>Promise.race([promiseOne, promiseTwo]).then(result =&gt; {<br>  console.log(result) // ‘two’<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## Async/Await</span><br><span class=\"line\">JavaScript在很短的时间内从回调发展到了promise (ES2015)，而且由于ES2017异步JavaScript使用async/ wait语法更加简单。</span><br><span class=\"line\"></span><br><span class=\"line\">异步函数是 promise和generate的组合，基本上，它们是比promise更高层次的抽象。让我重复一遍:async/ wait基于promise。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 为什么要Async/Await</span><br><span class=\"line\"></span><br><span class=\"line\">这种方式减少了promise的使用，和‘不打破promise链’的限制</span><br><span class=\"line\"></span><br><span class=\"line\">当promise在ES2015中引入时，它们是为了解决异步代码的问题，它们确实解决了这个问题，但是在ES2015和ES2017分开的两年时间里，很明显promise并不是最终的解决方案。</span><br><span class=\"line\"></span><br><span class=\"line\">引入promise是为了解决著名的回调地狱问题，但它们本身也带来了复杂性，以及语法复杂性。</span><br><span class=\"line\"></span><br><span class=\"line\">它们语义化更好，可以向开发人员提供更好的语法，因此当时机成熟时，我们就可以使用async函数。</span><br><span class=\"line\"></span><br><span class=\"line\">它们使代码看起来是同步的，但在幕后它是异步的，非阻塞的。</span><br><span class=\"line\"></span><br><span class=\"line\">#### async如何工作的</span><br><span class=\"line\"></span><br><span class=\"line\">一个async函数返回一个promise，就像这个例子:</span><br></pre></td></tr></table></figure></p>\n<p>const doSomethingAsync = () =&gt; {<br>  return new Promise(resolve =&gt; {<br>    setTimeout(() =&gt; resolve(‘I did something’), 3000)<br>  })<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当您想要调用这个函数时，您需要预先等待，调用代码将停止，直到promise被resolve或reject。一个警告:函数必须定义为async的。这里有一个例子:</span><br></pre></td></tr></table></figure></p>\n<p>const doSomething = async () =&gt; {<br>  console.log(await doSomethingAsync())<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 一个快速的案例</span><br><span class=\"line\">这是一个简单的async/await 的例子，用于异步运行一个函数:</span><br></pre></td></tr></table></figure></p>\n<p>const doSomethingAsync = () =&gt; {<br>  return new Promise(resolve =&gt; {<br>    setTimeout(() =&gt; resolve(‘I did something’), 3000)<br>  })<br>}<br>const doSomething = async () =&gt; {<br>  console.log(await doSomethingAsync())<br>}<br>console.log(‘Before’)<br>doSomething()<br>console.log(‘After’)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">以上代码将打印以下内容到浏览器控制台:</span><br></pre></td></tr></table></figure></p>\n<p>Before<br>After<br>I did something //after 3s<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 所有的事都是promise</span><br><span class=\"line\">在任何函数前面加上async关键字意味着函数将返回一个promise。</span><br><span class=\"line\"></span><br><span class=\"line\">即使它没有显式地返回promise，它也会在内部让它返回一个promise。</span><br><span class=\"line\"></span><br><span class=\"line\">这就是为什么这个代码是有效的:</span><br></pre></td></tr></table></figure></p>\n<p>const aFunction = async () =&gt; {<br>  return ‘test’<br>}<br>aFunction().then(alert) // This will alert ‘test’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">上面也和下面一样</span><br></pre></td></tr></table></figure></p>\n<p>const aFunction = async () =&gt; {<br>  return Promise.resolve(‘test’)<br>}<br>aFunction().then(alert) // This will alert ‘test’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 代码更易读</span><br><span class=\"line\">正如您在上面的示例中看到的，我们的代码看起来非常简单。将其与使用纯promise(带有链接和回调函数)的代码进行比较。</span><br><span class=\"line\"></span><br><span class=\"line\">这是一个非常简单的例子，当代码更加复杂时，主要的好处就会显现出来。</span><br><span class=\"line\"></span><br><span class=\"line\">例如，下面是如何获得JSON资源，并使用promise对其进行解析:</span><br></pre></td></tr></table></figure></p>\n<p>const getFirstUserData = () =&gt; {<br>  return fetch(‘/users.json’) // get users list<br>    .then(response =&gt; response.json()) // parse JSON<br>    .then(users =&gt; users[0]) // pick first user<br>    .then(user =&gt; fetch(<code>/users/${user.name}</code>)) // get user data<br>    .then(userResponse =&gt; response.json()) // parse JSON<br>}<br>getFirstUserData()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用await/async来实现上面的功能时</span><br></pre></td></tr></table></figure></p>\n<p>const getFirstUserData = async () =&gt; {<br>  const response = await fetch(‘/users.json’) // get users list<br>  const users = await response.json() // parse JSON<br>  const user = users[0] // pick first user<br>  const userResponse = await fetch(<code>/users/${user.name}</code>) // get user data<br>  const userData = await user.json() // parse JSON<br>  return userData<br>}<br>getFirstUserData()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 串联多个异步函数</span><br><span class=\"line\">异步函数可以很容易地链接起来，而且语法比普通的承诺更易读</span><br></pre></td></tr></table></figure></p>\n<p>const promiseToDoSomething = () =&gt; {<br>  return new Promise(resolve =&gt; {<br>    setTimeout(() =&gt; resolve(‘I did something’), 10000)<br>  })<br>}<br>const watchOverSomeoneDoingSomething = async () =&gt; {<br>  const something = await promiseToDoSomething()<br>  return something + ‘ and I watched’<br>}<br>const watchOverSomeoneWatchingSomeoneDoingSomething = async () =&gt; {<br>  const something = await watchOverSomeoneDoingSomething()<br>  return something + ‘ and I watched as well’<br>}<br>watchOverSomeoneWatchingSomeoneDoingSomething().then(res =&gt; {<br>  console.log(res)<br>})</p>\n<p>//输出<br>I did something and I watched and I watched as well<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 更好debug</span><br><span class=\"line\">调试promise很困难，因为调试器不会跳过异步代码。</span><br><span class=\"line\"></span><br><span class=\"line\">Async/ wait使这一切变得非常简单，因为对于编译器来说，它就像同步代码一样。</span><br><span class=\"line\"></span><br><span class=\"line\">## ES 模块</span><br><span class=\"line\">ES模块是用于处理模块的ECMAScript标准。</span><br><span class=\"line\"></span><br><span class=\"line\">nodeJS多年来一直使用CommonJS标准，浏览器从来没有模块系统，因为每一个重大决策，比如模块系统，都必须首先由ECMAScript标准化，然后由浏览器实现。</span><br><span class=\"line\"></span><br><span class=\"line\">这个标准化过程用ES6完成，浏览器开始实现这个标准，试图保持一切正常运行，以相同的方式工作，现在在Chrome、Safari、Edge和Firefox(从版本60开始)中都支持ES模块。</span><br><span class=\"line\"></span><br><span class=\"line\">模块非常酷，因为它们允许您封装各种功能，并将这些功能作为库公开给其他JavaScript文件。</span><br><span class=\"line\"></span><br><span class=\"line\">#### ES模块语法</span><br><span class=\"line\">导入模块的语法是:</span><br></pre></td></tr></table></figure></p>\n<p>import package from ‘module-name’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用CommonJS 时：</span><br></pre></td></tr></table></figure></p>\n<p>const package = require(‘module-name’)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">模块是一个JavaScript文件，它使用export关键字导出一个或多个值(对象、函数或变量)。例如，这个模块导出一个函数，返回一个大写字符串:</span><br><span class=\"line\">&gt; uppercase.js</span><br></pre></td></tr></table></figure></p>\n<p>export default str =&gt; str.toUpperCase()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在本例中，模块定义了一个default export，因此它可以是一个匿名函数。否则，它需要一个名称来将其与其他导出区分开。</span><br><span class=\"line\"></span><br><span class=\"line\">现在，通过导入这个文件，任何其他JavaScript模块都可以用导入的uppercase.js提供的功能。</span><br><span class=\"line\">HTML页面可以使用</span><br><span class=\"line\">```&lt;script&gt;``` 标记添加模块，该标记具有特殊的```type=&quot;module&quot;```属性:</span><br></pre></td></tr></table></figure></p>\n<p><script type=\"module\" src=\"index.js\"></script><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 注意:此模块导入的行为类似于defer脚本加载。</span><br><span class=\"line\"></span><br><span class=\"line\">需要注意的是，使用```type=&quot;module&quot;```加载的任何脚本都是在严格模式下加载的。</span><br><span class=\"line\"></span><br><span class=\"line\">在这个例子中，uppercase.js 模块定义了一个 default export,所以当我们导入它的时候，我们可以给它分配一个我们喜欢的名字:</span><br></pre></td></tr></table></figure></p>\n<p>import toUpperCase from ‘./uppercase.js’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">我们可以这样使用</span><br></pre></td></tr></table></figure></p>\n<p>toUpperCase(‘test’) //‘TEST’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">您还可以使用模块导入的绝对路径，来引用在另一个域中定义的模块:</span><br></pre></td></tr></table></figure></p>\n<p>import toUpperCase from ‘<a href=\"https://flavio-es-modules-example.glitch.me/uppercase.js&#39;\" target=\"_blank\" rel=\"noopener\">https://flavio-es-modules-example.glitch.me/uppercase.js&#39;</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这也是有效的导入语法:</span><br></pre></td></tr></table></figure></p>\n<p>import { foo } from ‘/uppercase.js’<br>import { foo } from ‘../uppercase.js’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">下面是不对的：</span><br></pre></td></tr></table></figure></p>\n<p>import { foo } from ‘uppercase.js’<br>import { foo } from ‘utils/uppercase.js’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">它要么是绝对的，要么在名字前有一个./或者/。</span><br><span class=\"line\"></span><br><span class=\"line\">## 其他 import/export方法</span><br><span class=\"line\">我们看到上面的例子:</span><br></pre></td></tr></table></figure></p>\n<p>export default str =&gt; str.toUpperCase()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这将创建一个默认导出。在一个文件中，你可以导出多个东西，通过使用以下语法:</span><br></pre></td></tr></table></figure></p>\n<p>const a = 1<br>const b = 2<br>const c = 3<br>export { a, b, c }<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">另一个模块可以使用import *来导入所有这些export的内容</span><br></pre></td></tr></table></figure></p>\n<p>import * from ‘module’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">你可以只导入其中的几个导出，使用析构赋值:</span><br></pre></td></tr></table></figure></p>\n<p>import { a } from ‘module’<br>import { a, b } from ‘module’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为了方便，可以使用as重命名任何导入</span><br></pre></td></tr></table></figure></p>\n<p>import { a, b as two } from ‘module’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">您可以按名称导入默认导出和任何非默认导出，如以下常见的React导入:</span><br></pre></td></tr></table></figure></p>\n<p>import React, { Component } from ‘react’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## CORS(跨域)</span><br><span class=\"line\">使用CORS获取模块。这意味着如果您引用来自其他域的脚本，它们必须具有允许跨站点加载的有效CORS头（比如Access-Control-Allow-Origin: *）</span><br><span class=\"line\">#### 那么不支持模块的浏览器呢?</span><br><span class=\"line\">结合使用```type=&quot;module&quot;``` 和```nomodule</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;module&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script nomodule src=&quot;fallback.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>ES模块是现代浏览器中引入的最大特性之一。它们是ES6的一部分，但实现它们的道路是漫长的。</p>\n<p>我们现在可以使用它们了!但是我们还必须记住，如果有多个模块，那么页面的性能将受到影响，因为这是浏览器在运行时必须执行更多一个步骤。</p>\n<p>即使ES模块在浏览器里能用了，Webpack可能仍然是一个巨大的玩家，但是直接在语言中构建这样的特性对于统一模块在客户端和nodeJS的工作方式是非常重要的。</p>\n<blockquote>\n<p>下节预告：React的概念</p>\n</blockquote>\n"},{"title":"React虚拟dom和diff算法","date":"2019-01-30T07:02:10.000Z","_content":"## 什么是虚拟dom？\n这就要从react如何渲染出页面开始\n通常情况下的步骤是这样\n1. 获取state数据\n2. JSX模板\n3. state+JSX模板结合，生成真实dom并显示\n\n这个是在state不发生变化的情况下，（state或者prop发生变化都会调用render函数，重新渲染页面）\n\nstate数据变化时，通常理解下应该是下面的步骤\n1. 获取state数据\n2. JSX模板\n3. state数据+JSX模板结合，生成真实dom并显示\n4. state数据发生变化\n5. 新的state数据+JSX模板结合，生成真实dom并显示\n\n这样可以实现，但是非常消耗性能，因为会渲染两次dom树，所以react就采用一种虚拟dom的方法来进行dom更新。\n\n\nJSX转成dom流程\n> 用JSX语法时，渲染dom的流程：JSX——JS dom描述对象——真实dom\n\n具体步骤：\n1. 获取state数据\n2. JSX模板\n3. 生成虚拟dom（虚拟dom就是一个JS对象，里面包含了对真实dom的描述\n\n```\n['div',{id:'a'},['span',{},'hello']]\n```\n4. 用虚拟dom解构，生成真实dom并显示\n```\n<div id='a'><span>hello</span></div>\n```\n5. state数据发生变化（比如hello变成了hi）\n6. 生成新的虚拟dom\n```\n['div',{id:'a'},['span',{},'hi']]\n```\n7. 比较原始虚拟dom和新的虚拟dom的区别，找出区别是span里的内容\n8. 直接操作dom，只改变span里的内容\n\n####  虚拟dom的好处\n1. 性能提升，dom比对变成js对象比对\n2. 使得跨端应用得以实现（react native）\n>在浏览器中可以用虚拟dom生成真实dom显示，在原生应用中也可以用虚拟dom生成对应的方式来显示页面\n\n## 虚拟dom中的diff算法\n在上面我们介绍了react中state变化时，dom是如何发生变化的，在第七步中比较原始虚拟dom和新的虚拟dom的区别采用的方法，就是diff算法（diffrence）\n\n虚拟dom在什么时候会发生比对？没错，数据发生变化时，也就是调用setState时\n\nreact的虚拟dom其实是同级比较的\n\n![](https://user-gold-cdn.xitu.io/2019/1/30/1689dac3232d3b6d?w=582&h=300&f=png&s=69471)\n如上图\n他的对比步骤如下\n1. 红色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对\n2. 蓝色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对\n3. 绿色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对，浅蓝色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对\n\n> 但凡在上面哪一步骤出现不同，就不再继续比对，而是删除下面的全部节点，采用新的虚拟dom(例如：如果红色框的原始虚拟dom和新的虚拟dom不一致，那么就不在进行比对，采用新的虚拟dom来生成dom)\n\n#### key的作用\nreact利用key来识别组件，它是一种身份标识标识，来提高虚拟dom的比对速度看下面\n\n![](https://user-gold-cdn.xitu.io/2019/1/30/1689dbb06ec80cda?w=477&h=191&f=png&s=7412)\n比如我要在abcde中添加一个f\n\n如果我们没有key值，那我们就需要A比对一遍，B对比一遍，以此类推很好性能，而有了key，就像下面的图一样，我们很快就知道只有f与之前不同，提高了列表渲染的性能\n![](https://user-gold-cdn.xitu.io/2019/1/30/1689dbbc688199b4?w=565&h=201&f=png&s=11659)\n\n","source":"_posts/React虚拟dom和diff算法.md","raw":"---\ntitle: React虚拟dom和diff算法\ndate: 2019-01-30 15:02:10\ntags:\n---\n## 什么是虚拟dom？\n这就要从react如何渲染出页面开始\n通常情况下的步骤是这样\n1. 获取state数据\n2. JSX模板\n3. state+JSX模板结合，生成真实dom并显示\n\n这个是在state不发生变化的情况下，（state或者prop发生变化都会调用render函数，重新渲染页面）\n\nstate数据变化时，通常理解下应该是下面的步骤\n1. 获取state数据\n2. JSX模板\n3. state数据+JSX模板结合，生成真实dom并显示\n4. state数据发生变化\n5. 新的state数据+JSX模板结合，生成真实dom并显示\n\n这样可以实现，但是非常消耗性能，因为会渲染两次dom树，所以react就采用一种虚拟dom的方法来进行dom更新。\n\n\nJSX转成dom流程\n> 用JSX语法时，渲染dom的流程：JSX——JS dom描述对象——真实dom\n\n具体步骤：\n1. 获取state数据\n2. JSX模板\n3. 生成虚拟dom（虚拟dom就是一个JS对象，里面包含了对真实dom的描述\n\n```\n['div',{id:'a'},['span',{},'hello']]\n```\n4. 用虚拟dom解构，生成真实dom并显示\n```\n<div id='a'><span>hello</span></div>\n```\n5. state数据发生变化（比如hello变成了hi）\n6. 生成新的虚拟dom\n```\n['div',{id:'a'},['span',{},'hi']]\n```\n7. 比较原始虚拟dom和新的虚拟dom的区别，找出区别是span里的内容\n8. 直接操作dom，只改变span里的内容\n\n####  虚拟dom的好处\n1. 性能提升，dom比对变成js对象比对\n2. 使得跨端应用得以实现（react native）\n>在浏览器中可以用虚拟dom生成真实dom显示，在原生应用中也可以用虚拟dom生成对应的方式来显示页面\n\n## 虚拟dom中的diff算法\n在上面我们介绍了react中state变化时，dom是如何发生变化的，在第七步中比较原始虚拟dom和新的虚拟dom的区别采用的方法，就是diff算法（diffrence）\n\n虚拟dom在什么时候会发生比对？没错，数据发生变化时，也就是调用setState时\n\nreact的虚拟dom其实是同级比较的\n\n![](https://user-gold-cdn.xitu.io/2019/1/30/1689dac3232d3b6d?w=582&h=300&f=png&s=69471)\n如上图\n他的对比步骤如下\n1. 红色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对\n2. 蓝色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对\n3. 绿色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对，浅蓝色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对\n\n> 但凡在上面哪一步骤出现不同，就不再继续比对，而是删除下面的全部节点，采用新的虚拟dom(例如：如果红色框的原始虚拟dom和新的虚拟dom不一致，那么就不在进行比对，采用新的虚拟dom来生成dom)\n\n#### key的作用\nreact利用key来识别组件，它是一种身份标识标识，来提高虚拟dom的比对速度看下面\n\n![](https://user-gold-cdn.xitu.io/2019/1/30/1689dbb06ec80cda?w=477&h=191&f=png&s=7412)\n比如我要在abcde中添加一个f\n\n如果我们没有key值，那我们就需要A比对一遍，B对比一遍，以此类推很好性能，而有了key，就像下面的图一样，我们很快就知道只有f与之前不同，提高了列表渲染的性能\n![](https://user-gold-cdn.xitu.io/2019/1/30/1689dbbc688199b4?w=565&h=201&f=png&s=11659)\n\n","slug":"React虚拟dom和diff算法","published":1,"updated":"2019-04-10T02:31:49.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzki50009jgf2s5edkftk","content":"<h2 id=\"什么是虚拟dom？\"><a href=\"#什么是虚拟dom？\" class=\"headerlink\" title=\"什么是虚拟dom？\"></a>什么是虚拟dom？</h2><p>这就要从react如何渲染出页面开始<br>通常情况下的步骤是这样</p>\n<ol>\n<li>获取state数据</li>\n<li>JSX模板</li>\n<li>state+JSX模板结合，生成真实dom并显示</li>\n</ol>\n<p>这个是在state不发生变化的情况下，（state或者prop发生变化都会调用render函数，重新渲染页面）</p>\n<p>state数据变化时，通常理解下应该是下面的步骤</p>\n<ol>\n<li>获取state数据</li>\n<li>JSX模板</li>\n<li>state数据+JSX模板结合，生成真实dom并显示</li>\n<li>state数据发生变化</li>\n<li>新的state数据+JSX模板结合，生成真实dom并显示</li>\n</ol>\n<p>这样可以实现，但是非常消耗性能，因为会渲染两次dom树，所以react就采用一种虚拟dom的方法来进行dom更新。</p>\n<p>JSX转成dom流程</p>\n<blockquote>\n<p>用JSX语法时，渲染dom的流程：JSX——JS dom描述对象——真实dom</p>\n</blockquote>\n<p>具体步骤：</p>\n<ol>\n<li>获取state数据</li>\n<li>JSX模板</li>\n<li>生成虚拟dom（虚拟dom就是一个JS对象，里面包含了对真实dom的描述</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&apos;div&apos;,&#123;id:&apos;a&apos;&#125;,[&apos;span&apos;,&#123;&#125;,&apos;hello&apos;]]</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li><p>用虚拟dom解构，生成真实dom并显示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&apos;a&apos;&gt;&lt;span&gt;hello&lt;/span&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>state数据发生变化（比如hello变成了hi）</p>\n</li>\n<li><p>生成新的虚拟dom</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&apos;div&apos;,&#123;id:&apos;a&apos;&#125;,[&apos;span&apos;,&#123;&#125;,&apos;hi&apos;]]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>比较原始虚拟dom和新的虚拟dom的区别，找出区别是span里的内容</p>\n</li>\n<li>直接操作dom，只改变span里的内容</li>\n</ol>\n<h4 id=\"虚拟dom的好处\"><a href=\"#虚拟dom的好处\" class=\"headerlink\" title=\"虚拟dom的好处\"></a>虚拟dom的好处</h4><ol>\n<li>性能提升，dom比对变成js对象比对</li>\n<li>使得跨端应用得以实现（react native）<blockquote>\n<p>在浏览器中可以用虚拟dom生成真实dom显示，在原生应用中也可以用虚拟dom生成对应的方式来显示页面</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"虚拟dom中的diff算法\"><a href=\"#虚拟dom中的diff算法\" class=\"headerlink\" title=\"虚拟dom中的diff算法\"></a>虚拟dom中的diff算法</h2><p>在上面我们介绍了react中state变化时，dom是如何发生变化的，在第七步中比较原始虚拟dom和新的虚拟dom的区别采用的方法，就是diff算法（diffrence）</p>\n<p>虚拟dom在什么时候会发生比对？没错，数据发生变化时，也就是调用setState时</p>\n<p>react的虚拟dom其实是同级比较的</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/30/1689dac3232d3b6d?w=582&amp;h=300&amp;f=png&amp;s=69471\" alt=\"\"><br>如上图<br>他的对比步骤如下</p>\n<ol>\n<li>红色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对</li>\n<li>蓝色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对</li>\n<li>绿色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对，浅蓝色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对</li>\n</ol>\n<blockquote>\n<p>但凡在上面哪一步骤出现不同，就不再继续比对，而是删除下面的全部节点，采用新的虚拟dom(例如：如果红色框的原始虚拟dom和新的虚拟dom不一致，那么就不在进行比对，采用新的虚拟dom来生成dom)</p>\n</blockquote>\n<h4 id=\"key的作用\"><a href=\"#key的作用\" class=\"headerlink\" title=\"key的作用\"></a>key的作用</h4><p>react利用key来识别组件，它是一种身份标识标识，来提高虚拟dom的比对速度看下面</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/30/1689dbb06ec80cda?w=477&amp;h=191&amp;f=png&amp;s=7412\" alt=\"\"><br>比如我要在abcde中添加一个f</p>\n<p>如果我们没有key值，那我们就需要A比对一遍，B对比一遍，以此类推很好性能，而有了key，就像下面的图一样，我们很快就知道只有f与之前不同，提高了列表渲染的性能<br><img src=\"https://user-gold-cdn.xitu.io/2019/1/30/1689dbbc688199b4?w=565&amp;h=201&amp;f=png&amp;s=11659\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是虚拟dom？\"><a href=\"#什么是虚拟dom？\" class=\"headerlink\" title=\"什么是虚拟dom？\"></a>什么是虚拟dom？</h2><p>这就要从react如何渲染出页面开始<br>通常情况下的步骤是这样</p>\n<ol>\n<li>获取state数据</li>\n<li>JSX模板</li>\n<li>state+JSX模板结合，生成真实dom并显示</li>\n</ol>\n<p>这个是在state不发生变化的情况下，（state或者prop发生变化都会调用render函数，重新渲染页面）</p>\n<p>state数据变化时，通常理解下应该是下面的步骤</p>\n<ol>\n<li>获取state数据</li>\n<li>JSX模板</li>\n<li>state数据+JSX模板结合，生成真实dom并显示</li>\n<li>state数据发生变化</li>\n<li>新的state数据+JSX模板结合，生成真实dom并显示</li>\n</ol>\n<p>这样可以实现，但是非常消耗性能，因为会渲染两次dom树，所以react就采用一种虚拟dom的方法来进行dom更新。</p>\n<p>JSX转成dom流程</p>\n<blockquote>\n<p>用JSX语法时，渲染dom的流程：JSX——JS dom描述对象——真实dom</p>\n</blockquote>\n<p>具体步骤：</p>\n<ol>\n<li>获取state数据</li>\n<li>JSX模板</li>\n<li>生成虚拟dom（虚拟dom就是一个JS对象，里面包含了对真实dom的描述</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&apos;div&apos;,&#123;id:&apos;a&apos;&#125;,[&apos;span&apos;,&#123;&#125;,&apos;hello&apos;]]</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li><p>用虚拟dom解构，生成真实dom并显示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&apos;a&apos;&gt;&lt;span&gt;hello&lt;/span&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>state数据发生变化（比如hello变成了hi）</p>\n</li>\n<li><p>生成新的虚拟dom</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&apos;div&apos;,&#123;id:&apos;a&apos;&#125;,[&apos;span&apos;,&#123;&#125;,&apos;hi&apos;]]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>比较原始虚拟dom和新的虚拟dom的区别，找出区别是span里的内容</p>\n</li>\n<li>直接操作dom，只改变span里的内容</li>\n</ol>\n<h4 id=\"虚拟dom的好处\"><a href=\"#虚拟dom的好处\" class=\"headerlink\" title=\"虚拟dom的好处\"></a>虚拟dom的好处</h4><ol>\n<li>性能提升，dom比对变成js对象比对</li>\n<li>使得跨端应用得以实现（react native）<blockquote>\n<p>在浏览器中可以用虚拟dom生成真实dom显示，在原生应用中也可以用虚拟dom生成对应的方式来显示页面</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"虚拟dom中的diff算法\"><a href=\"#虚拟dom中的diff算法\" class=\"headerlink\" title=\"虚拟dom中的diff算法\"></a>虚拟dom中的diff算法</h2><p>在上面我们介绍了react中state变化时，dom是如何发生变化的，在第七步中比较原始虚拟dom和新的虚拟dom的区别采用的方法，就是diff算法（diffrence）</p>\n<p>虚拟dom在什么时候会发生比对？没错，数据发生变化时，也就是调用setState时</p>\n<p>react的虚拟dom其实是同级比较的</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/30/1689dac3232d3b6d?w=582&amp;h=300&amp;f=png&amp;s=69471\" alt=\"\"><br>如上图<br>他的对比步骤如下</p>\n<ol>\n<li>红色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对</li>\n<li>蓝色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对</li>\n<li>绿色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对，浅蓝色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对</li>\n</ol>\n<blockquote>\n<p>但凡在上面哪一步骤出现不同，就不再继续比对，而是删除下面的全部节点，采用新的虚拟dom(例如：如果红色框的原始虚拟dom和新的虚拟dom不一致，那么就不在进行比对，采用新的虚拟dom来生成dom)</p>\n</blockquote>\n<h4 id=\"key的作用\"><a href=\"#key的作用\" class=\"headerlink\" title=\"key的作用\"></a>key的作用</h4><p>react利用key来识别组件，它是一种身份标识标识，来提高虚拟dom的比对速度看下面</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/30/1689dbb06ec80cda?w=477&amp;h=191&amp;f=png&amp;s=7412\" alt=\"\"><br>比如我要在abcde中添加一个f</p>\n<p>如果我们没有key值，那我们就需要A比对一遍，B对比一遍，以此类推很好性能，而有了key，就像下面的图一样，我们很快就知道只有f与之前不同，提高了列表渲染的性能<br><img src=\"https://user-gold-cdn.xitu.io/2019/1/30/1689dbbc688199b4?w=565&amp;h=201&amp;f=png&amp;s=11659\" alt=\"\"></p>\n"},{"title":"Vue使用踩坑记录","date":"2019-01-14T05:52:15.000Z","_content":"> 主要记录在Vue项目中遇到的一些问题\n1. \n```\nerror: Unexpected console statement (no-console) at src\\components\\leftSideBar\\index.vue:41:9:\n```\n解决：\n```\n  /* eslint no-console: 0*/\n  console.log('a')\n```\n2. 使用module.exports时遇到问题\n```\nmenu-conf.js?6ce3:1 Uncaught TypeError: Cannot assign to read only property 'exports' of object '#<Object>'\n\n\"export 'default' (imported as 'sidebarconf') was not found in '../../conf/menu-conf'\n```\n\n解决：\n改用\n```\nlet a = {\n\n}\n\nexport default a;\n\n```","source":"_posts/Vue使用踩坑记录.md","raw":"---\ntitle: Vue使用踩坑记录\ndate: 2019-01-14 13:52:15\ntags:\n---\n> 主要记录在Vue项目中遇到的一些问题\n1. \n```\nerror: Unexpected console statement (no-console) at src\\components\\leftSideBar\\index.vue:41:9:\n```\n解决：\n```\n  /* eslint no-console: 0*/\n  console.log('a')\n```\n2. 使用module.exports时遇到问题\n```\nmenu-conf.js?6ce3:1 Uncaught TypeError: Cannot assign to read only property 'exports' of object '#<Object>'\n\n\"export 'default' (imported as 'sidebarconf') was not found in '../../conf/menu-conf'\n```\n\n解决：\n改用\n```\nlet a = {\n\n}\n\nexport default a;\n\n```","slug":"Vue使用踩坑记录","published":1,"updated":"2019-04-10T02:31:49.126Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzki6000ajgf2au0wmmvv","content":"<blockquote>\n<p>主要记录在Vue项目中遇到的一些问题</p>\n<ol>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error: Unexpected console statement (no-console) at src\\components\\leftSideBar\\index.vue:41:9:</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<p>解决：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* eslint no-console: 0*/</span><br><span class=\"line\">console.log(&apos;a&apos;)</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>使用module.exports时遇到问题<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu-conf.js?6ce3:1 Uncaught TypeError: Cannot assign to read only property &apos;exports&apos; of object &apos;#&lt;Object&gt;&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;export &apos;default&apos; (imported as &apos;sidebarconf&apos;) was not found in &apos;../../conf/menu-conf&apos;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>解决：<br>改用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default a;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>主要记录在Vue项目中遇到的一些问题</p>\n<ol>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error: Unexpected console statement (no-console) at src\\components\\leftSideBar\\index.vue:41:9:</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<p>解决：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* eslint no-console: 0*/</span><br><span class=\"line\">console.log(&apos;a&apos;)</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>使用module.exports时遇到问题<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu-conf.js?6ce3:1 Uncaught TypeError: Cannot assign to read only property &apos;exports&apos; of object &apos;#&lt;Object&gt;&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;export &apos;default&apos; (imported as &apos;sidebarconf&apos;) was not found in &apos;../../conf/menu-conf&apos;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>解决：<br>改用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default a;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"javascript-闭包","date":"2019-01-10T02:56:47.000Z","_content":"闭包的作用:\n* 1.封装变量\n* 2.延续局部变量的寿命\n* 3.闭包和面向对象设计:实现私有数据和方法的封装(本质还是1,封装变量)\n* 闭包能使局部变量的生命期延长,这点与全局作用域的变量是一致的,不能算是内存泄漏!\n* 闭包与内存泄漏有关的部分是:\n使用闭包容易造成循环引用,如果闭包的作用域中保存着一些DOM节点,这时候有可能造成内存泄漏(互相引用导致内存无法释放)\n\n举例：\n```\n// 例1：\nvar increment = function () {\n    var count = 1;\n    return {\n        inc: function () {\n            return count++;\n        }\n    }\n}\nconsole.log(increment.count);   //undefined\nvar counter = increment();\nconsole.log(counter.inc()); //1\nconsole.log(counter.inc()); //2\nconsole.log(counter.inc()); //3\n\nvar counter2 = increment();\nconsole.log(counter2.inc()); //1\nconsole.log(counter == counter2);  //false,注:闭包每次返回的对象都不一样!\n\n\n// 例2\n\nvar getTypeChecker = function () {\n    var types = {};\n\n    for (var i = 0, type; type = ['String', 'Number', 'Array'][i++];) {\n        //使用闭包来封闭每次循环的变量\n        (function (type) {\n            types['is' + type] = function (obj) {\n                return Object.prototype.toString.call(obj) === '[object ' + type + ']';\n            }\n        })(type);\n    }\n    return types;\n}\n\nvar checker = getTypeChecker();\nconsole.log(checker.isArray([]));   // true\nconsole.log(checker.isString([]));   //false\nconsole.log(checker.isString('hello'));  //true\n```","source":"_posts/javascript-闭包.md","raw":"---\ntitle: javascript-闭包\ndate: 2019-01-10 10:56:47\ntags:\n---\n闭包的作用:\n* 1.封装变量\n* 2.延续局部变量的寿命\n* 3.闭包和面向对象设计:实现私有数据和方法的封装(本质还是1,封装变量)\n* 闭包能使局部变量的生命期延长,这点与全局作用域的变量是一致的,不能算是内存泄漏!\n* 闭包与内存泄漏有关的部分是:\n使用闭包容易造成循环引用,如果闭包的作用域中保存着一些DOM节点,这时候有可能造成内存泄漏(互相引用导致内存无法释放)\n\n举例：\n```\n// 例1：\nvar increment = function () {\n    var count = 1;\n    return {\n        inc: function () {\n            return count++;\n        }\n    }\n}\nconsole.log(increment.count);   //undefined\nvar counter = increment();\nconsole.log(counter.inc()); //1\nconsole.log(counter.inc()); //2\nconsole.log(counter.inc()); //3\n\nvar counter2 = increment();\nconsole.log(counter2.inc()); //1\nconsole.log(counter == counter2);  //false,注:闭包每次返回的对象都不一样!\n\n\n// 例2\n\nvar getTypeChecker = function () {\n    var types = {};\n\n    for (var i = 0, type; type = ['String', 'Number', 'Array'][i++];) {\n        //使用闭包来封闭每次循环的变量\n        (function (type) {\n            types['is' + type] = function (obj) {\n                return Object.prototype.toString.call(obj) === '[object ' + type + ']';\n            }\n        })(type);\n    }\n    return types;\n}\n\nvar checker = getTypeChecker();\nconsole.log(checker.isArray([]));   // true\nconsole.log(checker.isString([]));   //false\nconsole.log(checker.isString('hello'));  //true\n```","slug":"javascript-闭包","published":1,"updated":"2019-04-10T02:31:49.129Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzki9000bjgf25ieb60q4","content":"<p>闭包的作用:</p>\n<ul>\n<li>1.封装变量</li>\n<li>2.延续局部变量的寿命</li>\n<li>3.闭包和面向对象设计:实现私有数据和方法的封装(本质还是1,封装变量)</li>\n<li>闭包能使局部变量的生命期延长,这点与全局作用域的变量是一致的,不能算是内存泄漏!</li>\n<li>闭包与内存泄漏有关的部分是:<br>使用闭包容易造成循环引用,如果闭包的作用域中保存着一些DOM节点,这时候有可能造成内存泄漏(互相引用导致内存无法释放)</li>\n</ul>\n<p>举例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 例1：</span><br><span class=\"line\">var increment = function () &#123;</span><br><span class=\"line\">    var count = 1;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        inc: function () &#123;</span><br><span class=\"line\">            return count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(increment.count);   //undefined</span><br><span class=\"line\">var counter = increment();</span><br><span class=\"line\">console.log(counter.inc()); //1</span><br><span class=\"line\">console.log(counter.inc()); //2</span><br><span class=\"line\">console.log(counter.inc()); //3</span><br><span class=\"line\"></span><br><span class=\"line\">var counter2 = increment();</span><br><span class=\"line\">console.log(counter2.inc()); //1</span><br><span class=\"line\">console.log(counter == counter2);  //false,注:闭包每次返回的对象都不一样!</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 例2</span><br><span class=\"line\"></span><br><span class=\"line\">var getTypeChecker = function () &#123;</span><br><span class=\"line\">    var types = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (var i = 0, type; type = [&apos;String&apos;, &apos;Number&apos;, &apos;Array&apos;][i++];) &#123;</span><br><span class=\"line\">        //使用闭包来封闭每次循环的变量</span><br><span class=\"line\">        (function (type) &#123;</span><br><span class=\"line\">            types[&apos;is&apos; + type] = function (obj) &#123;</span><br><span class=\"line\">                return Object.prototype.toString.call(obj) === &apos;[object &apos; + type + &apos;]&apos;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)(type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return types;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var checker = getTypeChecker();</span><br><span class=\"line\">console.log(checker.isArray([]));   // true</span><br><span class=\"line\">console.log(checker.isString([]));   //false</span><br><span class=\"line\">console.log(checker.isString(&apos;hello&apos;));  //true</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>闭包的作用:</p>\n<ul>\n<li>1.封装变量</li>\n<li>2.延续局部变量的寿命</li>\n<li>3.闭包和面向对象设计:实现私有数据和方法的封装(本质还是1,封装变量)</li>\n<li>闭包能使局部变量的生命期延长,这点与全局作用域的变量是一致的,不能算是内存泄漏!</li>\n<li>闭包与内存泄漏有关的部分是:<br>使用闭包容易造成循环引用,如果闭包的作用域中保存着一些DOM节点,这时候有可能造成内存泄漏(互相引用导致内存无法释放)</li>\n</ul>\n<p>举例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 例1：</span><br><span class=\"line\">var increment = function () &#123;</span><br><span class=\"line\">    var count = 1;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        inc: function () &#123;</span><br><span class=\"line\">            return count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(increment.count);   //undefined</span><br><span class=\"line\">var counter = increment();</span><br><span class=\"line\">console.log(counter.inc()); //1</span><br><span class=\"line\">console.log(counter.inc()); //2</span><br><span class=\"line\">console.log(counter.inc()); //3</span><br><span class=\"line\"></span><br><span class=\"line\">var counter2 = increment();</span><br><span class=\"line\">console.log(counter2.inc()); //1</span><br><span class=\"line\">console.log(counter == counter2);  //false,注:闭包每次返回的对象都不一样!</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 例2</span><br><span class=\"line\"></span><br><span class=\"line\">var getTypeChecker = function () &#123;</span><br><span class=\"line\">    var types = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (var i = 0, type; type = [&apos;String&apos;, &apos;Number&apos;, &apos;Array&apos;][i++];) &#123;</span><br><span class=\"line\">        //使用闭包来封闭每次循环的变量</span><br><span class=\"line\">        (function (type) &#123;</span><br><span class=\"line\">            types[&apos;is&apos; + type] = function (obj) &#123;</span><br><span class=\"line\">                return Object.prototype.toString.call(obj) === &apos;[object &apos; + type + &apos;]&apos;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)(type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return types;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var checker = getTypeChecker();</span><br><span class=\"line\">console.log(checker.isArray([]));   // true</span><br><span class=\"line\">console.log(checker.isString([]));   //false</span><br><span class=\"line\">console.log(checker.isString(&apos;hello&apos;));  //true</span><br></pre></td></tr></table></figure></p>\n"},{"title":"javascript跨域","date":"2019-01-09T13:11:52.000Z","_content":"\n什么是跨域？\n概念：只要协议、域名、端口有任何一个不同，都被当作是不同的域。\n```\n比如下面四个，都会存在跨域的问题\nhttps://www.baidu.com:8080\nhttp://www.baidu.com:8080\nhttps://www.m.baidu.com:8080\nhttps://www.m.baidu.com:4000\n```\n\n#### 如何解决跨域问题\n###### 1.JSONP：\n> 原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。\n\n由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。\n优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。\nJSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里\n\n```\n<script>\n    function createJs(sUrl){\n        var oScript = document.createElement('script');\n        oScript.type = 'text/javascript';\n        oScript.src = sUrl;\n        document.getElementsByTagName('head')[0].appendChild(oScript);\n    }\n    createJs('jsonp.js');\n    box({\n       'name': 'test'\n    });\n    function box(json){\n        alert(json.name);\n    }\n</script>\n```\n###### 2.CORS\n服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。\n如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。\n\n###### 3.通过修改DOCUMENT.DOMAIN来跨子域\n将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，\n否则无法利用document.domain进行跨域,主域相同的使用document.domain\n\n###### 4.使用WINDOW.NAME来进行跨域\n\nwindow对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，\n每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的\n\n###### 5.使用HTML5中新引进的WINDOW.POSTMESSAGE方法来跨域传送数据\n\n###### 6.还有FLASH、在服务器上设置代理页面等跨域方式。\n\n\n\n\n","source":"_posts/javascript跨域.md","raw":"---\ntitle: javascript跨域\ndate: 2019-01-09 21:11:52\ntags:\n---\n\n什么是跨域？\n概念：只要协议、域名、端口有任何一个不同，都被当作是不同的域。\n```\n比如下面四个，都会存在跨域的问题\nhttps://www.baidu.com:8080\nhttp://www.baidu.com:8080\nhttps://www.m.baidu.com:8080\nhttps://www.m.baidu.com:4000\n```\n\n#### 如何解决跨域问题\n###### 1.JSONP：\n> 原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。\n\n由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。\n优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。\nJSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里\n\n```\n<script>\n    function createJs(sUrl){\n        var oScript = document.createElement('script');\n        oScript.type = 'text/javascript';\n        oScript.src = sUrl;\n        document.getElementsByTagName('head')[0].appendChild(oScript);\n    }\n    createJs('jsonp.js');\n    box({\n       'name': 'test'\n    });\n    function box(json){\n        alert(json.name);\n    }\n</script>\n```\n###### 2.CORS\n服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。\n如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。\n\n###### 3.通过修改DOCUMENT.DOMAIN来跨子域\n将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，\n否则无法利用document.domain进行跨域,主域相同的使用document.domain\n\n###### 4.使用WINDOW.NAME来进行跨域\n\nwindow对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，\n每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的\n\n###### 5.使用HTML5中新引进的WINDOW.POSTMESSAGE方法来跨域传送数据\n\n###### 6.还有FLASH、在服务器上设置代理页面等跨域方式。\n\n\n\n\n","slug":"javascript跨域","published":1,"updated":"2019-04-10T02:31:49.133Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzkia000cjgf2m33g9w39","content":"<p>什么是跨域？<br>概念：只要协议、域名、端口有任何一个不同，都被当作是不同的域。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">比如下面四个，都会存在跨域的问题</span><br><span class=\"line\">https://www.baidu.com:8080</span><br><span class=\"line\">http://www.baidu.com:8080</span><br><span class=\"line\">https://www.m.baidu.com:8080</span><br><span class=\"line\">https://www.m.baidu.com:4000</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"如何解决跨域问题\"><a href=\"#如何解决跨域问题\" class=\"headerlink\" title=\"如何解决跨域问题\"></a>如何解决跨域问题</h4><h6 id=\"1-JSONP：\"><a href=\"#1-JSONP：\" class=\"headerlink\" title=\"1.JSONP：\"></a>1.JSONP：</h6><blockquote>\n<p>原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。</p>\n</blockquote>\n<p>由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。<br>优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。<br>JSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    function createJs(sUrl)&#123;</span><br><span class=\"line\">        var oScript = document.createElement(&apos;script&apos;);</span><br><span class=\"line\">        oScript.type = &apos;text/javascript&apos;;</span><br><span class=\"line\">        oScript.src = sUrl;</span><br><span class=\"line\">        document.getElementsByTagName(&apos;head&apos;)[0].appendChild(oScript);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    createJs(&apos;jsonp.js&apos;);</span><br><span class=\"line\">    box(&#123;</span><br><span class=\"line\">       &apos;name&apos;: &apos;test&apos;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    function box(json)&#123;</span><br><span class=\"line\">        alert(json.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h6 id=\"2-CORS\"><a href=\"#2-CORS\" class=\"headerlink\" title=\"2.CORS\"></a>2.CORS</h6><p>服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。<br>如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。</p>\n<h6 id=\"3-通过修改DOCUMENT-DOMAIN来跨子域\"><a href=\"#3-通过修改DOCUMENT-DOMAIN来跨子域\" class=\"headerlink\" title=\"3.通过修改DOCUMENT.DOMAIN来跨子域\"></a>3.通过修改DOCUMENT.DOMAIN来跨子域</h6><p>将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，<br>否则无法利用document.domain进行跨域,主域相同的使用document.domain</p>\n<h6 id=\"4-使用WINDOW-NAME来进行跨域\"><a href=\"#4-使用WINDOW-NAME来进行跨域\" class=\"headerlink\" title=\"4.使用WINDOW.NAME来进行跨域\"></a>4.使用WINDOW.NAME来进行跨域</h6><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，<br>每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的</p>\n<h6 id=\"5-使用HTML5中新引进的WINDOW-POSTMESSAGE方法来跨域传送数据\"><a href=\"#5-使用HTML5中新引进的WINDOW-POSTMESSAGE方法来跨域传送数据\" class=\"headerlink\" title=\"5.使用HTML5中新引进的WINDOW.POSTMESSAGE方法来跨域传送数据\"></a>5.使用HTML5中新引进的WINDOW.POSTMESSAGE方法来跨域传送数据</h6><h6 id=\"6-还有FLASH、在服务器上设置代理页面等跨域方式。\"><a href=\"#6-还有FLASH、在服务器上设置代理页面等跨域方式。\" class=\"headerlink\" title=\"6.还有FLASH、在服务器上设置代理页面等跨域方式。\"></a>6.还有FLASH、在服务器上设置代理页面等跨域方式。</h6>","site":{"data":{}},"excerpt":"","more":"<p>什么是跨域？<br>概念：只要协议、域名、端口有任何一个不同，都被当作是不同的域。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">比如下面四个，都会存在跨域的问题</span><br><span class=\"line\">https://www.baidu.com:8080</span><br><span class=\"line\">http://www.baidu.com:8080</span><br><span class=\"line\">https://www.m.baidu.com:8080</span><br><span class=\"line\">https://www.m.baidu.com:4000</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"如何解决跨域问题\"><a href=\"#如何解决跨域问题\" class=\"headerlink\" title=\"如何解决跨域问题\"></a>如何解决跨域问题</h4><h6 id=\"1-JSONP：\"><a href=\"#1-JSONP：\" class=\"headerlink\" title=\"1.JSONP：\"></a>1.JSONP：</h6><blockquote>\n<p>原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。</p>\n</blockquote>\n<p>由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。<br>优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。<br>JSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    function createJs(sUrl)&#123;</span><br><span class=\"line\">        var oScript = document.createElement(&apos;script&apos;);</span><br><span class=\"line\">        oScript.type = &apos;text/javascript&apos;;</span><br><span class=\"line\">        oScript.src = sUrl;</span><br><span class=\"line\">        document.getElementsByTagName(&apos;head&apos;)[0].appendChild(oScript);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    createJs(&apos;jsonp.js&apos;);</span><br><span class=\"line\">    box(&#123;</span><br><span class=\"line\">       &apos;name&apos;: &apos;test&apos;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    function box(json)&#123;</span><br><span class=\"line\">        alert(json.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h6 id=\"2-CORS\"><a href=\"#2-CORS\" class=\"headerlink\" title=\"2.CORS\"></a>2.CORS</h6><p>服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。<br>如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。</p>\n<h6 id=\"3-通过修改DOCUMENT-DOMAIN来跨子域\"><a href=\"#3-通过修改DOCUMENT-DOMAIN来跨子域\" class=\"headerlink\" title=\"3.通过修改DOCUMENT.DOMAIN来跨子域\"></a>3.通过修改DOCUMENT.DOMAIN来跨子域</h6><p>将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，<br>否则无法利用document.domain进行跨域,主域相同的使用document.domain</p>\n<h6 id=\"4-使用WINDOW-NAME来进行跨域\"><a href=\"#4-使用WINDOW-NAME来进行跨域\" class=\"headerlink\" title=\"4.使用WINDOW.NAME来进行跨域\"></a>4.使用WINDOW.NAME来进行跨域</h6><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，<br>每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的</p>\n<h6 id=\"5-使用HTML5中新引进的WINDOW-POSTMESSAGE方法来跨域传送数据\"><a href=\"#5-使用HTML5中新引进的WINDOW-POSTMESSAGE方法来跨域传送数据\" class=\"headerlink\" title=\"5.使用HTML5中新引进的WINDOW.POSTMESSAGE方法来跨域传送数据\"></a>5.使用HTML5中新引进的WINDOW.POSTMESSAGE方法来跨域传送数据</h6><h6 id=\"6-还有FLASH、在服务器上设置代理页面等跨域方式。\"><a href=\"#6-还有FLASH、在服务器上设置代理页面等跨域方式。\" class=\"headerlink\" title=\"6.还有FLASH、在服务器上设置代理页面等跨域方式。\"></a>6.还有FLASH、在服务器上设置代理页面等跨域方式。</h6>"},{"title":"react生命周期","date":"2019-01-27T08:30:48.000Z","_content":"> 生命周期函数：在某一个时刻组件会自动调用执行的函数\n\n\n### React 生命周期\n\n![](https://user-gold-cdn.xitu.io/2017/11/11/88e11709488aeea3f9c6595ee4083bf3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n> 如图，React生命周期主要包括三个阶段：初始化阶段、运行中阶段和销毁阶段，在React不同的生命周期里，会依次触发不同的钩子函数，下面我们就来详细介绍一下React的生命周期函数\n\n#### 一、初始化阶段\n\n##### 1、设置组件的默认属性\n\n    static defaultProps = {\n        name: 'sls',\n        age:23\n    };\n    //or\n    Counter.defaltProps={name:'sls'}\n    复制代码\n\n##### 2、设置组件的初始化状态\n\n    constructor() {\n        super();\n        this.state = {number: 0}\n    }\n    复制代码\n\n##### 3、componentWillMount()\n\n> 组件即将被渲染到页面之前触发，此时可以进行开启定时器、向服务器发送请求等操作\n\n##### 4、render()\n\n> 组件渲染\n\n##### 5、componentDidMount()\n\n> 组件已经被渲染到页面中后触发：此时页面中有了真正的DOM的元素，可以进行DOM相关的操作\n\n\n\n#### 二、运行中阶段\n\n##### 1、componentWillReceiveProps()\n\n> 组件接收到属性时触发\n\n##### 2、shouldComponentUpdate()\n\n> 当组件接收到新属性，或者组件的状态发生改变时触发。组件首次渲染时并不会触发\n\n    shouldComponentUpdate(newProps, newState) {\n        if (newProps.number < 5) return true;\n        return false\n    }\n    //该钩子函数可以接收到两个参数，新的属性和状态，返回true/false来控制组件是否需要更新。\n    复制代码\n\n> 一般我们通过该函数来优化性能：\n\n> 一个React项目需要更新一个小组件时，很可能需要父组件更新自己的状态。而一个父组件的重新更新会造成它旗下所有的子组件重新执行render()方法，形成新的虚拟DOM，再用diff算法对新旧虚拟DOM进行结构和属性的比较，决定组件是否需要重新渲染\n\n> 无疑这样的操作会造成很多的性能浪费，所以我们开发者可以根据项目的业务逻辑，在`shouldComponentUpdate()`中加入条件判断，从而优化性能\n\n> 例如React中的就提供了一个`PureComponent`的类，当我们的组件继承于它时，组件更新时就会默认先比较新旧属性和状态，从而决定组件是否更新。值得注意的是，`PureComponent`进行的是浅比较，所以组件状态或属性改变时，都需要返回一个新的对象或数组\n\n##### 3、componentWillUpdate()\n\n> 组件即将被更新时触发\n\n##### 4、componentDidUpdate()\n\n> 组件被更新完成后触发。页面中产生了新的DOM的元素，可以进行DOM操作\n\n#### 三、销毁阶段\n\n##### 1、componentWillUnmount()\n\n> 组件被销毁时触发。这里我们可以进行一些清理操作，例如清理定时器，取消Redux的订阅事件等等。\n\n### 有兴趣的同学也可以用下面的代码进行测试\n\n#### 废话少说，放码过来!\n\n    import React from 'react'\n    import ReactDOM from 'react-dom';\n    \n    class SubCounter extends React.Component {\n        componentWillReceiveProps() {\n            console.log('9、子组件将要接收到新属性');\n        }\n    \n        shouldComponentUpdate(newProps, newState) {\n            console.log('10、子组件是否需要更新');\n            if (newProps.number < 5) return true;\n            return false\n        }\n    \n        componentWillUpdate() {\n            console.log('11、子组件将要更新');\n        }\n    \n        componentDidUpdate() {\n            console.log('13、子组件更新完成');\n        }\n    \n        componentWillUnmount() {\n            console.log('14、子组件将卸载');\n        }\n    \n        render() {\n            console.log('12、子组件挂载中');\n            return (\n                    <p>{this.props.number}</p>\n            )\n        }\n    }\n    \n    class Counter extends React.Component {\n        static defaultProps = {\n            //1、加载默认属性\n            name: 'sls',\n            age:23\n        };\n    \n        constructor() {\n            super();\n            //2、加载默认状态\n            this.state = {number: 0}\n        }\n    \n        componentWillMount() {\n            console.log('3、父组件挂载之前');\n        }\n    \n        componentDidMount() {\n            console.log('5、父组件挂载完成');\n        }\n    \n        shouldComponentUpdate(newProps, newState) {\n            console.log('6、父组件是否需要更新');\n            if (newState.number<15) return true;\n            return false\n        }\n    \n        componentWillUpdate() {\n            console.log('7、父组件将要更新');\n        }\n    \n        componentDidUpdate() {\n            console.log('8、父组件更新完成');\n        }\n    \n        handleClick = () => {\n            this.setState({\n                number: this.state.number + 1\n            })\n        };\n    \n        render() {\n            console.log('4、render(父组件挂载)');\n            return (\n                <div>\n                    <p>{this.state.number}</p>\n                    <button onClick={this.handleClick}>+</button>\n                    {this.state.number<10?<SubCounter number={this.state.number}/>:null}\n                </div>\n            )\n        }\n    }\n    ReactDOM.render(<Counter/>, document.getElementById('root'));\n","source":"_posts/react生命周期.md","raw":"---\ntitle: react生命周期\ndate: 2019-01-27 16:30:48\ntags:\n---\n> 生命周期函数：在某一个时刻组件会自动调用执行的函数\n\n\n### React 生命周期\n\n![](https://user-gold-cdn.xitu.io/2017/11/11/88e11709488aeea3f9c6595ee4083bf3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n> 如图，React生命周期主要包括三个阶段：初始化阶段、运行中阶段和销毁阶段，在React不同的生命周期里，会依次触发不同的钩子函数，下面我们就来详细介绍一下React的生命周期函数\n\n#### 一、初始化阶段\n\n##### 1、设置组件的默认属性\n\n    static defaultProps = {\n        name: 'sls',\n        age:23\n    };\n    //or\n    Counter.defaltProps={name:'sls'}\n    复制代码\n\n##### 2、设置组件的初始化状态\n\n    constructor() {\n        super();\n        this.state = {number: 0}\n    }\n    复制代码\n\n##### 3、componentWillMount()\n\n> 组件即将被渲染到页面之前触发，此时可以进行开启定时器、向服务器发送请求等操作\n\n##### 4、render()\n\n> 组件渲染\n\n##### 5、componentDidMount()\n\n> 组件已经被渲染到页面中后触发：此时页面中有了真正的DOM的元素，可以进行DOM相关的操作\n\n\n\n#### 二、运行中阶段\n\n##### 1、componentWillReceiveProps()\n\n> 组件接收到属性时触发\n\n##### 2、shouldComponentUpdate()\n\n> 当组件接收到新属性，或者组件的状态发生改变时触发。组件首次渲染时并不会触发\n\n    shouldComponentUpdate(newProps, newState) {\n        if (newProps.number < 5) return true;\n        return false\n    }\n    //该钩子函数可以接收到两个参数，新的属性和状态，返回true/false来控制组件是否需要更新。\n    复制代码\n\n> 一般我们通过该函数来优化性能：\n\n> 一个React项目需要更新一个小组件时，很可能需要父组件更新自己的状态。而一个父组件的重新更新会造成它旗下所有的子组件重新执行render()方法，形成新的虚拟DOM，再用diff算法对新旧虚拟DOM进行结构和属性的比较，决定组件是否需要重新渲染\n\n> 无疑这样的操作会造成很多的性能浪费，所以我们开发者可以根据项目的业务逻辑，在`shouldComponentUpdate()`中加入条件判断，从而优化性能\n\n> 例如React中的就提供了一个`PureComponent`的类，当我们的组件继承于它时，组件更新时就会默认先比较新旧属性和状态，从而决定组件是否更新。值得注意的是，`PureComponent`进行的是浅比较，所以组件状态或属性改变时，都需要返回一个新的对象或数组\n\n##### 3、componentWillUpdate()\n\n> 组件即将被更新时触发\n\n##### 4、componentDidUpdate()\n\n> 组件被更新完成后触发。页面中产生了新的DOM的元素，可以进行DOM操作\n\n#### 三、销毁阶段\n\n##### 1、componentWillUnmount()\n\n> 组件被销毁时触发。这里我们可以进行一些清理操作，例如清理定时器，取消Redux的订阅事件等等。\n\n### 有兴趣的同学也可以用下面的代码进行测试\n\n#### 废话少说，放码过来!\n\n    import React from 'react'\n    import ReactDOM from 'react-dom';\n    \n    class SubCounter extends React.Component {\n        componentWillReceiveProps() {\n            console.log('9、子组件将要接收到新属性');\n        }\n    \n        shouldComponentUpdate(newProps, newState) {\n            console.log('10、子组件是否需要更新');\n            if (newProps.number < 5) return true;\n            return false\n        }\n    \n        componentWillUpdate() {\n            console.log('11、子组件将要更新');\n        }\n    \n        componentDidUpdate() {\n            console.log('13、子组件更新完成');\n        }\n    \n        componentWillUnmount() {\n            console.log('14、子组件将卸载');\n        }\n    \n        render() {\n            console.log('12、子组件挂载中');\n            return (\n                    <p>{this.props.number}</p>\n            )\n        }\n    }\n    \n    class Counter extends React.Component {\n        static defaultProps = {\n            //1、加载默认属性\n            name: 'sls',\n            age:23\n        };\n    \n        constructor() {\n            super();\n            //2、加载默认状态\n            this.state = {number: 0}\n        }\n    \n        componentWillMount() {\n            console.log('3、父组件挂载之前');\n        }\n    \n        componentDidMount() {\n            console.log('5、父组件挂载完成');\n        }\n    \n        shouldComponentUpdate(newProps, newState) {\n            console.log('6、父组件是否需要更新');\n            if (newState.number<15) return true;\n            return false\n        }\n    \n        componentWillUpdate() {\n            console.log('7、父组件将要更新');\n        }\n    \n        componentDidUpdate() {\n            console.log('8、父组件更新完成');\n        }\n    \n        handleClick = () => {\n            this.setState({\n                number: this.state.number + 1\n            })\n        };\n    \n        render() {\n            console.log('4、render(父组件挂载)');\n            return (\n                <div>\n                    <p>{this.state.number}</p>\n                    <button onClick={this.handleClick}>+</button>\n                    {this.state.number<10?<SubCounter number={this.state.number}/>:null}\n                </div>\n            )\n        }\n    }\n    ReactDOM.render(<Counter/>, document.getElementById('root'));\n","slug":"react生命周期","published":1,"updated":"2019-04-10T02:31:49.139Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzkib000djgf2jm3ezrfa","content":"<blockquote>\n<p>生命周期函数：在某一个时刻组件会自动调用执行的函数</p>\n</blockquote>\n<h3 id=\"React-生命周期\"><a href=\"#React-生命周期\" class=\"headerlink\" title=\"React 生命周期\"></a>React 生命周期</h3><p><img src=\"https://user-gold-cdn.xitu.io/2017/11/11/88e11709488aeea3f9c6595ee4083bf3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\"></p>\n<blockquote>\n<p>如图，React生命周期主要包括三个阶段：初始化阶段、运行中阶段和销毁阶段，在React不同的生命周期里，会依次触发不同的钩子函数，下面我们就来详细介绍一下React的生命周期函数</p>\n</blockquote>\n<h4 id=\"一、初始化阶段\"><a href=\"#一、初始化阶段\" class=\"headerlink\" title=\"一、初始化阶段\"></a>一、初始化阶段</h4><h5 id=\"1、设置组件的默认属性\"><a href=\"#1、设置组件的默认属性\" class=\"headerlink\" title=\"1、设置组件的默认属性\"></a>1、设置组件的默认属性</h5><pre><code>static defaultProps = {\n    name: &apos;sls&apos;,\n    age:23\n};\n//or\nCounter.defaltProps={name:&apos;sls&apos;}\n复制代码\n</code></pre><h5 id=\"2、设置组件的初始化状态\"><a href=\"#2、设置组件的初始化状态\" class=\"headerlink\" title=\"2、设置组件的初始化状态\"></a>2、设置组件的初始化状态</h5><pre><code>constructor() {\n    super();\n    this.state = {number: 0}\n}\n复制代码\n</code></pre><h5 id=\"3、componentWillMount\"><a href=\"#3、componentWillMount\" class=\"headerlink\" title=\"3、componentWillMount()\"></a>3、componentWillMount()</h5><blockquote>\n<p>组件即将被渲染到页面之前触发，此时可以进行开启定时器、向服务器发送请求等操作</p>\n</blockquote>\n<h5 id=\"4、render\"><a href=\"#4、render\" class=\"headerlink\" title=\"4、render()\"></a>4、render()</h5><blockquote>\n<p>组件渲染</p>\n</blockquote>\n<h5 id=\"5、componentDidMount\"><a href=\"#5、componentDidMount\" class=\"headerlink\" title=\"5、componentDidMount()\"></a>5、componentDidMount()</h5><blockquote>\n<p>组件已经被渲染到页面中后触发：此时页面中有了真正的DOM的元素，可以进行DOM相关的操作</p>\n</blockquote>\n<h4 id=\"二、运行中阶段\"><a href=\"#二、运行中阶段\" class=\"headerlink\" title=\"二、运行中阶段\"></a>二、运行中阶段</h4><h5 id=\"1、componentWillReceiveProps\"><a href=\"#1、componentWillReceiveProps\" class=\"headerlink\" title=\"1、componentWillReceiveProps()\"></a>1、componentWillReceiveProps()</h5><blockquote>\n<p>组件接收到属性时触发</p>\n</blockquote>\n<h5 id=\"2、shouldComponentUpdate\"><a href=\"#2、shouldComponentUpdate\" class=\"headerlink\" title=\"2、shouldComponentUpdate()\"></a>2、shouldComponentUpdate()</h5><blockquote>\n<p>当组件接收到新属性，或者组件的状态发生改变时触发。组件首次渲染时并不会触发</p>\n</blockquote>\n<pre><code>shouldComponentUpdate(newProps, newState) {\n    if (newProps.number &lt; 5) return true;\n    return false\n}\n//该钩子函数可以接收到两个参数，新的属性和状态，返回true/false来控制组件是否需要更新。\n复制代码\n</code></pre><blockquote>\n<p>一般我们通过该函数来优化性能：</p>\n</blockquote>\n<blockquote>\n<p>一个React项目需要更新一个小组件时，很可能需要父组件更新自己的状态。而一个父组件的重新更新会造成它旗下所有的子组件重新执行render()方法，形成新的虚拟DOM，再用diff算法对新旧虚拟DOM进行结构和属性的比较，决定组件是否需要重新渲染</p>\n</blockquote>\n<blockquote>\n<p>无疑这样的操作会造成很多的性能浪费，所以我们开发者可以根据项目的业务逻辑，在<code>shouldComponentUpdate()</code>中加入条件判断，从而优化性能</p>\n</blockquote>\n<blockquote>\n<p>例如React中的就提供了一个<code>PureComponent</code>的类，当我们的组件继承于它时，组件更新时就会默认先比较新旧属性和状态，从而决定组件是否更新。值得注意的是，<code>PureComponent</code>进行的是浅比较，所以组件状态或属性改变时，都需要返回一个新的对象或数组</p>\n</blockquote>\n<h5 id=\"3、componentWillUpdate\"><a href=\"#3、componentWillUpdate\" class=\"headerlink\" title=\"3、componentWillUpdate()\"></a>3、componentWillUpdate()</h5><blockquote>\n<p>组件即将被更新时触发</p>\n</blockquote>\n<h5 id=\"4、componentDidUpdate\"><a href=\"#4、componentDidUpdate\" class=\"headerlink\" title=\"4、componentDidUpdate()\"></a>4、componentDidUpdate()</h5><blockquote>\n<p>组件被更新完成后触发。页面中产生了新的DOM的元素，可以进行DOM操作</p>\n</blockquote>\n<h4 id=\"三、销毁阶段\"><a href=\"#三、销毁阶段\" class=\"headerlink\" title=\"三、销毁阶段\"></a>三、销毁阶段</h4><h5 id=\"1、componentWillUnmount\"><a href=\"#1、componentWillUnmount\" class=\"headerlink\" title=\"1、componentWillUnmount()\"></a>1、componentWillUnmount()</h5><blockquote>\n<p>组件被销毁时触发。这里我们可以进行一些清理操作，例如清理定时器，取消Redux的订阅事件等等。</p>\n</blockquote>\n<h3 id=\"有兴趣的同学也可以用下面的代码进行测试\"><a href=\"#有兴趣的同学也可以用下面的代码进行测试\" class=\"headerlink\" title=\"有兴趣的同学也可以用下面的代码进行测试\"></a>有兴趣的同学也可以用下面的代码进行测试</h3><h4 id=\"废话少说，放码过来\"><a href=\"#废话少说，放码过来\" class=\"headerlink\" title=\"废话少说，放码过来!\"></a>废话少说，放码过来!</h4><pre><code>import React from &apos;react&apos;\nimport ReactDOM from &apos;react-dom&apos;;\n\nclass SubCounter extends React.Component {\n    componentWillReceiveProps() {\n        console.log(&apos;9、子组件将要接收到新属性&apos;);\n    }\n\n    shouldComponentUpdate(newProps, newState) {\n        console.log(&apos;10、子组件是否需要更新&apos;);\n        if (newProps.number &lt; 5) return true;\n        return false\n    }\n\n    componentWillUpdate() {\n        console.log(&apos;11、子组件将要更新&apos;);\n    }\n\n    componentDidUpdate() {\n        console.log(&apos;13、子组件更新完成&apos;);\n    }\n\n    componentWillUnmount() {\n        console.log(&apos;14、子组件将卸载&apos;);\n    }\n\n    render() {\n        console.log(&apos;12、子组件挂载中&apos;);\n        return (\n                &lt;p&gt;{this.props.number}&lt;/p&gt;\n        )\n    }\n}\n\nclass Counter extends React.Component {\n    static defaultProps = {\n        //1、加载默认属性\n        name: &apos;sls&apos;,\n        age:23\n    };\n\n    constructor() {\n        super();\n        //2、加载默认状态\n        this.state = {number: 0}\n    }\n\n    componentWillMount() {\n        console.log(&apos;3、父组件挂载之前&apos;);\n    }\n\n    componentDidMount() {\n        console.log(&apos;5、父组件挂载完成&apos;);\n    }\n\n    shouldComponentUpdate(newProps, newState) {\n        console.log(&apos;6、父组件是否需要更新&apos;);\n        if (newState.number&lt;15) return true;\n        return false\n    }\n\n    componentWillUpdate() {\n        console.log(&apos;7、父组件将要更新&apos;);\n    }\n\n    componentDidUpdate() {\n        console.log(&apos;8、父组件更新完成&apos;);\n    }\n\n    handleClick = () =&gt; {\n        this.setState({\n            number: this.state.number + 1\n        })\n    };\n\n    render() {\n        console.log(&apos;4、render(父组件挂载)&apos;);\n        return (\n            &lt;div&gt;\n                &lt;p&gt;{this.state.number}&lt;/p&gt;\n                &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt;\n                {this.state.number&lt;10?&lt;SubCounter number={this.state.number}/&gt;:null}\n            &lt;/div&gt;\n        )\n    }\n}\nReactDOM.render(&lt;Counter/&gt;, document.getElementById(&apos;root&apos;));\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>生命周期函数：在某一个时刻组件会自动调用执行的函数</p>\n</blockquote>\n<h3 id=\"React-生命周期\"><a href=\"#React-生命周期\" class=\"headerlink\" title=\"React 生命周期\"></a>React 生命周期</h3><p><img src=\"https://user-gold-cdn.xitu.io/2017/11/11/88e11709488aeea3f9c6595ee4083bf3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\"></p>\n<blockquote>\n<p>如图，React生命周期主要包括三个阶段：初始化阶段、运行中阶段和销毁阶段，在React不同的生命周期里，会依次触发不同的钩子函数，下面我们就来详细介绍一下React的生命周期函数</p>\n</blockquote>\n<h4 id=\"一、初始化阶段\"><a href=\"#一、初始化阶段\" class=\"headerlink\" title=\"一、初始化阶段\"></a>一、初始化阶段</h4><h5 id=\"1、设置组件的默认属性\"><a href=\"#1、设置组件的默认属性\" class=\"headerlink\" title=\"1、设置组件的默认属性\"></a>1、设置组件的默认属性</h5><pre><code>static defaultProps = {\n    name: &apos;sls&apos;,\n    age:23\n};\n//or\nCounter.defaltProps={name:&apos;sls&apos;}\n复制代码\n</code></pre><h5 id=\"2、设置组件的初始化状态\"><a href=\"#2、设置组件的初始化状态\" class=\"headerlink\" title=\"2、设置组件的初始化状态\"></a>2、设置组件的初始化状态</h5><pre><code>constructor() {\n    super();\n    this.state = {number: 0}\n}\n复制代码\n</code></pre><h5 id=\"3、componentWillMount\"><a href=\"#3、componentWillMount\" class=\"headerlink\" title=\"3、componentWillMount()\"></a>3、componentWillMount()</h5><blockquote>\n<p>组件即将被渲染到页面之前触发，此时可以进行开启定时器、向服务器发送请求等操作</p>\n</blockquote>\n<h5 id=\"4、render\"><a href=\"#4、render\" class=\"headerlink\" title=\"4、render()\"></a>4、render()</h5><blockquote>\n<p>组件渲染</p>\n</blockquote>\n<h5 id=\"5、componentDidMount\"><a href=\"#5、componentDidMount\" class=\"headerlink\" title=\"5、componentDidMount()\"></a>5、componentDidMount()</h5><blockquote>\n<p>组件已经被渲染到页面中后触发：此时页面中有了真正的DOM的元素，可以进行DOM相关的操作</p>\n</blockquote>\n<h4 id=\"二、运行中阶段\"><a href=\"#二、运行中阶段\" class=\"headerlink\" title=\"二、运行中阶段\"></a>二、运行中阶段</h4><h5 id=\"1、componentWillReceiveProps\"><a href=\"#1、componentWillReceiveProps\" class=\"headerlink\" title=\"1、componentWillReceiveProps()\"></a>1、componentWillReceiveProps()</h5><blockquote>\n<p>组件接收到属性时触发</p>\n</blockquote>\n<h5 id=\"2、shouldComponentUpdate\"><a href=\"#2、shouldComponentUpdate\" class=\"headerlink\" title=\"2、shouldComponentUpdate()\"></a>2、shouldComponentUpdate()</h5><blockquote>\n<p>当组件接收到新属性，或者组件的状态发生改变时触发。组件首次渲染时并不会触发</p>\n</blockquote>\n<pre><code>shouldComponentUpdate(newProps, newState) {\n    if (newProps.number &lt; 5) return true;\n    return false\n}\n//该钩子函数可以接收到两个参数，新的属性和状态，返回true/false来控制组件是否需要更新。\n复制代码\n</code></pre><blockquote>\n<p>一般我们通过该函数来优化性能：</p>\n</blockquote>\n<blockquote>\n<p>一个React项目需要更新一个小组件时，很可能需要父组件更新自己的状态。而一个父组件的重新更新会造成它旗下所有的子组件重新执行render()方法，形成新的虚拟DOM，再用diff算法对新旧虚拟DOM进行结构和属性的比较，决定组件是否需要重新渲染</p>\n</blockquote>\n<blockquote>\n<p>无疑这样的操作会造成很多的性能浪费，所以我们开发者可以根据项目的业务逻辑，在<code>shouldComponentUpdate()</code>中加入条件判断，从而优化性能</p>\n</blockquote>\n<blockquote>\n<p>例如React中的就提供了一个<code>PureComponent</code>的类，当我们的组件继承于它时，组件更新时就会默认先比较新旧属性和状态，从而决定组件是否更新。值得注意的是，<code>PureComponent</code>进行的是浅比较，所以组件状态或属性改变时，都需要返回一个新的对象或数组</p>\n</blockquote>\n<h5 id=\"3、componentWillUpdate\"><a href=\"#3、componentWillUpdate\" class=\"headerlink\" title=\"3、componentWillUpdate()\"></a>3、componentWillUpdate()</h5><blockquote>\n<p>组件即将被更新时触发</p>\n</blockquote>\n<h5 id=\"4、componentDidUpdate\"><a href=\"#4、componentDidUpdate\" class=\"headerlink\" title=\"4、componentDidUpdate()\"></a>4、componentDidUpdate()</h5><blockquote>\n<p>组件被更新完成后触发。页面中产生了新的DOM的元素，可以进行DOM操作</p>\n</blockquote>\n<h4 id=\"三、销毁阶段\"><a href=\"#三、销毁阶段\" class=\"headerlink\" title=\"三、销毁阶段\"></a>三、销毁阶段</h4><h5 id=\"1、componentWillUnmount\"><a href=\"#1、componentWillUnmount\" class=\"headerlink\" title=\"1、componentWillUnmount()\"></a>1、componentWillUnmount()</h5><blockquote>\n<p>组件被销毁时触发。这里我们可以进行一些清理操作，例如清理定时器，取消Redux的订阅事件等等。</p>\n</blockquote>\n<h3 id=\"有兴趣的同学也可以用下面的代码进行测试\"><a href=\"#有兴趣的同学也可以用下面的代码进行测试\" class=\"headerlink\" title=\"有兴趣的同学也可以用下面的代码进行测试\"></a>有兴趣的同学也可以用下面的代码进行测试</h3><h4 id=\"废话少说，放码过来\"><a href=\"#废话少说，放码过来\" class=\"headerlink\" title=\"废话少说，放码过来!\"></a>废话少说，放码过来!</h4><pre><code>import React from &apos;react&apos;\nimport ReactDOM from &apos;react-dom&apos;;\n\nclass SubCounter extends React.Component {\n    componentWillReceiveProps() {\n        console.log(&apos;9、子组件将要接收到新属性&apos;);\n    }\n\n    shouldComponentUpdate(newProps, newState) {\n        console.log(&apos;10、子组件是否需要更新&apos;);\n        if (newProps.number &lt; 5) return true;\n        return false\n    }\n\n    componentWillUpdate() {\n        console.log(&apos;11、子组件将要更新&apos;);\n    }\n\n    componentDidUpdate() {\n        console.log(&apos;13、子组件更新完成&apos;);\n    }\n\n    componentWillUnmount() {\n        console.log(&apos;14、子组件将卸载&apos;);\n    }\n\n    render() {\n        console.log(&apos;12、子组件挂载中&apos;);\n        return (\n                &lt;p&gt;{this.props.number}&lt;/p&gt;\n        )\n    }\n}\n\nclass Counter extends React.Component {\n    static defaultProps = {\n        //1、加载默认属性\n        name: &apos;sls&apos;,\n        age:23\n    };\n\n    constructor() {\n        super();\n        //2、加载默认状态\n        this.state = {number: 0}\n    }\n\n    componentWillMount() {\n        console.log(&apos;3、父组件挂载之前&apos;);\n    }\n\n    componentDidMount() {\n        console.log(&apos;5、父组件挂载完成&apos;);\n    }\n\n    shouldComponentUpdate(newProps, newState) {\n        console.log(&apos;6、父组件是否需要更新&apos;);\n        if (newState.number&lt;15) return true;\n        return false\n    }\n\n    componentWillUpdate() {\n        console.log(&apos;7、父组件将要更新&apos;);\n    }\n\n    componentDidUpdate() {\n        console.log(&apos;8、父组件更新完成&apos;);\n    }\n\n    handleClick = () =&gt; {\n        this.setState({\n            number: this.state.number + 1\n        })\n    };\n\n    render() {\n        console.log(&apos;4、render(父组件挂载)&apos;);\n        return (\n            &lt;div&gt;\n                &lt;p&gt;{this.state.number}&lt;/p&gt;\n                &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt;\n                {this.state.number&lt;10?&lt;SubCounter number={this.state.number}/&gt;:null}\n            &lt;/div&gt;\n        )\n    }\n}\nReactDOM.render(&lt;Counter/&gt;, document.getElementById(&apos;root&apos;));\n</code></pre>"},{"layout":"vue中AsyncAwait的使用示例","title":"vue中AsyncAwait的使用示例","date":"2018-12-25T05:47:23.000Z","_content":"> 想要await按照预期来执行，就必须是promise\n\n```\n  methods: {\n    getAll() {\n      return new Promise((resolve, reject) => {\n        this.$axios.get(eventApi.getAllUsers).then(response => {\n          let a = response.data[0];\n          console.log(a);\n          resolve(a);\n        });\n      });\n    },\n    getlog() {\n      return new Promise((resolve, reject) => {\n        console.log(\"111\");\n        resolve(\"111\");\n      });\n    },\n    getLog2() {\n      console.log(\"222\");\n    },\n    getlog3() {\n      setTimeout(() => {\n        console.log(\"333\");\n      }, 100);\n    },\n    getlog4() {\n      return new Promise((resolve, reject) => {\n        setTimeout(() => {\n          console.log(\"444\");\n          resolve();\n        }, 1000);\n      });\n    },\n    async getAllData() {\n      await this.getlog();\n      await this.getlog4();\n      await this.getAll();\n      await this.getlog3();\n      await this.getLog2();\n    }\n```\n结果如下\n\n![](https://user-gold-cdn.xitu.io/2018/12/21/167cf21020672ee8?w=673&h=172&f=png&s=71967)\n","source":"_posts/vue中AsyncAwait的使用示例.md","raw":"---\nlayout: vue中AsyncAwait的使用示例\ntitle: vue中AsyncAwait的使用示例\ndate: 2018-12-25 13:47:23\ntags:\n---\n> 想要await按照预期来执行，就必须是promise\n\n```\n  methods: {\n    getAll() {\n      return new Promise((resolve, reject) => {\n        this.$axios.get(eventApi.getAllUsers).then(response => {\n          let a = response.data[0];\n          console.log(a);\n          resolve(a);\n        });\n      });\n    },\n    getlog() {\n      return new Promise((resolve, reject) => {\n        console.log(\"111\");\n        resolve(\"111\");\n      });\n    },\n    getLog2() {\n      console.log(\"222\");\n    },\n    getlog3() {\n      setTimeout(() => {\n        console.log(\"333\");\n      }, 100);\n    },\n    getlog4() {\n      return new Promise((resolve, reject) => {\n        setTimeout(() => {\n          console.log(\"444\");\n          resolve();\n        }, 1000);\n      });\n    },\n    async getAllData() {\n      await this.getlog();\n      await this.getlog4();\n      await this.getAll();\n      await this.getlog3();\n      await this.getLog2();\n    }\n```\n结果如下\n\n![](https://user-gold-cdn.xitu.io/2018/12/21/167cf21020672ee8?w=673&h=172&f=png&s=71967)\n","slug":"vue中AsyncAwait的使用示例","published":1,"updated":"2019-04-10T02:31:49.144Z","comments":1,"photos":[],"link":"","_id":"cjuanzkic000ejgf21ymokpu2","content":"<blockquote>\n<p>想要await按照预期来执行，就必须是promise</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  getAll() &#123;</span><br><span class=\"line\">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">      this.$axios.get(eventApi.getAllUsers).then(response =&gt; &#123;</span><br><span class=\"line\">        let a = response.data[0];</span><br><span class=\"line\">        console.log(a);</span><br><span class=\"line\">        resolve(a);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getlog() &#123;</span><br><span class=\"line\">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">      console.log(&quot;111&quot;);</span><br><span class=\"line\">      resolve(&quot;111&quot;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getLog2() &#123;</span><br><span class=\"line\">    console.log(&quot;222&quot;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getlog3() &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      console.log(&quot;333&quot;);</span><br><span class=\"line\">    &#125;, 100);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getlog4() &#123;</span><br><span class=\"line\">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">      setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        console.log(&quot;444&quot;);</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">      &#125;, 1000);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  async getAllData() &#123;</span><br><span class=\"line\">    await this.getlog();</span><br><span class=\"line\">    await this.getlog4();</span><br><span class=\"line\">    await this.getAll();</span><br><span class=\"line\">    await this.getlog3();</span><br><span class=\"line\">    await this.getLog2();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>结果如下</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf21020672ee8?w=673&amp;h=172&amp;f=png&amp;s=71967\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>想要await按照预期来执行，就必须是promise</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  getAll() &#123;</span><br><span class=\"line\">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">      this.$axios.get(eventApi.getAllUsers).then(response =&gt; &#123;</span><br><span class=\"line\">        let a = response.data[0];</span><br><span class=\"line\">        console.log(a);</span><br><span class=\"line\">        resolve(a);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getlog() &#123;</span><br><span class=\"line\">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">      console.log(&quot;111&quot;);</span><br><span class=\"line\">      resolve(&quot;111&quot;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getLog2() &#123;</span><br><span class=\"line\">    console.log(&quot;222&quot;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getlog3() &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      console.log(&quot;333&quot;);</span><br><span class=\"line\">    &#125;, 100);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getlog4() &#123;</span><br><span class=\"line\">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">      setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        console.log(&quot;444&quot;);</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">      &#125;, 1000);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  async getAllData() &#123;</span><br><span class=\"line\">    await this.getlog();</span><br><span class=\"line\">    await this.getlog4();</span><br><span class=\"line\">    await this.getAll();</span><br><span class=\"line\">    await this.getlog3();</span><br><span class=\"line\">    await this.getLog2();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>结果如下</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf21020672ee8?w=673&amp;h=172&amp;f=png&amp;s=71967\" alt=\"\"></p>\n"},{"title":"webpack下build报错","date":"2019-02-09T08:01:23.000Z","_content":"执行npm run build时报错如下：\n```\nD:\\MyProjects\\react_ssr_demo>npm run build\n\n> react_ssr_demo@1.0.0 build D:\\MyProjects\\react_ssr_demo\n> webpack --config build/webpack.config.js\n\nHash: 0b1003a436390263970e\nVersion: webpack 4.29.3\nTime: 633ms\nBuilt at: 2019-02-09 15:46:04\n 1 asset\nEntrypoint app = app.0b1003a436390263970e.js\n[2] ./client/App.jsx 3 KiB {0} [not cacheable] [built] [failed] [1 error]\n[3] ./client/app.js 100 bytes {0} [built]\n[9] (webpack)/buildin/global.js 472 bytes {0} [built]\n    + 7 hidden modules\n\nWARNING in configuration\nThe 'mode' option has not been set, webpack will fallback to 'production' for th\nis value. Set 'mode' option to 'development' or 'production' to enable defaults\nfor each environment.\nYou can also set it to 'none' to disable any default behavior. Learn more: https\n://webpack.js.org/concepts/mode/\n\nERROR in ./client/App.jsx\nModule build failed (from ./node_modules/_babel-loader@8.0.5@babel-loader/lib/in\ndex.js):\nError: Cannot find module '@babel/core'\n babel-loader@8 requires Babel 7.x (the package '@babel/core'). If you'd like to\n use Babel 6.x ('babel-core'), you should install 'babel-loader@7'.\n    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:581:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:507:25)\n    at Module.require (internal/modules/cjs/loader.js:637:17)\n    at require (D:\\MyProjects\\react_ssr_demo\\node_modules\\_v8-compile-cache@2.0.\n2@v8-compile-cache\\v8-compile-cache.js:159:20)\n    at Object.<anonymous> (D:\\MyProjects\\react_ssr_demo\\node_modules\\_babel-load\ner@8.0.5@babel-loader\\lib\\index.js:10:11)\n    at Module._compile (D:\\MyProjects\\react_ssr_demo\\node_modules\\_v8-compile-ca\nche@2.0.2@v8-compile-cache\\v8-compile-cache.js:178:30)\n    at Object.Module._extensions..js (internal/modules/cjs/loader.js:700:10)\n    at Module.load (internal/modules/cjs/loader.js:599:32)\n    at tryModuleLoad (internal/modules/cjs/loader.js:538:12)\n    at Function.Module._load (internal/modules/cjs/loader.js:530:3)\n    at Module.require (internal/modules/cjs/loader.js:637:17)\n    at require (D:\\MyProjects\\react_ssr_demo\\node_modules\\_v8-compile-cache@2.0.\n2@v8-compile-cache\\v8-compile-cache.js:159:20)\n    at loadLoader (D:\\MyProjects\\react_ssr_demo\\node_modules\\_loader-runner@2.4.\n0@loader-runner\\lib\\loadLoader.js:18:17)\n    at iteratePitchingLoaders (D:\\MyProjects\\react_ssr_demo\\node_modules\\_loader\n-runner@2.4.0@loader-runner\\lib\\LoaderRunner.js:169:2)\n    at runLoaders (D:\\MyProjects\\react_ssr_demo\\node_modules\\_loader-runner@2.4.\n0@loader-runner\\lib\\LoaderRunner.js:365:2)\n    at NormalModule.doBuild (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@\n4.29.3@webpack\\lib\\NormalModule.js:280:3)\n    at NormalModule.build (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@4.\n29.3@webpack\\lib\\NormalModule.js:427:15)\n    at Compilation.buildModule (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpa\nck@4.29.3@webpack\\lib\\Compilation.js:635:10)\n    at factory.create (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@4.29.3\n@webpack\\lib\\Compilation.js:884:14)\n    at factory (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@4.29.3@webpac\nk\\lib\\NormalModuleFactory.js:405:6)\n    at hooks.afterResolve.callAsync (D:\\MyProjects\\react_ssr_demo\\node_modules\\_\nwebpack@4.29.3@webpack\\lib\\NormalModuleFactory.js:155:13)\n    at AsyncSeriesWaterfallHook.eval [as callAsync] (eval at create (D:\\MyProjec\nts\\react_ssr_demo\\node_modules\\_tapable@1.1.1@tapable\\lib\\HookCodeFactory.js:32:\n10), <anonymous>:6:1)\n    at resolver (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@4.29.3@webpa\nck\\lib\\NormalModuleFactory.js:138:29)\n    at process.nextTick (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@4.29\n.3@webpack\\lib\\NormalModuleFactory.js:342:9)\n    at process._tickCallback (internal/process/next_tick.js:61:11)\n @ ./client/app.js 2:0-27 4:16-19\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 2\nnpm ERR! react_ssr_demo@1.0.0 build: `webpack --config build/webpack.config.js`\nnpm ERR! Exit status 2\nnpm ERR!\nnpm ERR! Failed at the react_ssr_demo@1.0.0 build script.\nnpm ERR! This is probably not a problem with npm. There is likely additional log\nging output above.\n\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     C:\\Users\\Administrator.PC-201812050004\\AppData\\Roaming\\npm-cache\\_l\nogs\\2019-02-09T07_46_04_537Z-debug.log\n```\n\n这里面有两个问题\n1. WARNING in configuration\n> 解决方法：在webpack.config.js下增加mode: 'none'\nmodule.exports = {\n    mode: 'none',\n\n\n2. Error: Cannot find module '@babel/core'\n babel-loader@8 requires Babel 7.x (the package '@babel/core'). If you'd like to\n use Babel 6.x ('babel-core'), you should install 'babel-loader@7'.\n> 解决方法：npm i babel-loader@7 -D\n","source":"_posts/webpack下build报错.md","raw":"---\ntitle: webpack下build报错\ndate: 2019-02-09 16:01:23\ntags:\n---\n执行npm run build时报错如下：\n```\nD:\\MyProjects\\react_ssr_demo>npm run build\n\n> react_ssr_demo@1.0.0 build D:\\MyProjects\\react_ssr_demo\n> webpack --config build/webpack.config.js\n\nHash: 0b1003a436390263970e\nVersion: webpack 4.29.3\nTime: 633ms\nBuilt at: 2019-02-09 15:46:04\n 1 asset\nEntrypoint app = app.0b1003a436390263970e.js\n[2] ./client/App.jsx 3 KiB {0} [not cacheable] [built] [failed] [1 error]\n[3] ./client/app.js 100 bytes {0} [built]\n[9] (webpack)/buildin/global.js 472 bytes {0} [built]\n    + 7 hidden modules\n\nWARNING in configuration\nThe 'mode' option has not been set, webpack will fallback to 'production' for th\nis value. Set 'mode' option to 'development' or 'production' to enable defaults\nfor each environment.\nYou can also set it to 'none' to disable any default behavior. Learn more: https\n://webpack.js.org/concepts/mode/\n\nERROR in ./client/App.jsx\nModule build failed (from ./node_modules/_babel-loader@8.0.5@babel-loader/lib/in\ndex.js):\nError: Cannot find module '@babel/core'\n babel-loader@8 requires Babel 7.x (the package '@babel/core'). If you'd like to\n use Babel 6.x ('babel-core'), you should install 'babel-loader@7'.\n    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:581:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:507:25)\n    at Module.require (internal/modules/cjs/loader.js:637:17)\n    at require (D:\\MyProjects\\react_ssr_demo\\node_modules\\_v8-compile-cache@2.0.\n2@v8-compile-cache\\v8-compile-cache.js:159:20)\n    at Object.<anonymous> (D:\\MyProjects\\react_ssr_demo\\node_modules\\_babel-load\ner@8.0.5@babel-loader\\lib\\index.js:10:11)\n    at Module._compile (D:\\MyProjects\\react_ssr_demo\\node_modules\\_v8-compile-ca\nche@2.0.2@v8-compile-cache\\v8-compile-cache.js:178:30)\n    at Object.Module._extensions..js (internal/modules/cjs/loader.js:700:10)\n    at Module.load (internal/modules/cjs/loader.js:599:32)\n    at tryModuleLoad (internal/modules/cjs/loader.js:538:12)\n    at Function.Module._load (internal/modules/cjs/loader.js:530:3)\n    at Module.require (internal/modules/cjs/loader.js:637:17)\n    at require (D:\\MyProjects\\react_ssr_demo\\node_modules\\_v8-compile-cache@2.0.\n2@v8-compile-cache\\v8-compile-cache.js:159:20)\n    at loadLoader (D:\\MyProjects\\react_ssr_demo\\node_modules\\_loader-runner@2.4.\n0@loader-runner\\lib\\loadLoader.js:18:17)\n    at iteratePitchingLoaders (D:\\MyProjects\\react_ssr_demo\\node_modules\\_loader\n-runner@2.4.0@loader-runner\\lib\\LoaderRunner.js:169:2)\n    at runLoaders (D:\\MyProjects\\react_ssr_demo\\node_modules\\_loader-runner@2.4.\n0@loader-runner\\lib\\LoaderRunner.js:365:2)\n    at NormalModule.doBuild (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@\n4.29.3@webpack\\lib\\NormalModule.js:280:3)\n    at NormalModule.build (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@4.\n29.3@webpack\\lib\\NormalModule.js:427:15)\n    at Compilation.buildModule (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpa\nck@4.29.3@webpack\\lib\\Compilation.js:635:10)\n    at factory.create (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@4.29.3\n@webpack\\lib\\Compilation.js:884:14)\n    at factory (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@4.29.3@webpac\nk\\lib\\NormalModuleFactory.js:405:6)\n    at hooks.afterResolve.callAsync (D:\\MyProjects\\react_ssr_demo\\node_modules\\_\nwebpack@4.29.3@webpack\\lib\\NormalModuleFactory.js:155:13)\n    at AsyncSeriesWaterfallHook.eval [as callAsync] (eval at create (D:\\MyProjec\nts\\react_ssr_demo\\node_modules\\_tapable@1.1.1@tapable\\lib\\HookCodeFactory.js:32:\n10), <anonymous>:6:1)\n    at resolver (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@4.29.3@webpa\nck\\lib\\NormalModuleFactory.js:138:29)\n    at process.nextTick (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@4.29\n.3@webpack\\lib\\NormalModuleFactory.js:342:9)\n    at process._tickCallback (internal/process/next_tick.js:61:11)\n @ ./client/app.js 2:0-27 4:16-19\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 2\nnpm ERR! react_ssr_demo@1.0.0 build: `webpack --config build/webpack.config.js`\nnpm ERR! Exit status 2\nnpm ERR!\nnpm ERR! Failed at the react_ssr_demo@1.0.0 build script.\nnpm ERR! This is probably not a problem with npm. There is likely additional log\nging output above.\n\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     C:\\Users\\Administrator.PC-201812050004\\AppData\\Roaming\\npm-cache\\_l\nogs\\2019-02-09T07_46_04_537Z-debug.log\n```\n\n这里面有两个问题\n1. WARNING in configuration\n> 解决方法：在webpack.config.js下增加mode: 'none'\nmodule.exports = {\n    mode: 'none',\n\n\n2. Error: Cannot find module '@babel/core'\n babel-loader@8 requires Babel 7.x (the package '@babel/core'). If you'd like to\n use Babel 6.x ('babel-core'), you should install 'babel-loader@7'.\n> 解决方法：npm i babel-loader@7 -D\n","slug":"webpack下build报错","published":1,"updated":"2019-04-10T02:31:49.148Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzkid000fjgf2cf5fbxod","content":"<p>执行npm run build时报错如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\MyProjects\\react_ssr_demo&gt;npm run build</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; react_ssr_demo@1.0.0 build D:\\MyProjects\\react_ssr_demo</span><br><span class=\"line\">&gt; webpack --config build/webpack.config.js</span><br><span class=\"line\"></span><br><span class=\"line\">Hash: 0b1003a436390263970e</span><br><span class=\"line\">Version: webpack 4.29.3</span><br><span class=\"line\">Time: 633ms</span><br><span class=\"line\">Built at: 2019-02-09 15:46:04</span><br><span class=\"line\"> 1 asset</span><br><span class=\"line\">Entrypoint app = app.0b1003a436390263970e.js</span><br><span class=\"line\">[2] ./client/App.jsx 3 KiB &#123;0&#125; [not cacheable] [built] [failed] [1 error]</span><br><span class=\"line\">[3] ./client/app.js 100 bytes &#123;0&#125; [built]</span><br><span class=\"line\">[9] (webpack)/buildin/global.js 472 bytes &#123;0&#125; [built]</span><br><span class=\"line\">    + 7 hidden modules</span><br><span class=\"line\"></span><br><span class=\"line\">WARNING in configuration</span><br><span class=\"line\">The &apos;mode&apos; option has not been set, webpack will fallback to &apos;production&apos; for th</span><br><span class=\"line\">is value. Set &apos;mode&apos; option to &apos;development&apos; or &apos;production&apos; to enable defaults</span><br><span class=\"line\">for each environment.</span><br><span class=\"line\">You can also set it to &apos;none&apos; to disable any default behavior. Learn more: https</span><br><span class=\"line\">://webpack.js.org/concepts/mode/</span><br><span class=\"line\"></span><br><span class=\"line\">ERROR in ./client/App.jsx</span><br><span class=\"line\">Module build failed (from ./node_modules/_babel-loader@8.0.5@babel-loader/lib/in</span><br><span class=\"line\">dex.js):</span><br><span class=\"line\">Error: Cannot find module &apos;@babel/core&apos;</span><br><span class=\"line\"> babel-loader@8 requires Babel 7.x (the package &apos;@babel/core&apos;). If you&apos;d like to</span><br><span class=\"line\"> use Babel 6.x (&apos;babel-core&apos;), you should install &apos;babel-loader@7&apos;.</span><br><span class=\"line\">    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:581:15)</span><br><span class=\"line\">    at Function.Module._load (internal/modules/cjs/loader.js:507:25)</span><br><span class=\"line\">    at Module.require (internal/modules/cjs/loader.js:637:17)</span><br><span class=\"line\">    at require (D:\\MyProjects\\react_ssr_demo\\node_modules\\_v8-compile-cache@2.0.</span><br><span class=\"line\">2@v8-compile-cache\\v8-compile-cache.js:159:20)</span><br><span class=\"line\">    at Object.&lt;anonymous&gt; (D:\\MyProjects\\react_ssr_demo\\node_modules\\_babel-load</span><br><span class=\"line\">er@8.0.5@babel-loader\\lib\\index.js:10:11)</span><br><span class=\"line\">    at Module._compile (D:\\MyProjects\\react_ssr_demo\\node_modules\\_v8-compile-ca</span><br><span class=\"line\">che@2.0.2@v8-compile-cache\\v8-compile-cache.js:178:30)</span><br><span class=\"line\">    at Object.Module._extensions..js (internal/modules/cjs/loader.js:700:10)</span><br><span class=\"line\">    at Module.load (internal/modules/cjs/loader.js:599:32)</span><br><span class=\"line\">    at tryModuleLoad (internal/modules/cjs/loader.js:538:12)</span><br><span class=\"line\">    at Function.Module._load (internal/modules/cjs/loader.js:530:3)</span><br><span class=\"line\">    at Module.require (internal/modules/cjs/loader.js:637:17)</span><br><span class=\"line\">    at require (D:\\MyProjects\\react_ssr_demo\\node_modules\\_v8-compile-cache@2.0.</span><br><span class=\"line\">2@v8-compile-cache\\v8-compile-cache.js:159:20)</span><br><span class=\"line\">    at loadLoader (D:\\MyProjects\\react_ssr_demo\\node_modules\\_loader-runner@2.4.</span><br><span class=\"line\">0@loader-runner\\lib\\loadLoader.js:18:17)</span><br><span class=\"line\">    at iteratePitchingLoaders (D:\\MyProjects\\react_ssr_demo\\node_modules\\_loader</span><br><span class=\"line\">-runner@2.4.0@loader-runner\\lib\\LoaderRunner.js:169:2)</span><br><span class=\"line\">    at runLoaders (D:\\MyProjects\\react_ssr_demo\\node_modules\\_loader-runner@2.4.</span><br><span class=\"line\">0@loader-runner\\lib\\LoaderRunner.js:365:2)</span><br><span class=\"line\">    at NormalModule.doBuild (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@</span><br><span class=\"line\">4.29.3@webpack\\lib\\NormalModule.js:280:3)</span><br><span class=\"line\">    at NormalModule.build (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@4.</span><br><span class=\"line\">29.3@webpack\\lib\\NormalModule.js:427:15)</span><br><span class=\"line\">    at Compilation.buildModule (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpa</span><br><span class=\"line\">ck@4.29.3@webpack\\lib\\Compilation.js:635:10)</span><br><span class=\"line\">    at factory.create (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@4.29.3</span><br><span class=\"line\">@webpack\\lib\\Compilation.js:884:14)</span><br><span class=\"line\">    at factory (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@4.29.3@webpac</span><br><span class=\"line\">k\\lib\\NormalModuleFactory.js:405:6)</span><br><span class=\"line\">    at hooks.afterResolve.callAsync (D:\\MyProjects\\react_ssr_demo\\node_modules\\_</span><br><span class=\"line\">webpack@4.29.3@webpack\\lib\\NormalModuleFactory.js:155:13)</span><br><span class=\"line\">    at AsyncSeriesWaterfallHook.eval [as callAsync] (eval at create (D:\\MyProjec</span><br><span class=\"line\">ts\\react_ssr_demo\\node_modules\\_tapable@1.1.1@tapable\\lib\\HookCodeFactory.js:32:</span><br><span class=\"line\">10), &lt;anonymous&gt;:6:1)</span><br><span class=\"line\">    at resolver (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@4.29.3@webpa</span><br><span class=\"line\">ck\\lib\\NormalModuleFactory.js:138:29)</span><br><span class=\"line\">    at process.nextTick (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@4.29</span><br><span class=\"line\">.3@webpack\\lib\\NormalModuleFactory.js:342:9)</span><br><span class=\"line\">    at process._tickCallback (internal/process/next_tick.js:61:11)</span><br><span class=\"line\"> @ ./client/app.js 2:0-27 4:16-19</span><br><span class=\"line\">npm ERR! code ELIFECYCLE</span><br><span class=\"line\">npm ERR! errno 2</span><br><span class=\"line\">npm ERR! react_ssr_demo@1.0.0 build: `webpack --config build/webpack.config.js`</span><br><span class=\"line\">npm ERR! Exit status 2</span><br><span class=\"line\">npm ERR!</span><br><span class=\"line\">npm ERR! Failed at the react_ssr_demo@1.0.0 build script.</span><br><span class=\"line\">npm ERR! This is probably not a problem with npm. There is likely additional log</span><br><span class=\"line\">ging output above.</span><br><span class=\"line\"></span><br><span class=\"line\">npm ERR! A complete log of this run can be found in:</span><br><span class=\"line\">npm ERR!     C:\\Users\\Administrator.PC-201812050004\\AppData\\Roaming\\npm-cache\\_l</span><br><span class=\"line\">ogs\\2019-02-09T07_46_04_537Z-debug.log</span><br></pre></td></tr></table></figure></p>\n<p>这里面有两个问题</p>\n<ol>\n<li>WARNING in configuration<blockquote>\n<p>解决方法：在webpack.config.js下增加mode: ‘none’<br>module.exports = {<br> mode: ‘none’,</p>\n</blockquote>\n</li>\n</ol>\n<ol start=\"2\">\n<li>Error: Cannot find module ‘@babel/core’<br>babel-loader@8 requires Babel 7.x (the package ‘@babel/core’). If you’d like to<br>use Babel 6.x (‘babel-core’), you should install ‘babel-loader@7’.<blockquote>\n<p>解决方法：npm i babel-loader@7 -D</p>\n</blockquote>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>执行npm run build时报错如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\MyProjects\\react_ssr_demo&gt;npm run build</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; react_ssr_demo@1.0.0 build D:\\MyProjects\\react_ssr_demo</span><br><span class=\"line\">&gt; webpack --config build/webpack.config.js</span><br><span class=\"line\"></span><br><span class=\"line\">Hash: 0b1003a436390263970e</span><br><span class=\"line\">Version: webpack 4.29.3</span><br><span class=\"line\">Time: 633ms</span><br><span class=\"line\">Built at: 2019-02-09 15:46:04</span><br><span class=\"line\"> 1 asset</span><br><span class=\"line\">Entrypoint app = app.0b1003a436390263970e.js</span><br><span class=\"line\">[2] ./client/App.jsx 3 KiB &#123;0&#125; [not cacheable] [built] [failed] [1 error]</span><br><span class=\"line\">[3] ./client/app.js 100 bytes &#123;0&#125; [built]</span><br><span class=\"line\">[9] (webpack)/buildin/global.js 472 bytes &#123;0&#125; [built]</span><br><span class=\"line\">    + 7 hidden modules</span><br><span class=\"line\"></span><br><span class=\"line\">WARNING in configuration</span><br><span class=\"line\">The &apos;mode&apos; option has not been set, webpack will fallback to &apos;production&apos; for th</span><br><span class=\"line\">is value. Set &apos;mode&apos; option to &apos;development&apos; or &apos;production&apos; to enable defaults</span><br><span class=\"line\">for each environment.</span><br><span class=\"line\">You can also set it to &apos;none&apos; to disable any default behavior. Learn more: https</span><br><span class=\"line\">://webpack.js.org/concepts/mode/</span><br><span class=\"line\"></span><br><span class=\"line\">ERROR in ./client/App.jsx</span><br><span class=\"line\">Module build failed (from ./node_modules/_babel-loader@8.0.5@babel-loader/lib/in</span><br><span class=\"line\">dex.js):</span><br><span class=\"line\">Error: Cannot find module &apos;@babel/core&apos;</span><br><span class=\"line\"> babel-loader@8 requires Babel 7.x (the package &apos;@babel/core&apos;). If you&apos;d like to</span><br><span class=\"line\"> use Babel 6.x (&apos;babel-core&apos;), you should install &apos;babel-loader@7&apos;.</span><br><span class=\"line\">    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:581:15)</span><br><span class=\"line\">    at Function.Module._load (internal/modules/cjs/loader.js:507:25)</span><br><span class=\"line\">    at Module.require (internal/modules/cjs/loader.js:637:17)</span><br><span class=\"line\">    at require (D:\\MyProjects\\react_ssr_demo\\node_modules\\_v8-compile-cache@2.0.</span><br><span class=\"line\">2@v8-compile-cache\\v8-compile-cache.js:159:20)</span><br><span class=\"line\">    at Object.&lt;anonymous&gt; (D:\\MyProjects\\react_ssr_demo\\node_modules\\_babel-load</span><br><span class=\"line\">er@8.0.5@babel-loader\\lib\\index.js:10:11)</span><br><span class=\"line\">    at Module._compile (D:\\MyProjects\\react_ssr_demo\\node_modules\\_v8-compile-ca</span><br><span class=\"line\">che@2.0.2@v8-compile-cache\\v8-compile-cache.js:178:30)</span><br><span class=\"line\">    at Object.Module._extensions..js (internal/modules/cjs/loader.js:700:10)</span><br><span class=\"line\">    at Module.load (internal/modules/cjs/loader.js:599:32)</span><br><span class=\"line\">    at tryModuleLoad (internal/modules/cjs/loader.js:538:12)</span><br><span class=\"line\">    at Function.Module._load (internal/modules/cjs/loader.js:530:3)</span><br><span class=\"line\">    at Module.require (internal/modules/cjs/loader.js:637:17)</span><br><span class=\"line\">    at require (D:\\MyProjects\\react_ssr_demo\\node_modules\\_v8-compile-cache@2.0.</span><br><span class=\"line\">2@v8-compile-cache\\v8-compile-cache.js:159:20)</span><br><span class=\"line\">    at loadLoader (D:\\MyProjects\\react_ssr_demo\\node_modules\\_loader-runner@2.4.</span><br><span class=\"line\">0@loader-runner\\lib\\loadLoader.js:18:17)</span><br><span class=\"line\">    at iteratePitchingLoaders (D:\\MyProjects\\react_ssr_demo\\node_modules\\_loader</span><br><span class=\"line\">-runner@2.4.0@loader-runner\\lib\\LoaderRunner.js:169:2)</span><br><span class=\"line\">    at runLoaders (D:\\MyProjects\\react_ssr_demo\\node_modules\\_loader-runner@2.4.</span><br><span class=\"line\">0@loader-runner\\lib\\LoaderRunner.js:365:2)</span><br><span class=\"line\">    at NormalModule.doBuild (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@</span><br><span class=\"line\">4.29.3@webpack\\lib\\NormalModule.js:280:3)</span><br><span class=\"line\">    at NormalModule.build (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@4.</span><br><span class=\"line\">29.3@webpack\\lib\\NormalModule.js:427:15)</span><br><span class=\"line\">    at Compilation.buildModule (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpa</span><br><span class=\"line\">ck@4.29.3@webpack\\lib\\Compilation.js:635:10)</span><br><span class=\"line\">    at factory.create (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@4.29.3</span><br><span class=\"line\">@webpack\\lib\\Compilation.js:884:14)</span><br><span class=\"line\">    at factory (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@4.29.3@webpac</span><br><span class=\"line\">k\\lib\\NormalModuleFactory.js:405:6)</span><br><span class=\"line\">    at hooks.afterResolve.callAsync (D:\\MyProjects\\react_ssr_demo\\node_modules\\_</span><br><span class=\"line\">webpack@4.29.3@webpack\\lib\\NormalModuleFactory.js:155:13)</span><br><span class=\"line\">    at AsyncSeriesWaterfallHook.eval [as callAsync] (eval at create (D:\\MyProjec</span><br><span class=\"line\">ts\\react_ssr_demo\\node_modules\\_tapable@1.1.1@tapable\\lib\\HookCodeFactory.js:32:</span><br><span class=\"line\">10), &lt;anonymous&gt;:6:1)</span><br><span class=\"line\">    at resolver (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@4.29.3@webpa</span><br><span class=\"line\">ck\\lib\\NormalModuleFactory.js:138:29)</span><br><span class=\"line\">    at process.nextTick (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@4.29</span><br><span class=\"line\">.3@webpack\\lib\\NormalModuleFactory.js:342:9)</span><br><span class=\"line\">    at process._tickCallback (internal/process/next_tick.js:61:11)</span><br><span class=\"line\"> @ ./client/app.js 2:0-27 4:16-19</span><br><span class=\"line\">npm ERR! code ELIFECYCLE</span><br><span class=\"line\">npm ERR! errno 2</span><br><span class=\"line\">npm ERR! react_ssr_demo@1.0.0 build: `webpack --config build/webpack.config.js`</span><br><span class=\"line\">npm ERR! Exit status 2</span><br><span class=\"line\">npm ERR!</span><br><span class=\"line\">npm ERR! Failed at the react_ssr_demo@1.0.0 build script.</span><br><span class=\"line\">npm ERR! This is probably not a problem with npm. There is likely additional log</span><br><span class=\"line\">ging output above.</span><br><span class=\"line\"></span><br><span class=\"line\">npm ERR! A complete log of this run can be found in:</span><br><span class=\"line\">npm ERR!     C:\\Users\\Administrator.PC-201812050004\\AppData\\Roaming\\npm-cache\\_l</span><br><span class=\"line\">ogs\\2019-02-09T07_46_04_537Z-debug.log</span><br></pre></td></tr></table></figure></p>\n<p>这里面有两个问题</p>\n<ol>\n<li>WARNING in configuration<blockquote>\n<p>解决方法：在webpack.config.js下增加mode: ‘none’<br>module.exports = {<br> mode: ‘none’,</p>\n</blockquote>\n</li>\n</ol>\n<ol start=\"2\">\n<li>Error: Cannot find module ‘@babel/core’<br>babel-loader@8 requires Babel 7.x (the package ‘@babel/core’). If you’d like to<br>use Babel 6.x (‘babel-core’), you should install ‘babel-loader@7’.<blockquote>\n<p>解决方法：npm i babel-loader@7 -D</p>\n</blockquote>\n</li>\n</ol>\n"},{"title":"zabbix平台搭建","date":"2018-03-14T06:06:45.000Z","_content":"最近给公司搞了个zabbix平台监测，不得不说，网上的文章太杂了\n下面是我使用成功在centos7安装zabbix 3.11.4的命令\n1.1 安装依赖包：\n```\nyum -y install wget net-snmp-devel OpenIPMI-devel httpd openssl-devel java lrzsz fping-devel libcurl-devel perl-DBI pcre-devel libxml2 libxml2-devel mysql-devel gcc php php-bcmath php-gd php-xml php-mbstring php-ldap php-mysql.x86_64 php-pear php-xmlrpc  net-tools wget vim-enhanced\n```\n1.2 关闭防火墙：\n```\n# systemctl stop firewalld.service\n# systemctl disable firewalld.service \n需要关闭 selinux，一定要关闭这个，开启selinux会引起一连串问题，甚至zabbix的discovery功能也不能正常使用\n# sed -i \"s/SELINUX=enforcing/SELINUX=disabled/g\" /etc/selinux/config\n确认是否修改成功\n# grep SELINUX /etc/selinux/config\n然后重启系统即可\n\n# reboot\n```\n2.1 搭建lamp环境\n在centos7上安装zabbix server3.0之前，我们首先搭建zabbix所需要的lamp环境。\n\n下载最新的yum源，如下：\n```\n# wget -P /etc/yum.repos.d http://mirrors.aliyun.com/repo/Centos-7.repo\n```\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf289ca12ca6f?w=500&h=138&f=png&s=54932)\n在开始安装之前，还需要说明下centos7自带的mysql是mariadb，我们可以通过如下命令查看：\n```\nyum search mysql|tac\n```\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf289cac5b93a?w=550&h=117&f=png&s=20151)\n现在开始安装lamp环境，使用如下命令：\n```\nyum -y install mariadb mariadb-server php php-mysql httpd\n```\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf289caebc541?w=500&h=210&f=png&s=99112)\n\n通过上图，我们可以很明显的看出centos7默认安装的是php5.4、httpd2.4和maradb5.5，这个完全符合zabbix3.0对软件版本的要求。\n\nlamp安装完毕后，我们现在来配置mysql数据库。\n\n设置开机自启动mysql，并启动mysql，使用如下命令：\n```\n[root@zabbix ~]# systemctl enable mariadb.service\n[root@zabbix ~]# systemctl start mariadb.service\n```\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf289cc84fa02?w=886&h=66&f=png&s=3094)\n初始化mysql数据库，并配置root用户密码。使用如下命令：\n```\n[root@zabbix ~]# mysql_secure_installation\n```\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf289cde7dd14?w=500&h=342&f=png&s=104894)\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf289cdfa42e9?w=426&h=136&f=png&s=2147)\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf289f31c1c10?w=500&h=409&f=png&s=105873)\n注意：在上图中的Enter current passwdord for root处，我们直接敲回车键即可。因为centos7上mysql的默认root用户密码为空。\n上图中主要是为root用户配置密码，并刷新相关权限。（密码设为123456，只为实验用，生产环境自定义）\nRemove anonymous users? 删除匿名用户？\nDisallow root login remotely? 禁止root远程登陆\nRemove test database and access to it? 删除测试数据库并且和访问它\nReload privilege tables now? 重新载入特权表\n上图中主要是配置匿名用户、test用户以及root用户远程连接等相关配置。\nmysql初始化完毕后，我们现在来创建zabbix数据库及其用户，使用如下命令：\n```\n[root@zabbix ~]# mysql -uroot -p123456 -e \"create database zabbix default character set utf8 collate utf8_bin;\"\n\n[root@zabbix ~]# mysql -uroot -p123456 -e \"grant all on zabbix.* to \"zabbix\"@\"%\" identified by \"zabbix\";\"\n```\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf289f80f9ba8?w=550&h=71&f=png&s=39165)\n现在来测试刚刚创建的zabbix用户，是否可以连接mysql数据库，如下：\n```\n[root@zabbix ~]# mysql -uzabbix -pzabbix\n\nMariaDB [(none)]> show databases;\n\nMariaDB [(none)]> quit\n```\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf289fe4f7f03?w=500&h=210&f=png&s=49276)\n通过上图，我们可以很明显的看出zabbix用户是可以正常连接数据库的。\n\n启动apache以及开放80端口，如下：\n```\n[root@zabbix ~]# systemctl start httpd.service\n\n[root@zabbix ~]# netstat -ltun\n```\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a03047765?w=500&h=118&f=png&s=45381)\n\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a08b208e6?w=615&h=21&f=png&s=1120)\n到此lamp环境已经全部搭建完毕。\n浏览器输入IP地址即可看到如下\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a0b3a3547?w=500&h=113&f=png&s=75540)\n2.2 服务器端安装zabbix server3.0（zabbix server）\nlamp环境搭建完毕后，我们现在开始正式安装zabbix3.0。\n\n安装zabbix3.0所需要EPEL源和zabbix的yum源，如下：\n```\n#rpm -ivh https://mirrors.aliyun.com/centos/6.9/extras/x86_64/Packages/epel-release-6-8.noarch.rpm\n````\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a26598a68?w=500&h=65&f=png&s=33448)\n```\n#rpm -ivh http://repo.zabbix.com/zabbix/3.0/rhel/7/x86_64/zabbix-release-3.0-1.el7.noarch.rpm\n```\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a2704d6e7?w=825&h=98&f=png&s=5156)\n以上安装完毕后，我们现在来正式安装zabbix3.0，使用如下命令：\n```\n[root@zabbix ~]# yum -y install zabbix-server-mysql zabbix-web-mysql zabbix-get\n```\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a309e3504?w=814&h=304&f=png&s=31892)\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a3d3b20be?w=827&h=129&f=png&s=4702)\n\n通过上图，我们可以很明显的看出目前zabbix server是3.0.5版本的。\n\n以上安装完毕后，我们现在开始进行zabbix的相关配置。\n\n导入zabbix数据库结构，如下：\n```\n[root@zabbix ~]# cd /usr/share/doc/zabbix-server-mysql-3.0.5/\n\n[root@zabbix zabbix-server-mysql-3.0.5]# zcat create.sql.gz | mysql -uroot -pDe123456 zabbix\n```\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a3e070b44?w=732&h=67&f=png&s=3377)\n数据库导入完毕后，我们现在来修改zabbix sever的配置文件，如下：（我们只需要关注 DBHost、DBName、DBUser、\nDBPassword 几项即可。这几项是配置zabbix server连接mysql数据库的参数。）\n```\n[root@zabbix ~]# vi /etc/zabbix/zabbix_server.conf\n\nLogFile=/var/log/zabbix/zabbix_server.log\n\nLogFileSize=0\n\nPidFile=/var/run/zabbix/zabbix_server.pid\n\nDBHost=localhost\n\nDBName=zabbix\n\nDBUser=zabbix\n\nDBPassword=zabbix\n\nSNMPTrapperFile=/var/log/snmptrap/snmptrap.log\n\nTimeout=4\n\nAlertScriptsPath=/usr/lib/zabbix/alertscripts\n\nExternalScripts=/usr/lib/zabbix/externalscripts\n\nLogSlowQueries=3000\n```\n以上修改完毕后，我们再来修改下zabbix.conf文件。如下：\n```\nvi /etc/httpd/conf.d/zabbix.conf\n\nAlias /zabbix /usr/share/zabbix\n\nOptions FollowSymLinks\n\nAllowOverride None\n\nRequire all granted\n\nphp_value max_execution_time 300\n\nphp_value memory_limit 128M\n\nphp_value post_max_size 16M\n\nphp_value upload_max_filesize 2M\n\nphp_value max_input_time 300\n\nphp_value always_populate_raw_post_data -1\n\n   php_value date.timezone Asia/Shanghai \n```\n修改最后一项php_value date.timezone Asia/Shanghai 就行，定义php的时区\n以上修改完毕后，我们把把zabbix-server加入开机启动，并启动zabbix-server，如下：\n```\n[root@zabbix ~]# systemctl start zabbix-server.service\n\n[root@zabbix ~]# systemctl enable zabbix-server.service\n```\n最后重启apache，如下：\n```\n[root@zabbix ~]# systemctl restart httpd.service\n```\n3.1配置zabbix\n登录http://ip/zabbix/setup.php（ip就是你服务器的IP地址）\n一开始会有要输入密码的时候，如下\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a48afcfca?w=611&h=231&f=png&s=49591)\n输入之前设置的数据库密码即可\n接下来，很重要！\n一路next。。。\n然后就点登录 默认用户名是Admin 密码 zabbix 然后点击sign in\nzabbix server端就设置完毕\n4.1 配置客户端安装zabbix agent（被监测的服务器）\nzabbix agent的安装比较简单，我们只需要安装相应的仓库，然后执行安装命令即可。\n```\n[root@zabbix ~]# yum clean all\n\n[root@zabbix ~]# yum -y install zabbix zabbix-agent\n```\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a4c3cf45b?w=500&h=156&f=png&s=64317)\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a5aa62ae4?w=629&h=221&f=png&s=54174)\n在安装时如出现如上图所示错误，原因是软件这两个版本不一致，仔细观察发现这两个软件包使用了不同的仓库，把epel的关闭(enabled=0，位于/etc/yum.repos.d/epel.repo)再重装\n4.2 配置zabbix agent\n\nzabbix agent的配置很简单，只需要修改zabbix agent配置文件中的Server、ServerActive和Hostname这三项即可。\n\n其中Server、ServerActive是zabbix server服务器的IP地址，Hostname是被监控端的IP地址，如下：\n```\n[root@zabbix ~]# vi /etc/zabbix/zabbix_agentd.conf\n\nPidFile=/var/run/zabbix/zabbix_agentd.pid\n\nLogFile=/var/log/zabbix/zabbix_agentd.log\n\nLogFileSize=0\n\nServer=127.0.0.1\n\nServerActive=127.0.0.1\n\nHostname=127.0.0.1\n\nInclude=/etc/zabbix/zabbix_agentd.d/\n```\n以上配置完毕后，我们在zabbix web端添加该监控机器时，只需要把honst name与该配置文件中的hostname对应即可。如下：\n\nServer=服务器ip地址\n\nServerActive=服务器ip地址\n\nHostname=客户端ip地址\n\nServer被动ServerActive主动\n\n到此zabbix agent就已经安装完毕。\n\n启动客户端\n```\n[root@zabbix ~]# zabbix_agentd -c /etc/zabbix/zabbix_agentd.conf\n\n[root@zabbix ~]# systemctl start zabbix-agent\n\n[root@zabbix ~]# systemctl restart zabbix-agent\n\n[root@zabbix ~]# systemctl enable zabbix-agent\n```\n然后在浏览器中根据下面的美图设置\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a61d1df49?w=1240&h=308&f=png&s=96888)\n看到第四个了没，ZBX绿了就成功了\n\n点左上角的小人就能设置语言是中文\n但是会遇到图标坐标系没有文字的问题如下\n\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a6cf44eff?w=376&h=212&f=png&s=15317)\n解决乱码方法：\n把Windows 系统中找到 C:\\Windows\\Fonts 中的楷体（常规）用winscp （百度一下）拷贝到linux根目录\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a6fc86e4a?w=975&h=300&f=png&s=44909)\n可以上传到 linux 里面了，接下来把 SIMKAI.TTF 移动到 zabbix 安装目录的 fonts 目录下\n```\n[root@zabbix ~]# mv SIMKAI.TTF /usr/share/zabbix/fonts/\n```\n可以直接按照下面的图片设置，然后再看看，是不是搞定了\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a7b02865b?w=610&h=263&f=png&s=6823)\n\n\n\n","source":"_posts/zabbix平台搭建.md","raw":"---\ntitle: zabbix平台搭建\ndate: 2018-03-14 14:06:45\ntags:\n---\n最近给公司搞了个zabbix平台监测，不得不说，网上的文章太杂了\n下面是我使用成功在centos7安装zabbix 3.11.4的命令\n1.1 安装依赖包：\n```\nyum -y install wget net-snmp-devel OpenIPMI-devel httpd openssl-devel java lrzsz fping-devel libcurl-devel perl-DBI pcre-devel libxml2 libxml2-devel mysql-devel gcc php php-bcmath php-gd php-xml php-mbstring php-ldap php-mysql.x86_64 php-pear php-xmlrpc  net-tools wget vim-enhanced\n```\n1.2 关闭防火墙：\n```\n# systemctl stop firewalld.service\n# systemctl disable firewalld.service \n需要关闭 selinux，一定要关闭这个，开启selinux会引起一连串问题，甚至zabbix的discovery功能也不能正常使用\n# sed -i \"s/SELINUX=enforcing/SELINUX=disabled/g\" /etc/selinux/config\n确认是否修改成功\n# grep SELINUX /etc/selinux/config\n然后重启系统即可\n\n# reboot\n```\n2.1 搭建lamp环境\n在centos7上安装zabbix server3.0之前，我们首先搭建zabbix所需要的lamp环境。\n\n下载最新的yum源，如下：\n```\n# wget -P /etc/yum.repos.d http://mirrors.aliyun.com/repo/Centos-7.repo\n```\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf289ca12ca6f?w=500&h=138&f=png&s=54932)\n在开始安装之前，还需要说明下centos7自带的mysql是mariadb，我们可以通过如下命令查看：\n```\nyum search mysql|tac\n```\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf289cac5b93a?w=550&h=117&f=png&s=20151)\n现在开始安装lamp环境，使用如下命令：\n```\nyum -y install mariadb mariadb-server php php-mysql httpd\n```\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf289caebc541?w=500&h=210&f=png&s=99112)\n\n通过上图，我们可以很明显的看出centos7默认安装的是php5.4、httpd2.4和maradb5.5，这个完全符合zabbix3.0对软件版本的要求。\n\nlamp安装完毕后，我们现在来配置mysql数据库。\n\n设置开机自启动mysql，并启动mysql，使用如下命令：\n```\n[root@zabbix ~]# systemctl enable mariadb.service\n[root@zabbix ~]# systemctl start mariadb.service\n```\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf289cc84fa02?w=886&h=66&f=png&s=3094)\n初始化mysql数据库，并配置root用户密码。使用如下命令：\n```\n[root@zabbix ~]# mysql_secure_installation\n```\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf289cde7dd14?w=500&h=342&f=png&s=104894)\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf289cdfa42e9?w=426&h=136&f=png&s=2147)\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf289f31c1c10?w=500&h=409&f=png&s=105873)\n注意：在上图中的Enter current passwdord for root处，我们直接敲回车键即可。因为centos7上mysql的默认root用户密码为空。\n上图中主要是为root用户配置密码，并刷新相关权限。（密码设为123456，只为实验用，生产环境自定义）\nRemove anonymous users? 删除匿名用户？\nDisallow root login remotely? 禁止root远程登陆\nRemove test database and access to it? 删除测试数据库并且和访问它\nReload privilege tables now? 重新载入特权表\n上图中主要是配置匿名用户、test用户以及root用户远程连接等相关配置。\nmysql初始化完毕后，我们现在来创建zabbix数据库及其用户，使用如下命令：\n```\n[root@zabbix ~]# mysql -uroot -p123456 -e \"create database zabbix default character set utf8 collate utf8_bin;\"\n\n[root@zabbix ~]# mysql -uroot -p123456 -e \"grant all on zabbix.* to \"zabbix\"@\"%\" identified by \"zabbix\";\"\n```\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf289f80f9ba8?w=550&h=71&f=png&s=39165)\n现在来测试刚刚创建的zabbix用户，是否可以连接mysql数据库，如下：\n```\n[root@zabbix ~]# mysql -uzabbix -pzabbix\n\nMariaDB [(none)]> show databases;\n\nMariaDB [(none)]> quit\n```\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf289fe4f7f03?w=500&h=210&f=png&s=49276)\n通过上图，我们可以很明显的看出zabbix用户是可以正常连接数据库的。\n\n启动apache以及开放80端口，如下：\n```\n[root@zabbix ~]# systemctl start httpd.service\n\n[root@zabbix ~]# netstat -ltun\n```\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a03047765?w=500&h=118&f=png&s=45381)\n\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a08b208e6?w=615&h=21&f=png&s=1120)\n到此lamp环境已经全部搭建完毕。\n浏览器输入IP地址即可看到如下\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a0b3a3547?w=500&h=113&f=png&s=75540)\n2.2 服务器端安装zabbix server3.0（zabbix server）\nlamp环境搭建完毕后，我们现在开始正式安装zabbix3.0。\n\n安装zabbix3.0所需要EPEL源和zabbix的yum源，如下：\n```\n#rpm -ivh https://mirrors.aliyun.com/centos/6.9/extras/x86_64/Packages/epel-release-6-8.noarch.rpm\n````\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a26598a68?w=500&h=65&f=png&s=33448)\n```\n#rpm -ivh http://repo.zabbix.com/zabbix/3.0/rhel/7/x86_64/zabbix-release-3.0-1.el7.noarch.rpm\n```\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a2704d6e7?w=825&h=98&f=png&s=5156)\n以上安装完毕后，我们现在来正式安装zabbix3.0，使用如下命令：\n```\n[root@zabbix ~]# yum -y install zabbix-server-mysql zabbix-web-mysql zabbix-get\n```\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a309e3504?w=814&h=304&f=png&s=31892)\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a3d3b20be?w=827&h=129&f=png&s=4702)\n\n通过上图，我们可以很明显的看出目前zabbix server是3.0.5版本的。\n\n以上安装完毕后，我们现在开始进行zabbix的相关配置。\n\n导入zabbix数据库结构，如下：\n```\n[root@zabbix ~]# cd /usr/share/doc/zabbix-server-mysql-3.0.5/\n\n[root@zabbix zabbix-server-mysql-3.0.5]# zcat create.sql.gz | mysql -uroot -pDe123456 zabbix\n```\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a3e070b44?w=732&h=67&f=png&s=3377)\n数据库导入完毕后，我们现在来修改zabbix sever的配置文件，如下：（我们只需要关注 DBHost、DBName、DBUser、\nDBPassword 几项即可。这几项是配置zabbix server连接mysql数据库的参数。）\n```\n[root@zabbix ~]# vi /etc/zabbix/zabbix_server.conf\n\nLogFile=/var/log/zabbix/zabbix_server.log\n\nLogFileSize=0\n\nPidFile=/var/run/zabbix/zabbix_server.pid\n\nDBHost=localhost\n\nDBName=zabbix\n\nDBUser=zabbix\n\nDBPassword=zabbix\n\nSNMPTrapperFile=/var/log/snmptrap/snmptrap.log\n\nTimeout=4\n\nAlertScriptsPath=/usr/lib/zabbix/alertscripts\n\nExternalScripts=/usr/lib/zabbix/externalscripts\n\nLogSlowQueries=3000\n```\n以上修改完毕后，我们再来修改下zabbix.conf文件。如下：\n```\nvi /etc/httpd/conf.d/zabbix.conf\n\nAlias /zabbix /usr/share/zabbix\n\nOptions FollowSymLinks\n\nAllowOverride None\n\nRequire all granted\n\nphp_value max_execution_time 300\n\nphp_value memory_limit 128M\n\nphp_value post_max_size 16M\n\nphp_value upload_max_filesize 2M\n\nphp_value max_input_time 300\n\nphp_value always_populate_raw_post_data -1\n\n   php_value date.timezone Asia/Shanghai \n```\n修改最后一项php_value date.timezone Asia/Shanghai 就行，定义php的时区\n以上修改完毕后，我们把把zabbix-server加入开机启动，并启动zabbix-server，如下：\n```\n[root@zabbix ~]# systemctl start zabbix-server.service\n\n[root@zabbix ~]# systemctl enable zabbix-server.service\n```\n最后重启apache，如下：\n```\n[root@zabbix ~]# systemctl restart httpd.service\n```\n3.1配置zabbix\n登录http://ip/zabbix/setup.php（ip就是你服务器的IP地址）\n一开始会有要输入密码的时候，如下\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a48afcfca?w=611&h=231&f=png&s=49591)\n输入之前设置的数据库密码即可\n接下来，很重要！\n一路next。。。\n然后就点登录 默认用户名是Admin 密码 zabbix 然后点击sign in\nzabbix server端就设置完毕\n4.1 配置客户端安装zabbix agent（被监测的服务器）\nzabbix agent的安装比较简单，我们只需要安装相应的仓库，然后执行安装命令即可。\n```\n[root@zabbix ~]# yum clean all\n\n[root@zabbix ~]# yum -y install zabbix zabbix-agent\n```\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a4c3cf45b?w=500&h=156&f=png&s=64317)\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a5aa62ae4?w=629&h=221&f=png&s=54174)\n在安装时如出现如上图所示错误，原因是软件这两个版本不一致，仔细观察发现这两个软件包使用了不同的仓库，把epel的关闭(enabled=0，位于/etc/yum.repos.d/epel.repo)再重装\n4.2 配置zabbix agent\n\nzabbix agent的配置很简单，只需要修改zabbix agent配置文件中的Server、ServerActive和Hostname这三项即可。\n\n其中Server、ServerActive是zabbix server服务器的IP地址，Hostname是被监控端的IP地址，如下：\n```\n[root@zabbix ~]# vi /etc/zabbix/zabbix_agentd.conf\n\nPidFile=/var/run/zabbix/zabbix_agentd.pid\n\nLogFile=/var/log/zabbix/zabbix_agentd.log\n\nLogFileSize=0\n\nServer=127.0.0.1\n\nServerActive=127.0.0.1\n\nHostname=127.0.0.1\n\nInclude=/etc/zabbix/zabbix_agentd.d/\n```\n以上配置完毕后，我们在zabbix web端添加该监控机器时，只需要把honst name与该配置文件中的hostname对应即可。如下：\n\nServer=服务器ip地址\n\nServerActive=服务器ip地址\n\nHostname=客户端ip地址\n\nServer被动ServerActive主动\n\n到此zabbix agent就已经安装完毕。\n\n启动客户端\n```\n[root@zabbix ~]# zabbix_agentd -c /etc/zabbix/zabbix_agentd.conf\n\n[root@zabbix ~]# systemctl start zabbix-agent\n\n[root@zabbix ~]# systemctl restart zabbix-agent\n\n[root@zabbix ~]# systemctl enable zabbix-agent\n```\n然后在浏览器中根据下面的美图设置\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a61d1df49?w=1240&h=308&f=png&s=96888)\n看到第四个了没，ZBX绿了就成功了\n\n点左上角的小人就能设置语言是中文\n但是会遇到图标坐标系没有文字的问题如下\n\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a6cf44eff?w=376&h=212&f=png&s=15317)\n解决乱码方法：\n把Windows 系统中找到 C:\\Windows\\Fonts 中的楷体（常规）用winscp （百度一下）拷贝到linux根目录\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a6fc86e4a?w=975&h=300&f=png&s=44909)\n可以上传到 linux 里面了，接下来把 SIMKAI.TTF 移动到 zabbix 安装目录的 fonts 目录下\n```\n[root@zabbix ~]# mv SIMKAI.TTF /usr/share/zabbix/fonts/\n```\n可以直接按照下面的图片设置，然后再看看，是不是搞定了\n![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a7b02865b?w=610&h=263&f=png&s=6823)\n\n\n\n","slug":"zabbix平台搭建","published":1,"updated":"2019-04-10T02:31:49.153Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzkie000gjgf2gqggla6o","content":"<p>最近给公司搞了个zabbix平台监测，不得不说，网上的文章太杂了<br>下面是我使用成功在centos7安装zabbix 3.11.4的命令<br>1.1 安装依赖包：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y install wget net-snmp-devel OpenIPMI-devel httpd openssl-devel java lrzsz fping-devel libcurl-devel perl-DBI pcre-devel libxml2 libxml2-devel mysql-devel gcc php php-bcmath php-gd php-xml php-mbstring php-ldap php-mysql.x86_64 php-pear php-xmlrpc  net-tools wget vim-enhanced</span><br></pre></td></tr></table></figure></p>\n<p>1.2 关闭防火墙：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># systemctl stop firewalld.service</span><br><span class=\"line\"># systemctl disable firewalld.service </span><br><span class=\"line\">需要关闭 selinux，一定要关闭这个，开启selinux会引起一连串问题，甚至zabbix的discovery功能也不能正常使用</span><br><span class=\"line\"># sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/config</span><br><span class=\"line\">确认是否修改成功</span><br><span class=\"line\"># grep SELINUX /etc/selinux/config</span><br><span class=\"line\">然后重启系统即可</span><br><span class=\"line\"></span><br><span class=\"line\"># reboot</span><br></pre></td></tr></table></figure></p>\n<p>2.1 搭建lamp环境<br>在centos7上安装zabbix server3.0之前，我们首先搭建zabbix所需要的lamp环境。</p>\n<p>下载最新的yum源，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># wget -P /etc/yum.repos.d http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf289ca12ca6f?w=500&amp;h=138&amp;f=png&amp;s=54932\" alt=\"image.png\"><br>在开始安装之前，还需要说明下centos7自带的mysql是mariadb，我们可以通过如下命令查看：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum search mysql|tac</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf289cac5b93a?w=550&amp;h=117&amp;f=png&amp;s=20151\" alt=\"image.png\"><br>现在开始安装lamp环境，使用如下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y install mariadb mariadb-server php php-mysql httpd</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf289caebc541?w=500&amp;h=210&amp;f=png&amp;s=99112\" alt=\"image.png\"></p>\n<p>通过上图，我们可以很明显的看出centos7默认安装的是php5.4、httpd2.4和maradb5.5，这个完全符合zabbix3.0对软件版本的要求。</p>\n<p>lamp安装完毕后，我们现在来配置mysql数据库。</p>\n<p>设置开机自启动mysql，并启动mysql，使用如下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# systemctl enable mariadb.service</span><br><span class=\"line\">[root@zabbix ~]# systemctl start mariadb.service</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf289cc84fa02?w=886&amp;h=66&amp;f=png&amp;s=3094\" alt=\"image.png\"><br>初始化mysql数据库，并配置root用户密码。使用如下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# mysql_secure_installation</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf289cde7dd14?w=500&amp;h=342&amp;f=png&amp;s=104894\" alt=\"image.png\"><br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf289cdfa42e9?w=426&amp;h=136&amp;f=png&amp;s=2147\" alt=\"image.png\"><br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf289f31c1c10?w=500&amp;h=409&amp;f=png&amp;s=105873\" alt=\"image.png\"><br>注意：在上图中的Enter current passwdord for root处，我们直接敲回车键即可。因为centos7上mysql的默认root用户密码为空。<br>上图中主要是为root用户配置密码，并刷新相关权限。（密码设为123456，只为实验用，生产环境自定义）<br>Remove anonymous users? 删除匿名用户？<br>Disallow root login remotely? 禁止root远程登陆<br>Remove test database and access to it? 删除测试数据库并且和访问它<br>Reload privilege tables now? 重新载入特权表<br>上图中主要是配置匿名用户、test用户以及root用户远程连接等相关配置。<br>mysql初始化完毕后，我们现在来创建zabbix数据库及其用户，使用如下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# mysql -uroot -p123456 -e &quot;create database zabbix default character set utf8 collate utf8_bin;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">[root@zabbix ~]# mysql -uroot -p123456 -e &quot;grant all on zabbix.* to &quot;zabbix&quot;@&quot;%&quot; identified by &quot;zabbix&quot;;&quot;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf289f80f9ba8?w=550&amp;h=71&amp;f=png&amp;s=39165\" alt=\"image.png\"><br>现在来测试刚刚创建的zabbix用户，是否可以连接mysql数据库，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# mysql -uzabbix -pzabbix</span><br><span class=\"line\"></span><br><span class=\"line\">MariaDB [(none)]&gt; show databases;</span><br><span class=\"line\"></span><br><span class=\"line\">MariaDB [(none)]&gt; quit</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf289fe4f7f03?w=500&amp;h=210&amp;f=png&amp;s=49276\" alt=\"image.png\"><br>通过上图，我们可以很明显的看出zabbix用户是可以正常连接数据库的。</p>\n<p>启动apache以及开放80端口，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# systemctl start httpd.service</span><br><span class=\"line\"></span><br><span class=\"line\">[root@zabbix ~]# netstat -ltun</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a03047765?w=500&amp;h=118&amp;f=png&amp;s=45381\" alt=\"image.png\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a08b208e6?w=615&amp;h=21&amp;f=png&amp;s=1120\" alt=\"image.png\"><br>到此lamp环境已经全部搭建完毕。<br>浏览器输入IP地址即可看到如下<br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a0b3a3547?w=500&amp;h=113&amp;f=png&amp;s=75540\" alt=\"image.png\"><br>2.2 服务器端安装zabbix server3.0（zabbix server）<br>lamp环境搭建完毕后，我们现在开始正式安装zabbix3.0。</p>\n<p>安装zabbix3.0所需要EPEL源和zabbix的yum源，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#rpm -ivh https://mirrors.aliyun.com/centos/6.9/extras/x86_64/Packages/epel-release-6-8.noarch.rpm</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a26598a68?w=500&amp;h=65&amp;f=png&amp;s=33448\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#rpm -ivh http://repo.zabbix.com/zabbix/3.0/rhel/7/x86_64/zabbix-release-3.0-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a2704d6e7?w=825&amp;h=98&amp;f=png&amp;s=5156\" alt=\"image.png\"><br>以上安装完毕后，我们现在来正式安装zabbix3.0，使用如下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# yum -y install zabbix-server-mysql zabbix-web-mysql zabbix-get</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a309e3504?w=814&amp;h=304&amp;f=png&amp;s=31892\" alt=\"image.png\"><br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a3d3b20be?w=827&amp;h=129&amp;f=png&amp;s=4702\" alt=\"image.png\"></p>\n<p>通过上图，我们可以很明显的看出目前zabbix server是3.0.5版本的。</p>\n<p>以上安装完毕后，我们现在开始进行zabbix的相关配置。</p>\n<p>导入zabbix数据库结构，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# cd /usr/share/doc/zabbix-server-mysql-3.0.5/</span><br><span class=\"line\"></span><br><span class=\"line\">[root@zabbix zabbix-server-mysql-3.0.5]# zcat create.sql.gz | mysql -uroot -pDe123456 zabbix</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a3e070b44?w=732&amp;h=67&amp;f=png&amp;s=3377\" alt=\"image.png\"><br>数据库导入完毕后，我们现在来修改zabbix sever的配置文件，如下：（我们只需要关注 DBHost、DBName、DBUser、<br>DBPassword 几项即可。这几项是配置zabbix server连接mysql数据库的参数。）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# vi /etc/zabbix/zabbix_server.conf</span><br><span class=\"line\"></span><br><span class=\"line\">LogFile=/var/log/zabbix/zabbix_server.log</span><br><span class=\"line\"></span><br><span class=\"line\">LogFileSize=0</span><br><span class=\"line\"></span><br><span class=\"line\">PidFile=/var/run/zabbix/zabbix_server.pid</span><br><span class=\"line\"></span><br><span class=\"line\">DBHost=localhost</span><br><span class=\"line\"></span><br><span class=\"line\">DBName=zabbix</span><br><span class=\"line\"></span><br><span class=\"line\">DBUser=zabbix</span><br><span class=\"line\"></span><br><span class=\"line\">DBPassword=zabbix</span><br><span class=\"line\"></span><br><span class=\"line\">SNMPTrapperFile=/var/log/snmptrap/snmptrap.log</span><br><span class=\"line\"></span><br><span class=\"line\">Timeout=4</span><br><span class=\"line\"></span><br><span class=\"line\">AlertScriptsPath=/usr/lib/zabbix/alertscripts</span><br><span class=\"line\"></span><br><span class=\"line\">ExternalScripts=/usr/lib/zabbix/externalscripts</span><br><span class=\"line\"></span><br><span class=\"line\">LogSlowQueries=3000</span><br></pre></td></tr></table></figure></p>\n<p>以上修改完毕后，我们再来修改下zabbix.conf文件。如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/httpd/conf.d/zabbix.conf</span><br><span class=\"line\"></span><br><span class=\"line\">Alias /zabbix /usr/share/zabbix</span><br><span class=\"line\"></span><br><span class=\"line\">Options FollowSymLinks</span><br><span class=\"line\"></span><br><span class=\"line\">AllowOverride None</span><br><span class=\"line\"></span><br><span class=\"line\">Require all granted</span><br><span class=\"line\"></span><br><span class=\"line\">php_value max_execution_time 300</span><br><span class=\"line\"></span><br><span class=\"line\">php_value memory_limit 128M</span><br><span class=\"line\"></span><br><span class=\"line\">php_value post_max_size 16M</span><br><span class=\"line\"></span><br><span class=\"line\">php_value upload_max_filesize 2M</span><br><span class=\"line\"></span><br><span class=\"line\">php_value max_input_time 300</span><br><span class=\"line\"></span><br><span class=\"line\">php_value always_populate_raw_post_data -1</span><br><span class=\"line\"></span><br><span class=\"line\">   php_value date.timezone Asia/Shanghai</span><br></pre></td></tr></table></figure></p>\n<p>修改最后一项php_value date.timezone Asia/Shanghai 就行，定义php的时区<br>以上修改完毕后，我们把把zabbix-server加入开机启动，并启动zabbix-server，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# systemctl start zabbix-server.service</span><br><span class=\"line\"></span><br><span class=\"line\">[root@zabbix ~]# systemctl enable zabbix-server.service</span><br></pre></td></tr></table></figure></p>\n<p>最后重启apache，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# systemctl restart httpd.service</span><br></pre></td></tr></table></figure></p>\n<p>3.1配置zabbix<br>登录<a href=\"http://ip/zabbix/setup.php（ip就是你服务器的IP地址）\" target=\"_blank\" rel=\"noopener\">http://ip/zabbix/setup.php（ip就是你服务器的IP地址）</a><br>一开始会有要输入密码的时候，如下<br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a48afcfca?w=611&amp;h=231&amp;f=png&amp;s=49591\" alt=\"image.png\"><br>输入之前设置的数据库密码即可<br>接下来，很重要！<br>一路next。。。<br>然后就点登录 默认用户名是Admin 密码 zabbix 然后点击sign in<br>zabbix server端就设置完毕<br>4.1 配置客户端安装zabbix agent（被监测的服务器）<br>zabbix agent的安装比较简单，我们只需要安装相应的仓库，然后执行安装命令即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# yum clean all</span><br><span class=\"line\"></span><br><span class=\"line\">[root@zabbix ~]# yum -y install zabbix zabbix-agent</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a4c3cf45b?w=500&amp;h=156&amp;f=png&amp;s=64317\" alt=\"image.png\"><br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a5aa62ae4?w=629&amp;h=221&amp;f=png&amp;s=54174\" alt=\"image.png\"><br>在安装时如出现如上图所示错误，原因是软件这两个版本不一致，仔细观察发现这两个软件包使用了不同的仓库，把epel的关闭(enabled=0，位于/etc/yum.repos.d/epel.repo)再重装<br>4.2 配置zabbix agent</p>\n<p>zabbix agent的配置很简单，只需要修改zabbix agent配置文件中的Server、ServerActive和Hostname这三项即可。</p>\n<p>其中Server、ServerActive是zabbix server服务器的IP地址，Hostname是被监控端的IP地址，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# vi /etc/zabbix/zabbix_agentd.conf</span><br><span class=\"line\"></span><br><span class=\"line\">PidFile=/var/run/zabbix/zabbix_agentd.pid</span><br><span class=\"line\"></span><br><span class=\"line\">LogFile=/var/log/zabbix/zabbix_agentd.log</span><br><span class=\"line\"></span><br><span class=\"line\">LogFileSize=0</span><br><span class=\"line\"></span><br><span class=\"line\">Server=127.0.0.1</span><br><span class=\"line\"></span><br><span class=\"line\">ServerActive=127.0.0.1</span><br><span class=\"line\"></span><br><span class=\"line\">Hostname=127.0.0.1</span><br><span class=\"line\"></span><br><span class=\"line\">Include=/etc/zabbix/zabbix_agentd.d/</span><br></pre></td></tr></table></figure></p>\n<p>以上配置完毕后，我们在zabbix web端添加该监控机器时，只需要把honst name与该配置文件中的hostname对应即可。如下：</p>\n<p>Server=服务器ip地址</p>\n<p>ServerActive=服务器ip地址</p>\n<p>Hostname=客户端ip地址</p>\n<p>Server被动ServerActive主动</p>\n<p>到此zabbix agent就已经安装完毕。</p>\n<p>启动客户端<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# zabbix_agentd -c /etc/zabbix/zabbix_agentd.conf</span><br><span class=\"line\"></span><br><span class=\"line\">[root@zabbix ~]# systemctl start zabbix-agent</span><br><span class=\"line\"></span><br><span class=\"line\">[root@zabbix ~]# systemctl restart zabbix-agent</span><br><span class=\"line\"></span><br><span class=\"line\">[root@zabbix ~]# systemctl enable zabbix-agent</span><br></pre></td></tr></table></figure></p>\n<p>然后在浏览器中根据下面的美图设置<br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a61d1df49?w=1240&amp;h=308&amp;f=png&amp;s=96888\" alt=\"image.png\"><br>看到第四个了没，ZBX绿了就成功了</p>\n<p>点左上角的小人就能设置语言是中文<br>但是会遇到图标坐标系没有文字的问题如下</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a6cf44eff?w=376&amp;h=212&amp;f=png&amp;s=15317\" alt=\"image.png\"><br>解决乱码方法：<br>把Windows 系统中找到 C:\\Windows\\Fonts 中的楷体（常规）用winscp （百度一下）拷贝到linux根目录<br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a6fc86e4a?w=975&amp;h=300&amp;f=png&amp;s=44909\" alt=\"image.png\"><br>可以上传到 linux 里面了，接下来把 SIMKAI.TTF 移动到 zabbix 安装目录的 fonts 目录下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# mv SIMKAI.TTF /usr/share/zabbix/fonts/</span><br></pre></td></tr></table></figure></p>\n<p>可以直接按照下面的图片设置，然后再看看，是不是搞定了<br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a7b02865b?w=610&amp;h=263&amp;f=png&amp;s=6823\" alt=\"image.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近给公司搞了个zabbix平台监测，不得不说，网上的文章太杂了<br>下面是我使用成功在centos7安装zabbix 3.11.4的命令<br>1.1 安装依赖包：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y install wget net-snmp-devel OpenIPMI-devel httpd openssl-devel java lrzsz fping-devel libcurl-devel perl-DBI pcre-devel libxml2 libxml2-devel mysql-devel gcc php php-bcmath php-gd php-xml php-mbstring php-ldap php-mysql.x86_64 php-pear php-xmlrpc  net-tools wget vim-enhanced</span><br></pre></td></tr></table></figure></p>\n<p>1.2 关闭防火墙：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># systemctl stop firewalld.service</span><br><span class=\"line\"># systemctl disable firewalld.service </span><br><span class=\"line\">需要关闭 selinux，一定要关闭这个，开启selinux会引起一连串问题，甚至zabbix的discovery功能也不能正常使用</span><br><span class=\"line\"># sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/config</span><br><span class=\"line\">确认是否修改成功</span><br><span class=\"line\"># grep SELINUX /etc/selinux/config</span><br><span class=\"line\">然后重启系统即可</span><br><span class=\"line\"></span><br><span class=\"line\"># reboot</span><br></pre></td></tr></table></figure></p>\n<p>2.1 搭建lamp环境<br>在centos7上安装zabbix server3.0之前，我们首先搭建zabbix所需要的lamp环境。</p>\n<p>下载最新的yum源，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># wget -P /etc/yum.repos.d http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf289ca12ca6f?w=500&amp;h=138&amp;f=png&amp;s=54932\" alt=\"image.png\"><br>在开始安装之前，还需要说明下centos7自带的mysql是mariadb，我们可以通过如下命令查看：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum search mysql|tac</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf289cac5b93a?w=550&amp;h=117&amp;f=png&amp;s=20151\" alt=\"image.png\"><br>现在开始安装lamp环境，使用如下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y install mariadb mariadb-server php php-mysql httpd</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf289caebc541?w=500&amp;h=210&amp;f=png&amp;s=99112\" alt=\"image.png\"></p>\n<p>通过上图，我们可以很明显的看出centos7默认安装的是php5.4、httpd2.4和maradb5.5，这个完全符合zabbix3.0对软件版本的要求。</p>\n<p>lamp安装完毕后，我们现在来配置mysql数据库。</p>\n<p>设置开机自启动mysql，并启动mysql，使用如下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# systemctl enable mariadb.service</span><br><span class=\"line\">[root@zabbix ~]# systemctl start mariadb.service</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf289cc84fa02?w=886&amp;h=66&amp;f=png&amp;s=3094\" alt=\"image.png\"><br>初始化mysql数据库，并配置root用户密码。使用如下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# mysql_secure_installation</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf289cde7dd14?w=500&amp;h=342&amp;f=png&amp;s=104894\" alt=\"image.png\"><br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf289cdfa42e9?w=426&amp;h=136&amp;f=png&amp;s=2147\" alt=\"image.png\"><br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf289f31c1c10?w=500&amp;h=409&amp;f=png&amp;s=105873\" alt=\"image.png\"><br>注意：在上图中的Enter current passwdord for root处，我们直接敲回车键即可。因为centos7上mysql的默认root用户密码为空。<br>上图中主要是为root用户配置密码，并刷新相关权限。（密码设为123456，只为实验用，生产环境自定义）<br>Remove anonymous users? 删除匿名用户？<br>Disallow root login remotely? 禁止root远程登陆<br>Remove test database and access to it? 删除测试数据库并且和访问它<br>Reload privilege tables now? 重新载入特权表<br>上图中主要是配置匿名用户、test用户以及root用户远程连接等相关配置。<br>mysql初始化完毕后，我们现在来创建zabbix数据库及其用户，使用如下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# mysql -uroot -p123456 -e &quot;create database zabbix default character set utf8 collate utf8_bin;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">[root@zabbix ~]# mysql -uroot -p123456 -e &quot;grant all on zabbix.* to &quot;zabbix&quot;@&quot;%&quot; identified by &quot;zabbix&quot;;&quot;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf289f80f9ba8?w=550&amp;h=71&amp;f=png&amp;s=39165\" alt=\"image.png\"><br>现在来测试刚刚创建的zabbix用户，是否可以连接mysql数据库，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# mysql -uzabbix -pzabbix</span><br><span class=\"line\"></span><br><span class=\"line\">MariaDB [(none)]&gt; show databases;</span><br><span class=\"line\"></span><br><span class=\"line\">MariaDB [(none)]&gt; quit</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf289fe4f7f03?w=500&amp;h=210&amp;f=png&amp;s=49276\" alt=\"image.png\"><br>通过上图，我们可以很明显的看出zabbix用户是可以正常连接数据库的。</p>\n<p>启动apache以及开放80端口，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# systemctl start httpd.service</span><br><span class=\"line\"></span><br><span class=\"line\">[root@zabbix ~]# netstat -ltun</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a03047765?w=500&amp;h=118&amp;f=png&amp;s=45381\" alt=\"image.png\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a08b208e6?w=615&amp;h=21&amp;f=png&amp;s=1120\" alt=\"image.png\"><br>到此lamp环境已经全部搭建完毕。<br>浏览器输入IP地址即可看到如下<br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a0b3a3547?w=500&amp;h=113&amp;f=png&amp;s=75540\" alt=\"image.png\"><br>2.2 服务器端安装zabbix server3.0（zabbix server）<br>lamp环境搭建完毕后，我们现在开始正式安装zabbix3.0。</p>\n<p>安装zabbix3.0所需要EPEL源和zabbix的yum源，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#rpm -ivh https://mirrors.aliyun.com/centos/6.9/extras/x86_64/Packages/epel-release-6-8.noarch.rpm</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a26598a68?w=500&amp;h=65&amp;f=png&amp;s=33448\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#rpm -ivh http://repo.zabbix.com/zabbix/3.0/rhel/7/x86_64/zabbix-release-3.0-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a2704d6e7?w=825&amp;h=98&amp;f=png&amp;s=5156\" alt=\"image.png\"><br>以上安装完毕后，我们现在来正式安装zabbix3.0，使用如下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# yum -y install zabbix-server-mysql zabbix-web-mysql zabbix-get</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a309e3504?w=814&amp;h=304&amp;f=png&amp;s=31892\" alt=\"image.png\"><br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a3d3b20be?w=827&amp;h=129&amp;f=png&amp;s=4702\" alt=\"image.png\"></p>\n<p>通过上图，我们可以很明显的看出目前zabbix server是3.0.5版本的。</p>\n<p>以上安装完毕后，我们现在开始进行zabbix的相关配置。</p>\n<p>导入zabbix数据库结构，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# cd /usr/share/doc/zabbix-server-mysql-3.0.5/</span><br><span class=\"line\"></span><br><span class=\"line\">[root@zabbix zabbix-server-mysql-3.0.5]# zcat create.sql.gz | mysql -uroot -pDe123456 zabbix</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a3e070b44?w=732&amp;h=67&amp;f=png&amp;s=3377\" alt=\"image.png\"><br>数据库导入完毕后，我们现在来修改zabbix sever的配置文件，如下：（我们只需要关注 DBHost、DBName、DBUser、<br>DBPassword 几项即可。这几项是配置zabbix server连接mysql数据库的参数。）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# vi /etc/zabbix/zabbix_server.conf</span><br><span class=\"line\"></span><br><span class=\"line\">LogFile=/var/log/zabbix/zabbix_server.log</span><br><span class=\"line\"></span><br><span class=\"line\">LogFileSize=0</span><br><span class=\"line\"></span><br><span class=\"line\">PidFile=/var/run/zabbix/zabbix_server.pid</span><br><span class=\"line\"></span><br><span class=\"line\">DBHost=localhost</span><br><span class=\"line\"></span><br><span class=\"line\">DBName=zabbix</span><br><span class=\"line\"></span><br><span class=\"line\">DBUser=zabbix</span><br><span class=\"line\"></span><br><span class=\"line\">DBPassword=zabbix</span><br><span class=\"line\"></span><br><span class=\"line\">SNMPTrapperFile=/var/log/snmptrap/snmptrap.log</span><br><span class=\"line\"></span><br><span class=\"line\">Timeout=4</span><br><span class=\"line\"></span><br><span class=\"line\">AlertScriptsPath=/usr/lib/zabbix/alertscripts</span><br><span class=\"line\"></span><br><span class=\"line\">ExternalScripts=/usr/lib/zabbix/externalscripts</span><br><span class=\"line\"></span><br><span class=\"line\">LogSlowQueries=3000</span><br></pre></td></tr></table></figure></p>\n<p>以上修改完毕后，我们再来修改下zabbix.conf文件。如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/httpd/conf.d/zabbix.conf</span><br><span class=\"line\"></span><br><span class=\"line\">Alias /zabbix /usr/share/zabbix</span><br><span class=\"line\"></span><br><span class=\"line\">Options FollowSymLinks</span><br><span class=\"line\"></span><br><span class=\"line\">AllowOverride None</span><br><span class=\"line\"></span><br><span class=\"line\">Require all granted</span><br><span class=\"line\"></span><br><span class=\"line\">php_value max_execution_time 300</span><br><span class=\"line\"></span><br><span class=\"line\">php_value memory_limit 128M</span><br><span class=\"line\"></span><br><span class=\"line\">php_value post_max_size 16M</span><br><span class=\"line\"></span><br><span class=\"line\">php_value upload_max_filesize 2M</span><br><span class=\"line\"></span><br><span class=\"line\">php_value max_input_time 300</span><br><span class=\"line\"></span><br><span class=\"line\">php_value always_populate_raw_post_data -1</span><br><span class=\"line\"></span><br><span class=\"line\">   php_value date.timezone Asia/Shanghai</span><br></pre></td></tr></table></figure></p>\n<p>修改最后一项php_value date.timezone Asia/Shanghai 就行，定义php的时区<br>以上修改完毕后，我们把把zabbix-server加入开机启动，并启动zabbix-server，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# systemctl start zabbix-server.service</span><br><span class=\"line\"></span><br><span class=\"line\">[root@zabbix ~]# systemctl enable zabbix-server.service</span><br></pre></td></tr></table></figure></p>\n<p>最后重启apache，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# systemctl restart httpd.service</span><br></pre></td></tr></table></figure></p>\n<p>3.1配置zabbix<br>登录<a href=\"http://ip/zabbix/setup.php（ip就是你服务器的IP地址）\" target=\"_blank\" rel=\"noopener\">http://ip/zabbix/setup.php（ip就是你服务器的IP地址）</a><br>一开始会有要输入密码的时候，如下<br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a48afcfca?w=611&amp;h=231&amp;f=png&amp;s=49591\" alt=\"image.png\"><br>输入之前设置的数据库密码即可<br>接下来，很重要！<br>一路next。。。<br>然后就点登录 默认用户名是Admin 密码 zabbix 然后点击sign in<br>zabbix server端就设置完毕<br>4.1 配置客户端安装zabbix agent（被监测的服务器）<br>zabbix agent的安装比较简单，我们只需要安装相应的仓库，然后执行安装命令即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# yum clean all</span><br><span class=\"line\"></span><br><span class=\"line\">[root@zabbix ~]# yum -y install zabbix zabbix-agent</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a4c3cf45b?w=500&amp;h=156&amp;f=png&amp;s=64317\" alt=\"image.png\"><br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a5aa62ae4?w=629&amp;h=221&amp;f=png&amp;s=54174\" alt=\"image.png\"><br>在安装时如出现如上图所示错误，原因是软件这两个版本不一致，仔细观察发现这两个软件包使用了不同的仓库，把epel的关闭(enabled=0，位于/etc/yum.repos.d/epel.repo)再重装<br>4.2 配置zabbix agent</p>\n<p>zabbix agent的配置很简单，只需要修改zabbix agent配置文件中的Server、ServerActive和Hostname这三项即可。</p>\n<p>其中Server、ServerActive是zabbix server服务器的IP地址，Hostname是被监控端的IP地址，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# vi /etc/zabbix/zabbix_agentd.conf</span><br><span class=\"line\"></span><br><span class=\"line\">PidFile=/var/run/zabbix/zabbix_agentd.pid</span><br><span class=\"line\"></span><br><span class=\"line\">LogFile=/var/log/zabbix/zabbix_agentd.log</span><br><span class=\"line\"></span><br><span class=\"line\">LogFileSize=0</span><br><span class=\"line\"></span><br><span class=\"line\">Server=127.0.0.1</span><br><span class=\"line\"></span><br><span class=\"line\">ServerActive=127.0.0.1</span><br><span class=\"line\"></span><br><span class=\"line\">Hostname=127.0.0.1</span><br><span class=\"line\"></span><br><span class=\"line\">Include=/etc/zabbix/zabbix_agentd.d/</span><br></pre></td></tr></table></figure></p>\n<p>以上配置完毕后，我们在zabbix web端添加该监控机器时，只需要把honst name与该配置文件中的hostname对应即可。如下：</p>\n<p>Server=服务器ip地址</p>\n<p>ServerActive=服务器ip地址</p>\n<p>Hostname=客户端ip地址</p>\n<p>Server被动ServerActive主动</p>\n<p>到此zabbix agent就已经安装完毕。</p>\n<p>启动客户端<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# zabbix_agentd -c /etc/zabbix/zabbix_agentd.conf</span><br><span class=\"line\"></span><br><span class=\"line\">[root@zabbix ~]# systemctl start zabbix-agent</span><br><span class=\"line\"></span><br><span class=\"line\">[root@zabbix ~]# systemctl restart zabbix-agent</span><br><span class=\"line\"></span><br><span class=\"line\">[root@zabbix ~]# systemctl enable zabbix-agent</span><br></pre></td></tr></table></figure></p>\n<p>然后在浏览器中根据下面的美图设置<br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a61d1df49?w=1240&amp;h=308&amp;f=png&amp;s=96888\" alt=\"image.png\"><br>看到第四个了没，ZBX绿了就成功了</p>\n<p>点左上角的小人就能设置语言是中文<br>但是会遇到图标坐标系没有文字的问题如下</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a6cf44eff?w=376&amp;h=212&amp;f=png&amp;s=15317\" alt=\"image.png\"><br>解决乱码方法：<br>把Windows 系统中找到 C:\\Windows\\Fonts 中的楷体（常规）用winscp （百度一下）拷贝到linux根目录<br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a6fc86e4a?w=975&amp;h=300&amp;f=png&amp;s=44909\" alt=\"image.png\"><br>可以上传到 linux 里面了，接下来把 SIMKAI.TTF 移动到 zabbix 安装目录的 fonts 目录下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@zabbix ~]# mv SIMKAI.TTF /usr/share/zabbix/fonts/</span><br></pre></td></tr></table></figure></p>\n<p>可以直接按照下面的图片设置，然后再看看，是不是搞定了<br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf28a7b02865b?w=610&amp;h=263&amp;f=png&amp;s=6823\" alt=\"image.png\"></p>\n"},{"title":"关于我","date":"2019-01-11T10:00:59.000Z","_content":"### 我是Harry🐷\n> 17年正式毕业出栏，喜欢学习，编程，健身，做饭，吃喝玩乐\n> 前端开发从16年6月就开始，执迷于业务，所以至今技术方面仍然在追赶大佬，终究会有成功的一天\n>主要使用Vue，Angualr1，React，Mongodb，Node，Express，mysql，小程序等\n>如果客官有啥好事情，请速速带我上车\n**`邮箱：1562055324@qq.com`**\n**`微信：zq156205`**","source":"_posts/关于我.md","raw":"---\ntitle: 关于我\ndate: 2019-01-11 18:00:59\ntags:\n---\n### 我是Harry🐷\n> 17年正式毕业出栏，喜欢学习，编程，健身，做饭，吃喝玩乐\n> 前端开发从16年6月就开始，执迷于业务，所以至今技术方面仍然在追赶大佬，终究会有成功的一天\n>主要使用Vue，Angualr1，React，Mongodb，Node，Express，mysql，小程序等\n>如果客官有啥好事情，请速速带我上车\n**`邮箱：1562055324@qq.com`**\n**`微信：zq156205`**","slug":"关于我","published":1,"updated":"2019-04-10T02:31:49.157Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzkif000hjgf2cin0l3zy","content":"<h3 id=\"我是Harry🐷\"><a href=\"#我是Harry🐷\" class=\"headerlink\" title=\"我是Harry🐷\"></a>我是Harry🐷</h3><blockquote>\n<p>17年正式毕业出栏，喜欢学习，编程，健身，做饭，吃喝玩乐<br>前端开发从16年6月就开始，执迷于业务，所以至今技术方面仍然在追赶大佬，终究会有成功的一天<br>主要使用Vue，Angualr1，React，Mongodb，Node，Express，mysql，小程序等<br>如果客官有啥好事情，请速速带我上车<br><strong><code>邮箱：1562055324@qq.com</code></strong><br><strong><code>微信：zq156205</code></strong></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"我是Harry🐷\"><a href=\"#我是Harry🐷\" class=\"headerlink\" title=\"我是Harry🐷\"></a>我是Harry🐷</h3><blockquote>\n<p>17年正式毕业出栏，喜欢学习，编程，健身，做饭，吃喝玩乐<br>前端开发从16年6月就开始，执迷于业务，所以至今技术方面仍然在追赶大佬，终究会有成功的一天<br>主要使用Vue，Angualr1，React，Mongodb，Node，Express，mysql，小程序等<br>如果客官有啥好事情，请速速带我上车<br><strong><code>邮箱：1562055324@qq.com</code></strong><br><strong><code>微信：zq156205</code></strong></p>\n</blockquote>\n"},{"title":"函数节流与防抖","date":"2018-11-10T03:10:09.000Z","_content":"> 假设浏览器窗口滚动条滚动时会调用一个方法fn,下面一步步实现一个节流函数.\n\n```\n* 第一个版本\n     * 缺点:产生了全局变量\n<script>\n    var timer;\n    window.onscroll = function () {\n        clearTimeout(timer);\n        timer = setTimeout(function () {\n            console.log('window scroll...');\n        }, 200);\n    }\n</script>\n\n\n     * 第二个版本,使用闭包来封装全局变量\n     * 缺点:如果用户不停的滚动滚动条,那么延时函数一次都不会触发\n<script>\n    var throttle = function (fn, delay) {\n        var timer = null;\n        return function () {\n            clearTimeout(timer);\n            timer = setTimeout(function () {\n                fn();\n            }, delay);\n        }\n    }\n    var f = throttle(testFn, 200);\n    window.onscroll = function () {\n        f();\n    };\n</script>\n\n      * 于是我们又要添加一个功能：当用户触发 scroll 的时候应该 在某段时间 内至少触发一次，既然是在某段时间内，\n      * 那么这个判断条件就可以取当前的时间毫秒数，每次函数调用把当前的时间和上一次调用时间相减，然后判断差值如果大于 某段时间 就直接触发，\n      * 否则还是走 timeout 的延迟逻辑。\n      下面的代码里面需要指出的是：\n      1. previous 变量的作用和 timer 类似，都是记录上一次的标识，必须是相对的全局变量\n      2. 如果逻辑流程走的是“至少触发一次”的逻辑，那么函数调用完成需要把 previous 重置成当前时间，简单来说就是：相对于下一次的上一次其实就是当前\n     \n<script>\n\n   var COUNT = 0, demo = document.getElementById('demo');\n    function testFn() {\n        demo.innerHTML += 'testFN 被调用了 ' + ++COUNT + '次<br>';\n    }\n    var throttle = function (fn, delay, atleast) {\n        var timer = null;\n        var previous = null;\n        return function () {\n            var now = +new Date();\n            if (!previous) previous = now;\n            if (atleast && now - previous > atleast) {\n                fn();\n                // 重置上一次开始时间为本次结束时间\n                previous = now;\n                clearTimeout(timer);\n            } else {\n                clearTimeout(timer);\n                timer = setTimeout(function () {\n                    fn();\n                    previous = null;\n                }, delay);\n            }\n        }\n    };\n    window.onscroll = throttle(testFn, 200);\n    // window.onscroll = throttle(testFn, 500, 1000);\n</script>\n\n<script>\n    document.getElementById(\"btn\").onclick = throttle(function () {\n        console.log(\"button click...\");\n    }, 2000);\n\n    //debounce用于将相同的操作积累到一起再触发，节省性能\n    function debounce(fn, delay) {\n        var timer = null;\n        return function () {\n            clearTimeout(timer);\n            timer = setTimeout(function () {\n                return fn.apply(this, arguments);\n            }, delay);\n        }\n    }\n</script>\n```","source":"_posts/函数节流与防抖.md","raw":"---\ntitle: 函数节流与防抖\ndate: 2018-11-10 11:10:09\ntags:\n---\n> 假设浏览器窗口滚动条滚动时会调用一个方法fn,下面一步步实现一个节流函数.\n\n```\n* 第一个版本\n     * 缺点:产生了全局变量\n<script>\n    var timer;\n    window.onscroll = function () {\n        clearTimeout(timer);\n        timer = setTimeout(function () {\n            console.log('window scroll...');\n        }, 200);\n    }\n</script>\n\n\n     * 第二个版本,使用闭包来封装全局变量\n     * 缺点:如果用户不停的滚动滚动条,那么延时函数一次都不会触发\n<script>\n    var throttle = function (fn, delay) {\n        var timer = null;\n        return function () {\n            clearTimeout(timer);\n            timer = setTimeout(function () {\n                fn();\n            }, delay);\n        }\n    }\n    var f = throttle(testFn, 200);\n    window.onscroll = function () {\n        f();\n    };\n</script>\n\n      * 于是我们又要添加一个功能：当用户触发 scroll 的时候应该 在某段时间 内至少触发一次，既然是在某段时间内，\n      * 那么这个判断条件就可以取当前的时间毫秒数，每次函数调用把当前的时间和上一次调用时间相减，然后判断差值如果大于 某段时间 就直接触发，\n      * 否则还是走 timeout 的延迟逻辑。\n      下面的代码里面需要指出的是：\n      1. previous 变量的作用和 timer 类似，都是记录上一次的标识，必须是相对的全局变量\n      2. 如果逻辑流程走的是“至少触发一次”的逻辑，那么函数调用完成需要把 previous 重置成当前时间，简单来说就是：相对于下一次的上一次其实就是当前\n     \n<script>\n\n   var COUNT = 0, demo = document.getElementById('demo');\n    function testFn() {\n        demo.innerHTML += 'testFN 被调用了 ' + ++COUNT + '次<br>';\n    }\n    var throttle = function (fn, delay, atleast) {\n        var timer = null;\n        var previous = null;\n        return function () {\n            var now = +new Date();\n            if (!previous) previous = now;\n            if (atleast && now - previous > atleast) {\n                fn();\n                // 重置上一次开始时间为本次结束时间\n                previous = now;\n                clearTimeout(timer);\n            } else {\n                clearTimeout(timer);\n                timer = setTimeout(function () {\n                    fn();\n                    previous = null;\n                }, delay);\n            }\n        }\n    };\n    window.onscroll = throttle(testFn, 200);\n    // window.onscroll = throttle(testFn, 500, 1000);\n</script>\n\n<script>\n    document.getElementById(\"btn\").onclick = throttle(function () {\n        console.log(\"button click...\");\n    }, 2000);\n\n    //debounce用于将相同的操作积累到一起再触发，节省性能\n    function debounce(fn, delay) {\n        var timer = null;\n        return function () {\n            clearTimeout(timer);\n            timer = setTimeout(function () {\n                return fn.apply(this, arguments);\n            }, delay);\n        }\n    }\n</script>\n```","slug":"函数节流与防抖","published":1,"updated":"2019-04-10T02:31:49.166Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzkig000ijgf24dmnepad","content":"<blockquote>\n<p>假设浏览器窗口滚动条滚动时会调用一个方法fn,下面一步步实现一个节流函数.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 第一个版本</span><br><span class=\"line\">     * 缺点:产生了全局变量</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var timer;</span><br><span class=\"line\">    window.onscroll = function () &#123;</span><br><span class=\"line\">        clearTimeout(timer);</span><br><span class=\"line\">        timer = setTimeout(function () &#123;</span><br><span class=\"line\">            console.log(&apos;window scroll...&apos;);</span><br><span class=\"line\">        &#125;, 200);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">     * 第二个版本,使用闭包来封装全局变量</span><br><span class=\"line\">     * 缺点:如果用户不停的滚动滚动条,那么延时函数一次都不会触发</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var throttle = function (fn, delay) &#123;</span><br><span class=\"line\">        var timer = null;</span><br><span class=\"line\">        return function () &#123;</span><br><span class=\"line\">            clearTimeout(timer);</span><br><span class=\"line\">            timer = setTimeout(function () &#123;</span><br><span class=\"line\">                fn();</span><br><span class=\"line\">            &#125;, delay);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var f = throttle(testFn, 200);</span><br><span class=\"line\">    window.onscroll = function () &#123;</span><br><span class=\"line\">        f();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">      * 于是我们又要添加一个功能：当用户触发 scroll 的时候应该 在某段时间 内至少触发一次，既然是在某段时间内，</span><br><span class=\"line\">      * 那么这个判断条件就可以取当前的时间毫秒数，每次函数调用把当前的时间和上一次调用时间相减，然后判断差值如果大于 某段时间 就直接触发，</span><br><span class=\"line\">      * 否则还是走 timeout 的延迟逻辑。</span><br><span class=\"line\">      下面的代码里面需要指出的是：</span><br><span class=\"line\">      1. previous 变量的作用和 timer 类似，都是记录上一次的标识，必须是相对的全局变量</span><br><span class=\"line\">      2. 如果逻辑流程走的是“至少触发一次”的逻辑，那么函数调用完成需要把 previous 重置成当前时间，简单来说就是：相对于下一次的上一次其实就是当前</span><br><span class=\"line\">     </span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">   var COUNT = 0, demo = document.getElementById(&apos;demo&apos;);</span><br><span class=\"line\">    function testFn() &#123;</span><br><span class=\"line\">        demo.innerHTML += &apos;testFN 被调用了 &apos; + ++COUNT + &apos;次&lt;br&gt;&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var throttle = function (fn, delay, atleast) &#123;</span><br><span class=\"line\">        var timer = null;</span><br><span class=\"line\">        var previous = null;</span><br><span class=\"line\">        return function () &#123;</span><br><span class=\"line\">            var now = +new Date();</span><br><span class=\"line\">            if (!previous) previous = now;</span><br><span class=\"line\">            if (atleast &amp;&amp; now - previous &gt; atleast) &#123;</span><br><span class=\"line\">                fn();</span><br><span class=\"line\">                // 重置上一次开始时间为本次结束时间</span><br><span class=\"line\">                previous = now;</span><br><span class=\"line\">                clearTimeout(timer);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                clearTimeout(timer);</span><br><span class=\"line\">                timer = setTimeout(function () &#123;</span><br><span class=\"line\">                    fn();</span><br><span class=\"line\">                    previous = null;</span><br><span class=\"line\">                &#125;, delay);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    window.onscroll = throttle(testFn, 200);</span><br><span class=\"line\">    // window.onscroll = throttle(testFn, 500, 1000);</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    document.getElementById(&quot;btn&quot;).onclick = throttle(function () &#123;</span><br><span class=\"line\">        console.log(&quot;button click...&quot;);</span><br><span class=\"line\">    &#125;, 2000);</span><br><span class=\"line\"></span><br><span class=\"line\">    //debounce用于将相同的操作积累到一起再触发，节省性能</span><br><span class=\"line\">    function debounce(fn, delay) &#123;</span><br><span class=\"line\">        var timer = null;</span><br><span class=\"line\">        return function () &#123;</span><br><span class=\"line\">            clearTimeout(timer);</span><br><span class=\"line\">            timer = setTimeout(function () &#123;</span><br><span class=\"line\">                return fn.apply(this, arguments);</span><br><span class=\"line\">            &#125;, delay);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>假设浏览器窗口滚动条滚动时会调用一个方法fn,下面一步步实现一个节流函数.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 第一个版本</span><br><span class=\"line\">     * 缺点:产生了全局变量</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var timer;</span><br><span class=\"line\">    window.onscroll = function () &#123;</span><br><span class=\"line\">        clearTimeout(timer);</span><br><span class=\"line\">        timer = setTimeout(function () &#123;</span><br><span class=\"line\">            console.log(&apos;window scroll...&apos;);</span><br><span class=\"line\">        &#125;, 200);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">     * 第二个版本,使用闭包来封装全局变量</span><br><span class=\"line\">     * 缺点:如果用户不停的滚动滚动条,那么延时函数一次都不会触发</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var throttle = function (fn, delay) &#123;</span><br><span class=\"line\">        var timer = null;</span><br><span class=\"line\">        return function () &#123;</span><br><span class=\"line\">            clearTimeout(timer);</span><br><span class=\"line\">            timer = setTimeout(function () &#123;</span><br><span class=\"line\">                fn();</span><br><span class=\"line\">            &#125;, delay);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var f = throttle(testFn, 200);</span><br><span class=\"line\">    window.onscroll = function () &#123;</span><br><span class=\"line\">        f();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">      * 于是我们又要添加一个功能：当用户触发 scroll 的时候应该 在某段时间 内至少触发一次，既然是在某段时间内，</span><br><span class=\"line\">      * 那么这个判断条件就可以取当前的时间毫秒数，每次函数调用把当前的时间和上一次调用时间相减，然后判断差值如果大于 某段时间 就直接触发，</span><br><span class=\"line\">      * 否则还是走 timeout 的延迟逻辑。</span><br><span class=\"line\">      下面的代码里面需要指出的是：</span><br><span class=\"line\">      1. previous 变量的作用和 timer 类似，都是记录上一次的标识，必须是相对的全局变量</span><br><span class=\"line\">      2. 如果逻辑流程走的是“至少触发一次”的逻辑，那么函数调用完成需要把 previous 重置成当前时间，简单来说就是：相对于下一次的上一次其实就是当前</span><br><span class=\"line\">     </span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">   var COUNT = 0, demo = document.getElementById(&apos;demo&apos;);</span><br><span class=\"line\">    function testFn() &#123;</span><br><span class=\"line\">        demo.innerHTML += &apos;testFN 被调用了 &apos; + ++COUNT + &apos;次&lt;br&gt;&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var throttle = function (fn, delay, atleast) &#123;</span><br><span class=\"line\">        var timer = null;</span><br><span class=\"line\">        var previous = null;</span><br><span class=\"line\">        return function () &#123;</span><br><span class=\"line\">            var now = +new Date();</span><br><span class=\"line\">            if (!previous) previous = now;</span><br><span class=\"line\">            if (atleast &amp;&amp; now - previous &gt; atleast) &#123;</span><br><span class=\"line\">                fn();</span><br><span class=\"line\">                // 重置上一次开始时间为本次结束时间</span><br><span class=\"line\">                previous = now;</span><br><span class=\"line\">                clearTimeout(timer);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                clearTimeout(timer);</span><br><span class=\"line\">                timer = setTimeout(function () &#123;</span><br><span class=\"line\">                    fn();</span><br><span class=\"line\">                    previous = null;</span><br><span class=\"line\">                &#125;, delay);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    window.onscroll = throttle(testFn, 200);</span><br><span class=\"line\">    // window.onscroll = throttle(testFn, 500, 1000);</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    document.getElementById(&quot;btn&quot;).onclick = throttle(function () &#123;</span><br><span class=\"line\">        console.log(&quot;button click...&quot;);</span><br><span class=\"line\">    &#125;, 2000);</span><br><span class=\"line\"></span><br><span class=\"line\">    //debounce用于将相同的操作积累到一起再触发，节省性能</span><br><span class=\"line\">    function debounce(fn, delay) &#123;</span><br><span class=\"line\">        var timer = null;</span><br><span class=\"line\">        return function () &#123;</span><br><span class=\"line\">            clearTimeout(timer);</span><br><span class=\"line\">            timer = setTimeout(function () &#123;</span><br><span class=\"line\">                return fn.apply(this, arguments);</span><br><span class=\"line\">            &#125;, delay);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>"},{"title":"函数柯里化（curry)","date":"2019-01-10T02:34:05.000Z","_content":"> 函数柯里化的概念很简单，其实就是只提前接受一部分参数，但不执行结果，而是返回一个可以接受另一部分参数的函数。\n\n你可以像下面一样，一次性的调用curry函数，返回每次只传一次参数，传两次来获得想要的结果\n\n```\nfunction MathSumA(x){\n    return function MathSumB(y){\n        return x+y\n    }\n}\n// 先传如一个x=2\nlet x = MathSumA(2);\n\n// 再传入一个y=10\nlet result = x(10); //result = x+y =2+10 =12\n\n```\n","source":"_posts/函数柯里化（curry）.md","raw":"---\ntitle: 函数柯里化（curry)\ndate: 2019-01-10 10:34:05\ntags:\n---\n> 函数柯里化的概念很简单，其实就是只提前接受一部分参数，但不执行结果，而是返回一个可以接受另一部分参数的函数。\n\n你可以像下面一样，一次性的调用curry函数，返回每次只传一次参数，传两次来获得想要的结果\n\n```\nfunction MathSumA(x){\n    return function MathSumB(y){\n        return x+y\n    }\n}\n// 先传如一个x=2\nlet x = MathSumA(2);\n\n// 再传入一个y=10\nlet result = x(10); //result = x+y =2+10 =12\n\n```\n","slug":"函数柯里化（curry）","published":1,"updated":"2019-04-10T02:31:49.160Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzkih000jjgf2uudcbnfy","content":"<blockquote>\n<p>函数柯里化的概念很简单，其实就是只提前接受一部分参数，但不执行结果，而是返回一个可以接受另一部分参数的函数。</p>\n</blockquote>\n<p>你可以像下面一样，一次性的调用curry函数，返回每次只传一次参数，传两次来获得想要的结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function MathSumA(x)&#123;</span><br><span class=\"line\">    return function MathSumB(y)&#123;</span><br><span class=\"line\">        return x+y</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 先传如一个x=2</span><br><span class=\"line\">let x = MathSumA(2);</span><br><span class=\"line\"></span><br><span class=\"line\">// 再传入一个y=10</span><br><span class=\"line\">let result = x(10); //result = x+y =2+10 =12</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>函数柯里化的概念很简单，其实就是只提前接受一部分参数，但不执行结果，而是返回一个可以接受另一部分参数的函数。</p>\n</blockquote>\n<p>你可以像下面一样，一次性的调用curry函数，返回每次只传一次参数，传两次来获得想要的结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function MathSumA(x)&#123;</span><br><span class=\"line\">    return function MathSumB(y)&#123;</span><br><span class=\"line\">        return x+y</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 先传如一个x=2</span><br><span class=\"line\">let x = MathSumA(2);</span><br><span class=\"line\"></span><br><span class=\"line\">// 再传入一个y=10</span><br><span class=\"line\">let result = x(10); //result = x+y =2+10 =12</span><br></pre></td></tr></table></figure>\n"},{"title":"前端进阶学习路径","date":"2019-01-01T05:58:14.000Z","_content":"## 前端进阶学习路径这是引用自木易杨大佬的公众号（yygmind）传送门：https://github.com/yygmind/blog\n## 这里只是我用来做目录，留着自己以后学习\n\n1. 【进阶1期】 调用堆栈\n2. 【进阶2期】 作用域闭包\n3. 【进阶3期】 this全面解析\n4. 【进阶4期】 深浅拷贝原理\n5. 【进阶5期】 原型Prototype\n6. 【进阶6期】 高阶函数\n7. 【进阶7期】 事件机制\n8. 【进阶8期】 Event Loop原理\n9. 【进阶9期】 Promise原理\n10. 【进阶10期】Async/Await原理\n11. 【进阶11期】防抖/节流原理\n12. 【进阶12期】模块化详解\n13. 【进阶13期】ES6重难点\n14. 【进阶14期】计算机网络概述\n15. 【进阶15期】浏览器渲染原理\n16. 【进阶16期】webpack配置\n17. 【进阶17期】webpack原理\n18. 【进阶18期】前端监控\n19. 【进阶19期】跨域和安全\n20. 【进阶20期】性能优化\n21. 【进阶21期】VirtualDom原理\n22. 【进阶22期】Diff算法\n23. 【进阶23期】MVVM双向绑定\n24. 【进阶24期】Vuex原理\n25. 【进阶25期】Redux原理\n26. 【进阶26期】路由原理\n27. 【进阶27期】VueRouter源码解析\n28. 【进阶28期】ReactRouter源码解析\n","source":"_posts/前端进阶学习路径.md","raw":"---\ntitle: 前端进阶学习路径\ndate: 2019-01-01 13:58:14\ntags:\n---\n## 前端进阶学习路径这是引用自木易杨大佬的公众号（yygmind）传送门：https://github.com/yygmind/blog\n## 这里只是我用来做目录，留着自己以后学习\n\n1. 【进阶1期】 调用堆栈\n2. 【进阶2期】 作用域闭包\n3. 【进阶3期】 this全面解析\n4. 【进阶4期】 深浅拷贝原理\n5. 【进阶5期】 原型Prototype\n6. 【进阶6期】 高阶函数\n7. 【进阶7期】 事件机制\n8. 【进阶8期】 Event Loop原理\n9. 【进阶9期】 Promise原理\n10. 【进阶10期】Async/Await原理\n11. 【进阶11期】防抖/节流原理\n12. 【进阶12期】模块化详解\n13. 【进阶13期】ES6重难点\n14. 【进阶14期】计算机网络概述\n15. 【进阶15期】浏览器渲染原理\n16. 【进阶16期】webpack配置\n17. 【进阶17期】webpack原理\n18. 【进阶18期】前端监控\n19. 【进阶19期】跨域和安全\n20. 【进阶20期】性能优化\n21. 【进阶21期】VirtualDom原理\n22. 【进阶22期】Diff算法\n23. 【进阶23期】MVVM双向绑定\n24. 【进阶24期】Vuex原理\n25. 【进阶25期】Redux原理\n26. 【进阶26期】路由原理\n27. 【进阶27期】VueRouter源码解析\n28. 【进阶28期】ReactRouter源码解析\n","slug":"前端进阶学习路径","published":1,"updated":"2019-04-10T02:31:49.189Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzkih000kjgf2q8wruvmu","content":"<h2 id=\"前端进阶学习路径这是引用自木易杨大佬的公众号（yygmind）传送门：https-github-com-yygmind-blog\"><a href=\"#前端进阶学习路径这是引用自木易杨大佬的公众号（yygmind）传送门：https-github-com-yygmind-blog\" class=\"headerlink\" title=\"前端进阶学习路径这是引用自木易杨大佬的公众号（yygmind）传送门：https://github.com/yygmind/blog\"></a>前端进阶学习路径这是引用自木易杨大佬的公众号（yygmind）传送门：<a href=\"https://github.com/yygmind/blog\">https://github.com/yygmind/blog</a></h2><h2 id=\"这里只是我用来做目录，留着自己以后学习\"><a href=\"#这里只是我用来做目录，留着自己以后学习\" class=\"headerlink\" title=\"这里只是我用来做目录，留着自己以后学习\"></a>这里只是我用来做目录，留着自己以后学习</h2><ol>\n<li>【进阶1期】 调用堆栈</li>\n<li>【进阶2期】 作用域闭包</li>\n<li>【进阶3期】 this全面解析</li>\n<li>【进阶4期】 深浅拷贝原理</li>\n<li>【进阶5期】 原型Prototype</li>\n<li>【进阶6期】 高阶函数</li>\n<li>【进阶7期】 事件机制</li>\n<li>【进阶8期】 Event Loop原理</li>\n<li>【进阶9期】 Promise原理</li>\n<li>【进阶10期】Async/Await原理</li>\n<li>【进阶11期】防抖/节流原理</li>\n<li>【进阶12期】模块化详解</li>\n<li>【进阶13期】ES6重难点</li>\n<li>【进阶14期】计算机网络概述</li>\n<li>【进阶15期】浏览器渲染原理</li>\n<li>【进阶16期】webpack配置</li>\n<li>【进阶17期】webpack原理</li>\n<li>【进阶18期】前端监控</li>\n<li>【进阶19期】跨域和安全</li>\n<li>【进阶20期】性能优化</li>\n<li>【进阶21期】VirtualDom原理</li>\n<li>【进阶22期】Diff算法</li>\n<li>【进阶23期】MVVM双向绑定</li>\n<li>【进阶24期】Vuex原理</li>\n<li>【进阶25期】Redux原理</li>\n<li>【进阶26期】路由原理</li>\n<li>【进阶27期】VueRouter源码解析</li>\n<li>【进阶28期】ReactRouter源码解析</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前端进阶学习路径这是引用自木易杨大佬的公众号（yygmind）传送门：https-github-com-yygmind-blog\"><a href=\"#前端进阶学习路径这是引用自木易杨大佬的公众号（yygmind）传送门：https-github-com-yygmind-blog\" class=\"headerlink\" title=\"前端进阶学习路径这是引用自木易杨大佬的公众号（yygmind）传送门：https://github.com/yygmind/blog\"></a>前端进阶学习路径这是引用自木易杨大佬的公众号（yygmind）传送门：<a href=\"https://github.com/yygmind/blog\">https://github.com/yygmind/blog</a></h2><h2 id=\"这里只是我用来做目录，留着自己以后学习\"><a href=\"#这里只是我用来做目录，留着自己以后学习\" class=\"headerlink\" title=\"这里只是我用来做目录，留着自己以后学习\"></a>这里只是我用来做目录，留着自己以后学习</h2><ol>\n<li>【进阶1期】 调用堆栈</li>\n<li>【进阶2期】 作用域闭包</li>\n<li>【进阶3期】 this全面解析</li>\n<li>【进阶4期】 深浅拷贝原理</li>\n<li>【进阶5期】 原型Prototype</li>\n<li>【进阶6期】 高阶函数</li>\n<li>【进阶7期】 事件机制</li>\n<li>【进阶8期】 Event Loop原理</li>\n<li>【进阶9期】 Promise原理</li>\n<li>【进阶10期】Async/Await原理</li>\n<li>【进阶11期】防抖/节流原理</li>\n<li>【进阶12期】模块化详解</li>\n<li>【进阶13期】ES6重难点</li>\n<li>【进阶14期】计算机网络概述</li>\n<li>【进阶15期】浏览器渲染原理</li>\n<li>【进阶16期】webpack配置</li>\n<li>【进阶17期】webpack原理</li>\n<li>【进阶18期】前端监控</li>\n<li>【进阶19期】跨域和安全</li>\n<li>【进阶20期】性能优化</li>\n<li>【进阶21期】VirtualDom原理</li>\n<li>【进阶22期】Diff算法</li>\n<li>【进阶23期】MVVM双向绑定</li>\n<li>【进阶24期】Vuex原理</li>\n<li>【进阶25期】Redux原理</li>\n<li>【进阶26期】路由原理</li>\n<li>【进阶27期】VueRouter源码解析</li>\n<li>【进阶28期】ReactRouter源码解析</li>\n</ol>\n"},{"title":"发布流程","date":"2019-03-01T07:28:21.000Z","_content":"### 不能算是正规的发布系统，只是按照自己的需求、能力和想法实现的一个简单的自动化\n\n##### 主要涉及的地方\n\n1. 代码仓库\n2. 静态资源站点\n3. web站点\n\n##### 逻辑\n\n1. 打包 \n\t\t\n\t\t1. 从代码仓库拉取代码到静态资源站点\n\t\t2. 生成版本号（即时间戳）命名的文件夹\n\t\t3. 输出版本号\n2. 发布\n\t\t1. 修改输出HTML引用文件的版本号\n\n##### 功能\n\n1. web服务\n2. 静态资源站点\n3. 可视化发布站点","source":"_posts/发布流程.md","raw":"---\ntitle: 发布流程\ndate: 2019-03-01 15:28:21\ntags:\n---\n### 不能算是正规的发布系统，只是按照自己的需求、能力和想法实现的一个简单的自动化\n\n##### 主要涉及的地方\n\n1. 代码仓库\n2. 静态资源站点\n3. web站点\n\n##### 逻辑\n\n1. 打包 \n\t\t\n\t\t1. 从代码仓库拉取代码到静态资源站点\n\t\t2. 生成版本号（即时间戳）命名的文件夹\n\t\t3. 输出版本号\n2. 发布\n\t\t1. 修改输出HTML引用文件的版本号\n\n##### 功能\n\n1. web服务\n2. 静态资源站点\n3. 可视化发布站点","slug":"发布流程","published":1,"updated":"2019-04-10T02:42:15.257Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzkii000ljgf2bq6jomty","content":"<h3 id=\"不能算是正规的发布系统，只是按照自己的需求、能力和想法实现的一个简单的自动化\"><a href=\"#不能算是正规的发布系统，只是按照自己的需求、能力和想法实现的一个简单的自动化\" class=\"headerlink\" title=\"不能算是正规的发布系统，只是按照自己的需求、能力和想法实现的一个简单的自动化\"></a>不能算是正规的发布系统，只是按照自己的需求、能力和想法实现的一个简单的自动化</h3><h5 id=\"主要涉及的地方\"><a href=\"#主要涉及的地方\" class=\"headerlink\" title=\"主要涉及的地方\"></a>主要涉及的地方</h5><ol>\n<li>代码仓库</li>\n<li>静态资源站点</li>\n<li>web站点</li>\n</ol>\n<h5 id=\"逻辑\"><a href=\"#逻辑\" class=\"headerlink\" title=\"逻辑\"></a>逻辑</h5><ol>\n<li><p>打包 </p>\n<pre><code>1. 从代码仓库拉取代码到静态资源站点\n2. 生成版本号（即时间戳）命名的文件夹\n3. 输出版本号\n</code></pre></li>\n<li>发布<pre><code>1. 修改输出HTML引用文件的版本号\n</code></pre></li>\n</ol>\n<h5 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h5><ol>\n<li>web服务</li>\n<li>静态资源站点</li>\n<li>可视化发布站点</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"不能算是正规的发布系统，只是按照自己的需求、能力和想法实现的一个简单的自动化\"><a href=\"#不能算是正规的发布系统，只是按照自己的需求、能力和想法实现的一个简单的自动化\" class=\"headerlink\" title=\"不能算是正规的发布系统，只是按照自己的需求、能力和想法实现的一个简单的自动化\"></a>不能算是正规的发布系统，只是按照自己的需求、能力和想法实现的一个简单的自动化</h3><h5 id=\"主要涉及的地方\"><a href=\"#主要涉及的地方\" class=\"headerlink\" title=\"主要涉及的地方\"></a>主要涉及的地方</h5><ol>\n<li>代码仓库</li>\n<li>静态资源站点</li>\n<li>web站点</li>\n</ol>\n<h5 id=\"逻辑\"><a href=\"#逻辑\" class=\"headerlink\" title=\"逻辑\"></a>逻辑</h5><ol>\n<li><p>打包 </p>\n<pre><code>1. 从代码仓库拉取代码到静态资源站点\n2. 生成版本号（即时间戳）命名的文件夹\n3. 输出版本号\n</code></pre></li>\n<li>发布<pre><code>1. 修改输出HTML引用文件的版本号\n</code></pre></li>\n</ol>\n<h5 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h5><ol>\n<li>web服务</li>\n<li>静态资源站点</li>\n<li>可视化发布站点</li>\n</ol>\n"},{"title":"十分钟了解ajax","date":"2016-09-06T06:09:16.000Z","_content":"ajax其实是实现异步刷新，他的用处是在不重新载入页面的情况下，与与服务器交换数据并更新网页。\n看下面的例子,不着急看懂，后面我会详细解释\n```\n<span>输入账号</span>\n<input id=\"name\" name=\"name\" onkeyup=\"check()\" type=\"text\">  \n<span id=\"checkResult\"></span>\n```\n\n```\n<script>\nvar xmlhttp;\nfunction check(){\nvar name =document.getElementById('name').value;\nvar url=\"/study/checkName.jsp?name=\"+name;\n\nxmlhttp =new XMLHttpRequest(); \n  xmlhttp.onreadystatechange=checkResult; //响应函数\n  xmlhttp.open(\"GET\",url,true);   //设置访问的页面\n  xmlhttp.send(null);  //执行访问\n\nfunction checkResult(){\n  if (xmlhttp.readyState==4 && xmlhttp.status==200)\n    document.getElementById('checkResult').innerHTML=xmlhttp.responseText;\n  \n}\n</script>\n```\n第一步：ajax请求的示意图如下，大概了解是怎么走的：\n![](https://user-gold-cdn.xitu.io/2018/12/21/167cf29b4557b6c0?w=495&h=345&f=png&s=23735)\n\n第二步：创建XMLHttpRequest（XHR）\nXHR是一个javascript对象，他是在幕后通过一个小线程与服务器进行数据交互的，从而实现无刷新效果。\n```\n<script>\nvar xmlhttp = new XMLHttpRequest();\ndocumen.write(xmlhttp);\n</script>\n```\n结果：\n```\n[object XMLHttpRequest]\n```\n\n第三步：设置响应函数\nXHR对象的作用是和服务器进行交互，所以不仅发送消息给服务器，也接受服务器返回的响应。当从服务器返回响应时我们想做点什么该怎么办？\n通过xmlhttp.onreadystatechange=checkResult 就可以指定用checkResult 函数进行处理。\n\n第四步：设置并发出请求\n通过open函数设置幕后的小线程，将要访问的url。在本例中就是 /study/checkName.jsp\n```\nxmlhttp.open('GET',url,true);//规定请求的类型、URL 以及是否异步处理请求。method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步）\n```\n通过send函数进行实际的访问\n```\nxmlhttp.send(null);//send(string),将请求发送到服务器。\n```\n\n第五步：处理响应信息\n在checkResult 函数中处理响应\n```\nfunction checkResult(){\n  if(xmlhttp.readyStats==4 && xmlhttp.status ==200)\n   document.getElementById('checkResult').innerHTML=xmlhttp.responseText;\n}\n```\nxmlhttp.readyState 4 表示请求已完成\nxmlhttp.status 200 表示响应成功\nxmlhttp.responseText; 用于获取服务端传回来的文本\ndocument.getElementById('checkResult').innerHTML 设置span的内容为服务端传递回来的文本\n\n\n\n![](https://user-gold-cdn.xitu.io/2018/12/21/167cf29b456d09ab?w=605&h=268&f=jpeg&s=21414)\n\n再返回来看第一段代码，是不是就理解了呢","source":"_posts/十分钟了解ajax.md","raw":"---\ntitle: 十分钟了解ajax\ndate: 2016-09-06 14:09:16\ntags:\n---\najax其实是实现异步刷新，他的用处是在不重新载入页面的情况下，与与服务器交换数据并更新网页。\n看下面的例子,不着急看懂，后面我会详细解释\n```\n<span>输入账号</span>\n<input id=\"name\" name=\"name\" onkeyup=\"check()\" type=\"text\">  \n<span id=\"checkResult\"></span>\n```\n\n```\n<script>\nvar xmlhttp;\nfunction check(){\nvar name =document.getElementById('name').value;\nvar url=\"/study/checkName.jsp?name=\"+name;\n\nxmlhttp =new XMLHttpRequest(); \n  xmlhttp.onreadystatechange=checkResult; //响应函数\n  xmlhttp.open(\"GET\",url,true);   //设置访问的页面\n  xmlhttp.send(null);  //执行访问\n\nfunction checkResult(){\n  if (xmlhttp.readyState==4 && xmlhttp.status==200)\n    document.getElementById('checkResult').innerHTML=xmlhttp.responseText;\n  \n}\n</script>\n```\n第一步：ajax请求的示意图如下，大概了解是怎么走的：\n![](https://user-gold-cdn.xitu.io/2018/12/21/167cf29b4557b6c0?w=495&h=345&f=png&s=23735)\n\n第二步：创建XMLHttpRequest（XHR）\nXHR是一个javascript对象，他是在幕后通过一个小线程与服务器进行数据交互的，从而实现无刷新效果。\n```\n<script>\nvar xmlhttp = new XMLHttpRequest();\ndocumen.write(xmlhttp);\n</script>\n```\n结果：\n```\n[object XMLHttpRequest]\n```\n\n第三步：设置响应函数\nXHR对象的作用是和服务器进行交互，所以不仅发送消息给服务器，也接受服务器返回的响应。当从服务器返回响应时我们想做点什么该怎么办？\n通过xmlhttp.onreadystatechange=checkResult 就可以指定用checkResult 函数进行处理。\n\n第四步：设置并发出请求\n通过open函数设置幕后的小线程，将要访问的url。在本例中就是 /study/checkName.jsp\n```\nxmlhttp.open('GET',url,true);//规定请求的类型、URL 以及是否异步处理请求。method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步）\n```\n通过send函数进行实际的访问\n```\nxmlhttp.send(null);//send(string),将请求发送到服务器。\n```\n\n第五步：处理响应信息\n在checkResult 函数中处理响应\n```\nfunction checkResult(){\n  if(xmlhttp.readyStats==4 && xmlhttp.status ==200)\n   document.getElementById('checkResult').innerHTML=xmlhttp.responseText;\n}\n```\nxmlhttp.readyState 4 表示请求已完成\nxmlhttp.status 200 表示响应成功\nxmlhttp.responseText; 用于获取服务端传回来的文本\ndocument.getElementById('checkResult').innerHTML 设置span的内容为服务端传递回来的文本\n\n\n\n![](https://user-gold-cdn.xitu.io/2018/12/21/167cf29b456d09ab?w=605&h=268&f=jpeg&s=21414)\n\n再返回来看第一段代码，是不是就理解了呢","slug":"十分钟了解ajax","published":1,"updated":"2019-04-10T02:31:49.193Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzkij000mjgf2icyxp1ke","content":"<p>ajax其实是实现异步刷新，他的用处是在不重新载入页面的情况下，与与服务器交换数据并更新网页。<br>看下面的例子,不着急看懂，后面我会详细解释<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span&gt;输入账号&lt;/span&gt;</span><br><span class=\"line\">&lt;input id=&quot;name&quot; name=&quot;name&quot; onkeyup=&quot;check()&quot; type=&quot;text&quot;&gt;  </span><br><span class=\"line\">&lt;span id=&quot;checkResult&quot;&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var xmlhttp;</span><br><span class=\"line\">function check()&#123;</span><br><span class=\"line\">var name =document.getElementById(&apos;name&apos;).value;</span><br><span class=\"line\">var url=&quot;/study/checkName.jsp?name=&quot;+name;</span><br><span class=\"line\"></span><br><span class=\"line\">xmlhttp =new XMLHttpRequest(); </span><br><span class=\"line\">  xmlhttp.onreadystatechange=checkResult; //响应函数</span><br><span class=\"line\">  xmlhttp.open(&quot;GET&quot;,url,true);   //设置访问的页面</span><br><span class=\"line\">  xmlhttp.send(null);  //执行访问</span><br><span class=\"line\"></span><br><span class=\"line\">function checkResult()&#123;</span><br><span class=\"line\">  if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)</span><br><span class=\"line\">    document.getElementById(&apos;checkResult&apos;).innerHTML=xmlhttp.responseText;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>第一步：ajax请求的示意图如下，大概了解是怎么走的：<br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf29b4557b6c0?w=495&amp;h=345&amp;f=png&amp;s=23735\" alt=\"\"></p>\n<p>第二步：创建XMLHttpRequest（XHR）<br>XHR是一个javascript对象，他是在幕后通过一个小线程与服务器进行数据交互的，从而实现无刷新效果。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var xmlhttp = new XMLHttpRequest();</span><br><span class=\"line\">documen.write(xmlhttp);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[object XMLHttpRequest]</span><br></pre></td></tr></table></figure></p>\n<p>第三步：设置响应函数<br>XHR对象的作用是和服务器进行交互，所以不仅发送消息给服务器，也接受服务器返回的响应。当从服务器返回响应时我们想做点什么该怎么办？<br>通过xmlhttp.onreadystatechange=checkResult 就可以指定用checkResult 函数进行处理。</p>\n<p>第四步：设置并发出请求<br>通过open函数设置幕后的小线程，将要访问的url。在本例中就是 /study/checkName.jsp<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlhttp.open(&apos;GET&apos;,url,true);//规定请求的类型、URL 以及是否异步处理请求。method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步）</span><br></pre></td></tr></table></figure></p>\n<p>通过send函数进行实际的访问<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlhttp.send(null);//send(string),将请求发送到服务器。</span><br></pre></td></tr></table></figure></p>\n<p>第五步：处理响应信息<br>在checkResult 函数中处理响应<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function checkResult()&#123;</span><br><span class=\"line\">  if(xmlhttp.readyStats==4 &amp;&amp; xmlhttp.status ==200)</span><br><span class=\"line\">   document.getElementById(&apos;checkResult&apos;).innerHTML=xmlhttp.responseText;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>xmlhttp.readyState 4 表示请求已完成<br>xmlhttp.status 200 表示响应成功<br>xmlhttp.responseText; 用于获取服务端传回来的文本<br>document.getElementById(‘checkResult’).innerHTML 设置span的内容为服务端传递回来的文本</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf29b456d09ab?w=605&amp;h=268&amp;f=jpeg&amp;s=21414\" alt=\"\"></p>\n<p>再返回来看第一段代码，是不是就理解了呢</p>\n","site":{"data":{}},"excerpt":"","more":"<p>ajax其实是实现异步刷新，他的用处是在不重新载入页面的情况下，与与服务器交换数据并更新网页。<br>看下面的例子,不着急看懂，后面我会详细解释<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span&gt;输入账号&lt;/span&gt;</span><br><span class=\"line\">&lt;input id=&quot;name&quot; name=&quot;name&quot; onkeyup=&quot;check()&quot; type=&quot;text&quot;&gt;  </span><br><span class=\"line\">&lt;span id=&quot;checkResult&quot;&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var xmlhttp;</span><br><span class=\"line\">function check()&#123;</span><br><span class=\"line\">var name =document.getElementById(&apos;name&apos;).value;</span><br><span class=\"line\">var url=&quot;/study/checkName.jsp?name=&quot;+name;</span><br><span class=\"line\"></span><br><span class=\"line\">xmlhttp =new XMLHttpRequest(); </span><br><span class=\"line\">  xmlhttp.onreadystatechange=checkResult; //响应函数</span><br><span class=\"line\">  xmlhttp.open(&quot;GET&quot;,url,true);   //设置访问的页面</span><br><span class=\"line\">  xmlhttp.send(null);  //执行访问</span><br><span class=\"line\"></span><br><span class=\"line\">function checkResult()&#123;</span><br><span class=\"line\">  if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)</span><br><span class=\"line\">    document.getElementById(&apos;checkResult&apos;).innerHTML=xmlhttp.responseText;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>第一步：ajax请求的示意图如下，大概了解是怎么走的：<br><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf29b4557b6c0?w=495&amp;h=345&amp;f=png&amp;s=23735\" alt=\"\"></p>\n<p>第二步：创建XMLHttpRequest（XHR）<br>XHR是一个javascript对象，他是在幕后通过一个小线程与服务器进行数据交互的，从而实现无刷新效果。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var xmlhttp = new XMLHttpRequest();</span><br><span class=\"line\">documen.write(xmlhttp);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[object XMLHttpRequest]</span><br></pre></td></tr></table></figure></p>\n<p>第三步：设置响应函数<br>XHR对象的作用是和服务器进行交互，所以不仅发送消息给服务器，也接受服务器返回的响应。当从服务器返回响应时我们想做点什么该怎么办？<br>通过xmlhttp.onreadystatechange=checkResult 就可以指定用checkResult 函数进行处理。</p>\n<p>第四步：设置并发出请求<br>通过open函数设置幕后的小线程，将要访问的url。在本例中就是 /study/checkName.jsp<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlhttp.open(&apos;GET&apos;,url,true);//规定请求的类型、URL 以及是否异步处理请求。method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步）</span><br></pre></td></tr></table></figure></p>\n<p>通过send函数进行实际的访问<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlhttp.send(null);//send(string),将请求发送到服务器。</span><br></pre></td></tr></table></figure></p>\n<p>第五步：处理响应信息<br>在checkResult 函数中处理响应<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function checkResult()&#123;</span><br><span class=\"line\">  if(xmlhttp.readyStats==4 &amp;&amp; xmlhttp.status ==200)</span><br><span class=\"line\">   document.getElementById(&apos;checkResult&apos;).innerHTML=xmlhttp.responseText;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>xmlhttp.readyState 4 表示请求已完成<br>xmlhttp.status 200 表示响应成功<br>xmlhttp.responseText; 用于获取服务端传回来的文本<br>document.getElementById(‘checkResult’).innerHTML 设置span的内容为服务端传递回来的文本</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf29b456d09ab?w=605&amp;h=268&amp;f=jpeg&amp;s=21414\" alt=\"\"></p>\n<p>再返回来看第一段代码，是不是就理解了呢</p>\n"},{"title":"如何理解es6中的class以及class中的constructor函数","date":"2018-06-17T06:06:08.000Z","_content":"首先，“语法糖”的意思是现有技术本可以实现，但是采用某种写法会更加简洁优雅。最常见的就是声明对象采用的就是语法糖 var a={b:111}。\nES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。\n```\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function () {\n  return '(' + this.x + ', ' + this.y + ')';\n};\n```\n等同于\n```\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\n```\n在constructor中必须调用 super方法，子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。super代表了父类构造函数。对于你的实例相当于执行Component(props)。但是注意，此处this指向 子类。更严谨的是相当于\n```\nComponent.prototype.constructor.call(this,props)。\n```\n","source":"_posts/如何理解es6中的class以及class中的constructor函数.md","raw":"---\ntitle: 如何理解es6中的class以及class中的constructor函数\ndate: 2018-06-17 14:06:08\ntags:\n---\n首先，“语法糖”的意思是现有技术本可以实现，但是采用某种写法会更加简洁优雅。最常见的就是声明对象采用的就是语法糖 var a={b:111}。\nES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。\n```\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function () {\n  return '(' + this.x + ', ' + this.y + ')';\n};\n```\n等同于\n```\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\n```\n在constructor中必须调用 super方法，子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。super代表了父类构造函数。对于你的实例相当于执行Component(props)。但是注意，此处this指向 子类。更严谨的是相当于\n```\nComponent.prototype.constructor.call(this,props)。\n```\n","slug":"如何理解es6中的class以及class中的constructor函数","published":1,"updated":"2019-04-10T02:31:49.200Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzkik000njgf24e9x8736","content":"<p>首先，“语法糖”的意思是现有技术本可以实现，但是采用某种写法会更加简洁优雅。最常见的就是声明对象采用的就是语法糖 var a={b:111}。<br>ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Point(x, y) &#123;</span><br><span class=\"line\">  this.x = x;</span><br><span class=\"line\">  this.y = y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Point.prototype.toString = function () &#123;</span><br><span class=\"line\">  return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>等同于<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Point &#123;</span><br><span class=\"line\">  constructor(x, y) &#123;</span><br><span class=\"line\">    this.x = x;</span><br><span class=\"line\">    this.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在constructor中必须调用 super方法，子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。super代表了父类构造函数。对于你的实例相当于执行Component(props)。但是注意，此处this指向 子类。更严谨的是相当于<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Component.prototype.constructor.call(this,props)。</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>首先，“语法糖”的意思是现有技术本可以实现，但是采用某种写法会更加简洁优雅。最常见的就是声明对象采用的就是语法糖 var a={b:111}。<br>ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Point(x, y) &#123;</span><br><span class=\"line\">  this.x = x;</span><br><span class=\"line\">  this.y = y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Point.prototype.toString = function () &#123;</span><br><span class=\"line\">  return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>等同于<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Point &#123;</span><br><span class=\"line\">  constructor(x, y) &#123;</span><br><span class=\"line\">    this.x = x;</span><br><span class=\"line\">    this.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在constructor中必须调用 super方法，子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。super代表了父类构造函数。对于你的实例相当于执行Component(props)。但是注意，此处this指向 子类。更严谨的是相当于<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Component.prototype.constructor.call(this,props)。</span><br></pre></td></tr></table></figure></p>\n"},{"title":"如何让小孩学习javascript","date":"2018-11-07T06:10:39.000Z","_content":"最近少儿编程培训好像有点热了，开发思维，兴趣爱好等培训班的各类理由让家长不由动心。对于不会编程的家长来说，这是一个不错的学习平台，我也研究过一段时间，确实不错，对小孩的各方面能力都有一定程度的提高，\n但对于程序员，我觉得还是尽量自己来教，毕竟还能给小孩充分的沟通和陪伴时间，也能给自己不小的启发和进步。\n所以我最近看到一些不错的JS学习资源，可以提高小孩的学习兴趣，当然这些学习网站也同样适用于成人，因为的确是不错的资源。\n首先，如果你的小孩没有接触过任何编程，可以通过[scratch](https://scratch.mit.edu/download)或者[scratchjr](http://www.scratchjr.org/about)(平板版的scratch)来入门，别担心，都是一些简单有趣的动画，也没有很复杂的语法，对小孩理解编程思想很有用。官网和其他网站都有大量的实例和教学，社区也很友好。\n\n下面就进入正题啦\n##用[Code Combat](https://cn.codecombat.com/)来过渡javascript\n\n![Paste_Image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf2a4c9bf49ce?w=700&h=339&f=png&s=278960)\n让一个小孩系统的学习他们的第一种编程语言的网站就是 [Code Combat](https://codecombat.com/)，它支持python和javascript。\n这个平台通过一种让小孩通过游戏的方式学习代码，让孩子通过javascript解决谜题，打败怪兽。甚至对我们成年人来说也是非常有趣的。虽然游戏的方式使他有趣，但是他也有短板，不够深入，但用来入门和培养兴趣还是不错的。\n\n###非结构化的js编程\n\n为了让小孩开始他们的第一个javascript应用，我们可以通过 [Codepen](https://codepen.io/)或者 [JS Fiddle](https://jsfiddle.net/)这样的在线编辑器而非专业性的编辑器类似webstorm等。当然，大多数程序员都知道这些在线网站。我们可以让孩子从简单的开始，比如dom操作，数字生成器，简单的计算器等。大多数孩子都喜欢交互式的，图形化的东西，这都非常时候只需要浏览器的javascript!\n\n### [JS With PlayCanvas](https://playcanvas.com/)来提升\n\n![Paste_Image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf2a4c9c4f2ba?w=600&h=342&f=png&s=16187)\n对于我们的更高级的学生，一个很酷的选择就是一个三维引擎 [Play Canvas](https://playcanvas.com/)。当你说“三维”时，你已经钓了90%个孩子，如果你加上“游戏引擎”，你就成功了！[Play Canvas](https://playcanvas.com/)支持刚体物理模拟，处理三维音频(没错！)，三维动画，和大量其他东西，如果你有时间看它。它有一套很好的教程，你一定要看看。\n\n当你快速过滤这个网站，一些实例或甚至只是阅读官方说明，你会感觉到这对于孩子是否太难了。该工具本身可以是一个陡峭的坡道，特别是对于孩子们，所以我们在平衡工具学习和学习的时候总是很谨慎。家长可能需要为一些孩子做一些准备工作-从零开始创建一个三维应用程序对于大多数孩子来说都是相当困难的。\n好啦，今天介绍到这里，如果有不理解的欢迎私信留言，我会一一回的。\n\n参考[原文](https://dzone.com/articles/teaching-kids-javascript)","source":"_posts/如何让小孩学习javascript.md","raw":"---\ntitle: 如何让小孩学习javascript\ndate: 2018-11-07 14:10:39\ntags:\n---\n最近少儿编程培训好像有点热了，开发思维，兴趣爱好等培训班的各类理由让家长不由动心。对于不会编程的家长来说，这是一个不错的学习平台，我也研究过一段时间，确实不错，对小孩的各方面能力都有一定程度的提高，\n但对于程序员，我觉得还是尽量自己来教，毕竟还能给小孩充分的沟通和陪伴时间，也能给自己不小的启发和进步。\n所以我最近看到一些不错的JS学习资源，可以提高小孩的学习兴趣，当然这些学习网站也同样适用于成人，因为的确是不错的资源。\n首先，如果你的小孩没有接触过任何编程，可以通过[scratch](https://scratch.mit.edu/download)或者[scratchjr](http://www.scratchjr.org/about)(平板版的scratch)来入门，别担心，都是一些简单有趣的动画，也没有很复杂的语法，对小孩理解编程思想很有用。官网和其他网站都有大量的实例和教学，社区也很友好。\n\n下面就进入正题啦\n##用[Code Combat](https://cn.codecombat.com/)来过渡javascript\n\n![Paste_Image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf2a4c9bf49ce?w=700&h=339&f=png&s=278960)\n让一个小孩系统的学习他们的第一种编程语言的网站就是 [Code Combat](https://codecombat.com/)，它支持python和javascript。\n这个平台通过一种让小孩通过游戏的方式学习代码，让孩子通过javascript解决谜题，打败怪兽。甚至对我们成年人来说也是非常有趣的。虽然游戏的方式使他有趣，但是他也有短板，不够深入，但用来入门和培养兴趣还是不错的。\n\n###非结构化的js编程\n\n为了让小孩开始他们的第一个javascript应用，我们可以通过 [Codepen](https://codepen.io/)或者 [JS Fiddle](https://jsfiddle.net/)这样的在线编辑器而非专业性的编辑器类似webstorm等。当然，大多数程序员都知道这些在线网站。我们可以让孩子从简单的开始，比如dom操作，数字生成器，简单的计算器等。大多数孩子都喜欢交互式的，图形化的东西，这都非常时候只需要浏览器的javascript!\n\n### [JS With PlayCanvas](https://playcanvas.com/)来提升\n\n![Paste_Image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf2a4c9c4f2ba?w=600&h=342&f=png&s=16187)\n对于我们的更高级的学生，一个很酷的选择就是一个三维引擎 [Play Canvas](https://playcanvas.com/)。当你说“三维”时，你已经钓了90%个孩子，如果你加上“游戏引擎”，你就成功了！[Play Canvas](https://playcanvas.com/)支持刚体物理模拟，处理三维音频(没错！)，三维动画，和大量其他东西，如果你有时间看它。它有一套很好的教程，你一定要看看。\n\n当你快速过滤这个网站，一些实例或甚至只是阅读官方说明，你会感觉到这对于孩子是否太难了。该工具本身可以是一个陡峭的坡道，特别是对于孩子们，所以我们在平衡工具学习和学习的时候总是很谨慎。家长可能需要为一些孩子做一些准备工作-从零开始创建一个三维应用程序对于大多数孩子来说都是相当困难的。\n好啦，今天介绍到这里，如果有不理解的欢迎私信留言，我会一一回的。\n\n参考[原文](https://dzone.com/articles/teaching-kids-javascript)","slug":"如何让小孩学习javascript","published":1,"updated":"2019-04-10T02:31:49.204Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzkil000ojgf25aoy1os6","content":"<p>最近少儿编程培训好像有点热了，开发思维，兴趣爱好等培训班的各类理由让家长不由动心。对于不会编程的家长来说，这是一个不错的学习平台，我也研究过一段时间，确实不错，对小孩的各方面能力都有一定程度的提高，<br>但对于程序员，我觉得还是尽量自己来教，毕竟还能给小孩充分的沟通和陪伴时间，也能给自己不小的启发和进步。<br>所以我最近看到一些不错的JS学习资源，可以提高小孩的学习兴趣，当然这些学习网站也同样适用于成人，因为的确是不错的资源。<br>首先，如果你的小孩没有接触过任何编程，可以通过<a href=\"https://scratch.mit.edu/download\" target=\"_blank\" rel=\"noopener\">scratch</a>或者<a href=\"http://www.scratchjr.org/about\" target=\"_blank\" rel=\"noopener\">scratchjr</a>(平板版的scratch)来入门，别担心，都是一些简单有趣的动画，也没有很复杂的语法，对小孩理解编程思想很有用。官网和其他网站都有大量的实例和教学，社区也很友好。</p>\n<p>下面就进入正题啦</p>\n<p>##用<a href=\"https://cn.codecombat.com/\" target=\"_blank\" rel=\"noopener\">Code Combat</a>来过渡javascript</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf2a4c9bf49ce?w=700&amp;h=339&amp;f=png&amp;s=278960\" alt=\"Paste_Image.png\"><br>让一个小孩系统的学习他们的第一种编程语言的网站就是 <a href=\"https://codecombat.com/\" target=\"_blank\" rel=\"noopener\">Code Combat</a>，它支持python和javascript。<br>这个平台通过一种让小孩通过游戏的方式学习代码，让孩子通过javascript解决谜题，打败怪兽。甚至对我们成年人来说也是非常有趣的。虽然游戏的方式使他有趣，但是他也有短板，不够深入，但用来入门和培养兴趣还是不错的。</p>\n<p>###非结构化的js编程</p>\n<p>为了让小孩开始他们的第一个javascript应用，我们可以通过 <a href=\"https://codepen.io/\" target=\"_blank\" rel=\"noopener\">Codepen</a>或者 <a href=\"https://jsfiddle.net/\" target=\"_blank\" rel=\"noopener\">JS Fiddle</a>这样的在线编辑器而非专业性的编辑器类似webstorm等。当然，大多数程序员都知道这些在线网站。我们可以让孩子从简单的开始，比如dom操作，数字生成器，简单的计算器等。大多数孩子都喜欢交互式的，图形化的东西，这都非常时候只需要浏览器的javascript!</p>\n<h3 id=\"JS-With-PlayCanvas来提升\"><a href=\"#JS-With-PlayCanvas来提升\" class=\"headerlink\" title=\"JS With PlayCanvas来提升\"></a><a href=\"https://playcanvas.com/\" target=\"_blank\" rel=\"noopener\">JS With PlayCanvas</a>来提升</h3><p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf2a4c9c4f2ba?w=600&amp;h=342&amp;f=png&amp;s=16187\" alt=\"Paste_Image.png\"><br>对于我们的更高级的学生，一个很酷的选择就是一个三维引擎 <a href=\"https://playcanvas.com/\" target=\"_blank\" rel=\"noopener\">Play Canvas</a>。当你说“三维”时，你已经钓了90%个孩子，如果你加上“游戏引擎”，你就成功了！<a href=\"https://playcanvas.com/\" target=\"_blank\" rel=\"noopener\">Play Canvas</a>支持刚体物理模拟，处理三维音频(没错！)，三维动画，和大量其他东西，如果你有时间看它。它有一套很好的教程，你一定要看看。</p>\n<p>当你快速过滤这个网站，一些实例或甚至只是阅读官方说明，你会感觉到这对于孩子是否太难了。该工具本身可以是一个陡峭的坡道，特别是对于孩子们，所以我们在平衡工具学习和学习的时候总是很谨慎。家长可能需要为一些孩子做一些准备工作-从零开始创建一个三维应用程序对于大多数孩子来说都是相当困难的。<br>好啦，今天介绍到这里，如果有不理解的欢迎私信留言，我会一一回的。</p>\n<p>参考<a href=\"https://dzone.com/articles/teaching-kids-javascript\" target=\"_blank\" rel=\"noopener\">原文</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近少儿编程培训好像有点热了，开发思维，兴趣爱好等培训班的各类理由让家长不由动心。对于不会编程的家长来说，这是一个不错的学习平台，我也研究过一段时间，确实不错，对小孩的各方面能力都有一定程度的提高，<br>但对于程序员，我觉得还是尽量自己来教，毕竟还能给小孩充分的沟通和陪伴时间，也能给自己不小的启发和进步。<br>所以我最近看到一些不错的JS学习资源，可以提高小孩的学习兴趣，当然这些学习网站也同样适用于成人，因为的确是不错的资源。<br>首先，如果你的小孩没有接触过任何编程，可以通过<a href=\"https://scratch.mit.edu/download\" target=\"_blank\" rel=\"noopener\">scratch</a>或者<a href=\"http://www.scratchjr.org/about\" target=\"_blank\" rel=\"noopener\">scratchjr</a>(平板版的scratch)来入门，别担心，都是一些简单有趣的动画，也没有很复杂的语法，对小孩理解编程思想很有用。官网和其他网站都有大量的实例和教学，社区也很友好。</p>\n<p>下面就进入正题啦</p>\n<p>##用<a href=\"https://cn.codecombat.com/\" target=\"_blank\" rel=\"noopener\">Code Combat</a>来过渡javascript</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf2a4c9bf49ce?w=700&amp;h=339&amp;f=png&amp;s=278960\" alt=\"Paste_Image.png\"><br>让一个小孩系统的学习他们的第一种编程语言的网站就是 <a href=\"https://codecombat.com/\" target=\"_blank\" rel=\"noopener\">Code Combat</a>，它支持python和javascript。<br>这个平台通过一种让小孩通过游戏的方式学习代码，让孩子通过javascript解决谜题，打败怪兽。甚至对我们成年人来说也是非常有趣的。虽然游戏的方式使他有趣，但是他也有短板，不够深入，但用来入门和培养兴趣还是不错的。</p>\n<p>###非结构化的js编程</p>\n<p>为了让小孩开始他们的第一个javascript应用，我们可以通过 <a href=\"https://codepen.io/\" target=\"_blank\" rel=\"noopener\">Codepen</a>或者 <a href=\"https://jsfiddle.net/\" target=\"_blank\" rel=\"noopener\">JS Fiddle</a>这样的在线编辑器而非专业性的编辑器类似webstorm等。当然，大多数程序员都知道这些在线网站。我们可以让孩子从简单的开始，比如dom操作，数字生成器，简单的计算器等。大多数孩子都喜欢交互式的，图形化的东西，这都非常时候只需要浏览器的javascript!</p>\n<h3 id=\"JS-With-PlayCanvas来提升\"><a href=\"#JS-With-PlayCanvas来提升\" class=\"headerlink\" title=\"JS With PlayCanvas来提升\"></a><a href=\"https://playcanvas.com/\" target=\"_blank\" rel=\"noopener\">JS With PlayCanvas</a>来提升</h3><p><img src=\"https://user-gold-cdn.xitu.io/2018/12/21/167cf2a4c9c4f2ba?w=600&amp;h=342&amp;f=png&amp;s=16187\" alt=\"Paste_Image.png\"><br>对于我们的更高级的学生，一个很酷的选择就是一个三维引擎 <a href=\"https://playcanvas.com/\" target=\"_blank\" rel=\"noopener\">Play Canvas</a>。当你说“三维”时，你已经钓了90%个孩子，如果你加上“游戏引擎”，你就成功了！<a href=\"https://playcanvas.com/\" target=\"_blank\" rel=\"noopener\">Play Canvas</a>支持刚体物理模拟，处理三维音频(没错！)，三维动画，和大量其他东西，如果你有时间看它。它有一套很好的教程，你一定要看看。</p>\n<p>当你快速过滤这个网站，一些实例或甚至只是阅读官方说明，你会感觉到这对于孩子是否太难了。该工具本身可以是一个陡峭的坡道，特别是对于孩子们，所以我们在平衡工具学习和学习的时候总是很谨慎。家长可能需要为一些孩子做一些准备工作-从零开始创建一个三维应用程序对于大多数孩子来说都是相当困难的。<br>好啦，今天介绍到这里，如果有不理解的欢迎私信留言，我会一一回的。</p>\n<p>参考<a href=\"https://dzone.com/articles/teaching-kids-javascript\" target=\"_blank\" rel=\"noopener\">原文</a></p>\n"},{"title":"常用的一些git命令行","date":"2019-02-16T03:41:21.000Z","_content":"## 工作中常用的一些git命令行\n\n#### 相关概念\n\n| 四个库   | 四种文件状态                         |\n|:--------|-----------------------------------:|\n| 工作区   | Unstracked(未被跟踪的)              |\n|         | Modified(有修改的，和本地仓库快照不同) |\n| 暂存区   | staged(暂存状态)                    |\n| 本地仓库 | Unmodify(未改动)                    |\n| 远程仓库 |                                    |\n\n\n#### 克隆代码仓库\n\n* `git clone 仓库地址`\n\n远程地址为仓库地址\n***\n#### 暂存区操作\n\n* `git add 文件名` 添加文件到暂存区\n\n* `git add .` 添加所有（未被添加过但存在在仓库文件夹里的）文件到暂存区\n\n* `git rm 文件名` 从暂存区删除文件,文件会被删除\n\n* `git rm 文件名 -f` 从暂存区强制删除，文件会被删除\n\n* `git rm 文件名 --cached` 从暂存区删除，但是文件不会被删除，状态变为Unstracked\n\n* `git checkout -- 文件名` 从暂存区拉取文件覆盖到工作区\n\n* `git reset HEAD 文件名` 从本地仓库拉取文件覆盖到暂存区\n\n* `git mv 'oldName' 'newName'` 更改文件名\n\n* `git status` 获取仓库状态，包含四个库和文件状态\n\n* `git reset --hard HEAD^` 重置到上一个commit状态，覆盖staged和工作区\n\n* `git reset --hard <commitkey>` 重置到对应commit版本，覆盖staged和工作区\n\n##### 一些技巧\n*工作区误删文件（手动删除）*\n`git checkout -- 文件名` \n\n*暂存区误删文件，删除之后想恢复*\n`git reset HEAD 文件名 + git checkout -- 文件名`\n\n#### 本地仓库操作\n\n* `git commit -m 提交描述信息` 将暂存区里的改动提交到本地仓库， -m 参数表示带入提交描述信息，不加命令行会打开vim在让你输入\n\n* `git commit -a -m 提交描述信息` 将所有非Unstracked\b状态的文件改动提交到本地仓库，相当于`git add 改动文件 + git commit -m`\n\n* `git commit --amend` 补充上一次的提交\n\n#### 远程仓库操作\n\n* `git remote -v` 查看目前远程仓库地址\n\n* `git remote add origin 远程仓库地址` 添加远程仓库地址，已经有了的话会失败\n\n* `git remote origin` 删除远程仓库，解除关联\n\n* `git remote set-url origin 远程仓库地址` 设置远程仓库地址，可覆盖\n\n* `git push -u origin master` 推送本地仓库到远程仓库master分支，-u表示关联，之后可省略为`git push, git pull`\n\n* `git pull` 从远程仓库拉取到本地\n\n\n\n#### 基础操作流程图(不包含全部)\n![流程图](https://img-blog.csdn.net/20140417113336421)","source":"_posts/常用的一些git命令行.md","raw":"---\ntitle: 常用的一些git命令行\ndate: 2019-02-16 11:41:21\ntags:\n---\n## 工作中常用的一些git命令行\n\n#### 相关概念\n\n| 四个库   | 四种文件状态                         |\n|:--------|-----------------------------------:|\n| 工作区   | Unstracked(未被跟踪的)              |\n|         | Modified(有修改的，和本地仓库快照不同) |\n| 暂存区   | staged(暂存状态)                    |\n| 本地仓库 | Unmodify(未改动)                    |\n| 远程仓库 |                                    |\n\n\n#### 克隆代码仓库\n\n* `git clone 仓库地址`\n\n远程地址为仓库地址\n***\n#### 暂存区操作\n\n* `git add 文件名` 添加文件到暂存区\n\n* `git add .` 添加所有（未被添加过但存在在仓库文件夹里的）文件到暂存区\n\n* `git rm 文件名` 从暂存区删除文件,文件会被删除\n\n* `git rm 文件名 -f` 从暂存区强制删除，文件会被删除\n\n* `git rm 文件名 --cached` 从暂存区删除，但是文件不会被删除，状态变为Unstracked\n\n* `git checkout -- 文件名` 从暂存区拉取文件覆盖到工作区\n\n* `git reset HEAD 文件名` 从本地仓库拉取文件覆盖到暂存区\n\n* `git mv 'oldName' 'newName'` 更改文件名\n\n* `git status` 获取仓库状态，包含四个库和文件状态\n\n* `git reset --hard HEAD^` 重置到上一个commit状态，覆盖staged和工作区\n\n* `git reset --hard <commitkey>` 重置到对应commit版本，覆盖staged和工作区\n\n##### 一些技巧\n*工作区误删文件（手动删除）*\n`git checkout -- 文件名` \n\n*暂存区误删文件，删除之后想恢复*\n`git reset HEAD 文件名 + git checkout -- 文件名`\n\n#### 本地仓库操作\n\n* `git commit -m 提交描述信息` 将暂存区里的改动提交到本地仓库， -m 参数表示带入提交描述信息，不加命令行会打开vim在让你输入\n\n* `git commit -a -m 提交描述信息` 将所有非Unstracked\b状态的文件改动提交到本地仓库，相当于`git add 改动文件 + git commit -m`\n\n* `git commit --amend` 补充上一次的提交\n\n#### 远程仓库操作\n\n* `git remote -v` 查看目前远程仓库地址\n\n* `git remote add origin 远程仓库地址` 添加远程仓库地址，已经有了的话会失败\n\n* `git remote origin` 删除远程仓库，解除关联\n\n* `git remote set-url origin 远程仓库地址` 设置远程仓库地址，可覆盖\n\n* `git push -u origin master` 推送本地仓库到远程仓库master分支，-u表示关联，之后可省略为`git push, git pull`\n\n* `git pull` 从远程仓库拉取到本地\n\n\n\n#### 基础操作流程图(不包含全部)\n![流程图](https://img-blog.csdn.net/20140417113336421)","slug":"常用的一些git命令行","published":1,"updated":"2019-04-10T02:40:04.211Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzkil000pjgf2azvnmy06","content":"<h2 id=\"工作中常用的一些git命令行\"><a href=\"#工作中常用的一些git命令行\" class=\"headerlink\" title=\"工作中常用的一些git命令行\"></a>工作中常用的一些git命令行</h2><h4 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">四个库</th>\n<th style=\"text-align:right\">四种文件状态</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">工作区</td>\n<td style=\"text-align:right\">Unstracked(未被跟踪的)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:right\">Modified(有修改的，和本地仓库快照不同)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">暂存区</td>\n<td style=\"text-align:right\">staged(暂存状态)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">本地仓库</td>\n<td style=\"text-align:right\">Unmodify(未改动)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">远程仓库</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"克隆代码仓库\"><a href=\"#克隆代码仓库\" class=\"headerlink\" title=\"克隆代码仓库\"></a>克隆代码仓库</h4><ul>\n<li><code>git clone 仓库地址</code></li>\n</ul>\n<p>远程地址为仓库地址</p>\n<hr>\n<h4 id=\"暂存区操作\"><a href=\"#暂存区操作\" class=\"headerlink\" title=\"暂存区操作\"></a>暂存区操作</h4><ul>\n<li><p><code>git add 文件名</code> 添加文件到暂存区</p>\n</li>\n<li><p><code>git add .</code> 添加所有（未被添加过但存在在仓库文件夹里的）文件到暂存区</p>\n</li>\n<li><p><code>git rm 文件名</code> 从暂存区删除文件,文件会被删除</p>\n</li>\n<li><p><code>git rm 文件名 -f</code> 从暂存区强制删除，文件会被删除</p>\n</li>\n<li><p><code>git rm 文件名 --cached</code> 从暂存区删除，但是文件不会被删除，状态变为Unstracked</p>\n</li>\n<li><p><code>git checkout -- 文件名</code> 从暂存区拉取文件覆盖到工作区</p>\n</li>\n<li><p><code>git reset HEAD 文件名</code> 从本地仓库拉取文件覆盖到暂存区</p>\n</li>\n<li><p><code>git mv &#39;oldName&#39; &#39;newName&#39;</code> 更改文件名</p>\n</li>\n<li><p><code>git status</code> 获取仓库状态，包含四个库和文件状态</p>\n</li>\n<li><p><code>git reset --hard HEAD^</code> 重置到上一个commit状态，覆盖staged和工作区</p>\n</li>\n<li><p><code>git reset --hard &lt;commitkey&gt;</code> 重置到对应commit版本，覆盖staged和工作区</p>\n</li>\n</ul>\n<h5 id=\"一些技巧\"><a href=\"#一些技巧\" class=\"headerlink\" title=\"一些技巧\"></a>一些技巧</h5><p><em>工作区误删文件（手动删除）</em><br><code>git checkout -- 文件名</code> </p>\n<p><em>暂存区误删文件，删除之后想恢复</em><br><code>git reset HEAD 文件名 + git checkout -- 文件名</code></p>\n<h4 id=\"本地仓库操作\"><a href=\"#本地仓库操作\" class=\"headerlink\" title=\"本地仓库操作\"></a>本地仓库操作</h4><ul>\n<li><p><code>git commit -m 提交描述信息</code> 将暂存区里的改动提交到本地仓库， -m 参数表示带入提交描述信息，不加命令行会打开vim在让你输入</p>\n</li>\n<li><p><code>git commit -a -m 提交描述信息</code> 将所有非Unstracked\b状态的文件改动提交到本地仓库，相当于<code>git add 改动文件 + git commit -m</code></p>\n</li>\n<li><p><code>git commit --amend</code> 补充上一次的提交</p>\n</li>\n</ul>\n<h4 id=\"远程仓库操作\"><a href=\"#远程仓库操作\" class=\"headerlink\" title=\"远程仓库操作\"></a>远程仓库操作</h4><ul>\n<li><p><code>git remote -v</code> 查看目前远程仓库地址</p>\n</li>\n<li><p><code>git remote add origin 远程仓库地址</code> 添加远程仓库地址，已经有了的话会失败</p>\n</li>\n<li><p><code>git remote origin</code> 删除远程仓库，解除关联</p>\n</li>\n<li><p><code>git remote set-url origin 远程仓库地址</code> 设置远程仓库地址，可覆盖</p>\n</li>\n<li><p><code>git push -u origin master</code> 推送本地仓库到远程仓库master分支，-u表示关联，之后可省略为<code>git push, git pull</code></p>\n</li>\n<li><p><code>git pull</code> 从远程仓库拉取到本地</p>\n</li>\n</ul>\n<h4 id=\"基础操作流程图-不包含全部\"><a href=\"#基础操作流程图-不包含全部\" class=\"headerlink\" title=\"基础操作流程图(不包含全部)\"></a>基础操作流程图(不包含全部)</h4><p><img src=\"https://img-blog.csdn.net/20140417113336421\" alt=\"流程图\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"工作中常用的一些git命令行\"><a href=\"#工作中常用的一些git命令行\" class=\"headerlink\" title=\"工作中常用的一些git命令行\"></a>工作中常用的一些git命令行</h2><h4 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">四个库</th>\n<th style=\"text-align:right\">四种文件状态</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">工作区</td>\n<td style=\"text-align:right\">Unstracked(未被跟踪的)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:right\">Modified(有修改的，和本地仓库快照不同)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">暂存区</td>\n<td style=\"text-align:right\">staged(暂存状态)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">本地仓库</td>\n<td style=\"text-align:right\">Unmodify(未改动)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">远程仓库</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"克隆代码仓库\"><a href=\"#克隆代码仓库\" class=\"headerlink\" title=\"克隆代码仓库\"></a>克隆代码仓库</h4><ul>\n<li><code>git clone 仓库地址</code></li>\n</ul>\n<p>远程地址为仓库地址</p>\n<hr>\n<h4 id=\"暂存区操作\"><a href=\"#暂存区操作\" class=\"headerlink\" title=\"暂存区操作\"></a>暂存区操作</h4><ul>\n<li><p><code>git add 文件名</code> 添加文件到暂存区</p>\n</li>\n<li><p><code>git add .</code> 添加所有（未被添加过但存在在仓库文件夹里的）文件到暂存区</p>\n</li>\n<li><p><code>git rm 文件名</code> 从暂存区删除文件,文件会被删除</p>\n</li>\n<li><p><code>git rm 文件名 -f</code> 从暂存区强制删除，文件会被删除</p>\n</li>\n<li><p><code>git rm 文件名 --cached</code> 从暂存区删除，但是文件不会被删除，状态变为Unstracked</p>\n</li>\n<li><p><code>git checkout -- 文件名</code> 从暂存区拉取文件覆盖到工作区</p>\n</li>\n<li><p><code>git reset HEAD 文件名</code> 从本地仓库拉取文件覆盖到暂存区</p>\n</li>\n<li><p><code>git mv &#39;oldName&#39; &#39;newName&#39;</code> 更改文件名</p>\n</li>\n<li><p><code>git status</code> 获取仓库状态，包含四个库和文件状态</p>\n</li>\n<li><p><code>git reset --hard HEAD^</code> 重置到上一个commit状态，覆盖staged和工作区</p>\n</li>\n<li><p><code>git reset --hard &lt;commitkey&gt;</code> 重置到对应commit版本，覆盖staged和工作区</p>\n</li>\n</ul>\n<h5 id=\"一些技巧\"><a href=\"#一些技巧\" class=\"headerlink\" title=\"一些技巧\"></a>一些技巧</h5><p><em>工作区误删文件（手动删除）</em><br><code>git checkout -- 文件名</code> </p>\n<p><em>暂存区误删文件，删除之后想恢复</em><br><code>git reset HEAD 文件名 + git checkout -- 文件名</code></p>\n<h4 id=\"本地仓库操作\"><a href=\"#本地仓库操作\" class=\"headerlink\" title=\"本地仓库操作\"></a>本地仓库操作</h4><ul>\n<li><p><code>git commit -m 提交描述信息</code> 将暂存区里的改动提交到本地仓库， -m 参数表示带入提交描述信息，不加命令行会打开vim在让你输入</p>\n</li>\n<li><p><code>git commit -a -m 提交描述信息</code> 将所有非Unstracked\b状态的文件改动提交到本地仓库，相当于<code>git add 改动文件 + git commit -m</code></p>\n</li>\n<li><p><code>git commit --amend</code> 补充上一次的提交</p>\n</li>\n</ul>\n<h4 id=\"远程仓库操作\"><a href=\"#远程仓库操作\" class=\"headerlink\" title=\"远程仓库操作\"></a>远程仓库操作</h4><ul>\n<li><p><code>git remote -v</code> 查看目前远程仓库地址</p>\n</li>\n<li><p><code>git remote add origin 远程仓库地址</code> 添加远程仓库地址，已经有了的话会失败</p>\n</li>\n<li><p><code>git remote origin</code> 删除远程仓库，解除关联</p>\n</li>\n<li><p><code>git remote set-url origin 远程仓库地址</code> 设置远程仓库地址，可覆盖</p>\n</li>\n<li><p><code>git push -u origin master</code> 推送本地仓库到远程仓库master分支，-u表示关联，之后可省略为<code>git push, git pull</code></p>\n</li>\n<li><p><code>git pull</code> 从远程仓库拉取到本地</p>\n</li>\n</ul>\n<h4 id=\"基础操作流程图-不包含全部\"><a href=\"#基础操作流程图-不包含全部\" class=\"headerlink\" title=\"基础操作流程图(不包含全部)\"></a>基础操作流程图(不包含全部)</h4><p><img src=\"https://img-blog.csdn.net/20140417113336421\" alt=\"流程图\"></p>\n"},{"title":"我从没理解过的Javascript闭包","date":"2019-01-03T05:20:03.000Z","_content":"> 原文地址: https://medium.com/dailyjs/i-never-understood-javascript-closures-9663703368e8","source":"_posts/我从没理解过的Javascript闭包.md","raw":"---\ntitle: 我从没理解过的Javascript闭包\ndate: 2019-01-03 13:20:03\ntags: Javascript 闭包\n---\n> 原文地址: https://medium.com/dailyjs/i-never-understood-javascript-closures-9663703368e8","slug":"我从没理解过的Javascript闭包","published":1,"updated":"2019-04-10T02:31:49.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzkim000qjgf2o4z996l1","content":"<blockquote>\n<p>原文地址: <a href=\"https://medium.com/dailyjs/i-never-understood-javascript-closures-9663703368e8\" target=\"_blank\" rel=\"noopener\">https://medium.com/dailyjs/i-never-understood-javascript-closures-9663703368e8</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>原文地址: <a href=\"https://medium.com/dailyjs/i-never-understood-javascript-closures-9663703368e8\" target=\"_blank\" rel=\"noopener\">https://medium.com/dailyjs/i-never-understood-javascript-closures-9663703368e8</a></p>\n</blockquote>\n"},{"title":"看懂js中this关键字的指向问题","date":"2018-04-06T06:07:13.000Z","_content":"this总是指向函数的直接调用者（而非间接调用者）；如果有new关键字，this指向new出来的那个对象；在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；\n通俗的讲，因为ｔｈｉｓ只存在于函数中，而函数是需要被调用的，然后ｔｈｉｓ是谁（对象）调用函数就指向谁（对象）。下面我们看看不同情况下的ｔｈｉｓ指向情况。\n\n１）单纯的函数调用\n```\nfunction test(){ \n    this.x = 1; \n    alert(this.x)／／结果为：１\n };\ntest();／／这里window调用了test函数， window.x即this.x\nalert(this.x) ;／／结果为：１\nalert('x' in window);／／结果为：true\n``\n\n２）函数作为对象的方法调用\n```\nvar test = {\n    a:1,\n    b:function(){\n        alert(this.a);\n    }\n};\ntest.b();／／结果为：1　test调用了函数b，this指向test\nalert(this.a);//结果为：undefined　 window调用了alert函数，this指向 window而window里并没有a这个属性。\n```\n注：在非严格模式下，this没有正确指向，则指向window对象，在严格模式下，没有正确指向，为 undefined。默认就是非严格模式。\n\n3)作为构造函数调用\n```\n    function test(){\n        this.a = 1;\n    };\n    var test2 = new test();\n    alert(test2.a);//结果为：1\n```\n这里this指向的是构造的新对象，也就是 test2，所以test2也有了属性a并等于1。\n\n4)apply()、call() 调用\n\n```\n    var a = 0,\n        test1 = {\n            a:1,\n            fun:function(){\n                alert(this.a);\n            }\n        },\n        test2 = {\n            a:2\n        };\n    test1.fun();//结果为：1\n    test1.fun.call(test2);//结果为：2\n    test1.fun.call();//结果为：0\n```\n\n这里的三次调用，this分别指向test1、test2和window。第一种前面已经提到了，第二种是通过call或者apply方法使fun中原本指向test1的this变成了指向test2（即call、apply方法的第一个参数）。第三种情况属于第一个参数为空（好像为undefined时也会指向window）时，会默认指向window，..call() =》 ..call(window)。\n\n","source":"_posts/看懂js中this关键字的指向问题.md","raw":"---\ntitle: 看懂js中this关键字的指向问题\ndate: 2018-04-06 14:07:13\ntags:\n---\nthis总是指向函数的直接调用者（而非间接调用者）；如果有new关键字，this指向new出来的那个对象；在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；\n通俗的讲，因为ｔｈｉｓ只存在于函数中，而函数是需要被调用的，然后ｔｈｉｓ是谁（对象）调用函数就指向谁（对象）。下面我们看看不同情况下的ｔｈｉｓ指向情况。\n\n１）单纯的函数调用\n```\nfunction test(){ \n    this.x = 1; \n    alert(this.x)／／结果为：１\n };\ntest();／／这里window调用了test函数， window.x即this.x\nalert(this.x) ;／／结果为：１\nalert('x' in window);／／结果为：true\n``\n\n２）函数作为对象的方法调用\n```\nvar test = {\n    a:1,\n    b:function(){\n        alert(this.a);\n    }\n};\ntest.b();／／结果为：1　test调用了函数b，this指向test\nalert(this.a);//结果为：undefined　 window调用了alert函数，this指向 window而window里并没有a这个属性。\n```\n注：在非严格模式下，this没有正确指向，则指向window对象，在严格模式下，没有正确指向，为 undefined。默认就是非严格模式。\n\n3)作为构造函数调用\n```\n    function test(){\n        this.a = 1;\n    };\n    var test2 = new test();\n    alert(test2.a);//结果为：1\n```\n这里this指向的是构造的新对象，也就是 test2，所以test2也有了属性a并等于1。\n\n4)apply()、call() 调用\n\n```\n    var a = 0,\n        test1 = {\n            a:1,\n            fun:function(){\n                alert(this.a);\n            }\n        },\n        test2 = {\n            a:2\n        };\n    test1.fun();//结果为：1\n    test1.fun.call(test2);//结果为：2\n    test1.fun.call();//结果为：0\n```\n\n这里的三次调用，this分别指向test1、test2和window。第一种前面已经提到了，第二种是通过call或者apply方法使fun中原本指向test1的this变成了指向test2（即call、apply方法的第一个参数）。第三种情况属于第一个参数为空（好像为undefined时也会指向window）时，会默认指向window，..call() =》 ..call(window)。\n\n","slug":"看懂js中this关键字的指向问题","published":1,"updated":"2019-04-10T02:31:49.212Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzkin000rjgf2yw5a921p","content":"<p>this总是指向函数的直接调用者（而非间接调用者）；如果有new关键字，this指向new出来的那个对象；在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；<br>通俗的讲，因为ｔｈｉｓ只存在于函数中，而函数是需要被调用的，然后ｔｈｉｓ是谁（对象）调用函数就指向谁（对象）。下面我们看看不同情况下的ｔｈｉｓ指向情况。</p>\n<p>１）单纯的函数调用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test()&#123; </span><br><span class=\"line\">    this.x = 1; </span><br><span class=\"line\">    alert(this.x)／／结果为：１</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\">test();／／这里window调用了test函数， window.x即this.x</span><br><span class=\"line\">alert(this.x) ;／／结果为：１</span><br><span class=\"line\">alert(&apos;x&apos; in window);／／结果为：true</span><br><span class=\"line\">``</span><br><span class=\"line\"></span><br><span class=\"line\">２）函数作为对象的方法调用</span><br></pre></td></tr></table></figure></p>\n<p>var test = {<br>    a:1,<br>    b:function(){<br>        alert(this.a);<br>    }<br>};<br>test.b();／／结果为：1　test调用了函数b，this指向test<br>alert(this.a);//结果为：undefined　 window调用了alert函数，this指向 window而window里并没有a这个属性。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注：在非严格模式下，this没有正确指向，则指向window对象，在严格模式下，没有正确指向，为 undefined。默认就是非严格模式。</span><br><span class=\"line\"></span><br><span class=\"line\">3)作为构造函数调用</span><br></pre></td></tr></table></figure></p>\n<pre><code>function test(){\n    this.a = 1;\n};\nvar test2 = new test();\nalert(test2.a);//结果为：1\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这里this指向的是构造的新对象，也就是 test2，所以test2也有了属性a并等于1。</span><br><span class=\"line\"></span><br><span class=\"line\">4)apply()、call() 调用</span><br></pre></td></tr></table></figure>\n<pre><code>var a = 0,\n    test1 = {\n        a:1,\n        fun:function(){\n            alert(this.a);\n        }\n    },\n    test2 = {\n        a:2\n    };\ntest1.fun();//结果为：1\ntest1.fun.call(test2);//结果为：2\ntest1.fun.call();//结果为：0\n</code></pre><p><code>`</code></p>\n<p>这里的三次调用，this分别指向test1、test2和window。第一种前面已经提到了，第二种是通过call或者apply方法使fun中原本指向test1的this变成了指向test2（即call、apply方法的第一个参数）。第三种情况属于第一个参数为空（好像为undefined时也会指向window）时，会默认指向window，..call() =》 ..call(window)。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>this总是指向函数的直接调用者（而非间接调用者）；如果有new关键字，this指向new出来的那个对象；在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；<br>通俗的讲，因为ｔｈｉｓ只存在于函数中，而函数是需要被调用的，然后ｔｈｉｓ是谁（对象）调用函数就指向谁（对象）。下面我们看看不同情况下的ｔｈｉｓ指向情况。</p>\n<p>１）单纯的函数调用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test()&#123; </span><br><span class=\"line\">    this.x = 1; </span><br><span class=\"line\">    alert(this.x)／／结果为：１</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\">test();／／这里window调用了test函数， window.x即this.x</span><br><span class=\"line\">alert(this.x) ;／／结果为：１</span><br><span class=\"line\">alert(&apos;x&apos; in window);／／结果为：true</span><br><span class=\"line\">``</span><br><span class=\"line\"></span><br><span class=\"line\">２）函数作为对象的方法调用</span><br></pre></td></tr></table></figure></p>\n<p>var test = {<br>    a:1,<br>    b:function(){<br>        alert(this.a);<br>    }<br>};<br>test.b();／／结果为：1　test调用了函数b，this指向test<br>alert(this.a);//结果为：undefined　 window调用了alert函数，this指向 window而window里并没有a这个属性。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注：在非严格模式下，this没有正确指向，则指向window对象，在严格模式下，没有正确指向，为 undefined。默认就是非严格模式。</span><br><span class=\"line\"></span><br><span class=\"line\">3)作为构造函数调用</span><br></pre></td></tr></table></figure></p>\n<pre><code>function test(){\n    this.a = 1;\n};\nvar test2 = new test();\nalert(test2.a);//结果为：1\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这里this指向的是构造的新对象，也就是 test2，所以test2也有了属性a并等于1。</span><br><span class=\"line\"></span><br><span class=\"line\">4)apply()、call() 调用</span><br></pre></td></tr></table></figure>\n<pre><code>var a = 0,\n    test1 = {\n        a:1,\n        fun:function(){\n            alert(this.a);\n        }\n    },\n    test2 = {\n        a:2\n    };\ntest1.fun();//结果为：1\ntest1.fun.call(test2);//结果为：2\ntest1.fun.call();//结果为：0\n</code></pre><p><code>`</code></p>\n<p>这里的三次调用，this分别指向test1、test2和window。第一种前面已经提到了，第二种是通过call或者apply方法使fun中原本指向test1的this变成了指向test2（即call、apply方法的第一个参数）。第三种情况属于第一个参数为空（好像为undefined时也会指向window）时，会默认指向window，..call() =》 ..call(window)。</p>\n"},{"title":"浏览器缓存的了解","date":"2019-04-10T02:44:03.000Z","_content":"1. 浏览器缓存 主要指的是 htttp的缓存 ，即协议层的缓存\n2. 协议层的缓存 分为 强制缓存 和 对比缓存\n\n强制缓存：\n概念：只有当 缓存失效时 才会向服务器获取最新资源。\n方式： Expires  和  Cache-Control\n\n1.Expires：\n  Expires: Thu, 10 Nov 2017 08:45:11 GMT\n绝对时间，受客户端本地时间的影响，修改后会导致浏览器的缓存判断失效，而重新请求。并且 修改后会导致 客户端 与服务端时间不一致，使得缓存失效\n\n2.Cache-Control：\n例：  Response Header：\n        Cache-Control：max-age=25454500\nmax-age：即最大有效时间，在上面的例子中我们可以看到\nno-cache：表示没有缓存，即告诉浏览器该资源并没有设置缓存\ns-maxage：同max-age，但是仅用于共享缓存，如CDN缓存\npublic：多用户共享缓存，默认设置\nprivate：不能够多用户共享，HTTP认证之后，字段会自动转换成private。\n相对时间，所以不会受客户端的 影响。可配置性强。\n\n对比缓存：\n概念：简单来说就是 先去找缓存，然后获取缓存的标识，拿着标识去服务请求 确认该数据是否更新过，\n如果更新了 就返回最新的数据。否则 返回304，从缓存中获取数据。\n方式：Last-Modified和If-Modified-Since  和 Etag\n\nLast-Modified：服务器告知客户端，资源最后一次被修改的时间\n例： Response Header：\n      Last-Modified: Thu, 10 Nov 2015 08:45:11 GMT\n      \nIf-Modified-Since：\n再次请求时，请求头中带有该字段，服务器会将If-Modified-Since的值与Last-Modified字段进行对比，\n如果相等，则表示未修改，响应304；\n反之，则表示修改了，响应200状态码，返回数据。\n\nEtag：就是个hash值。每次随着数据资源返回，来回传递，进行识别对比，来判断是否返回304或者数据资源\n\n","source":"_posts/浏览器缓存的了解.md","raw":"---\ntitle: 浏览器缓存的了解\ndate: 2019-04-10 10:44:03\ntags:\n---\n1. 浏览器缓存 主要指的是 htttp的缓存 ，即协议层的缓存\n2. 协议层的缓存 分为 强制缓存 和 对比缓存\n\n强制缓存：\n概念：只有当 缓存失效时 才会向服务器获取最新资源。\n方式： Expires  和  Cache-Control\n\n1.Expires：\n  Expires: Thu, 10 Nov 2017 08:45:11 GMT\n绝对时间，受客户端本地时间的影响，修改后会导致浏览器的缓存判断失效，而重新请求。并且 修改后会导致 客户端 与服务端时间不一致，使得缓存失效\n\n2.Cache-Control：\n例：  Response Header：\n        Cache-Control：max-age=25454500\nmax-age：即最大有效时间，在上面的例子中我们可以看到\nno-cache：表示没有缓存，即告诉浏览器该资源并没有设置缓存\ns-maxage：同max-age，但是仅用于共享缓存，如CDN缓存\npublic：多用户共享缓存，默认设置\nprivate：不能够多用户共享，HTTP认证之后，字段会自动转换成private。\n相对时间，所以不会受客户端的 影响。可配置性强。\n\n对比缓存：\n概念：简单来说就是 先去找缓存，然后获取缓存的标识，拿着标识去服务请求 确认该数据是否更新过，\n如果更新了 就返回最新的数据。否则 返回304，从缓存中获取数据。\n方式：Last-Modified和If-Modified-Since  和 Etag\n\nLast-Modified：服务器告知客户端，资源最后一次被修改的时间\n例： Response Header：\n      Last-Modified: Thu, 10 Nov 2015 08:45:11 GMT\n      \nIf-Modified-Since：\n再次请求时，请求头中带有该字段，服务器会将If-Modified-Since的值与Last-Modified字段进行对比，\n如果相等，则表示未修改，响应304；\n反之，则表示修改了，响应200状态码，返回数据。\n\nEtag：就是个hash值。每次随着数据资源返回，来回传递，进行识别对比，来判断是否返回304或者数据资源\n\n","slug":"浏览器缓存的了解","published":1,"updated":"2019-04-10T02:44:14.612Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzkix000tjgf2vl35tku2","content":"<ol>\n<li>浏览器缓存 主要指的是 htttp的缓存 ，即协议层的缓存</li>\n<li>协议层的缓存 分为 强制缓存 和 对比缓存</li>\n</ol>\n<p>强制缓存：<br>概念：只有当 缓存失效时 才会向服务器获取最新资源。<br>方式： Expires  和  Cache-Control</p>\n<p>1.Expires：<br>  Expires: Thu, 10 Nov 2017 08:45:11 GMT<br>绝对时间，受客户端本地时间的影响，修改后会导致浏览器的缓存判断失效，而重新请求。并且 修改后会导致 客户端 与服务端时间不一致，使得缓存失效</p>\n<p>2.Cache-Control：<br>例：  Response Header：<br>        Cache-Control：max-age=25454500<br>max-age：即最大有效时间，在上面的例子中我们可以看到<br>no-cache：表示没有缓存，即告诉浏览器该资源并没有设置缓存<br>s-maxage：同max-age，但是仅用于共享缓存，如CDN缓存<br>public：多用户共享缓存，默认设置<br>private：不能够多用户共享，HTTP认证之后，字段会自动转换成private。<br>相对时间，所以不会受客户端的 影响。可配置性强。</p>\n<p>对比缓存：<br>概念：简单来说就是 先去找缓存，然后获取缓存的标识，拿着标识去服务请求 确认该数据是否更新过，<br>如果更新了 就返回最新的数据。否则 返回304，从缓存中获取数据。<br>方式：Last-Modified和If-Modified-Since  和 Etag</p>\n<p>Last-Modified：服务器告知客户端，资源最后一次被修改的时间<br>例： Response Header：<br>      Last-Modified: Thu, 10 Nov 2015 08:45:11 GMT</p>\n<p>If-Modified-Since：<br>再次请求时，请求头中带有该字段，服务器会将If-Modified-Since的值与Last-Modified字段进行对比，<br>如果相等，则表示未修改，响应304；<br>反之，则表示修改了，响应200状态码，返回数据。</p>\n<p>Etag：就是个hash值。每次随着数据资源返回，来回传递，进行识别对比，来判断是否返回304或者数据资源</p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>浏览器缓存 主要指的是 htttp的缓存 ，即协议层的缓存</li>\n<li>协议层的缓存 分为 强制缓存 和 对比缓存</li>\n</ol>\n<p>强制缓存：<br>概念：只有当 缓存失效时 才会向服务器获取最新资源。<br>方式： Expires  和  Cache-Control</p>\n<p>1.Expires：<br>  Expires: Thu, 10 Nov 2017 08:45:11 GMT<br>绝对时间，受客户端本地时间的影响，修改后会导致浏览器的缓存判断失效，而重新请求。并且 修改后会导致 客户端 与服务端时间不一致，使得缓存失效</p>\n<p>2.Cache-Control：<br>例：  Response Header：<br>        Cache-Control：max-age=25454500<br>max-age：即最大有效时间，在上面的例子中我们可以看到<br>no-cache：表示没有缓存，即告诉浏览器该资源并没有设置缓存<br>s-maxage：同max-age，但是仅用于共享缓存，如CDN缓存<br>public：多用户共享缓存，默认设置<br>private：不能够多用户共享，HTTP认证之后，字段会自动转换成private。<br>相对时间，所以不会受客户端的 影响。可配置性强。</p>\n<p>对比缓存：<br>概念：简单来说就是 先去找缓存，然后获取缓存的标识，拿着标识去服务请求 确认该数据是否更新过，<br>如果更新了 就返回最新的数据。否则 返回304，从缓存中获取数据。<br>方式：Last-Modified和If-Modified-Since  和 Etag</p>\n<p>Last-Modified：服务器告知客户端，资源最后一次被修改的时间<br>例： Response Header：<br>      Last-Modified: Thu, 10 Nov 2015 08:45:11 GMT</p>\n<p>If-Modified-Since：<br>再次请求时，请求头中带有该字段，服务器会将If-Modified-Since的值与Last-Modified字段进行对比，<br>如果相等，则表示未修改，响应304；<br>反之，则表示修改了，响应200状态码，返回数据。</p>\n<p>Etag：就是个hash值。每次随着数据资源返回，来回传递，进行识别对比，来判断是否返回304或者数据资源</p>\n"},{"title":"项目管理师学习-信息化和信息系统1","date":"2019-01-07T14:17:55.000Z","_content":"\n## 第一章 信息化和信息系统1\n> 本章节只考上午选择题，约22分左右\n### 1.1 信息系统与信息化\n\n#### 1.1.1 信息的基本概念\n\n##### 信息的质量属性：\n\n1. 精确性：对事物描述的精准程度\n2. 完整性：对事物描述的全面程度\n3. 可靠性：信息的来源，采集方法，传输过程是可以信任的，符合预期的\n4. 及时性：获得信息的时刻与事情发生时刻的间隔时长\n5. 经济性：信息获取传输带来的成本在可接受的范围内\n6. 可验证性：信息的主要质量属性可以被证实或者证伪的程度\n7. 安全性：在信息的生命周期内，信息可以被非授权访问的可能性。可能性越低，信息越安全\n\n##### 信息的传输模型\n\n> 信息是有价值的一种客观存在。信息技术主要未解决信息的采集、加工、存储、传输、处理、计算、转换、表现等问题而不断繁荣发展。信息系统只有流动起来，才能体现价值，因此信息的传输技术（通常指通信、网络等）是信息技术的核心。信息的传输模型如下图\n\n![](https://upload-images.jianshu.io/upload_images/4132208-8fa7479a893c6c4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/635/format/webp)\n\n信源： 产生信息的实体\n信宿：信息的归宿或接收者\n信道：传送信息的通道\n编码器：泛指所有变换信号的设备，实际上是终端机的发送部分\n译码器：译码器是编码器的逆变换信号，把信道上送来的信号（原始信息与噪声的叠加）转成信宿能接受的信号\n噪声：噪声可以理解为干扰\n\n信息系统的主要性能指标是它的**有效性**和**可靠性**，可靠性就是在系统传送中尽可能多的信息；可靠性是要求信宿收到的信息尽可能地与信源发出的信息一致或者说是失真尽可能小\n\n#### 1.1.2 不看\n\n#### 1.1.3 信息化的基本概念\n\n信息化从小到大分为以下五个层次\n\n1. 产品信息化\n2. 企业信息化\n3. 产业信息化\n4. 国民经济信息化\n5. 社会生活信息化\n\n信息化的基本内涵启示我们：\n\n1. 信息化的主体是全社会成员，包括政府企业事业团体和个人；\n2. 它的时域是一个长期的过程\n3. 它的空域是政治、经济、文化、军事和社会的一切领域\n4. 它的手段是基于现代信息技术的先进社会生产工具\n5. 它的途径是创建信息时代的社会生产力，推动社会生产关系及社会上层建筑的改革\n6. 它的目标是使国家的综合实力、社会的文明素质和人民的生活质量全面提高\n\n了解： \n\n1. 两网是指政府内网和政府外网\n2. 一站是指政府门户网站\n\n\n国家信息化体系的六要素：\n![](https://upload-images.jianshu.io/upload_images/4132208-6ac347e1b38255b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/651/format/webp)\n1. 信息资源：信息资源的开发和利用是国家信息化的核心任务\n2. 信息网络：信息网络是信息开发和利用的基础设施\n3. 信息技术应用： 信息技术应用是指把信息技术广泛应用于经济和社会的各个领域\n4. 信息技术和产业： 信息产业是信息化的物质基础\n5. 信息化人才：人才信息化的成功之本 \n6. 信息化政策法规和标准规范：是国家信息化快速、有序、健康和持续发展的保障\n\n#### 1.1.3 信息系统的生命周期\n\n##### 信息系统的生命周期\n软件的生命周期包括：可行性与项目开发计划、需求分析、概要设计、详细设计、编码、测试、运维等阶段\n\n信息系统的生命周期可以简化为系统规划（可行性与项目开发计划）、系统分析（需求分析）、系统设计（概要设计、详细设计）、系统实施（编码、测试）、系统运维（运维）等阶段\n\n信息系统的生命周期还可以简化为：立项（系统规划）、开发（系统分析，系统设计，系统实施）、运维及消亡四个阶段。开发阶段不仅包括系统分析，系统设计，系统实施，也包括系统验收等工作。\n\n##### 信息系统的生命周期五个阶段的输出\n\n1. 系统规划：可行性研究报告，系统设计任务书\n2. 系统分析：系统说明书\n3. 系统设计：总体设计（概要设计），详细设计，系统设计说明书\n4. 系统实施：计算机等设备的购置、安装和调试，程序编写和测试、人员培训、数据文件转换\n5. 系统运行和维护阶段： 经常进行维护和评价\n\n### 1.2 信息系统的开发方法\n\n> 常用的开发方法包括结构化方法、面向对象方法、原型法、面向服务方法等\n\n#### 1.2.1 结构化方法\n\n精髓是自顶向下、逐步求精和模块化设计，在初期就要理解用户的需求\n\n结构化的主要特点列举如下：\n1. 开发目标清晰化\n2. 开发工作阶段化\n3. 开发文档规范化\n4. 设计方法结构化\n\n结构化方法是目前最成熟，应用最广泛的一种工程化方法，特别适合于数据处理领域的问题，但不适合于规模较大、比较复杂的系统开发。结构化方法的不足：\n1. 开发周期长\n2. 难以适应需求的变化\n3. 很少考虑数据结构\n\n> 补充：\n > 1. 可行性与项目开发计划、需求分析、概要设计、详细设计、编码、测试、运维等阶段中上一个阶段的输出是下一个阶段的输入。每一个阶段都需要评审，通常由评审委员会进行。\n > 2. 评审委员的好处是及时发现问，不会把错误带给下一个阶段。\n > 3. 经过甲方确认的SRS（需求分析文档）就是需求的基线。\n\n#### 1.2.2 面向对象方法\n\nOO方法使得系统的描述及信息模型的表示与客观实体相对应，符合人们的思维习惯，有利于系统开发过程中用户与开发人员的交流和沟通，缩短开发周期。OO方法普遍适用于各类信息系统的开发。OO方法也存在明显的不足，必须依靠一定的OO技术支持。\n\n#### 1.2.3 原型化方法\n\n原型化方法也称为快速原型法，或者简称为原型法。他是一种根据用户初步需求利用系统开发工具，快速的建立一个系统模型展示给用户，在此基础上与用户交流，最终实现用户需求的信息系统快速开发的方法。\n\n##### 原型法的特点\n1. 原型法可以使得系统开发的周期缩短、成本和风险降低、速度加快，获得较高的综合开发效益。\n2. 原型法是以用户为中心来开发系统的，用户参与的程度大大提高\n3. 由于用户参与了系统开发的全过程，对系统的功能和结构容易理解和接受，有利于系统的移交，有利于系统的运行与维护\n   \n原型法的缺点\n1. 开发的环境要求高\n2. 管理水平要求高\n\n原型法适用于需求不明确的系统开发。事实上，对于分析层面难度大，技术层面难度不大的系统，适合于原型法开发，而对于技术层面的困难远大于其分析层面的系统，则不适用于原型法。\n\n#### 1.2.4 面向服务方法（看一下）\n\n对于跨构件的功能调用，则采用接口的形式暴露出来。\n如何使信息系统快速响应需求与环境变化，提高系统可复用性、信息资源共享和系统之间的互操作性，成为影响信息化建设效率的关键问题。而SO的思维正好满足了这个问题。\n\n### 1.3 常规信息系统集成技术\n\n##### OSI协议\n\n#### 1.3.1 网络标准与网络协议\n\n国际化标准组织ISO\nOSI采用了分层的结构化技术，从下到上分为七层（从底层到高层）\n1. 物理层 物理联网媒介，如电缆连线连接线，标准有RS232,RJ-45\n2. 数据链路层 控制网络层与物理层的通信，协议有IEEE，802.3/2\n3. 网络层 将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方，协议有IP、ICMP、IGMP、IPX、ARP。\n4. 传输层 确保数据可靠、顺序、无错的从A点传输到B点，提供可靠的透明的数据传送，提供端到端的错误恢复和流量控制，协议有TCP,UDP,SPX\n5. 会话层 负责在网络中的两节点之间建立和维持通信，以及提供交互会话的管理功能，协议有RPC、SQL、NFS\n6. 表示层 如同应用程序和网络之间的翻译官，常见的协议有JPEG、GIF、ASCII\n7. 应用层 负责对软件提供接口以使应用程序能使用网络服务，协议有HTTP、Telnet、FTP、SMTP\n\n802.3（以太网的CSMA/CD载波监听多路访问/冲突检测协议）\n802.11（无线局域网WLAN标准协议）\n\n##### TCP/IP\n1. 应用层协议\n   * FTP （文件传输协议）是网络上两台计算机传送文件的协议，运行在TCP之上\n   * TFTP（简单文件传输协议） 客户机与服务器之间进行简单文件传输的协议，建立在UDP（用户数据报协议）之上\n   * HTTP（超文本传输协议） 建立在TCP之上\n   * SMTP（简单邮件传输协议）建立在TCP之上，是一种提高可靠且有效的电子邮件传输的协议\n   * DHCP（动态主机配置协议）IP地址自动分配，建立在UDP之上\n   * Telnet（远程登录协议）建立在TCP之上\n   * DNS（域名系统）建立在UDP之上\n   * SNMP（简单网络管理协议）建立在UDP之上\n2. 传输层协议\n    * TCP 为应用程序提供了一个可靠的、面向连接的全双工的数据传输服务。TCP协议一般用于**传输数量比较少，可靠性要求高**的场合。\n    * UDP 是不可靠的，无连接的协议。UDP协议一般用于**传输数据量大，对可靠性要求不高**，要求速度快的场合。\n3. 网络层协议\n网络层中的协议主要有 IP、ICMP、IGMP、ARP、RARP\n* ARP用于动态的完成ip地址向物理地址的转换\n* RARP用于动态的完成物理地址向IP地址的转换\n* ICMP 专门用于发生差错报文的协议，并能在发生差错时报告的机制\n\n#### 1.3.2 网络设备（读一下）\n| 互联设备 | 工作层次 | 主要功能 \n| :------| ------: | :------: |\n| 路由器 | 网络层 | 通过逻辑地址进行网络之间的信息转发，可完成异构网络之间的互联互通\n| 交换机 | 数据链路层 |\n| 三层交换机 | 网络层 \n\n无线AP （无线接入点）\n\n#### 1.3.3 网络服务器\n\n客户机：需要请求服务的\n\n服务器：提供服务的\n","source":"_posts/项目管理师学习-信息化和信息系统1.md","raw":"---\ntitle: 项目管理师学习-信息化和信息系统1\ndate: 2019-01-07 22:17:55\ntags:\n---\n\n## 第一章 信息化和信息系统1\n> 本章节只考上午选择题，约22分左右\n### 1.1 信息系统与信息化\n\n#### 1.1.1 信息的基本概念\n\n##### 信息的质量属性：\n\n1. 精确性：对事物描述的精准程度\n2. 完整性：对事物描述的全面程度\n3. 可靠性：信息的来源，采集方法，传输过程是可以信任的，符合预期的\n4. 及时性：获得信息的时刻与事情发生时刻的间隔时长\n5. 经济性：信息获取传输带来的成本在可接受的范围内\n6. 可验证性：信息的主要质量属性可以被证实或者证伪的程度\n7. 安全性：在信息的生命周期内，信息可以被非授权访问的可能性。可能性越低，信息越安全\n\n##### 信息的传输模型\n\n> 信息是有价值的一种客观存在。信息技术主要未解决信息的采集、加工、存储、传输、处理、计算、转换、表现等问题而不断繁荣发展。信息系统只有流动起来，才能体现价值，因此信息的传输技术（通常指通信、网络等）是信息技术的核心。信息的传输模型如下图\n\n![](https://upload-images.jianshu.io/upload_images/4132208-8fa7479a893c6c4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/635/format/webp)\n\n信源： 产生信息的实体\n信宿：信息的归宿或接收者\n信道：传送信息的通道\n编码器：泛指所有变换信号的设备，实际上是终端机的发送部分\n译码器：译码器是编码器的逆变换信号，把信道上送来的信号（原始信息与噪声的叠加）转成信宿能接受的信号\n噪声：噪声可以理解为干扰\n\n信息系统的主要性能指标是它的**有效性**和**可靠性**，可靠性就是在系统传送中尽可能多的信息；可靠性是要求信宿收到的信息尽可能地与信源发出的信息一致或者说是失真尽可能小\n\n#### 1.1.2 不看\n\n#### 1.1.3 信息化的基本概念\n\n信息化从小到大分为以下五个层次\n\n1. 产品信息化\n2. 企业信息化\n3. 产业信息化\n4. 国民经济信息化\n5. 社会生活信息化\n\n信息化的基本内涵启示我们：\n\n1. 信息化的主体是全社会成员，包括政府企业事业团体和个人；\n2. 它的时域是一个长期的过程\n3. 它的空域是政治、经济、文化、军事和社会的一切领域\n4. 它的手段是基于现代信息技术的先进社会生产工具\n5. 它的途径是创建信息时代的社会生产力，推动社会生产关系及社会上层建筑的改革\n6. 它的目标是使国家的综合实力、社会的文明素质和人民的生活质量全面提高\n\n了解： \n\n1. 两网是指政府内网和政府外网\n2. 一站是指政府门户网站\n\n\n国家信息化体系的六要素：\n![](https://upload-images.jianshu.io/upload_images/4132208-6ac347e1b38255b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/651/format/webp)\n1. 信息资源：信息资源的开发和利用是国家信息化的核心任务\n2. 信息网络：信息网络是信息开发和利用的基础设施\n3. 信息技术应用： 信息技术应用是指把信息技术广泛应用于经济和社会的各个领域\n4. 信息技术和产业： 信息产业是信息化的物质基础\n5. 信息化人才：人才信息化的成功之本 \n6. 信息化政策法规和标准规范：是国家信息化快速、有序、健康和持续发展的保障\n\n#### 1.1.3 信息系统的生命周期\n\n##### 信息系统的生命周期\n软件的生命周期包括：可行性与项目开发计划、需求分析、概要设计、详细设计、编码、测试、运维等阶段\n\n信息系统的生命周期可以简化为系统规划（可行性与项目开发计划）、系统分析（需求分析）、系统设计（概要设计、详细设计）、系统实施（编码、测试）、系统运维（运维）等阶段\n\n信息系统的生命周期还可以简化为：立项（系统规划）、开发（系统分析，系统设计，系统实施）、运维及消亡四个阶段。开发阶段不仅包括系统分析，系统设计，系统实施，也包括系统验收等工作。\n\n##### 信息系统的生命周期五个阶段的输出\n\n1. 系统规划：可行性研究报告，系统设计任务书\n2. 系统分析：系统说明书\n3. 系统设计：总体设计（概要设计），详细设计，系统设计说明书\n4. 系统实施：计算机等设备的购置、安装和调试，程序编写和测试、人员培训、数据文件转换\n5. 系统运行和维护阶段： 经常进行维护和评价\n\n### 1.2 信息系统的开发方法\n\n> 常用的开发方法包括结构化方法、面向对象方法、原型法、面向服务方法等\n\n#### 1.2.1 结构化方法\n\n精髓是自顶向下、逐步求精和模块化设计，在初期就要理解用户的需求\n\n结构化的主要特点列举如下：\n1. 开发目标清晰化\n2. 开发工作阶段化\n3. 开发文档规范化\n4. 设计方法结构化\n\n结构化方法是目前最成熟，应用最广泛的一种工程化方法，特别适合于数据处理领域的问题，但不适合于规模较大、比较复杂的系统开发。结构化方法的不足：\n1. 开发周期长\n2. 难以适应需求的变化\n3. 很少考虑数据结构\n\n> 补充：\n > 1. 可行性与项目开发计划、需求分析、概要设计、详细设计、编码、测试、运维等阶段中上一个阶段的输出是下一个阶段的输入。每一个阶段都需要评审，通常由评审委员会进行。\n > 2. 评审委员的好处是及时发现问，不会把错误带给下一个阶段。\n > 3. 经过甲方确认的SRS（需求分析文档）就是需求的基线。\n\n#### 1.2.2 面向对象方法\n\nOO方法使得系统的描述及信息模型的表示与客观实体相对应，符合人们的思维习惯，有利于系统开发过程中用户与开发人员的交流和沟通，缩短开发周期。OO方法普遍适用于各类信息系统的开发。OO方法也存在明显的不足，必须依靠一定的OO技术支持。\n\n#### 1.2.3 原型化方法\n\n原型化方法也称为快速原型法，或者简称为原型法。他是一种根据用户初步需求利用系统开发工具，快速的建立一个系统模型展示给用户，在此基础上与用户交流，最终实现用户需求的信息系统快速开发的方法。\n\n##### 原型法的特点\n1. 原型法可以使得系统开发的周期缩短、成本和风险降低、速度加快，获得较高的综合开发效益。\n2. 原型法是以用户为中心来开发系统的，用户参与的程度大大提高\n3. 由于用户参与了系统开发的全过程，对系统的功能和结构容易理解和接受，有利于系统的移交，有利于系统的运行与维护\n   \n原型法的缺点\n1. 开发的环境要求高\n2. 管理水平要求高\n\n原型法适用于需求不明确的系统开发。事实上，对于分析层面难度大，技术层面难度不大的系统，适合于原型法开发，而对于技术层面的困难远大于其分析层面的系统，则不适用于原型法。\n\n#### 1.2.4 面向服务方法（看一下）\n\n对于跨构件的功能调用，则采用接口的形式暴露出来。\n如何使信息系统快速响应需求与环境变化，提高系统可复用性、信息资源共享和系统之间的互操作性，成为影响信息化建设效率的关键问题。而SO的思维正好满足了这个问题。\n\n### 1.3 常规信息系统集成技术\n\n##### OSI协议\n\n#### 1.3.1 网络标准与网络协议\n\n国际化标准组织ISO\nOSI采用了分层的结构化技术，从下到上分为七层（从底层到高层）\n1. 物理层 物理联网媒介，如电缆连线连接线，标准有RS232,RJ-45\n2. 数据链路层 控制网络层与物理层的通信，协议有IEEE，802.3/2\n3. 网络层 将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方，协议有IP、ICMP、IGMP、IPX、ARP。\n4. 传输层 确保数据可靠、顺序、无错的从A点传输到B点，提供可靠的透明的数据传送，提供端到端的错误恢复和流量控制，协议有TCP,UDP,SPX\n5. 会话层 负责在网络中的两节点之间建立和维持通信，以及提供交互会话的管理功能，协议有RPC、SQL、NFS\n6. 表示层 如同应用程序和网络之间的翻译官，常见的协议有JPEG、GIF、ASCII\n7. 应用层 负责对软件提供接口以使应用程序能使用网络服务，协议有HTTP、Telnet、FTP、SMTP\n\n802.3（以太网的CSMA/CD载波监听多路访问/冲突检测协议）\n802.11（无线局域网WLAN标准协议）\n\n##### TCP/IP\n1. 应用层协议\n   * FTP （文件传输协议）是网络上两台计算机传送文件的协议，运行在TCP之上\n   * TFTP（简单文件传输协议） 客户机与服务器之间进行简单文件传输的协议，建立在UDP（用户数据报协议）之上\n   * HTTP（超文本传输协议） 建立在TCP之上\n   * SMTP（简单邮件传输协议）建立在TCP之上，是一种提高可靠且有效的电子邮件传输的协议\n   * DHCP（动态主机配置协议）IP地址自动分配，建立在UDP之上\n   * Telnet（远程登录协议）建立在TCP之上\n   * DNS（域名系统）建立在UDP之上\n   * SNMP（简单网络管理协议）建立在UDP之上\n2. 传输层协议\n    * TCP 为应用程序提供了一个可靠的、面向连接的全双工的数据传输服务。TCP协议一般用于**传输数量比较少，可靠性要求高**的场合。\n    * UDP 是不可靠的，无连接的协议。UDP协议一般用于**传输数据量大，对可靠性要求不高**，要求速度快的场合。\n3. 网络层协议\n网络层中的协议主要有 IP、ICMP、IGMP、ARP、RARP\n* ARP用于动态的完成ip地址向物理地址的转换\n* RARP用于动态的完成物理地址向IP地址的转换\n* ICMP 专门用于发生差错报文的协议，并能在发生差错时报告的机制\n\n#### 1.3.2 网络设备（读一下）\n| 互联设备 | 工作层次 | 主要功能 \n| :------| ------: | :------: |\n| 路由器 | 网络层 | 通过逻辑地址进行网络之间的信息转发，可完成异构网络之间的互联互通\n| 交换机 | 数据链路层 |\n| 三层交换机 | 网络层 \n\n无线AP （无线接入点）\n\n#### 1.3.3 网络服务器\n\n客户机：需要请求服务的\n\n服务器：提供服务的\n","slug":"项目管理师学习-信息化和信息系统1","published":1,"updated":"2019-04-10T02:31:49.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzkiy000ujgf2kt4jwz3k","content":"<h2 id=\"第一章-信息化和信息系统1\"><a href=\"#第一章-信息化和信息系统1\" class=\"headerlink\" title=\"第一章 信息化和信息系统1\"></a>第一章 信息化和信息系统1</h2><blockquote>\n<p>本章节只考上午选择题，约22分左右</p>\n</blockquote>\n<h3 id=\"1-1-信息系统与信息化\"><a href=\"#1-1-信息系统与信息化\" class=\"headerlink\" title=\"1.1 信息系统与信息化\"></a>1.1 信息系统与信息化</h3><h4 id=\"1-1-1-信息的基本概念\"><a href=\"#1-1-1-信息的基本概念\" class=\"headerlink\" title=\"1.1.1 信息的基本概念\"></a>1.1.1 信息的基本概念</h4><h5 id=\"信息的质量属性：\"><a href=\"#信息的质量属性：\" class=\"headerlink\" title=\"信息的质量属性：\"></a>信息的质量属性：</h5><ol>\n<li>精确性：对事物描述的精准程度</li>\n<li>完整性：对事物描述的全面程度</li>\n<li>可靠性：信息的来源，采集方法，传输过程是可以信任的，符合预期的</li>\n<li>及时性：获得信息的时刻与事情发生时刻的间隔时长</li>\n<li>经济性：信息获取传输带来的成本在可接受的范围内</li>\n<li>可验证性：信息的主要质量属性可以被证实或者证伪的程度</li>\n<li>安全性：在信息的生命周期内，信息可以被非授权访问的可能性。可能性越低，信息越安全</li>\n</ol>\n<h5 id=\"信息的传输模型\"><a href=\"#信息的传输模型\" class=\"headerlink\" title=\"信息的传输模型\"></a>信息的传输模型</h5><blockquote>\n<p>信息是有价值的一种客观存在。信息技术主要未解决信息的采集、加工、存储、传输、处理、计算、转换、表现等问题而不断繁荣发展。信息系统只有流动起来，才能体现价值，因此信息的传输技术（通常指通信、网络等）是信息技术的核心。信息的传输模型如下图</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4132208-8fa7479a893c6c4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/635/format/webp\" alt=\"\"></p>\n<p>信源： 产生信息的实体<br>信宿：信息的归宿或接收者<br>信道：传送信息的通道<br>编码器：泛指所有变换信号的设备，实际上是终端机的发送部分<br>译码器：译码器是编码器的逆变换信号，把信道上送来的信号（原始信息与噪声的叠加）转成信宿能接受的信号<br>噪声：噪声可以理解为干扰</p>\n<p>信息系统的主要性能指标是它的<strong>有效性</strong>和<strong>可靠性</strong>，可靠性就是在系统传送中尽可能多的信息；可靠性是要求信宿收到的信息尽可能地与信源发出的信息一致或者说是失真尽可能小</p>\n<h4 id=\"1-1-2-不看\"><a href=\"#1-1-2-不看\" class=\"headerlink\" title=\"1.1.2 不看\"></a>1.1.2 不看</h4><h4 id=\"1-1-3-信息化的基本概念\"><a href=\"#1-1-3-信息化的基本概念\" class=\"headerlink\" title=\"1.1.3 信息化的基本概念\"></a>1.1.3 信息化的基本概念</h4><p>信息化从小到大分为以下五个层次</p>\n<ol>\n<li>产品信息化</li>\n<li>企业信息化</li>\n<li>产业信息化</li>\n<li>国民经济信息化</li>\n<li>社会生活信息化</li>\n</ol>\n<p>信息化的基本内涵启示我们：</p>\n<ol>\n<li>信息化的主体是全社会成员，包括政府企业事业团体和个人；</li>\n<li>它的时域是一个长期的过程</li>\n<li>它的空域是政治、经济、文化、军事和社会的一切领域</li>\n<li>它的手段是基于现代信息技术的先进社会生产工具</li>\n<li>它的途径是创建信息时代的社会生产力，推动社会生产关系及社会上层建筑的改革</li>\n<li>它的目标是使国家的综合实力、社会的文明素质和人民的生活质量全面提高</li>\n</ol>\n<p>了解： </p>\n<ol>\n<li>两网是指政府内网和政府外网</li>\n<li>一站是指政府门户网站</li>\n</ol>\n<p>国家信息化体系的六要素：<br><img src=\"https://upload-images.jianshu.io/upload_images/4132208-6ac347e1b38255b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/651/format/webp\" alt=\"\"></p>\n<ol>\n<li>信息资源：信息资源的开发和利用是国家信息化的核心任务</li>\n<li>信息网络：信息网络是信息开发和利用的基础设施</li>\n<li>信息技术应用： 信息技术应用是指把信息技术广泛应用于经济和社会的各个领域</li>\n<li>信息技术和产业： 信息产业是信息化的物质基础</li>\n<li>信息化人才：人才信息化的成功之本 </li>\n<li>信息化政策法规和标准规范：是国家信息化快速、有序、健康和持续发展的保障</li>\n</ol>\n<h4 id=\"1-1-3-信息系统的生命周期\"><a href=\"#1-1-3-信息系统的生命周期\" class=\"headerlink\" title=\"1.1.3 信息系统的生命周期\"></a>1.1.3 信息系统的生命周期</h4><h5 id=\"信息系统的生命周期\"><a href=\"#信息系统的生命周期\" class=\"headerlink\" title=\"信息系统的生命周期\"></a>信息系统的生命周期</h5><p>软件的生命周期包括：可行性与项目开发计划、需求分析、概要设计、详细设计、编码、测试、运维等阶段</p>\n<p>信息系统的生命周期可以简化为系统规划（可行性与项目开发计划）、系统分析（需求分析）、系统设计（概要设计、详细设计）、系统实施（编码、测试）、系统运维（运维）等阶段</p>\n<p>信息系统的生命周期还可以简化为：立项（系统规划）、开发（系统分析，系统设计，系统实施）、运维及消亡四个阶段。开发阶段不仅包括系统分析，系统设计，系统实施，也包括系统验收等工作。</p>\n<h5 id=\"信息系统的生命周期五个阶段的输出\"><a href=\"#信息系统的生命周期五个阶段的输出\" class=\"headerlink\" title=\"信息系统的生命周期五个阶段的输出\"></a>信息系统的生命周期五个阶段的输出</h5><ol>\n<li>系统规划：可行性研究报告，系统设计任务书</li>\n<li>系统分析：系统说明书</li>\n<li>系统设计：总体设计（概要设计），详细设计，系统设计说明书</li>\n<li>系统实施：计算机等设备的购置、安装和调试，程序编写和测试、人员培训、数据文件转换</li>\n<li>系统运行和维护阶段： 经常进行维护和评价</li>\n</ol>\n<h3 id=\"1-2-信息系统的开发方法\"><a href=\"#1-2-信息系统的开发方法\" class=\"headerlink\" title=\"1.2 信息系统的开发方法\"></a>1.2 信息系统的开发方法</h3><blockquote>\n<p>常用的开发方法包括结构化方法、面向对象方法、原型法、面向服务方法等</p>\n</blockquote>\n<h4 id=\"1-2-1-结构化方法\"><a href=\"#1-2-1-结构化方法\" class=\"headerlink\" title=\"1.2.1 结构化方法\"></a>1.2.1 结构化方法</h4><p>精髓是自顶向下、逐步求精和模块化设计，在初期就要理解用户的需求</p>\n<p>结构化的主要特点列举如下：</p>\n<ol>\n<li>开发目标清晰化</li>\n<li>开发工作阶段化</li>\n<li>开发文档规范化</li>\n<li>设计方法结构化</li>\n</ol>\n<p>结构化方法是目前最成熟，应用最广泛的一种工程化方法，特别适合于数据处理领域的问题，但不适合于规模较大、比较复杂的系统开发。结构化方法的不足：</p>\n<ol>\n<li>开发周期长</li>\n<li>难以适应需求的变化</li>\n<li>很少考虑数据结构</li>\n</ol>\n<blockquote>\n<p>补充：</p>\n<ol>\n<li>可行性与项目开发计划、需求分析、概要设计、详细设计、编码、测试、运维等阶段中上一个阶段的输出是下一个阶段的输入。每一个阶段都需要评审，通常由评审委员会进行。</li>\n<li>评审委员的好处是及时发现问，不会把错误带给下一个阶段。</li>\n<li>经过甲方确认的SRS（需求分析文档）就是需求的基线。</li>\n</ol>\n</blockquote>\n<h4 id=\"1-2-2-面向对象方法\"><a href=\"#1-2-2-面向对象方法\" class=\"headerlink\" title=\"1.2.2 面向对象方法\"></a>1.2.2 面向对象方法</h4><p>OO方法使得系统的描述及信息模型的表示与客观实体相对应，符合人们的思维习惯，有利于系统开发过程中用户与开发人员的交流和沟通，缩短开发周期。OO方法普遍适用于各类信息系统的开发。OO方法也存在明显的不足，必须依靠一定的OO技术支持。</p>\n<h4 id=\"1-2-3-原型化方法\"><a href=\"#1-2-3-原型化方法\" class=\"headerlink\" title=\"1.2.3 原型化方法\"></a>1.2.3 原型化方法</h4><p>原型化方法也称为快速原型法，或者简称为原型法。他是一种根据用户初步需求利用系统开发工具，快速的建立一个系统模型展示给用户，在此基础上与用户交流，最终实现用户需求的信息系统快速开发的方法。</p>\n<h5 id=\"原型法的特点\"><a href=\"#原型法的特点\" class=\"headerlink\" title=\"原型法的特点\"></a>原型法的特点</h5><ol>\n<li>原型法可以使得系统开发的周期缩短、成本和风险降低、速度加快，获得较高的综合开发效益。</li>\n<li>原型法是以用户为中心来开发系统的，用户参与的程度大大提高</li>\n<li>由于用户参与了系统开发的全过程，对系统的功能和结构容易理解和接受，有利于系统的移交，有利于系统的运行与维护</li>\n</ol>\n<p>原型法的缺点</p>\n<ol>\n<li>开发的环境要求高</li>\n<li>管理水平要求高</li>\n</ol>\n<p>原型法适用于需求不明确的系统开发。事实上，对于分析层面难度大，技术层面难度不大的系统，适合于原型法开发，而对于技术层面的困难远大于其分析层面的系统，则不适用于原型法。</p>\n<h4 id=\"1-2-4-面向服务方法（看一下）\"><a href=\"#1-2-4-面向服务方法（看一下）\" class=\"headerlink\" title=\"1.2.4 面向服务方法（看一下）\"></a>1.2.4 面向服务方法（看一下）</h4><p>对于跨构件的功能调用，则采用接口的形式暴露出来。<br>如何使信息系统快速响应需求与环境变化，提高系统可复用性、信息资源共享和系统之间的互操作性，成为影响信息化建设效率的关键问题。而SO的思维正好满足了这个问题。</p>\n<h3 id=\"1-3-常规信息系统集成技术\"><a href=\"#1-3-常规信息系统集成技术\" class=\"headerlink\" title=\"1.3 常规信息系统集成技术\"></a>1.3 常规信息系统集成技术</h3><h5 id=\"OSI协议\"><a href=\"#OSI协议\" class=\"headerlink\" title=\"OSI协议\"></a>OSI协议</h5><h4 id=\"1-3-1-网络标准与网络协议\"><a href=\"#1-3-1-网络标准与网络协议\" class=\"headerlink\" title=\"1.3.1 网络标准与网络协议\"></a>1.3.1 网络标准与网络协议</h4><p>国际化标准组织ISO<br>OSI采用了分层的结构化技术，从下到上分为七层（从底层到高层）</p>\n<ol>\n<li>物理层 物理联网媒介，如电缆连线连接线，标准有RS232,RJ-45</li>\n<li>数据链路层 控制网络层与物理层的通信，协议有IEEE，802.3/2</li>\n<li>网络层 将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方，协议有IP、ICMP、IGMP、IPX、ARP。</li>\n<li>传输层 确保数据可靠、顺序、无错的从A点传输到B点，提供可靠的透明的数据传送，提供端到端的错误恢复和流量控制，协议有TCP,UDP,SPX</li>\n<li>会话层 负责在网络中的两节点之间建立和维持通信，以及提供交互会话的管理功能，协议有RPC、SQL、NFS</li>\n<li>表示层 如同应用程序和网络之间的翻译官，常见的协议有JPEG、GIF、ASCII</li>\n<li>应用层 负责对软件提供接口以使应用程序能使用网络服务，协议有HTTP、Telnet、FTP、SMTP</li>\n</ol>\n<p>802.3（以太网的CSMA/CD载波监听多路访问/冲突检测协议）<br>802.11（无线局域网WLAN标准协议）</p>\n<h5 id=\"TCP-IP\"><a href=\"#TCP-IP\" class=\"headerlink\" title=\"TCP/IP\"></a>TCP/IP</h5><ol>\n<li>应用层协议<ul>\n<li>FTP （文件传输协议）是网络上两台计算机传送文件的协议，运行在TCP之上</li>\n<li>TFTP（简单文件传输协议） 客户机与服务器之间进行简单文件传输的协议，建立在UDP（用户数据报协议）之上</li>\n<li>HTTP（超文本传输协议） 建立在TCP之上</li>\n<li>SMTP（简单邮件传输协议）建立在TCP之上，是一种提高可靠且有效的电子邮件传输的协议</li>\n<li>DHCP（动态主机配置协议）IP地址自动分配，建立在UDP之上</li>\n<li>Telnet（远程登录协议）建立在TCP之上</li>\n<li>DNS（域名系统）建立在UDP之上</li>\n<li>SNMP（简单网络管理协议）建立在UDP之上</li>\n</ul>\n</li>\n<li>传输层协议<ul>\n<li>TCP 为应用程序提供了一个可靠的、面向连接的全双工的数据传输服务。TCP协议一般用于<strong>传输数量比较少，可靠性要求高</strong>的场合。</li>\n<li>UDP 是不可靠的，无连接的协议。UDP协议一般用于<strong>传输数据量大，对可靠性要求不高</strong>，要求速度快的场合。</li>\n</ul>\n</li>\n<li>网络层协议<br>网络层中的协议主要有 IP、ICMP、IGMP、ARP、RARP</li>\n</ol>\n<ul>\n<li>ARP用于动态的完成ip地址向物理地址的转换</li>\n<li>RARP用于动态的完成物理地址向IP地址的转换</li>\n<li>ICMP 专门用于发生差错报文的协议，并能在发生差错时报告的机制</li>\n</ul>\n<h4 id=\"1-3-2-网络设备（读一下）\"><a href=\"#1-3-2-网络设备（读一下）\" class=\"headerlink\" title=\"1.3.2 网络设备（读一下）\"></a>1.3.2 网络设备（读一下）</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">互联设备</th>\n<th style=\"text-align:right\">工作层次</th>\n<th style=\"text-align:center\">主要功能 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">路由器</td>\n<td style=\"text-align:right\">网络层</td>\n<td style=\"text-align:center\">通过逻辑地址进行网络之间的信息转发，可完成异构网络之间的互联互通</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">交换机</td>\n<td style=\"text-align:right\">数据链路层</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">三层交换机</td>\n<td style=\"text-align:right\">网络层 </td>\n</tr>\n</tbody>\n</table>\n<p>无线AP （无线接入点）</p>\n<h4 id=\"1-3-3-网络服务器\"><a href=\"#1-3-3-网络服务器\" class=\"headerlink\" title=\"1.3.3 网络服务器\"></a>1.3.3 网络服务器</h4><p>客户机：需要请求服务的</p>\n<p>服务器：提供服务的</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"第一章-信息化和信息系统1\"><a href=\"#第一章-信息化和信息系统1\" class=\"headerlink\" title=\"第一章 信息化和信息系统1\"></a>第一章 信息化和信息系统1</h2><blockquote>\n<p>本章节只考上午选择题，约22分左右</p>\n</blockquote>\n<h3 id=\"1-1-信息系统与信息化\"><a href=\"#1-1-信息系统与信息化\" class=\"headerlink\" title=\"1.1 信息系统与信息化\"></a>1.1 信息系统与信息化</h3><h4 id=\"1-1-1-信息的基本概念\"><a href=\"#1-1-1-信息的基本概念\" class=\"headerlink\" title=\"1.1.1 信息的基本概念\"></a>1.1.1 信息的基本概念</h4><h5 id=\"信息的质量属性：\"><a href=\"#信息的质量属性：\" class=\"headerlink\" title=\"信息的质量属性：\"></a>信息的质量属性：</h5><ol>\n<li>精确性：对事物描述的精准程度</li>\n<li>完整性：对事物描述的全面程度</li>\n<li>可靠性：信息的来源，采集方法，传输过程是可以信任的，符合预期的</li>\n<li>及时性：获得信息的时刻与事情发生时刻的间隔时长</li>\n<li>经济性：信息获取传输带来的成本在可接受的范围内</li>\n<li>可验证性：信息的主要质量属性可以被证实或者证伪的程度</li>\n<li>安全性：在信息的生命周期内，信息可以被非授权访问的可能性。可能性越低，信息越安全</li>\n</ol>\n<h5 id=\"信息的传输模型\"><a href=\"#信息的传输模型\" class=\"headerlink\" title=\"信息的传输模型\"></a>信息的传输模型</h5><blockquote>\n<p>信息是有价值的一种客观存在。信息技术主要未解决信息的采集、加工、存储、传输、处理、计算、转换、表现等问题而不断繁荣发展。信息系统只有流动起来，才能体现价值，因此信息的传输技术（通常指通信、网络等）是信息技术的核心。信息的传输模型如下图</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4132208-8fa7479a893c6c4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/635/format/webp\" alt=\"\"></p>\n<p>信源： 产生信息的实体<br>信宿：信息的归宿或接收者<br>信道：传送信息的通道<br>编码器：泛指所有变换信号的设备，实际上是终端机的发送部分<br>译码器：译码器是编码器的逆变换信号，把信道上送来的信号（原始信息与噪声的叠加）转成信宿能接受的信号<br>噪声：噪声可以理解为干扰</p>\n<p>信息系统的主要性能指标是它的<strong>有效性</strong>和<strong>可靠性</strong>，可靠性就是在系统传送中尽可能多的信息；可靠性是要求信宿收到的信息尽可能地与信源发出的信息一致或者说是失真尽可能小</p>\n<h4 id=\"1-1-2-不看\"><a href=\"#1-1-2-不看\" class=\"headerlink\" title=\"1.1.2 不看\"></a>1.1.2 不看</h4><h4 id=\"1-1-3-信息化的基本概念\"><a href=\"#1-1-3-信息化的基本概念\" class=\"headerlink\" title=\"1.1.3 信息化的基本概念\"></a>1.1.3 信息化的基本概念</h4><p>信息化从小到大分为以下五个层次</p>\n<ol>\n<li>产品信息化</li>\n<li>企业信息化</li>\n<li>产业信息化</li>\n<li>国民经济信息化</li>\n<li>社会生活信息化</li>\n</ol>\n<p>信息化的基本内涵启示我们：</p>\n<ol>\n<li>信息化的主体是全社会成员，包括政府企业事业团体和个人；</li>\n<li>它的时域是一个长期的过程</li>\n<li>它的空域是政治、经济、文化、军事和社会的一切领域</li>\n<li>它的手段是基于现代信息技术的先进社会生产工具</li>\n<li>它的途径是创建信息时代的社会生产力，推动社会生产关系及社会上层建筑的改革</li>\n<li>它的目标是使国家的综合实力、社会的文明素质和人民的生活质量全面提高</li>\n</ol>\n<p>了解： </p>\n<ol>\n<li>两网是指政府内网和政府外网</li>\n<li>一站是指政府门户网站</li>\n</ol>\n<p>国家信息化体系的六要素：<br><img src=\"https://upload-images.jianshu.io/upload_images/4132208-6ac347e1b38255b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/651/format/webp\" alt=\"\"></p>\n<ol>\n<li>信息资源：信息资源的开发和利用是国家信息化的核心任务</li>\n<li>信息网络：信息网络是信息开发和利用的基础设施</li>\n<li>信息技术应用： 信息技术应用是指把信息技术广泛应用于经济和社会的各个领域</li>\n<li>信息技术和产业： 信息产业是信息化的物质基础</li>\n<li>信息化人才：人才信息化的成功之本 </li>\n<li>信息化政策法规和标准规范：是国家信息化快速、有序、健康和持续发展的保障</li>\n</ol>\n<h4 id=\"1-1-3-信息系统的生命周期\"><a href=\"#1-1-3-信息系统的生命周期\" class=\"headerlink\" title=\"1.1.3 信息系统的生命周期\"></a>1.1.3 信息系统的生命周期</h4><h5 id=\"信息系统的生命周期\"><a href=\"#信息系统的生命周期\" class=\"headerlink\" title=\"信息系统的生命周期\"></a>信息系统的生命周期</h5><p>软件的生命周期包括：可行性与项目开发计划、需求分析、概要设计、详细设计、编码、测试、运维等阶段</p>\n<p>信息系统的生命周期可以简化为系统规划（可行性与项目开发计划）、系统分析（需求分析）、系统设计（概要设计、详细设计）、系统实施（编码、测试）、系统运维（运维）等阶段</p>\n<p>信息系统的生命周期还可以简化为：立项（系统规划）、开发（系统分析，系统设计，系统实施）、运维及消亡四个阶段。开发阶段不仅包括系统分析，系统设计，系统实施，也包括系统验收等工作。</p>\n<h5 id=\"信息系统的生命周期五个阶段的输出\"><a href=\"#信息系统的生命周期五个阶段的输出\" class=\"headerlink\" title=\"信息系统的生命周期五个阶段的输出\"></a>信息系统的生命周期五个阶段的输出</h5><ol>\n<li>系统规划：可行性研究报告，系统设计任务书</li>\n<li>系统分析：系统说明书</li>\n<li>系统设计：总体设计（概要设计），详细设计，系统设计说明书</li>\n<li>系统实施：计算机等设备的购置、安装和调试，程序编写和测试、人员培训、数据文件转换</li>\n<li>系统运行和维护阶段： 经常进行维护和评价</li>\n</ol>\n<h3 id=\"1-2-信息系统的开发方法\"><a href=\"#1-2-信息系统的开发方法\" class=\"headerlink\" title=\"1.2 信息系统的开发方法\"></a>1.2 信息系统的开发方法</h3><blockquote>\n<p>常用的开发方法包括结构化方法、面向对象方法、原型法、面向服务方法等</p>\n</blockquote>\n<h4 id=\"1-2-1-结构化方法\"><a href=\"#1-2-1-结构化方法\" class=\"headerlink\" title=\"1.2.1 结构化方法\"></a>1.2.1 结构化方法</h4><p>精髓是自顶向下、逐步求精和模块化设计，在初期就要理解用户的需求</p>\n<p>结构化的主要特点列举如下：</p>\n<ol>\n<li>开发目标清晰化</li>\n<li>开发工作阶段化</li>\n<li>开发文档规范化</li>\n<li>设计方法结构化</li>\n</ol>\n<p>结构化方法是目前最成熟，应用最广泛的一种工程化方法，特别适合于数据处理领域的问题，但不适合于规模较大、比较复杂的系统开发。结构化方法的不足：</p>\n<ol>\n<li>开发周期长</li>\n<li>难以适应需求的变化</li>\n<li>很少考虑数据结构</li>\n</ol>\n<blockquote>\n<p>补充：</p>\n<ol>\n<li>可行性与项目开发计划、需求分析、概要设计、详细设计、编码、测试、运维等阶段中上一个阶段的输出是下一个阶段的输入。每一个阶段都需要评审，通常由评审委员会进行。</li>\n<li>评审委员的好处是及时发现问，不会把错误带给下一个阶段。</li>\n<li>经过甲方确认的SRS（需求分析文档）就是需求的基线。</li>\n</ol>\n</blockquote>\n<h4 id=\"1-2-2-面向对象方法\"><a href=\"#1-2-2-面向对象方法\" class=\"headerlink\" title=\"1.2.2 面向对象方法\"></a>1.2.2 面向对象方法</h4><p>OO方法使得系统的描述及信息模型的表示与客观实体相对应，符合人们的思维习惯，有利于系统开发过程中用户与开发人员的交流和沟通，缩短开发周期。OO方法普遍适用于各类信息系统的开发。OO方法也存在明显的不足，必须依靠一定的OO技术支持。</p>\n<h4 id=\"1-2-3-原型化方法\"><a href=\"#1-2-3-原型化方法\" class=\"headerlink\" title=\"1.2.3 原型化方法\"></a>1.2.3 原型化方法</h4><p>原型化方法也称为快速原型法，或者简称为原型法。他是一种根据用户初步需求利用系统开发工具，快速的建立一个系统模型展示给用户，在此基础上与用户交流，最终实现用户需求的信息系统快速开发的方法。</p>\n<h5 id=\"原型法的特点\"><a href=\"#原型法的特点\" class=\"headerlink\" title=\"原型法的特点\"></a>原型法的特点</h5><ol>\n<li>原型法可以使得系统开发的周期缩短、成本和风险降低、速度加快，获得较高的综合开发效益。</li>\n<li>原型法是以用户为中心来开发系统的，用户参与的程度大大提高</li>\n<li>由于用户参与了系统开发的全过程，对系统的功能和结构容易理解和接受，有利于系统的移交，有利于系统的运行与维护</li>\n</ol>\n<p>原型法的缺点</p>\n<ol>\n<li>开发的环境要求高</li>\n<li>管理水平要求高</li>\n</ol>\n<p>原型法适用于需求不明确的系统开发。事实上，对于分析层面难度大，技术层面难度不大的系统，适合于原型法开发，而对于技术层面的困难远大于其分析层面的系统，则不适用于原型法。</p>\n<h4 id=\"1-2-4-面向服务方法（看一下）\"><a href=\"#1-2-4-面向服务方法（看一下）\" class=\"headerlink\" title=\"1.2.4 面向服务方法（看一下）\"></a>1.2.4 面向服务方法（看一下）</h4><p>对于跨构件的功能调用，则采用接口的形式暴露出来。<br>如何使信息系统快速响应需求与环境变化，提高系统可复用性、信息资源共享和系统之间的互操作性，成为影响信息化建设效率的关键问题。而SO的思维正好满足了这个问题。</p>\n<h3 id=\"1-3-常规信息系统集成技术\"><a href=\"#1-3-常规信息系统集成技术\" class=\"headerlink\" title=\"1.3 常规信息系统集成技术\"></a>1.3 常规信息系统集成技术</h3><h5 id=\"OSI协议\"><a href=\"#OSI协议\" class=\"headerlink\" title=\"OSI协议\"></a>OSI协议</h5><h4 id=\"1-3-1-网络标准与网络协议\"><a href=\"#1-3-1-网络标准与网络协议\" class=\"headerlink\" title=\"1.3.1 网络标准与网络协议\"></a>1.3.1 网络标准与网络协议</h4><p>国际化标准组织ISO<br>OSI采用了分层的结构化技术，从下到上分为七层（从底层到高层）</p>\n<ol>\n<li>物理层 物理联网媒介，如电缆连线连接线，标准有RS232,RJ-45</li>\n<li>数据链路层 控制网络层与物理层的通信，协议有IEEE，802.3/2</li>\n<li>网络层 将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方，协议有IP、ICMP、IGMP、IPX、ARP。</li>\n<li>传输层 确保数据可靠、顺序、无错的从A点传输到B点，提供可靠的透明的数据传送，提供端到端的错误恢复和流量控制，协议有TCP,UDP,SPX</li>\n<li>会话层 负责在网络中的两节点之间建立和维持通信，以及提供交互会话的管理功能，协议有RPC、SQL、NFS</li>\n<li>表示层 如同应用程序和网络之间的翻译官，常见的协议有JPEG、GIF、ASCII</li>\n<li>应用层 负责对软件提供接口以使应用程序能使用网络服务，协议有HTTP、Telnet、FTP、SMTP</li>\n</ol>\n<p>802.3（以太网的CSMA/CD载波监听多路访问/冲突检测协议）<br>802.11（无线局域网WLAN标准协议）</p>\n<h5 id=\"TCP-IP\"><a href=\"#TCP-IP\" class=\"headerlink\" title=\"TCP/IP\"></a>TCP/IP</h5><ol>\n<li>应用层协议<ul>\n<li>FTP （文件传输协议）是网络上两台计算机传送文件的协议，运行在TCP之上</li>\n<li>TFTP（简单文件传输协议） 客户机与服务器之间进行简单文件传输的协议，建立在UDP（用户数据报协议）之上</li>\n<li>HTTP（超文本传输协议） 建立在TCP之上</li>\n<li>SMTP（简单邮件传输协议）建立在TCP之上，是一种提高可靠且有效的电子邮件传输的协议</li>\n<li>DHCP（动态主机配置协议）IP地址自动分配，建立在UDP之上</li>\n<li>Telnet（远程登录协议）建立在TCP之上</li>\n<li>DNS（域名系统）建立在UDP之上</li>\n<li>SNMP（简单网络管理协议）建立在UDP之上</li>\n</ul>\n</li>\n<li>传输层协议<ul>\n<li>TCP 为应用程序提供了一个可靠的、面向连接的全双工的数据传输服务。TCP协议一般用于<strong>传输数量比较少，可靠性要求高</strong>的场合。</li>\n<li>UDP 是不可靠的，无连接的协议。UDP协议一般用于<strong>传输数据量大，对可靠性要求不高</strong>，要求速度快的场合。</li>\n</ul>\n</li>\n<li>网络层协议<br>网络层中的协议主要有 IP、ICMP、IGMP、ARP、RARP</li>\n</ol>\n<ul>\n<li>ARP用于动态的完成ip地址向物理地址的转换</li>\n<li>RARP用于动态的完成物理地址向IP地址的转换</li>\n<li>ICMP 专门用于发生差错报文的协议，并能在发生差错时报告的机制</li>\n</ul>\n<h4 id=\"1-3-2-网络设备（读一下）\"><a href=\"#1-3-2-网络设备（读一下）\" class=\"headerlink\" title=\"1.3.2 网络设备（读一下）\"></a>1.3.2 网络设备（读一下）</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">互联设备</th>\n<th style=\"text-align:right\">工作层次</th>\n<th style=\"text-align:center\">主要功能 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">路由器</td>\n<td style=\"text-align:right\">网络层</td>\n<td style=\"text-align:center\">通过逻辑地址进行网络之间的信息转发，可完成异构网络之间的互联互通</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">交换机</td>\n<td style=\"text-align:right\">数据链路层</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">三层交换机</td>\n<td style=\"text-align:right\">网络层 </td>\n</tr>\n</tbody>\n</table>\n<p>无线AP （无线接入点）</p>\n<h4 id=\"1-3-3-网络服务器\"><a href=\"#1-3-3-网络服务器\" class=\"headerlink\" title=\"1.3.3 网络服务器\"></a>1.3.3 网络服务器</h4><p>客户机：需要请求服务的</p>\n<p>服务器：提供服务的</p>\n"},{"title":"前端知识点1901","date":"2019-01-11T06:11:16.000Z","_content":"**一面 1：ES 基础知识点与高频考题解析**\n========================\n\nJavaScript 是 ECMAScript 规范的一种实现，本小节重点梳理下 ECMAScript 中的常考知识点，然后就一些容易出现的题目进行解析。\n\n**知识点梳理**\n---------\n\n*   变量类型\n    *   JS 的数据类型分类和判断\n    *   值类型和引用类型\n*   原型与原型链（继承）\n    *   原型和原型链定义\n    *   继承写法\n*   作用域和闭包\n    *   执行上下文\n    *   this\n    *   闭包是什么\n*   异步\n    *   同步 vs 异步\n    *   异步和单线程\n    *   前端异步的场景\n*   ES6/7 新标准的考查\n    *   箭头函数\n    *   Module\n    *   Class\n    *   Set 和 Map\n    *   Promise\n\n* * *\n\n**变量类型**\n--------\n\nJavaScript 是一种弱类型脚本语言，所谓弱类型指的是定义变量时，不需要什么类型，在程序运行过程中会自动判断类型。\n\nECMAScript 中定义了 6 种原始类型：\n\n*   Boolean\n*   String\n*   Number\n*   Null\n*   Undefined\n*   Symbol（ES6 新定义）\n\n**注意**：原始类型不包含 Object。\n\n> 题目：类型判断用到哪些方法？\n\n### **`typeof`**\n\n`typeof xxx`得到的值有以下几种类型：`undefined``boolean``number``string``object``function`、`symbol` ，比较简单，不再一一演示了。这里需要注意的有三点：\n\n*   `typeof null`结果是`object` ，实际这是`typeof`的一个bug，null是原始值，非引用类型\n*   `typeof [1, 2]`结果是`object`，结果中没有`array`这一项，引用类型除了`function`其他的全部都是`object`\n*   `typeof Symbol()` 用`typeof`获取`symbol`类型的值得到的是`symbol`，这是 ES6 新增的知识点\n\n### **`instanceof`**\n\n用于实例和构造函数的对应。例如判断一个变量是否是数组，使用`typeof`无法判断，但可以使用`[1, 2] instanceof Array`来判断。因为，`[1, 2]`是数组，它的构造函数就是`Array`。同理：\n\n    function Foo(name) {\n        this.name = name\n    }\n    var foo = new Foo('bar')\n    console.log(foo instanceof Foo) // true\n    \n    \n\n复制\n\n> 题目：值类型和引用类型的区别\n\n### **值类型 vs 引用类型**\n\n除了原始类型，ES 还有引用类型，上文提到的`typeof`识别出来的类型中，只有`object`和`function`是引用类型，其他都是值类型。\n\n根据 JavaScript 中的变量类型传递方式，又分为**值类型**和**引用类型**，值类型变量包括 Boolean、String、Number、Undefined、Null，引用类型包括了 Object 类的所有，如 Date、Array、Function 等。在参数传递方式上，值类型是按值传递，引用类型是按共享传递。\n\n下面通过一个小题目，来看下两者的主要区别，以及实际开发中需要注意的地方。\n\n    // 值类型\n    var a = 10\n    var b = a\n    b = 20\n    console.log(a)  // 10\n    console.log(b)  // 20\n    \n    \n\n复制\n\n上述代码中，`a``b`都是值类型，两者分别修改赋值，相互之间没有任何影响。再看引用类型的例子：\n\n    // 引用类型\n    var a = {x: 10, y: 20}\n    var b = a\n    b.x = 100\n    b.y = 200\n    console.log(a)  // {x: 100, y: 200}\n    console.log(b)  // {x: 100, y: 200}\n    \n    \n\n复制\n\n上述代码中，`a``b`都是引用类型。在执行了`b = a`之后，修改`b`的属性值，`a`的也跟着变化。因为`a`和`b`都是引用类型，指向了同一个内存地址，即两者引用的是同一个值，因此`b`修改属性时，`a`的值随之改动。\n\n再借助题目进一步讲解一下。\n\n> 说出下面代码的执行结果，并分析其原因。\n\n    function foo(a){\n        a = a * 10;\n    }\n    function bar(b){\n        b.value = 'new';\n    }\n    var a = 1;\n    var b = {value: 'old'};\n    foo(a);\n    bar(b);\n    console.log(a); // 1\n    console.log(b); // value: new\n    \n    \n\n复制\n\n通过代码执行，会发现：\n\n*   `a`的值没有发生改变\n*   而`b`的值发生了改变\n\n这就是因为`Number`类型的`a`是按值传递的，而`Object`类型的`b`是按共享传递的。\n\nJS 中这种设计的原因是：按值传递的类型，复制一份存入栈内存，这类类型一般不占用太多内存，而且按值传递保证了其访问速度。按共享传递的类型，是复制其引用，而不是整个复制其值（C 语言中的指针），保证过大的对象等不会因为不停复制内容而造成内存的浪费。\n\n引用类型经常会在代码中按照下面的写法使用，或者说**容易不知不觉中造成错误**！\n\n    var obj = {\n        a: 1,\n        b: [1,2,3]\n    }\n    var a = obj.a\n    var b = obj.b\n    a = 2\n    b.push(4)\n    console.log(obj, a, b)\n    \n    \n\n复制\n\n虽然`obj`本身是个引用类型的变量（对象），但是内部的`a`和`b`一个是值类型一个是引用类型，`a`的赋值不会改变`obj.a`，但是`b`的操作却会反映到`obj`对象上。\n\n* * *\n\n**原型和原型链**\n----------\n\nJavaScript 是基于原型的语言，原型理解起来非常简单，但却特别重要，下面还是通过题目来理解下JavaScript 的原型概念。\n\n> 题目：如何理解 JavaScript 的原型\n\n对于这个问题，可以从下面这几个要点来理解和回答，**下面几条必须记住并且理解**\n\n*   **所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（`null`除外）**\n*   **所有的引用类型（数组、对象、函数），都有一个`__proto__`属性，属性值是一个普通的对象**\n*   **所有的函数，都有一个`prototype`属性，属性值也是一个普通的对象**\n*   **所有的引用类型（数组、对象、函数），`__proto__`属性值指向它的构造函数的`prototype`属性值**\n\n通过代码解释一下，大家可自行运行以下代码，看结果。\n\n    // 要点一：自由扩展属性\n    var obj = {}; obj.a = 100;\n    var arr = []; arr.a = 100;\n    function fn () {}\n    fn.a = 100;\n    \n    // 要点二：__proto__\n    console.log(obj.__proto__);\n    console.log(arr.__proto__);\n    console.log(fn.__proto__);\n    \n    // 要点三：函数有 prototype\n    console.log(fn.prototype)\n    \n    // 要点四：引用类型的 __proto__ 属性值指向它的构造函数的 prototype 属性值\n    console.log(obj.__proto__ === Object.prototype)\n    \n    \n\n复制\n\n### **原型**\n\n先写一个简单的代码示例。\n\n    // 构造函数\n    function Foo(name, age) {\n        this.name = name\n    }\n    Foo.prototype.alertName = function () {\n        alert(this.name)\n    }\n    // 创建示例\n    var f = new Foo('zhangsan')\n    f.printName = function () {\n        console.log(this.name)\n    }\n    // 测试\n    f.printName()\n    f.alertName()\n    \n    \n\n复制\n\n执行`printName`时很好理解，但是执行`alertName`时发生了什么？这里再记住一个重点 **当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的`__proto__`（即它的构造函数的`prototype`）中寻找**，因此`f.alertName`就会找到`Foo.prototype.alertName`。\n\n那么如何判断这个属性是不是对象本身的属性呢？使用`hasOwnProperty`，常用的地方是遍历一个对象的时候。\n\n    var item\n    for (item in f) {\n        // 高级浏览器已经在 for in 中屏蔽了来自原型的属性，但是这里建议大家还是加上这个判断，保证程序的健壮性\n        if (f.hasOwnProperty(item)) {\n            console.log(item)\n        }\n    }\n    \n    \n\n复制\n\n> 题目：如何理解 JS 的原型链\n\n### **原型链**\n\n还是接着上面的示例，如果执行`f.toString()`时，又发生了什么？\n\n    // 省略 N 行\n    \n    // 测试\n    f.printName()\n    f.alertName()\n    f.toString()\n    \n    \n\n复制\n\n因为`f`本身没有`toString()`，并且`f.__proto__`（即`Foo.prototype`）中也没有`toString`。这个问题还是得拿出刚才那句话——**当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的`__proto__`（即它的构造函数的`prototype`）中寻找**。\n\n如果在`f.__proto__`中没有找到`toString`，那么就继续去`f.__proto__.__proto__`中寻找，因为`f.__proto__`就是一个普通的对象而已嘛！\n\n*   `f.__proto__`即`Foo.prototype`，没有找到`toString`，继续往上找\n*   `f.__proto__.__proto__`即`Foo.prototype.__proto__`。`Foo.prototype`就是一个普通的对象，因此`Foo.prototype.__proto__`就是`Object.prototype`，在这里可以找到`toString`\n*   因此`f.toString`最终对应到了`Object.prototype.toString`\n\n这样一直往上找，你会发现是一个链式的结构，所以叫做“原型链”。如果一直找到最上层都没有找到，那么就宣告失败，返回`undefined`。最上层是什么 —— `Object.prototype.__proto__ === null`\n\n### **原型链中的`this`**\n\n所有从原型或更高级原型中得到、执行的方法，其中的`this`在执行时，就指向了当前这个触发事件执行的对象。因此`printName`和`alertName`中的`this`都是`f`。\n\n* * *\n\n**作用域和闭包**\n----------\n\n作用域和闭包是前端面试中，最可能考查的知识点。例如下面的题目：\n\n> 题目：现在有个 HTML 片段，要求编写代码，点击编号为几的链接就`alert`弹出其编号\n\n    <ul>\n        <li>编号1，点击我请弹出1</li>\n        <li>2</li>\n        <li>3</li>\n        <li>4</li>\n        <li>5</li>\n    </ul>\n    \n    \n\n复制\n\n一般不知道这个题目用闭包的话，会写出下面的代码：\n\n    var list = document.getElementsByTagName('li');\n    for (var i = 0; i < list.length; i++) {\n        list[i].addEventListener('click', function(){\n            alert(i + 1)\n        }, true)\n    }\n    \n    \n\n复制\n\n实际上执行才会发现始终弹出的是`6`，这时候就应该通过闭包来解决：\n\n    var list = document.getElementsByTagName('li');\n    for (var i = 0; i < list.length; i++) {\n        list[i].addEventListener('click', function(i){\n            return function(){\n                alert(i + 1)\n            }\n        }(i), true)\n    }\n    \n    \n\n复制\n\n要理解闭包，就需要我们从「执行上下文」开始讲起。\n\n### **执行上下文**\n\n先讲一个关于 **变量提升** 的知识点，面试中可能会遇见下面的问题，很多候选人都回答错误：\n\n> 题目：说出下面执行的结果（这里笔者直接注释输出了）\n\n    console.log(a)  // undefined\n    var a = 100\n    \n    fn('zhangsan')  // 'zhangsan' 20\n    function fn(name) {\n        age = 20\n        console.log(name, age)\n        var age\n    }\n    \n    console.log(b); // 这里报错\n    // Uncaught ReferenceError: b is not defined\n    b = 100;\n    \n    \n\n复制\n\n在一段 JS 脚本（即一个`<script>`标签中）执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个 **全局执行上下文** 环境，先把代码中即将执行的（内部函数的不算，因为你不知道函数何时执行）变量、函数声明都拿出来。变量先暂时赋值为`undefined`，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。再次强调，这是在代码执行之前才开始的工作。\n\n我们来看下上面的面试小题目，为什么`a`是`undefined`，而`b`却报错了，实际 JS 在代码执行之前，要「全文解析」，发现`var a`，知道有个`a`的变量，存入了执行上下文，而`b`没有找到`var`关键字，这时候没有在执行上下文提前「占位」，所以代码执行的时候，提前报到的`a`是有记录的，只不过值暂时还没有赋值，即为`undefined`，而`b`在执行上下文没有找到，自然会报错（没有找到`b`的引用）。\n\n另外，一个函数在执行之前，也会创建一个 **函数执行上下文** 环境，跟 **全局上下文** 差不多，不过 **函数执行上下文** 中会多出`this``arguments`和函数的参数。参数和`arguments`好理解，这里的`this`咱们需要专门讲解。\n\n总结一下：\n\n*   范围：一段`<script>`、js 文件或者一个函数\n*   全局上下文：变量定义，函数声明\n*   函数上下文：变量定义，函数声明，`this`，`arguments`\n\n### **`this`**\n\n先搞明白一个很重要的概念 —— **`this`的值是在执行的时候才能确认，定义的时候不能确认！** 为什么呢 —— 因为`this`是执行上下文环境的一部分，而执行上下文需要在代码执行之前确定，而不是定义的时候。看如下例子\n\n    var a = {\n        name: 'A',\n        fn: function () {\n            console.log(this.name)\n        }\n    }\n    a.fn()  // this === a\n    a.fn.call({name: 'B'})  // this === {name: 'B'}\n    var fn1 = a.fn\n    fn1()  // this === window\n    \n    \n\n复制\n\n`this`执行会有不同，主要集中在这几个场景中\n\n*   作为构造函数执行，构造函数中\n*   作为对象属性执行，上述代码中`a.fn()`\n*   作为普通函数执行，上述代码中`fn1()`\n*   用于`call``apply``bind`，上述代码中`a.fn.call({name: 'B'})`\n\n下面再来讲解下什么是作用域和作用域链，作用域链和作用域也是常考的题目。\n\n> 题目：如何理解 JS 的作用域和作用域链\n\n### **作用域**\n\nES6 之前 JS 没有块级作用域。例如\n\n    if (true) {\n        var name = 'zhangsan'\n    }\n    console.log(name)\n    \n    \n\n复制\n\n从上面的例子可以体会到作用域的概念，作用域就是一个独立的地盘，让变量不会外泄、暴露出去。上面的`name`就被暴露出去了，因此，**JS 没有块级作用域，只有全局作用域和函数作用域**。\n\n    var a = 100\n    function fn() {\n        var a = 200\n        console.log('fn', a)\n    }\n    console.log('global', a)\n    fn()\n    \n    \n\n复制\n\n全局作用域就是最外层的作用域，如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样的坏处就是很容易撞车、冲突。\n\n    // 张三写的代码中\n    var data = {a: 100}\n    \n    // 李四写的代码中\n    var data = {x: true}\n    \n    \n\n复制\n\n这就是为何 jQuery、Zepto 等库的源码，所有的代码都会放在`(function(){....})()`中。因为放在里面的所有变量，都不会被外泄和暴露，不会污染到外面，不会对其他的库或者 JS 脚本造成影响。这是函数作用域的一个体现。\n\n附：ES6 中开始加入了块级作用域，使用`let`定义变量即可，如下：\n\n    if (true) {\n        let name = 'zhangsan'\n    }\n    console.log(name)  // undefined\n    \n    \n\n复制\n\n### **作用域链**\n\n首先认识一下什么叫做 **自由变量** 。如下代码中，`console.log(a)`要得到`a`变量，但是在当前的作用域中没有定义`a`（可对比一下`b`）。当前作用域没有定义的变量，这成为 **自由变量** 。自由变量如何得到 —— 向父级作用域寻找。\n\n    var a = 100\n    function fn() {\n        var b = 200\n        console.log(a)\n        console.log(b)\n    }\n    fn()\n    \n    \n\n复制\n\n如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 **作用域链** 。\n\n    var a = 100\n    function F1() {\n        var b = 200\n        function F2() {\n            var c = 300\n            console.log(a) // 自由变量，顺作用域链向父作用域找\n            console.log(b) // 自由变量，顺作用域链向父作用域找\n            console.log(c) // 本作用域的变量\n        }\n        F2()\n    }\n    F1()\n    \n    \n\n复制\n\n### **闭包**\n\n讲完这些内容，我们再来看一个例子，通过例子来理解闭包。\n\n    function F1() {\n        var a = 100\n        return function () {\n            console.log(a)\n        }\n    }\n    var f1 = F1()\n    var a = 200\n    f1()\n    \n    \n\n复制\n\n自由变量将从作用域链中去寻找，但是 **依据的是函数定义时的作用域链，而不是函数执行时**，以上这个例子就是闭包。闭包主要有两个应用场景：\n\n*   **函数作为返回值**，上面的例子就是\n*   **函数作为参数传递**，看以下例子\n\n    function F1() {\n        var a = 100\n        return function () {\n            console.log(a)\n        }\n    }\n    function F2(f1) {\n        var a = 200\n        console.log(f1())\n    }\n    var f1 = F1()\n    F2(f1)\n    \n    \n\n复制\n\n至此，对应着「作用域和闭包」这部分一开始的点击弹出`alert`的代码再看闭包，就很好理解了。\n\n* * *\n\n**异步**\n------\n\n异步和同步也是面试中常考的内容，下面笔者来讲解下同步和异步的区别。\n\n### **同步 vs 异步**\n\n先看下面的 demo，根据程序阅读起来表达的意思，应该是先打印`100`，1秒钟之后打印`200`，最后打印`300`。但是实际运行根本不是那么回事。\n\n    console.log(100)\n    setTimeout(function () {\n        console.log(200)\n    }, 1000)\n    console.log(300)\n    \n    \n\n复制\n\n再对比以下程序。先打印`100`，再弹出`200`（等待用户确认），最后打印`300`。这个运行效果就符合预期要求。\n\n    console.log(100)\n    alert(200)  // 1秒钟之后点击确认\n    console.log(300)\n    \n    \n\n复制\n\n这俩到底有何区别？—— 第一个示例中间的步骤根本没有阻塞接下来程序的运行，而第二个示例却阻塞了后面程序的运行。前面这种表现就叫做 **异步**（后面这个叫做 **同步** ），即**不会阻塞后面程序的运行**。\n\n### **异步和单线程**\n\nJS 需要异步的根本原因是 **JS 是单线程运行的**，即在同一时间只能做一件事，不能“一心二用”。\n\n一个 Ajax 请求由于网络比较慢，请求需要 5 秒钟。如果是同步，这 5 秒钟页面就卡死在这里啥也干不了了。异步的话，就好很多了，5 秒等待就等待了，其他事情不耽误做，至于那 5 秒钟等待是网速太慢，不是因为 JS 的原因。\n\n讲到单线程，我们再来看个真题：\n\n> 题目：讲解下面代码的执行过程和结果\n\n    var a = true;\n    setTimeout(function(){\n        a = false;\n    }, 100)\n    while(a){\n        console.log('while执行了')\n    }\n    \n    \n\n复制\n\n这是一个很有迷惑性的题目，不少候选人认为`100ms`之后，由于`a`变成了`false`，所以`while`就中止了，实际不是这样，因为JS是单线程的，所以进入`while`循环之后，没有「时间」（线程）去跑定时器了，所以这个代码跑起来是个死循环！\n\n### **前端异步的场景**\n\n*   定时 `setTimeout``setInverval`\n*   网络请求，如 `Ajax``<img>`加载\n\nAjax 代码示例\n\n    console.log('start')\n    $.get('./data1.json', function (data1) {\n        console.log(data1)\n    })\n    console.log('end')\n    \n    \n\n复制\n\nimg 代码示例（常用于打点统计）\n\n    console.log('start')\n    var img = document.createElement('img')\n    // 或者 img = new Image()\n    img.onload = function () {\n        console.log('loaded')\n        img.onload = null\n    }\n    img.src = '/xxx.png'\n    console.log('end')\n    \n    \n\n复制\n\n* * *\n\n**ES6/7 新标准的考查**\n----------------\n\n> 题目：ES6 箭头函数中的`this`和普通函数中的有什么不同\n\n### **箭头函数**\n\n箭头函数是 ES6 中新的函数定义形式，`function name(arg1, arg2) {...}`可以使用`(arg1, arg2) => {...}`来定义。示例如下：\n\n    // JS 普通函数\n    var arr = [1, 2, 3]\n    arr.map(function (item) {\n        console.log(index)\n        return item + 1\n    })\n    \n    // ES6 箭头函数\n    const arr = [1, 2, 3]\n    arr.map((item, index) => {\n        console.log(index)\n        return item + 1\n    })\n    \n    \n\n复制\n\n箭头函数存在的意义，第一写起来更加简洁，第二可以解决 ES6 之前函数执行中`this`是全局变量的问题，看如下代码\n\n    function fn() {\n        console.log('real', this)  // {a: 100} ，该作用域下的 this 的真实的值\n        var arr = [1, 2, 3]\n        // 普通 JS\n        arr.map(function (item) {\n            console.log('js', this)  // window 。普通函数，这里打印出来的是全局变量，令人费解\n            return item + 1\n        })\n        // 箭头函数\n        arr.map(item => {\n            console.log('es6', this)  // {a: 100} 。箭头函数，这里打印的就是父作用域的 this\n            return item + 1\n        })\n    }\n    fn.call({a: 100})\n    \n    \n\n复制\n\n> 题目：ES6 模块化如何使用？\n\n### **Module**\n\nES6 中模块化语法更加简洁，直接看示例。\n\n如果只是输出一个唯一的对象，使用`export default`即可，代码如下\n\n    // 创建 util1.js 文件，内容如\n    export default {\n        a: 100\n    }\n    \n    // 创建 index.js 文件，内容如\n    import obj from './util1.js'\n    console.log(obj)\n    \n    \n\n复制\n\n如果想要输出许多个对象，就不能用`default`了，且`import`时候要加`{...}`，代码如下\n\n    // 创建 util2.js 文件，内容如\n    export function fn1() {\n        alert('fn1')\n    }\n    export function fn2() {\n        alert('fn2')\n    }\n    \n    // 创建 index.js 文件，内容如\n    import { fn1, fn2 } from './util2.js'\n    fn1()\n    fn2()\n    \n    \n\n复制\n\n> 题目：ES6 class 和普通构造函数的区别\n\n### **class**\n\nclass 其实一直是 JS 的关键字（保留字），但是一直没有正式使用，直到 ES6 。 ES6 的 class 就是取代之前构造函数初始化对象的形式，从语法上更加符合面向对象的写法。例如：\n\nJS 构造函数的写法\n\n    function MathHandle(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n    \n    MathHandle.prototype.add = function () {\n      return this.x + this.y;\n    };\n    \n    var m = new MathHandle(1, 2);\n    console.log(m.add())\n    \n    \n\n复制\n\n用 ES6 class 的写法\n\n    class MathHandle {\n      constructor(x, y) {\n        this.x = x;\n        this.y = y;\n      }\n    \n      add() {\n        return this.x + this.y;\n      }\n    }\n    const m = new MathHandle(1, 2);\n    console.log(m.add())\n    \n    \n\n复制\n\n注意以下几点，全都是关于 class 语法的：\n\n*   class 是一种新的语法形式，是`class Name {...}`这种形式，和函数的写法完全不一样\n*   两者对比，构造函数函数体的内容要放在 class 中的`constructor`函数中，`constructor`即构造器，初始化实例时默认执行\n*   class 中函数的写法是`add() {...}`这种形式，并没有`function`关键字\n\n使用 class 来实现继承就更加简单了，至少比构造函数实现继承简单很多。看下面例子\n\nJS 构造函数实现继承\n\n    // 动物\n    function Animal() {\n        this.eat = function () {\n            console.log('animal eat')\n        }\n    }\n    // 狗\n    function Dog() {\n        this.bark = function () {\n            console.log('dog bark')\n        }\n    }\n    Dog.prototype = new Animal()\n    // 哈士奇\n    var hashiqi = new Dog()\n    \n    \n\n复制\n\nES6 class 实现继承\n\n    class Animal {\n        constructor(name) {\n            this.name = name\n        }\n        eat() {\n            console.log(`${this.name} eat`)\n        }\n    }\n    \n    class Dog extends Animal {\n        constructor(name) {\n            super(name)\n            this.name = name\n        }\n        say() {\n            console.log(`${this.name} say`)\n        }\n    }\n    const dog = new Dog('哈士奇')\n    dog.say()\n    dog.eat()\n    \n    \n\n复制\n\n注意以下两点：\n\n*   使用`extends`即可实现继承，更加符合经典面向对象语言的写法，如 Java\n*   子类的`constructor`一定要执行`super()`，以调用父类的`constructor`\n\n> 题目：ES6 中新增的数据类型有哪些？\n\n### **Set 和 Map**\n\nSet 和 Map 都是 ES6 中新增的数据结构，是对当前 JS 数组和对象这两种重要数据结构的扩展。由于是新增的数据结构，目前尚未被大规模使用，但是作为前端程序员，提前了解是必须做到的。先总结一下两者最关键的地方：\n\n*   Set 类似于数组，但数组可以允许元素重复，Set 不允许元素重复\n*   Map 类似于对象，但普通对象的 key 必须是字符串或者数字，而 Map 的 key 可以是任何数据类型\n\n**Set**\n\nSet 实例不允许元素有重复，可以通过以下示例证明。可以通过一个数组初始化一个 Set 实例，或者通过`add`添加元素，元素不能重复，重复的会被忽略。\n\n    // 例1\n    const set = new Set([1, 2, 3, 4, 4]);\n    console.log(set) // Set(4) {1, 2, 3, 4}\n    \n    // 例2\n    const set = new Set();\n    [2, 3, 5, 4, 5, 8, 8].forEach(item => set.add(item));\n    for (let item of set) {\n      console.log(item);\n    }\n    // 2 3 5 4 8\n    \n    \n\n复制\n\nSet 实例的属性和方法有\n\n*   `size`：获取元素数量。\n*   `add(value)`：添加元素，返回 Set 实例本身。\n*   `delete(value)`：删除元素，返回一个布尔值，表示删除是否成功。\n*   `has(value)`：返回一个布尔值，表示该值是否是 Set 实例的元素。\n*   `clear()`：清除所有元素，没有返回值。\n\n    const s = new Set();\n    s.add(1).add(2).add(2); // 添加元素\n    \n    s.size // 2\n    \n    s.has(1) // true\n    s.has(2) // true\n    s.has(3) // false\n    \n    s.delete(2);\n    s.has(2) // false\n    \n    s.clear();\n    console.log(s);  // Set(0) {}\n    \n    \n\n复制\n\nSet 实例的遍历，可使用如下方法\n\n*   `keys()`：返回键名的遍历器。\n*   `values()`：返回键值的遍历器。不过由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以`keys()`和`values()`返回结果一致。\n*   `entries()`：返回键值对的遍历器。\n*   `forEach()`：使用回调函数遍历每个成员。\n\n    let set = new Set(['aaa', 'bbb', 'ccc']);\n    \n    for (let item of set.keys()) {\n      console.log(item);\n    }\n    // aaa\n    // bbb\n    // ccc\n    \n    for (let item of set.values()) {\n      console.log(item);\n    }\n    // aaa\n    // bbb\n    // ccc\n    \n    for (let item of set.entries()) {\n      console.log(item);\n    }\n    // [\"aaa\", \"aaa\"]\n    // [\"bbb\", \"bbb\"]\n    // [\"ccc\", \"ccc\"]\n    \n    set.forEach((value, key) => console.log(key + ' : ' + value))\n    // aaa : aaa\n    // bbb : bbb\n    // ccc : ccc\n    \n    \n\n复制\n\n**Map**\n\nMap 的用法和普通对象基本一致，先看一下它能用非字符串或者数字作为 key 的特性。\n\n    const map = new Map();\n    const obj = {p: 'Hello World'};\n    \n    map.set(obj, 'OK')\n    map.get(obj) // \"OK\"\n    \n    map.has(obj) // true\n    map.delete(obj) // true\n    map.has(obj) // false\n    \n    \n\n复制\n\n需要使用`new Map()`初始化一个实例，下面代码中`set``get``has``delete`顾名即可思义（下文也会演示）。其中，`map.set(obj, 'OK')`就是用对象作为的 key （不光可以是对象，任何数据类型都可以），并且后面通过`map.get(obj)`正确获取了。\n\nMap 实例的属性和方法如下：\n\n*   `size`：获取成员的数量\n*   `set`：设置成员 key 和 value\n*   `get`：获取成员属性值\n*   `has`：判断成员是否存在\n*   `delete`：删除成员\n*   `clear`：清空所有\n\n    const map = new Map();\n    map.set('aaa', 100);\n    map.set('bbb', 200);\n    \n    map.size // 2\n    \n    map.get('aaa') // 100\n    \n    map.has('aaa') // true\n    \n    map.delete('aaa')\n    map.has('aaa') // false\n    \n    map.clear()\n    \n    \n\n复制\n\nMap 实例的遍历方法有：\n\n*   `keys()`：返回键名的遍历器。\n*   `values()`：返回键值的遍历器。\n*   `entries()`：返回所有成员的遍历器。\n*   `forEach()`：遍历 Map 的所有成员。\n\n    const map = new Map();\n    map.set('aaa', 100);\n    map.set('bbb', 200);\n    \n    for (let key of map.keys()) {\n      console.log(key);\n    }\n    // \"aaa\"\n    // \"bbb\"\n    \n    for (let value of map.values()) {\n      console.log(value);\n    }\n    // 100\n    // 200\n    \n    for (let item of map.entries()) {\n      console.log(item[0], item[1]);\n    }\n    // aaa 100\n    // bbb 200\n    \n    // 或者\n    for (let [key, value] of map.entries()) {\n      console.log(key, value);\n    }\n    // aaa 100\n    // bbb 200\n    \n    \n\n复制\n\n### **Promise**\n\n`Promise`是 CommonJS 提出来的这一种规范，有多个版本，在 ES6 当中已经纳入规范，原生支持 Promise 对象，非 ES6 环境可以用类似 Bluebird、Q 这类库来支持。\n\n`Promise` 可以将回调变成链式调用写法，流程更加清晰，代码更加优雅。\n\n简单归纳下 Promise：**三个状态、两个过程、一个方法**，快速记忆方法：**3-2-1**\n\n三个状态：`pending`、`fulfilled`、`rejected`\n\n两个过程：\n\n*   pending→fulfilled（resolve）\n*   pending→rejected（reject）\n\n一个方法：`then`\n\n当然还有其他概念，如`catch`、 `Promise.all/race`，这里就不展开了。\n\n关于 ES6/7 的考查内容还有很多，本小节就不逐一介绍了，如果想继续深入学习，可以在线看《[ES6入门](https://link.juejin.im?target=http%3A%2F%2Fes6.ruanyifeng.com%2F)》。\n\n**小结**\n------\n\n本小节主要总结了 ES 基础语法中面试经常考查的知识点，包括之前就考查较多的原型、异步、作用域，以及 ES6 的一些新内容，这些知识点希望大家都要掌握。\n\n上一篇：[准备：简历编写和面试前准备](541670)下一篇：[一面 2：JS-Web-API 知识点与高频考题解析](541672)\n\n**一面 2：JS-Web-API 知识点与高频考题解析**\n==============================\n\n除 ES 基础之外，Web 前端经常会用到一些跟浏览器相关的 API，接下来我们一起梳理一下。\n\n**知识点梳理**\n---------\n\n*   BOM 操作\n*   DOM 操作\n*   事件绑定\n*   Ajax\n*   存储\n\n* * *\n\n**BOM**\n-------\n\nBOM（浏览器对象模型）是浏览器本身的一些信息的设置和获取，例如获取浏览器的宽度、高度，设置让浏览器跳转到哪个地址。\n\n*   `navigator`\n*   `screen`\n*   `location`\n*   `history`\n\n这些对象就是一堆非常简单粗暴的 API，没任何技术含量，讲起来一点意思都没有，大家去 MDN 或者 w3school 这种网站一查就都明白了。面试的时候，面试官基本不会出太多这方面的题目，因为只要基础知识过关了，这些 API 即便你记不住，上网一查也都知道了。下面列举一下常用功能的代码示例\n\n获取浏览器特性（即俗称的`UA`）然后识别客户端，例如判断是不是 Chrome 浏览器\n\n    var ua = navigator.userAgent\n    var isChrome = ua.indexOf('Chrome')\n    console.log(isChrome)\n    \n    \n\n复制\n\n获取屏幕的宽度和高度\n\n    console.log(screen.width)\n    console.log(screen.height)\n    \n    \n\n复制\n\n获取网址、协议、path、参数、hash 等\n\n    // 例如当前网址是 https://juejin.im/timeline/frontend?a=10&b=10#some\n    console.log(location.href)  // https://juejin.im/timeline/frontend?a=10&b=10#some\n    console.log(location.protocol) // https:\n    console.log(location.pathname) // /timeline/frontend\n    console.log(location.search) // ?a=10&b=10\n    console.log(location.hash) // #some\n    \n    \n\n复制\n\n另外，还有调用浏览器的前进、后退功能等\n\n    history.back()\n    history.forward()\n    \n    \n\n复制\n\n* * *\n\n**DOM**\n-------\n\n> 题目：DOM 和 HTML 区别和联系\n\n### **什么是 DOM**\n\n讲 DOM 先从 HTML 讲起，讲 HTML 先从 XML 讲起。XML 是一种可扩展的标记语言，所谓可扩展就是它可以描述任何结构化的数据，它是一棵树！\n\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <note>\n      <to>Tove</to>\n      <from>Jani</from>\n      <heading>Reminder</heading>\n      <body>Don't forget me this weekend!</body>\n      <other>\n        <a></a>\n        <b></b>\n      </other>\n    </note>\n    \n    \n\n复制\n\nHTML 是一个有既定标签标准的 XML 格式，标签的名字、层级关系和属性，都被标准化（否则浏览器无法解析）。同样，它也是一棵树。\n\n    <!DOCTYPE html>\n    <html>\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Document</title>\n    </head>\n    <body>\n        <div>\n            <p>this is p</p>\n        </div>\n    </body>\n    </html>\n    \n    \n\n复制\n\n我们开发完的 HTML 代码会保存到一个文档中（一般以`.html`或者`.htm`结尾），文档放在服务器上，浏览器请求服务器，这个文档被返回。因此，最终浏览器拿到的是一个文档而已，文档的内容就是 HTML 格式的代码。\n\n但是浏览器要把这个文档中的 HTML 按照标准渲染成一个页面，此时浏览器就需要将这堆代码处理成自己能理解的东西，也得处理成 JS 能理解的东西，因为还得允许 JS 修改页面内容呢。\n\n基于以上需求，浏览器就需要把 HTML 转变成 DOM，HTML 是一棵树，DOM 也是一棵树。对 DOM 的理解，可以暂时先抛开浏览器的内部因素，先从 JS 着手，即可以认为 DOM 就是 JS 能识别的 HTML 结构，一个普通的 JS 对象或者数组。\n\n!\\[DOM图示\\](data:image/svg+xml;utf8,)\n\n### **获取 DOM 节点**\n\n最常用的 DOM API 就是获取节点，其中常用的获取方法如下面代码示例：\n\n    // 通过 id 获取\n    var div1 = document.getElementById('div1') // 元素\n    \n    // 通过 tagname 获取\n    var divList = document.getElementsByTagName('div')  // 集合\n    console.log(divList.length)\n    console.log(divList[0])\n    \n    // 通过 class 获取\n    var containerList = document.getElementsByClassName('container') // 集合\n    \n    // 通过 CSS 选择器获取\n    var pList = document.querySelectorAll('p') // 集合\n    \n    \n\n复制\n\n> 题目：property 和 attribute 的区别是什么？\n\n### **property**\n\nDOM 节点就是一个 JS 对象，它符合之前讲述的对象的特征 —— 可扩展属性，因为 DOM 节点本质上也是一个 JS 对象。因此，如下代码所示，`p`可以有`style`属性，有`className``nodeName``nodeType`属性。注意，**这些都是 JS 范畴的属性，符合 JS 语法标准的**。\n\n    var pList = document.querySelectorAll('p')\n    var p = pList[0]\n    console.log(p.style.width)  // 获取样式\n    p.style.width = '100px'  // 修改样式\n    console.log(p.className)  // 获取 class\n    p.className = 'p1'  // 修改 class\n    \n    // 获取 nodeName 和 nodeType\n    console.log(p.nodeName)\n    console.log(p.nodeType)\n    \n    \n\n复制\n\n### **attribute**\n\nproperty 的获取和修改，是直接改变 JS 对象，而 attribute 是直接改变 HTML 的属性，两种有很大的区别。attribute 就是对 HTML 属性的 get 和 set，和 DOM 节点的 JS 范畴的 property 没有关系。\n\n    var pList = document.querySelectorAll('p')\n    var p = pList[0]\n    p.getAttribute('data-name')\n    p.setAttribute('data-name', 'juejin')\n    p.getAttribute('style')\n    p.setAttribute('style', 'font-size:30px;')\n    \n    \n\n复制\n\n而且，get 和 set attribute 时，还会触发 DOM 的查询或者重绘、重排，频繁操作会影响页面性能。\n\n> 题目：DOM 操作的基本 API 有哪些？\n\n### **DOM 树操作**\n\n新增节点\n\n    var div1 = document.getElementById('div1')\n    \n    // 添加新节点\n    var p1 = document.createElement('p')\n    p1.innerHTML = 'this is p1'\n    div1.appendChild(p1) // 添加新创建的元素\n    \n    // 移动已有节点。注意，这里是“移动”，并不是拷贝\n    var p2 = document.getElementById('p2')\n    div1.appendChild(p2)\n    \n    \n\n复制\n\n获取父元素\n\n    var div1 = document.getElementById('div1')\n    var parent = div1.parentElement\n    \n    \n\n复制\n\n获取子元素\n\n    var div1 = document.getElementById('div1')\n    var child = div1.childNodes\n    \n    \n\n复制\n\n删除节点\n\n    var div1 = document.getElementById('div1')\n    var child = div1.childNodes\n    div1.removeChild(child[0])\n    \n    \n\n复制\n\n还有其他操作的API，例如获取前一个节点、获取后一个节点等，但是面试过程中经常考到的就是上面几个。\n\n* * *\n\n**事件**\n------\n\n### **事件绑定**\n\n普通的事件绑定写法如下：\n\n    var btn = document.getElementById('btn1')\n    btn.addEventListener('click', function (event) {\n        // event.preventDefault() // 阻止默认行为\n        // event.stopPropagation() // 阻止冒泡\n        console.log('clicked')\n    })\n    \n    \n\n复制\n\n为了编写简单的事件绑定，可以编写通用的事件绑定函数。这里虽然比较简单，但是会随着后文的讲解，来继续完善和丰富这个函数。\n\n    // 通用的事件绑定函数\n    function bindEvent(elem, type, fn) {\n        elem.addEventListener(type, fn)\n    }\n    var a = document.getElementById('link1')\n    // 写起来更加简单了\n    bindEvent(a, 'click', function(e) {\n        e.preventDefault() // 阻止默认行为\n        alert('clicked')\n    })\n    \n    \n\n复制\n\n最后，**如果面试被问到 IE 低版本兼容性问题，我劝你果断放弃这份工作机会**。现在互联网流量都在 App 上， IE 占比越来越少，再去为 IE 浪费青春不值得，要尽量去做 App 相关的工作。\n\n> 题目：什么是事件冒泡？\n\n### **事件冒泡**\n\n    <body>\n        <div id=\"div1\">\n            <p id=\"p1\">激活</p>\n            <p id=\"p2\">取消</p>\n            <p id=\"p3\">取消</p>\n            <p id=\"p4\">取消</p>\n        </div>\n        <div id=\"div2\">\n            <p id=\"p5\">取消</p>\n            <p id=\"p6\">取消</p>\n        </div>\n    </body>\n    \n    \n\n复制\n\n对于以上 HTML 代码结构，要求点击`p1`时候进入激活状态，点击其他任何`<p>`都取消激活状态，如何实现？代码如下，注意看注释：\n\n    var body = document.body\n    bindEvent(body, 'click', function (e) {\n        // 所有 p 的点击都会冒泡到 body 上，因为 DOM 结构中 body 是 p 的上级节点，事件会沿着 DOM 树向上冒泡\n        alert('取消')\n    })\n    \n    var p1 = document.getElementById('p1')\n    bindEvent(p1, 'click', function (e) {\n        e.stopPropagation() // 阻止冒泡\n        alert('激活')\n    })\n    \n    \n\n复制\n\n如果我们在`p1``div1``body`中都绑定了事件，它是会根据 DOM 的结构来冒泡，从下到上挨个执行的。但是我们使用`e.stopPropagation()`就可以阻止冒泡\n\n> 题目：如何使用事件代理？有何好处？\n\n### **事件代理**\n\n我们设定一种场景，如下代码，一个`<div>`中包含了若干个`<a>`，而且还能继续增加。那如何快捷方便地为所有`<a>`绑定事件呢？\n\n    <div id=\"div1\">\n        <a href=\"#\">a1</a>\n        <a href=\"#\">a2</a>\n        <a href=\"#\">a3</a>\n        <a href=\"#\">a4</a>\n    </div>\n    <button>点击增加一个 a 标签</button>\n    \n    \n\n复制\n\n这里就会用到事件代理。我们要监听`<a>`的事件，但要把具体的事件绑定到`<div>`上，然后看事件的触发点是不是`<a>`。\n\n    var div1 = document.getElementById('div1')\n    div1.addEventListener('click', function (e) {\n        // e.target 可以监听到触发点击事件的元素是哪一个\n        var target = e.target\n        if (e.nodeName === 'A') {\n            // 点击的是 <a> 元素\n            alert(target.innerHTML)\n        }\n    })\n    \n    \n\n复制\n\n我们现在完善一下之前写的通用事件绑定函数，加上事件代理。\n\n    function bindEvent(elem, type, selector, fn) {\n        // 这样处理，可接收两种调用方式 bindEvent(div1, 'click', 'a', function () {...}) 和 bindEvent(div1, 'click', function () {...}) 这两种\n        if (fn == null) {\n            fn = selector\n            selector = null\n        }\n    \n        // 绑定事件\n        elem.addEventListener(type, function (e) {\n            var target\n            if (selector) {\n                // 有 selector 说明需要做事件代理\n                // 获取触发时间的元素，即 e.target\n                target = e.target\n                // 看是否符合 selector 这个条件\n                if (target.matches(selector)) {\n                    fn.call(target, e)\n                }\n            } else {\n                // 无 selector ，说明不需要事件代理\n                fn(e)\n            }\n        })\n    }\n    \n    \n\n复制\n\n然后这样使用，简单很多。\n\n    // 使用代理，bindEvent 多一个 'a' 参数\n    var div1 = document.getElementById('div1')\n    bindEvent(div1, 'click', 'a', function (e) {\n        console.log(this.innerHTML)\n    })\n    \n    // 不使用代理\n    var a = document.getElementById('a1')\n    bindEvent(div1, 'click', function (e) {\n        console.log(a.innerHTML)\n    })\n    \n    \n\n复制\n\n最后，使用代理的优点如下：\n\n*   使代码简洁\n*   减少浏览器的内存占用\n\n* * *\n\n**Ajax**\n--------\n\n### **XMLHttpRequest**\n\n> 题目：手写 XMLHttpRequest 不借助任何库\n\n这是很多奇葩的、个性的面试官经常用的手段。这种考查方式存在很多争议，但是你不能完全说它是错误的，毕竟也是考查对最基础知识的掌握情况。\n\n    var xhr = new XMLHttpRequest()\n    xhr.open(\"GET\", \"/api\", false)\n    xhr.onreadystatechange = function () {\n        // 这里的函数异步执行，可参考之前 JS 基础中的异步模块\n        if (xhr.readyState == 4) {\n            if (xhr.status == 200) {\n                alert(xhr.responseText)\n            }\n        }\n    }\n    xhr.send(null)\n    \n    \n\n复制\n\n当然，使用 jQuery、Zepto 或 Fetch 等库来写就更加简单了，这里不再赘述。\n\n### **状态码说明**\n\n上述代码中，有两处状态码需要说明。`xhr.readyState`是浏览器判断请求过程中各个阶段的，`xhr.status`是 HTTP 协议中规定的不同结果的返回状态说明。\n\n`xhr.readyState`的状态码说明：\n\n*   0 - (未初始化）还没有调用`send()`方法\n*   1 -（载入）已调用`send()`方法，正在发送请求\n*   2 -（载入完成）`send()`方法执行完成，已经接收到全部响应内容\n*   3 -（交互）正在解析响应内容\n*   4 -（完成）响应内容解析完成，可以在客户端调用了\n\n> 题目：HTTP 协议中，response 的状态码，常见的有哪些？\n\n`xhr.status`即 HTTP 状态码，有 `2xx``3xx``4xx``5xx` 这几种，比较常用的有以下几种：\n\n*   `200` 正常\n*   `3xx`\n    *   `301` 永久重定向。如`http://xxx.com`这个 GET 请求（最后没有`/`），就会被`301`到`http://xxx.com/`（最后是`/`）\n    *   `302` 临时重定向。临时的，不是永久的\n    *   `304` 资源找到但是不符合请求条件，不会返回任何主体。如发送 GET 请求时，head 中有`If-Modified-Since: xxx`（要求返回更新时间是`xxx`时间之后的资源），如果此时服务器 端资源未更新，则会返回`304`，即不符合要求\n*   `404` 找不到资源\n*   `5xx` 服务器端出错了\n\n看完要明白，为何上述代码中要同时满足`xhr.readyState == 4`和`xhr.status == 200`。\n\n### **Fetch API**\n\n目前已经有一个获取 HTTP 请求更加方便的 API：`Fetch`，通过`Fetch`提供的`fetch()`这个全局函数方法可以很简单地发起异步请求，并且支持`Promise`的回调。但是 Fetch API 是比较新的 API，具体使用的时候还需要查查 [caniuse](https://link.juejin.im?target=https%3A%2F%2Fcaniuse.com%2F)，看下其浏览器兼容情况。\n\n看一个简单的例子：\n\n    fetch('some/api/data.json', {\n      method:'POST', //请求类型 GET、POST\n      headers:{}, // 请求的头信息，形式为 Headers 对象或 ByteString\n      body:{}, //请求发送的数据 blob、BufferSource、FormData、URLSearchParams（get 或head 方法中不能包含 body）\n      mode:'', //请求的模式，是否跨域等，如 cors、 no-cors 或 same-origin\n      credentials:'', //cookie 的跨域策略，如 omit、same-origin 或 include\n      cache:'', //请求的 cache 模式: default、no-store、reload、no-cache、 force-cache 或 only-if-cached\n    }).then(function(response) { ... });\n    \n    \n\n复制\n\n`Fetch` 支持`headers`定义，通过`headers`自定义可以方便地实现多种请求方法（ PUT、GET、POST 等）、请求头（包括跨域）和`cache`策略等；除此之外还支持 response（返回数据）多种类型，比如支持二进制文件、字符串和`formData`等。\n\n### **跨域**\n\n> 题目：如何实现跨域？\n\n浏览器中有 **同源策略** ，即一个域下的页面中，无法通过 Ajax 获取到其他域的接口。例如有一个接口`http://m.juejin.com/course/ajaxcourserecom?cid=459`，你自己的一个页面`http://www.yourname.com/page1.html`中的 Ajax 无法获取这个接口。这正是命中了“同源策略”。如果浏览器哪些地方忽略了同源策略，那就是浏览器的安全漏洞，需要紧急修复。\n\nurl 哪些地方不同算作跨域？\n\n*   协议\n*   域名\n*   端口\n\n但是 HTML 中几个标签能逃避过同源策略——`<script src=\"xxx\">`、`<img src=\"xxxx\"/>`、`<link href=\"xxxx\">`，这三个标签的`src/href`可以加载其他域的资源，不受同源策略限制。\n\n因此，这使得这三个标签可以做一些特殊的事情。\n\n*   `<img>`可以做打点统计，因为统计方并不一定是同域的，在讲解 JS 基础知识异步的时候有过代码示例。除了能跨域之外，`<img>`几乎没有浏览器兼容问题，它是一个非常古老的标签。\n*   `<script>`和`<link>`可以使用 CDN，CDN 基本都是其他域的链接。\n*   另外`<script>`还可以实现 JSONP，能获取其他域接口的信息，接下来马上讲解。\n\n但是请注意，所有的跨域请求方式，最终都需要信息提供方来做出相应的支持和改动，也就是要经过信息提供方的同意才行，否则接收方是无法得到它们的信息的，浏览器是不允许的。\n\n### **解决跨域 \\- JSONP**\n\n首先，有一个概念你要明白，例如访问`http://coding.m.juejin.com/classindex.html`的时候，服务器端就一定有一个`classindex.html`文件吗？—— 不一定，服务器可以拿到这个请求，动态生成一个文件，然后返回。 同理，`<script src=\"http://coding.m.juejin.com/api.js\">`也不一定加载一个服务器端的静态文件，服务器也可以动态生成文件并返回。OK，接下来正式开始。\n\n例如我们的网站和掘金网，肯定不是一个域。我们需要掘金网提供一个接口，供我们来获取。首先，我们在自己的页面这样定义\n\n    <script>\n    window.callback = function (data) {\n        // 这是我们跨域得到信息\n        console.log(data)\n    }\n    </script>\n    \n    \n\n复制\n\n然后掘金网给我提供了一个`http://coding.m.juejin.com/api.js`，内容如下（之前说过，服务器可动态生成内容）\n\n    callback({x:100, y:200})\n    \n    \n\n复制\n\n最后我们在页面中加入`<script src=\"http://coding.m.juejin.com/api.js\"></script>`，那么这个js加载之后，就会执行内容，我们就得到内容了。\n\n### **解决跨域 \\- 服务器端设置 http header**\n\n这是需要在服务器端设置的，作为前端工程师我们不用详细掌握，但是要知道有这么个解决方案。而且，现在推崇的跨域解决方案是这一种，比 JSONP 简单许多。\n\n    response.setHeader(\"Access-Control-Allow-Origin\", \"http://m.juejin.com/\");  // 第二个参数填写允许跨域的域名称，不建议直接写 \"*\"\n    response.setHeader(\"Access-Control-Allow-Headers\", \"X-Requested-With\");\n    response.setHeader(\"Access-Control-Allow-Methods\", \"PUT,POST,GET,DELETE,OPTIONS\");\n    \n    // 接收跨域的cookie\n    response.setHeader(\"Access-Control-Allow-Credentials\", \"true\");\n    \n    \n\n复制\n\n* * *\n\n**存储**\n------\n\n> 题目：cookie 和 localStorage 有何区别？\n\n### **cookie**\n\ncookie 本身不是用来做服务器端存储的（计算机领域有很多这种“狗拿耗子”的例子，例如 CSS 中的 float），它是设计用来在服务器和客户端进行信息传递的，因此我们的每个 HTTP 请求都带着 cookie。但是 cookie 也具备浏览器端存储的能力（例如记住用户名和密码），因此就被开发者用上了。\n\n使用起来也非常简单，`document.cookie = ....`即可。\n\n但是 cookie 有它致命的缺点：\n\n*   存储量太小，只有 4KB\n*   所有 HTTP 请求都带着，会影响获取资源的效率\n*   API 简单，需要封装才能用\n\n### **locationStorage 和 sessionStorage**\n\n后来，HTML5 标准就带来了`sessionStorage`和`localStorage`，先拿`localStorage`来说，它是专门为了浏览器端缓存而设计的。其优点有：\n\n*   存储量增大到 5MB\n*   不会带到 HTTP 请求中\n*   API 适用于数据存储 `localStorage.setItem(key, value)``localStorage.getItem(key)`\n\n`sessionStorage`的区别就在于它是根据 session 过去时间而实现，而`localStorage`会永久有效，应用场景不同。例如，一些需要及时失效的重要信息放在`sessionStorage`中，一些不重要但是不经常设置的信息，放在`localStorage`中。\n\n另外告诉大家一个小技巧，针对`localStorage.setItem`，使用时尽量加入到`try-catch`中，某些浏览器是禁用这个 API 的，要注意。\n\n* * *\n\n**小结**\n------\n\n本小节总结了 W3C 标准中 Web-API 部分，面试中常考的知识点，这些也是日常开发中最常用的 API 和知识。\n\n上一篇：[一面 1：ES 基础知识点与高频考题解析](541671)下一篇：[一面 3：CSS-HTML 知识点与高频考题解析](541673)\n\n**一面 3：CSS-HTML 知识点与高频考题解析**\n============================\n\nCSS 和 HTML 是网页开发中布局相关的组成部分，涉及的内容比较多和杂乱，本小节重点介绍下常考的知识点。\n\n**知识点梳理**\n---------\n\n*   选择器的权重和优先级\n*   盒模型\n    *   盒子大小计算\n    *   margin 的重叠计算\n*   浮动`float`\n    *   浮动布局概念\n    *   清理浮动\n*   定位`position`\n    *   文档流概念\n    *   定位分类\n    *   fixed 定位特点\n    *   绝对定位计算方式\n*   `flex`布局\n*   如何实现居中对齐？\n*   理解语义化\n*   CSS3 动画\n*   重绘和回流\n\n* * *\n\n**选择器的权重和优先级**\n--------------\n\nCSS 选择器有很多，不同的选择器的权重和优先级不一样，对于一个元素，如果存在多个选择器，那么就需要根据权重来计算其优先级。\n\n权重分为四级，分别是：\n\n1.  代表内联样式，如`style=\"xxx\"`，权值为 1000；\n2.  代表 ID 选择器，如`#content`，权值为 100；\n3.  代表类、伪类和属性选择器，如`.content`、`:hover`、`[attribute]`，权值为 10；\n4.  代表元素选择器和伪元素选择器，如`div`、`p`，权值为 1。\n\n**需要注意的是：通用选择器（*）、子选择器（>）和相邻同胞选择器（+）并不在这四个等级中，所以他们的权值都为 0**。 权重值大的选择器其优先级也高，相同权重的优先级又遵循后定义覆盖前面定义的情况。\n\n**盒模型**\n-------\n\n### **什么是“盒子”**\n\n初学 CSS 的朋友，一开始学 CSS 基础知识的时候一定学过`padding``border`和`margin`，即内边距、边框和外边距。它们三者就构成了一个“盒子”。就像我们收到的快递，本来买了一部小小的手机，收到的却是那么大一个盒子。因为手机白色的包装盒和手机机器之间有间隔层（内边距），手机白色盒子有厚度，虽然很薄（边框），盒子和快递箱子之间还有一层泡沫板（外边距）。这就是一个典型的盒子。\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n如上图，真正的内容就是这些文字，文字外围有 10px 的内边距，5px 的边框，10px 的外边距。看到盒子了吧？\n\n> 题目：盒子模型的宽度如何计算\n\n### **固定宽度的盒子**\n\n    <div style=\"padding:10px; border:5px solid blue; margin: 10px; width:300px;\">\n        之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》，\n        文章言简意赅的介绍的浏览器的工作过程，web前端\n    </div>\n    \n    \n\n复制\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n如上图，得到网页效果之后，我们可以用截图工具来量一下文字内容的宽度。发现，文字内容的宽度刚好是 300px，也就是我们设置的宽度。\n\n因此，**在盒子模型中，我们设置的宽度都是内容宽度，不是整个盒子的宽度。而整个盒子的宽度是：（内容宽度 \\+ `border`宽度 \\+ `padding`宽度 \\+ `margin`宽度）之和**。这样我们改四个中的其中一个，都会导致盒子宽度的改变。这对我们来说不友好。\n\n没关系，这个东西不友好早就有人发现了，而且已经解决，下文再说。\n\n### **充满父容器的盒子**\n\n默认情况下，`div`是`display:block`，宽度会充满整个父容器。如下图：\n\n    <div style=\"padding:10px; border:5px solid blue; margin: 10px; width:300px;\">\n        之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》，\n        文章言简意赅的介绍的浏览器的工作过程，web前端\n        之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》，\n        文章言简意赅的介绍的浏览器的工作过程，web前端\n    </div>\n    \n    \n\n复制\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n但是别忘记，这个 div 是个盒子模型，它的整个宽度包括（内容宽度 + `border`宽度 \\+ `padding`宽度 \\+ `margin`宽度），整个的宽度充满父容器。\n\n问题就在这里。如果父容器宽度不变，我们手动增大`margin`、`border`或`padding`其中一项的宽度值，都会导致内容宽度的减少。极端情况下，如果内容的宽度压缩到不能再压缩了（例如一个字的宽度），那么浏览器会强迫增加父容器的宽度。这可不是我们想要看到的。\n\n### **包裹内容的盒子**\n\n这种情况下比较简单，内容的宽度按照内容计算，盒子的宽度将在内容宽度的基础上再增加（`padding`宽度 \\+ `border`宽度 \\+ `margin`宽度）之和。\n\n    <div style=\"padding:10px; border:5px solid blue; margin: 10px; width:300px;\">\n        之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》\n    </div>\n    \n    \n\n复制\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n### `box-sizing:border-box`\n\n前面提到，为盒子模型设置宽度，结果只是设置了内容的宽度，这个不合理。如何解决这一问题？答案就是为盒子指定样式：**`box-sizing:border-box`**。\n\n    <div style=\"padding:10px; border:5px solid blue; margin: 10px; width:300px; box-sizing:border-box;\">\n        之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》\n    </div>\n    \n    \n\n复制\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n上图中，为`div`设置了`box-sizing:border-box`之后，300px 的**宽度是内容 \\+ `border` \\+ 边框的宽度（不包括`margin`）**，这样就比较符合我们的实际要求了。建议大家在为系统写 CSS 时候，第一个样式是：\n\n    * {\n        box-sizing:border-box;\n    }\n    \n    \n\n复制\n\n大名鼎鼎的 Bootstrap 也把`box-sizing:border-box`加入到它的`*`选择器中，我们为什么不这样做呢？\n\n### **纵向 margin 重叠**\n\n这里提到 margin，就不得不提一下 margin 的这一特性——纵向重叠。如`<p>`的纵向 margin 是 16px，那么两个`<p>`之间纵向的距离是多少？—— 按常理来说应该是 16 + 16 = 32px，但是答案仍然是 16px。因为纵向的 margin 是会重叠的，如果两者不一样大的话，大的会把小的“吃掉”。\n\n* * *\n\n**浮动`float`**\n-------------\n\nfloat 用于网页布局比较多，使用起来也比较简单，这里总结了一些比较重要、需要注意的知识点，供大家参考。\n\n### **误解和误用**\n\nfloat 被设计出来的初衷是用于**文字环绕效果**，即一个图片一段文字，图片`float:left`之后，文字会环绕图片。\n\n    <div>\n        <img src=\"image/1.png\" style=\"float:left\">\n        一段文字一段文字一段文字一段文字一段文字一段文字一段文字一段文字一段文字\n    </div>\n    \n    \n\n复制\n\n但是，后来大家发现结合`float + div`可以实现之前通过`table`实现的网页布局，因此就被“误用”于网页布局了。\n\n> 题目：为何 float 会导致父元素塌陷？\n\n### **破坏性**\n\n!\\[\\](data:image/svg+xml;utf8,)\n\nfloat 的**破坏性** —— float 破坏了父标签的原本结构，使得父标签出现了坍塌现象。导致这一现象的最根本原因在于：**被设置了 float 的元素会脱离文档流**。其根本原因在于 float 的设计初衷是解决文字环绕图片的问题。大家要记住 float 的这个影响。\n\n### **包裹性**\n\n**包裹性**也是 float 的一个非常重要的特性，大家用 float 时一定要熟知这一特性。咱们还是先从一个小例子看起：\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n如上图，普通的 div 如果没有设置宽度，它会撑满整个屏幕，在之前的盒子模型那一节也讲到过。而如果给 div 增加`float:left`之后，它突然变得紧凑了，宽度发生了变化，把内容中的三个字包裹了——这就是包裹性。为 div 设置了 float 之后，其宽度会自动调整为包裹住内容宽度，而不是撑满整个父容器。\n\n注意，此时 div 虽然体现了包裹性，但是它的 display 样式是没有变化的，还是`display: block`。\n\nfloat 为什么要具有包裹性？其实答案还是得从 float 的设计初衷来寻找，float 是被设计用于实现文字环绕效果的。文字环绕图片比较好理解，但是如果想要让文字环绕一个 div 呢？此时 div 不被“包裹”起来的话，就无法实现环绕效果了。\n\n### **清空格**\n\nfloat 还有一个大家可能不是很熟悉的特性——清空格。按照惯例，咱还是先举例子说明。\n\n    <div style=\"border: 2px solid blue; padding:3px;\">\n        <img src=\"image/1.png\"/>\n        <img src=\"image/2.png\"/>\n        <img src=\"image/3.png\"/>\n        <img src=\"image/4.png\"/>\n    </div>\n    \n    \n\n复制\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n加上`float:left`之后：\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n上面第一张图中，正常的 img 中间是会有空格的，因为多个 img 标签会有换行，而浏览器识别换行为空格，这也是很正常的。第二张图中，为 img 增加了`float:left`的样式，这就使得 img 之间没有了空格，4 个 img 紧紧挨着。\n\n如果大家之前没注意，现在想想之前写过的程序，是不是有这个特性。为什么 float 适合用于网页排版（俗称“砌砖头”）？就是因为 float 排版出来的网页严丝合缝，中间连个苍蝇都飞不进去。\n\n“清空格”这一特性的根本原因是 float 会导致节点脱离文档流结构。它都不属于文档流结构了，那么它身边的什么换行、空格就都和它没了关系，它就尽量往一边靠拢，能靠多近就靠多近，这就是清空格的本质。\n\n> 题目：手写 clearfix\n\n### **`clearfix`**\n\n清除浮动的影响，一般使用的样式如下，统称`clearfix`代码。所有 float 元素的父容器，一般情况下都应该加`clearfix`这个 class。\n\n    .clearfix:after {\n        content: '';\n        display: table;\n        clear: both;\n    }\n    .clearfix {\n        *zoom: 1; /* 兼容 IE 低版本 */\n    }\n    \n    \n\n复制\n\n    <div class=\"clearfix\">\n        <img src=\"image/1.png\" style=\"float: left\"/>\n        <img src=\"image/2.png\" style=\"float: left\"/>\n    </div>\n    \n    \n\n复制\n\n### **小结**\n\nfloat 的设计初衷是解决文字环绕图片的问题，后来误打误撞用于做布局，因此有许多不合适或者需要注意的地方，上文基本都讲到了需要的知识点。如果是刚开始接触 float 的同学，学完上面的基础知识之后，还应该做一些练习实战一下 —— 经典的“圣杯布局”和“双飞翼布局”。这里就不再展开讲了，网上资料非常多，例如[浅谈面试中常考的两种经典布局——圣杯与双飞翼](https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fentry%2F5a8868cdf265da4e7e10c133%3Futm_source%3Dgold_browser_extension)（此文的最后两张图清晰地展示了这两种布局）。\n\n* * *\n\n**定位`position`**\n----------------\n\nposition 用于网页元素的定位，可设置 static/relative/absolute/fixed 这些值，其中 static 是默认值，不用介绍。\n\n> 题目：relative 和 absolute 有何区别？\n\n### **relative**\n\n相对定位 relative 可以用一个例子很轻松地演示出来。例如我们写 4 个`<p>`，出来的样子大家不用看也能知道。\n\n    <p>第一段文字</p>\n    <p>第二段文字</p>\n    <p>第三段文字</p>\n    <p>第四段文字</p>\n    \n    \n\n复制\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n然后我们在第三个`<p>`上面，加上`position:relative`并且设置`left`和`top`值，看这个`<p>`有什么变化。\n\n    <p>第一段文字</p>\n    <p>第二段文字</p>\n    <p style=\"position:relative; top: 10px; left: 10px\">第三段文字</p>\n    <p>第四段文字</p>\n    \n    \n\n复制\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n上图中，大家应该要识别出两个信息（相信大部分人会忽略第二个信息）\n\n*   第三个`<p>`发生了位置变化，分别向右向下移动了10px；\n*   其他的三个`<p>`位置没有发生变化，这一点也很重要。\n\n可见，**relative 会导致自身位置的相对变化，而不会影响其他元素的位置、大小**。这是 relative 的要点之一。还有第二个要点，就是 relative 产生一个新的定位上下文。下文有关于定位上下文的详细介绍，这里可以先通过一个例子来展示一下区别：\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n注意看这两图的区别，下文将有解释。\n\n### **absolute**\n\n还是先写一个基本的 demo。\n\n    <p>第一段文字</p>\n    <p>第二段文字</p>\n    <p style=\"background: yellow\">第三段文字</p>\n    <p>第四段文字</p>\n    \n    \n\n复制\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n然后，我们把第三个`<p>`改为`position:absolute;`，看看会发生什么变化。\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n从上面的结果中，我们能看出几点信息：\n\n*   absolute 元素脱离了文档结构。和 relative 不同，其他三个元素的位置重新排列了。只要元素会脱离文档结构，它就会产生破坏性，导致父元素坍塌。（此时你应该能立刻想起来，float 元素也会脱离文档结构。）\n*   absolute 元素具有“包裹性”。之前`<p>`的宽度是撑满整个屏幕的，而此时`<p>`的宽度刚好是内容的宽度。\n*   absolute 元素具有“跟随性”。虽然 absolute 元素脱离了文档结构，但是它的位置并没有发生变化，还是老老实实地呆在它原本的位置，因为我们此时没有设置 top、left 的值。\n*   absolute 元素会悬浮在页面上方，会遮挡住下方的页面内容。\n\n最后，通过给 absolute元素设置 top、left 值，可自定义其内容，这个都是平时比较常用的了。这里需要注意的是，设置了 top、left 值时，元素是相对于最近的定位上下文来定位的，而不是相对于浏览器定位。\n\n### **fixed**\n\n其实 fixed 和 absolute 是一样的，唯一的区别在于：absolute 元素是根据最近的定位上下文确定位置，而 fixed 根据浏览器确定位置。\n\n> 题目：relative、absolute 和 fixed 分别依据谁来定位？\n\n### **定位上下文**\n\nrelative 元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。\n\n!\\[\\](data:image/svg+xml;utf8,)\n\nfixed 元素的定位是相对于浏览器边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。\n\n!\\[\\](data:image/svg+xml;utf8,)\n\nabsolute 的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了`position:relative/absolute/fixed`的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。如下两个图所示：\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n* * *\n\n**`flex`布局**\n------------\n\n布局的传统解决方案基于盒子模型，依赖 `display` 属性 \\+ `position` 属性 \\+ `float` 属性。它对于那些特殊布局非常不方便，比如，垂直居中（下文会专门讲解）就不容易实现。在目前主流的移动端页面中，使用 flex 布局能更好地完成需求，因此 flex 布局的知识是必须要掌握的。\n\n### **基本使用**\n\n任何一个容器都可以使用 flex 布局，代码也很简单。\n\n    <style type=\"text/css\">\n        .container {\n          display: flex;\n        }\n        .item {\n            border: 1px solid #000;\n            flex: 1;\n        }\n    </style>\n    \n    <div class=\"container\">\n        <div class=\"item\">aaa</div>\n        <div class=\"item\" style=\"flex: 2\">bbb</div>\n        <div class=\"item\">ccc</div>\n        <div class=\"item\">ddd</div>\n    </div>\n    \n    \n\n复制\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n注意，第三个`<div>`的`flex: 2`，其他的`<div>`的`flex: 1`，这样第二个`<div>`的宽度就是其他的`<div>`的两倍。\n\n### **设计原理**\n\n设置了`display: flex`的元素，我们称为“容器”（flex container），其所有的子节点我们称为“成员”（flex item）。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n将以上文字和图片结合起来，再详细看一遍，这样就能理解 flex 的设计原理，才能更好地实际使用。\n\n### **设置主轴的方向**\n\n`flex-direction`可决定主轴的方向，有四个可选值：\n\n*   row（默认值）：主轴为水平方向，起点在左端。\n*   row-reverse：主轴为水平方向，起点在右端。\n*   column：主轴为垂直方向，起点在上沿。\n*   column-reverse：主轴为垂直方向，起点在下沿。\n\n    .box {\n      flex-direction: column-reverse| column | row | row-reverse;\n    }\n    \n    \n\n复制\n\n以上代码设置的主轴方向，将依次对应下图：\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n### **设置主轴的对齐方式**\n\n`justify-content`属性定义了项目在主轴上的对齐方式，值如下：\n\n*   flex-start（默认值）：向主轴开始方向对齐。\n*   flex-end：向主轴结束方向对齐。\n*   center： 居中。\n*   space-between：两端对齐，项目之间的间隔都相等。\n*   space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n    .box {\n        justify-content: flex-start | flex-end | center | space-between | space-around;\n    }\n    \n    \n\n复制\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n### **交叉轴的对齐方式**\n\n`align-items`属性定义项目在交叉轴上如何对齐，值如下：\n\n*   flex-start：交叉轴的起点对齐。\n*   flex-end：交叉轴的终点对齐。\n*   center：交叉轴的中点对齐。\n*   baseline: 项目的第一行文字的基线对齐。\n*   stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。\n\n    .box {\n        align-items: flex-start | flex-end | center | baseline | stretch;\n    }\n    \n    \n\n复制\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n* * *\n\n**如何实现居中对齐？**\n-------------\n\n> 题目：如何实现水平居中？\n\n### **水平居中**\n\ninline 元素用`text-align: center;`即可，如下：\n\n    .container {\n       text-align: center;\n    }\n    \n    \n\n复制\n\nblock 元素可使用`margin: auto;`，PC 时代的很多网站都这么搞。\n\n    .container {\n        text-align: center; \n    }\n    .item {\n        width: 1000px;\n        margin: auto; \n    }\n    \n    \n\n复制\n\n绝对定位元素可结合`left`和`margin`实现，但是必须知道宽度。\n\n    .container {\n        position: relative;\n        width: 500px;\n    }\n    .item {\n        width: 300px;\n        height: 100px;\n        position: absolute;\n        left: 50%;\n        margin: -150px;\n    }\n    \n    \n\n复制\n\n> 题目：如何实现垂直居中？\n\n### **垂直居中**\n\ninline 元素可设置`line-height`的值等于`height`值，如单行文字垂直居中：\n\n    .container {\n       height: 50px;\n       line-height: 50px;\n    }\n    \n    \n\n复制\n\n绝对定位元素，可结合`left`和`margin`实现，但是必须知道尺寸。\n\n*   优点：兼容性好\n*   缺点：需要提前知道尺寸\n\n    .container {\n        position: relative;\n        height: 200px;\n    }\n    .item {\n        width: 80px;\n        height: 40px;\n        position: absolute;\n        left: 50%;\n        top: 50%;\n        margin-top: -20px;\n        margin-left: -40px;\n    }\n    \n    \n\n复制\n\n绝对定位可结合`transform`实现居中。\n\n*   优点：不需要提前知道尺寸\n*   缺点：兼容性不好\n\n    .container {\n        position: relative;\n        height: 200px;\n    }\n    .item {\n        width: 80px;\n        height: 40px;\n        position: absolute;\n        left: 50%;\n        top: 50%;\n        transform: translate(-50%, -50%);\n        background: blue;\n    }\n    \n    \n\n复制\n\n绝对定位结合`margin: auto`，不需要提前知道尺寸，兼容性好。\n\n    .container {\n        position: relative;\n        height: 300px;\n    }\n    .item {\n        width: 100px;\n        height: 50px;\n        position: absolute;\n        left: 0;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        margin: auto;\n    }\n    \n    \n\n复制\n\n其他的解决方案还有，不过没必要掌握太多，能说出上文的这几个解决方案即可。\n\n* * *\n\n**理解语义化**\n---------\n\n> 题目：如何理解 HTML 语义化？\n\n所谓“语义”就是为了更易读懂，这要分两部分：\n\n*   让人（写程序、读程序）更易读懂\n*   让机器（浏览器、搜索引擎）更易读懂\n\n### **让人更易读懂**\n\n对于人来说，代码可读性、语义化就是一个非常广泛的概念了，例如定义 JS 变量的时候使用更易读懂的名称，定义 CSS class 的时候也一样，例如`length``list`等，而不是使用`a``b`这种谁都看不懂的名称。\n\n不过我们平常考查的“语义化”并不会考查这么广义、这么泛的问题，而是考查 HTML 的语义化，是为了更好地让机器读懂 HTML。\n\n### **让机器更易读懂**\n\nHTML 符合 XML 标准，但又和 XML 不一样 —— HTML 不允许像 XML 那样自定义标签名称，HTML 有自己规定的标签名称。问题就在这里 —— HTML 为何要自己规定那么多标签名称呢，例如`p``div``h1``ul`等 —— 就是为了语义化。其实，如果你精通 CSS 的话，你完全可以全部用`<div>`标签来实现所有的网页效果，其他的`p``h1``ul`等标签可以一个都不用。但是我们不推荐这么做，这样做就失去了 HTML 语义化的意义。\n\n拿搜索引擎来说，爬虫下载到我们网页的 HTML 代码，它如何更好地去理解网页的内容呢？—— 就是根据 HTML 既定的标签。`h1`标签就代表是标题；`p`里面的就是段落详细内容，权重肯定没有标题高；`ul`里面就是列表；`strong`就是加粗的强调的内容 …… 如果我们不按照 HTML 语义化来写，全部都用`<div>`标签，那搜索引擎将很难理解我们网页的内容。\n\n为了加强 HTML 语义化，HTML5 标准中又增加了`header``section``artical`等标签。因此，书写 HTML 时，语义化是非常重要的，否则 W3C 也没必要辛辛苦苦制定出这些标准来。\n\n* * *\n\n**CSS3 动画**\n-----------\n\nCSS3 可以实现动画，代替原来的 Flash 和 JavaScript 方案。\n\n首先，使用`@keyframes`定义一个动画，名称为`testAnimation`，如下代码，通过百分比来设置不同的 CSS 样式，规定动画的变化。所有的动画变化都可以这么定义出来。\n\n    @keyframes testAnimation\n    {\n        0%   {background: red; left:0; top:0;}\n        25%  {background: yellow; left:200px; top:0;}\n        50%  {background: blue; left:200px; top:200px;}\n        75%  {background: green; left:0; top:200px;}\n        100% {background: red; left:0; top:0;}\n    }\n    \n    \n\n复制\n\n然后，针对一个 CSS 选择器来设置动画，例如针对`div`元素设置动画，如下：\n\n    div {\n        width: 100px;\n        height: 50px;\n        position: absolute;\n    \n        animation-name: myfirst;\n        animation-duration: 5s;\n    }\n    \n    \n\n复制\n\n`animation-name`对应到动画名称，`animation-duration`是动画时长，还有其他属性：\n\n*   `animation-timing-function`：规定动画的速度曲线。默认是`ease`\n*   `animation-delay`：规定动画何时开始。默认是 0\n*   `animation-iteration-count`：规定动画被播放的次数。默认是 1\n*   `animation-direction`：规定动画是否在下一周期逆向地播放。默认是`normal`\n*   `animation-play-state` ：规定动画是否正在运行或暂停。默认是`running`\n*   `animation-fill-mode`：规定动画执行之前和之后如何给动画的目标应用，默认是`none`，保留在最后一帧可以用`forwards`\n\n> 题目：CSS 的`transition`和`animation`有何区别？\n\n首先`transition`和`animation`都可以做动效，从语义上来理解，`transition`是过渡，由一个状态过渡到另一个状态，比如高度`100px`过渡到`200px`；而`animation`是动画，即更专业做动效的，`animation`有帧的概念，可以设置关键帧`keyframe`，一个动画可以由多个关键帧多个状态过渡组成，另外`animation`也包含上面提到的多个属性。\n\n**重绘和回流**\n---------\n\n重绘和回流是面试题经常考的题目，也是性能优化当中应该注意的点，下面笔者简单介绍下。\n\n*   **重绘**：指的是当页面中的元素不脱离文档流，而简单地进行样式的变化，比如修改颜色、背景等，浏览器重新绘制样式\n*   **回流**：指的是处于文档流中 DOM 的尺寸大小、位置或者某些属性发生变化时，导致浏览器重新渲染部分或全部文档的情况\n\n相比之下，**回流要比重绘消耗性能开支更大**。另外，一些属性的读取也会引起回流，比如读取某个 DOM 的高度和宽度，或者使用`getComputedStyle`方法。在写代码的时候要避免回流和重绘。比如在笔试中可能会遇见下面的题目：\n\n> 题目：找出下面代码的优化点，并且优化它\n\n    var data = ['string1', 'string2', 'string3'];\n    for(var i = 0; i < data.length; i++){\n        var dom = document.getElementById('list');\n        dom.innerHTML += '<li>' + data[i] + '</li>';\n    }\n    \n    \n\n复制\n\n上面的代码在循环中每次都获取`dom`，然后对其内部的 HTML 进行累加`li`，每次都会操作 DOM 结构，可以改成使用`documentFragment`或者先遍历组成 HTML 的字符串，最后操作一次`innerHTML`。\n\n* * *\n\n**小结**\n------\n\n本小节总结了 CSS 和 HTML 常考的知识点，包括 CSS 中比较重要的定位、布局的知识，也介绍了一些 CSS3 的知识点概念和题目，以及 HTML 的语义化。\n\n上一篇：[一面 2：JS-Web-API 知识点与高频考题解析](541672)下一篇：[一面 4：从容应对算法题目](541674)\n\n**一面 4：从容应对算法题目**\n=================\n\n由冯·诺依曼机组成我们知道：数据存储和运算是计算机工作的主要内容。`程序=数据结构+算法`，所以计算机类工程师必须掌握一定的数据结构和算法知识。\n\n**知识点梳理**\n---------\n\n*   常见的数据结构\n    *   栈、队列、链表\n    *   集合、字典、散列集\n*   常见算法\n    *   递归\n    *   排序\n    *   枚举\n*   算法复杂度分析\n*   算法思维\n    *   分治\n    *   贪心\n    *   动态规划\n*   高级数据结构\n    *   树、图\n    *   深度优先和广度优先搜索\n\n本小节会带领大家快速过一遍数据结构和算法，重点讲解一些常考、前端会用到的算法和数据结构。\n\n* * *\n\n**数据结构**\n--------\n\n数据结构决定了数据存储的空间和时间效率问题，数据的写入和提取速度要求也决定了应该选择怎样的数据结构。\n\n根据对场景需求的不同，我们设计不同的数据结构，比如：\n\n*   读得多的数据结构，应该想办法提高数据的读取效率，比如 IP 数据库，只需要写一次，剩下的都是读取；\n*   读写都多的数据结构，要兼顾两者的需求平衡，比如 LRU Cache 算法。\n\n算法是数据加工处理的方式，一定的算法会提升数据的处理效率。比如有序数组的二分查找，要比普通的顺序查找快很多，尤其是在处理大量数据的时候。\n\n数据结构和算法是程序开发的通用技能，所以在任何面试中都可能会遇见。随着近几年 AI、大数据、小游戏越来越火，Web 前端职位难免会跟数据结构和算法打交道，面试中也会出现越来越多的算法题目。学习数据结构和算法也能够帮助我们打开思路，突破技能瓶颈。\n\n**前端常遇见的数据结构问题**\n----------------\n\n现在我来梳理下前端常遇见的数据结构：\n\n*   简单数据结构（必须理解掌握）\n    *   有序数据结构：栈、队列、链表，有序数据结构省空间（存储空间小）\n    *   无序数据结构：集合、字典、散列表，无序数据结构省时间（读取时间快）\n*   复杂数据结构\n    *   树、堆\n    *   图\n\n对于简单数据结构，在 ES 中对应的是数组（`Array`）和对象（`Object`）。可以想一下，数组的存储是有序的，对象的存储是无序的，但是我要在对象中根据`key`找到一个值是立即返回的，数组则需要查找的过程。\n\n这里我通过一个真实面试题目来说明介绍下数据结构设计。\n\n> 题目：使用 ECMAScript（JS）代码实现一个事件类`Event`，包含下面功能：绑定事件、解绑事件和派发事件。\n\n在稍微复杂点的页面中，比如组件化开发的页面，同一个页面由两三个人来开发，为了保证组件的独立性和降低组件间耦合度，我们往往使用「订阅发布模式」，即组件间通信使用事件监听和派发的方式，而不是直接相互调用组件方法，这就是题目要求写的`Event`类。\n\n这个题目的核心是一个事件类型对应回调函数的数据设计。为了实现绑定事件，我们需要一个`_cache`对象来记录绑定了哪些事件。而事件发生的时候，我们需要从`_cache`中读取出来事件回调，依次执行它们。一般页面中事件派发（读）要比事件绑定（写）多。所以我们设计的数据结构应该尽量地能够在事件发生时，更加快速地找到对应事件的回调函数们，然后执行。\n\n经过这样一番考虑，我简单写了下代码实现：\n\n    class Event {\n        constructor() {\n            // 存储事件的数据结构\n            // 为了查找迅速，使用了对象（字典）\n            this._cache = {};\n        }\n        // 绑定\n        on(type, callback) {\n            // 为了按类查找方便和节省空间，\n            // 将同一类型事件放到一个数组中\n            // 这里的数组是队列，遵循先进先出\n            // 即先绑定的事件先触发\n            let fns = (this._cache[type] = this._cache[type] || []);\n            if (fns.indexOf(callback) === -1) {\n                fns.push(callback);\n            }\n            return this;\n        }\n        // 触发\n        trigger(type, data) {\n            let fns = this._cache[type];\n            if (Array.isArray(fns)) {\n                fns.forEach((fn) => {\n                    fn(data);\n                });\n            }\n            return this;\n        }\n        // 解绑\n        off(type, callback) {\n            let fns = this._cache[type];\n            if (Array.isArray(fns)) {\n                if (callback) {\n                    let index = fns.indexOf(callback);\n                    if (index !== -1) {\n                        fns.splice(index, 1);\n                    }\n                } else {\n                    //全部清空\n                    fns.length = 0;\n                }\n            }\n            return this;\n        }\n    }\n    // 测试用例\n    const event = new Event();\n    event.on('test', (a) => {\n        console.log(a);\n    });\n    event.trigger('test', 'hello world');\n    \n    event.off('test');\n    event.trigger('test', 'hello world');\n    \n    \n\n复制\n\n类似于树、堆、图这些高级数据结构，前端一般也不会考查太多，但是它们的查找方法却常考，后面介绍。高级数据应该平时多积累，好好理解，比如理解了堆是什么样的数据结构，在面试中遇见的「查找最大的 K 个数」这类算法问题，就会迎刃而解。\n\n**算法的效率是通过算法复杂度来衡量的**\n---------------------\n\n算法的好坏可以通过算法复杂度来衡量，算法复杂度包括时间复杂度和空间复杂度两个。时间复杂度由于好估算、好评估等特点，是面试中考查的重点。空间复杂度在面试中考查得不多。\n\n常见的时间复杂度有：\n\n*   常数阶 `O(1)`\n*   对数阶 `O(logN)`\n*   线性阶 `O(n)`\n*   线性对数阶 `O(nlogN)`\n*   平方阶 `O(n^2)`\n*   立方阶 `O(n^3)`\n*   !k次方阶 `O(n^k)`\n*   指数阶`O(2^n)`\n\n随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低。\n\n一般做算法复杂度分析的时候，遵循下面的技巧：\n\n1.  看看有几重循环，一般来说一重就是`O(n)`，两重就是 `O(n^2)`，以此类推\n2.  如果有二分，则为`O(logN)`\n3.  保留最高项，去除常数项\n\n> 题目：分析下面代码的算法复杂度（为了方便，我已经在注释中加了代码分析）\n\n    let i =0; // 语句执行一次 \n    while (i < n) { // 语句执行 n 次 \n      console.log(`Current i is ${i}`); //语句执行 n 次\n      i++; // 语句执行 n 次\n    }\n    \n    \n\n复制\n\n根据注释可以得到，算法复杂度为`1 + n + n + n = 1 + 3n`，去除常数项，为`O(n)`。\n\n    let number = 1; // 语句执行一次 \n    while (number < n) { // 语句执行 logN 次\n      number *= 2; // 语句执行 logN 次\n    }\n    \n    \n\n复制\n\n上面代码`while`的跳出判断条件是`number<n`，而循环体内`number`增长速度是`(2^n)`，所以循环代码实际执行`logN`次，复杂度为：`1 + 2 * logN = O(logN)`\n\n    for (let i = 0; i < n; i++) {// 语句执行 n 次\n      for (let j = 0; j < n; j++) {// 语句执行 n^2 次\n        console.log('I am here!'); // 语句执行 n^2 次\n      }\n    }\n    \n    \n\n复制\n\n上面代码是两个`for`循环嵌套，很容易得出复杂度为：`O(n^2)`\n\n**人人都要掌握的基础算法**\n---------------\n\n枚举和递归是最最简单的算法，也是复杂算法的基础，人人都应该掌握！枚举相对比较简单，我们重点说下递归。\n\n递归由下面两部分组成：\n\n1.  递归主体，就是要循环解决问题的代码\n2.  递归的跳出条件，递归不能一直递归下去，需要完成一定条件后跳出\n\n关于递归有个经典的面试题目是：\n\n> 实现 JS 对象的深拷贝\n\n**什么是深拷贝？**\n\n「深拷贝」就是在拷贝数据的时候，将数据的所有**引用结构**都拷贝一份。简单的说就是，在内存中存在两个数据结构完全相同又相互独立的数据，将引用型类型进行复制，而不是只复制其引用关系。\n\n分析下怎么做「深拷贝」：\n\n1.  首先假设深拷贝这个方法已经完成，为 deepClone\n2.  要拷贝一个数据，我们肯定要去遍历它的属性，如果这个对象的属性仍是对象，继续使用这个方法，如此往复\n\n    function deepClone(o1, o2) {\n        for (let k in o2) {\n            if (typeof o2[k] === 'object') {\n                o1[k] = {};\n                deepClone(o1[k], o2[k]);\n            } else {\n                o1[k] = o2[k];\n            }\n        }\n    }\n    // 测试用例\n    let obj = {\n        a: 1,\n        b: [1, 2, 3],\n        c: {}\n    };\n    let emptyObj = Object.create(null);\n    deepClone(emptyObj, obj);\n    console.log(emptyObj.a == obj.a);\n    console.log(emptyObj.b == obj.b);\n    \n    \n\n复制\n\n递归容易造成爆栈，尾部调用可以解决递归的这个问题，Chrome 的 V8 引擎做了尾部调用优化，我们在写代码的时候也要注意尾部调用写法。递归的爆栈问题可以通过将递归改写成枚举的方式来解决，就是通过`for`或者`while`来代替递归。\n\n我们在使用递归的时候，要注意做优化，比如下面的题目。\n\n> 题目：求斐波那契数列（兔子数列） 1,1,2,3,5,8,13,21,34,55,89...中的第 n 项\n\n下面的代码中`count`记录递归的次数，我们看下两种差异性的代码中的`count`的值：\n\n    let count = 0;\n    function fn(n) {\n        let cache = {};\n        function _fn(n) {\n            if (cache[n]) {\n                return cache[n];\n            }\n            count++;\n            if (n == 1 || n == 2) {\n                return 1;\n            }\n            let prev = _fn(n - 1);\n            cache[n - 1] = prev;\n            let next = _fn(n - 2);\n            cache[n - 2] = next;\n            return prev + next;\n        }\n        return _fn(n);\n    }\n    \n    let count2 = 0;\n    function fn2(n) {\n        count2++;\n        if (n == 1 || n == 2) {\n            return 1;\n        }\n        return fn2(n - 1) + fn2(n - 2);\n    }\n    \n    console.log(fn(20), count); // 6765 20\n    console.log(fn2(20), count2); // 6765 13529\n    \n    \n\n复制\n\n**快排和二分查找**\n-----------\n\n前端中面试排序和查找的可能性比较小，因为 JS 引擎已经把这些常用操作优化得很好了，可能项目中你费劲写的一个排序方法，都不如`Array.sort`速度快且代码少。因此，掌握快排和二分查找就可以了。\n\n快排和二分查找都基于一种叫做「分治」的算法思想，通过对数据进行分类处理，不断降低数量级，实现`O(logN)`（对数级别，比`O(n)`这种线性复杂度更低的一种）的复杂度。\n\n### **快速排序**\n\n快排大概的流程是：\n\n1.  随机选择数组中的一个数 A，以这个数为基准\n2.  其他数字跟这个数进行比较，比这个数小的放在其左边，大的放到其右边\n3.  经过一次循环之后，A 左边为小于 A 的，右边为大于 A 的\n4.  这时候将左边和右边的数再递归上面的过程\n\n具体代码如下：\n\n    const Arr = [85, 24, 63, 45, 17, 31, 96, 50];\n    function quickSort(arr) {\n        if (arr.length <= 1) {\n            return arr;\n        }\n        let pivotIndex = Math.floor(arr.length / 2);\n        let pivot = arr.splice(pivotIndex, 1)[0];\n        let left = [];\n        let right = [];\n        for (let i = 0; i < arr.length; i++) {\n            if (arr[i] < pivot) {\n                left.push(arr[i]);\n            } else {\n                right.push(arr[i]);\n            }\n        }\n        // 递归\n        return quickSort(left).concat([pivot], quickSort(right));\n    }\n    \n    console.log(quickSort(Arr));\n    \n    \n\n复制\n\n### **二分查找**\n\n二分查找法主要是解决「在一堆有序的数中找出指定的数」这类问题，不管这些数是一维数组还是多维数组，只要有序，就可以用二分查找来优化。\n\n二分查找是一种「分治」思想的算法，大概流程如下：\n\n1.  数组中排在中间的数字 A，与要找的数字比较大小\n2.  因为数组是有序的，所以： a) A 较大则说明要查找的数字应该从前半部分查找 b) A 较小则说明应该从查找数字的后半部分查找\n3.  这样不断查找缩小数量级（扔掉一半数据），直到找完数组为止\n\n> 题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n    function Find(target, array) {\n        let i = 0;\n        let j = array[i].length - 1;\n        while (i < array.length && j >= 0) {\n            if (array[i][j] < target) {\n                i++;\n            } else if (array[i][j] > target) {\n                j--;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    //测试用例\n    console.log(Find(10, [\n        [1, 2, 3, 4], \n        [5, 9, 10, 11], \n        [13, 20, 21, 23]\n        ])\n    );\n    \n    \n\n复制\n\n另外笔者在面试中遇见过下面的问题：\n\n> 题目：现在我有一个 1~1000 区间中的正整数，需要你猜下这个数字是几，你只能问一个问题：大了还是小了？问需要猜几次才能猜对？\n\n拿到这个题目，笔者想到的就是电视上面有个「猜价格」的购物节目，在规定时间内猜对价格就可以把实物抱回家。所以问题就是让面试官不停地回答我猜的数字比这个数字大了还是小了。这就是二分查找！\n\n猜几次呢？其实这个问题就是个二分查找的算法时间复杂度问题，二分查找的时间复杂度是`O(logN)`，所以求`log1000`的解就是猜的次数。我们知道`2^10=1024`，所以可以快速估算出：`log1000`约等于 10，最多问 10 次就能得到这个数！\n\n**面试遇见不会的算法问题怎么办**\n------------------\n\n面试的时候，在遇见算法题目的时候，应该揣摩面试官的意图，听好关键词，比如：有序的数列做查找、要求算法复杂度是`O(logN)`这类一般就是用二分的思想。\n\n一般来说算法题目的解题思路分以下四步：\n\n1.  先降低数量级，拿可以计算出来的情况（数据）来构思解题步骤\n2.  根据解题步骤编写程序，优先将特殊情况做好判断处理，比如一个大数组的问题，如果数组为两个数长度的情况\n3.  检验程序正确性\n4.  是否可以优化（由浅到深），有能力的话可以故意预留优化点，这样可以体现个人技术能力\n\n**正则匹配解题**\n----------\n\n很多算法题目利用 ES 语法的特性来回答更加简单，比如正则匹配就是常用的一种方式。笔者简单通过几个真题来汇总下正则的知识点。\n\n> 题目：字符串中第一个出现一次的字符\n\n请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符「go」时，第一个只出现一次的字符是「g」。当从该字符流中读出前六个字符「google」时，第一个只出现一次的字符是「l」。\n\n这个如果用纯算法来解答需要遍历字符串，统计每个字符出现的次数，然后按照字符串的顺序来找出第一次出现一次的字符，整个过程比较繁琐，如果用正则就简单多了。\n\n    function find(str){\n        for (var i = 0; i < str.length; i++) {\n            let char = str[i]\n            let reg = new RegExp(char, 'g');\n            let l = str.match(reg).length\n            if(l===1){\n                return char\n            }\n        }\n    }\n    \n    \n\n复制\n\n当然，使用`indexOf/lastIndexOf`也是一个取巧的方式。再来看一个千分位问题。\n\n> 题目：将`1234567` 变成 `1,234,567`，即千分位标注\n\n这个题目可以用算法直接来解，如果候选人使用正则来回答，这样主动展现了自己其他方面的优势，即使不是算法解答出来的，面试官一般也不会太难为他。这道题目可以利用正则的「零宽断言」`(?=exp)`，意思是它断言自身出现的位置的后面能匹配表达式 exp。数字千分位的特点是，第一个逗号后面数字的个数是3的倍数，正则：`/(\\d{3})+$/`；第一个逗号前最多可以有 1~3 个数字，正则：`/\\d{1,3}/`。加起来就是`/\\d{1,3}(\\d{3})+$/`，分隔符要从前往后加。\n\n对于零宽断言的详细介绍可以阅读「[零宽断言](https://link.juejin.im?target=https%3A%2F%2Fdeerchao.net%2Ftutorials%2Fregex%2Fregex.htm%23lookaround)」这篇文章。\n\n    function exchange(num) {\n        num += ''; //转成字符串\n        if (num.length <= 3) {\n            return num;\n        }\n    \n        num = num.replace(/\\d{1,3}(?=(\\d{3})+$)/g, (v) => {\n            console.log(v)\n            return v + ',';\n        });\n        return num;\n    }\n    \n    console.log(exchange(1234567));\n    \n    \n\n复制\n\n当然上面讲到的多数是算法题目取巧的方式，下面这个题目是纯正则考查，笔者在面试的过程中碰见过，这里顺便提一下。\n\n> 题目，请写出下面的代码执行结果\n\n    var str = 'google';\n    var reg = /o/g;\n    console.log(reg.test(str))\n    console.log(reg.test(str))\n    console.log(reg.test(str))\n    \n    \n\n复制\n\n代码执行后，会发现，最后一个不是为`true`，而是`false`，这是因为`reg`这个正则有个`g`，即`global`全局的属性，这种情况下`lastIndex`就发挥作用了，可以看下面的代码执行结果就明白了。\n\n    console.log(reg.test(str), reg.lastIndex)\n    console.log(reg.test(str), reg.lastIndex)\n    console.log(reg.test(str), reg.lastIndex)\n    \n    \n\n复制\n\n实际开发中也会犯这样的错误，比如为了减少变量每次都重新定义，会把用到的变量提前定义好，这样在使用的时候容易掉进坑里，比如下面代码：\n\n    (function(){\n        const reg = /o/g;\n        function isHasO(str){\n            // reg.lastIndex = 0; 这样就可以避免这种情况\n            return reg.test(str)\n        }\n        var str = 'google';\n        console.log(isHasO(str))\n        console.log(isHasO(str))\n        console.log(isHasO(str))\n    }())\n    \n    \n\n复制\n\n**小结**\n------\n\n本小节介绍了数据结构和算法的关系，作为普通的前端也应该学习数据结构和算法知识，并且顺带介绍了下正则匹配。具体来说，本小节梳理了以下几部分数据结构和算法知识点：\n\n1.  经常用到的数据结构有哪些，它们的特点有哪些\n2.  递归和枚举是最基础的算法，必须牢牢掌握\n3.  排序里面理解并掌握快速排序算法，其他排序算法可以根据个人实际情况大概了解\n4.  有序查找用二分查找\n5.  遇见不会的算法问题，先缩小数量级，然后分析推导\n\n当然算法部分还有很多知识，比如动态规划这些算法思想，还有图和树常用到的广度优先搜索和深度优先搜索。这些知识在前端面试和项目中遇见得不多，感兴趣的读者可以在梳理知识点的时候根据个人情况自行决定是否复习。\n\n上一篇：[一面 3：CSS-HTML 知识点与高频考题解析](541673)下一篇：[一面 5：浏览器相关知识点与高频考题解析](541675)\n\n**一面 5：浏览器相关知识点与高频考题解析**\n========================\n\nWeb 前端工程师写的页面要跑在浏览器里面，所以面试中也会出现很多跟浏览器相关的面试题目。\n\n**知识点梳理**\\*\\*\\*\\*\n-----------------\n\n*   浏览器加载页面和渲染过程\n*   性能优化\n*   Web 安全\n\n本小节会从浏览器的加载过程开始讲解，然后介绍如何进行性能优化，最后介绍下 Web 开发中常见的安全问题和预防。\n\n* * *\n\n**加载页面和渲染过程**\n-------------\n\n可将加载过程和渲染过程分开说。回答问题的时候，关键要抓住核心的要点，把要点说全面，稍加解析即可，简明扼要不拖沓。\n\n> 题目：浏览器从加载页面到渲染页面的过程\n\n### **加载过程**\n\n要点如下：\n\n*   浏览器根据 DNS 服务器得到域名的 IP 地址\n*   向这个 IP 的机器发送 HTTP 请求\n*   服务器收到、处理并返回 HTTP 请求\n*   浏览器得到返回内容\n\n例如在浏览器输入`https://juejin.im/timeline`，然后经过 DNS 解析，`juejin.im`对应的 IP 是`36.248.217.149`（不同时间、地点对应的 IP 可能会不同）。然后浏览器向该 IP 发送 HTTP 请求。\n\nserver 端接收到 HTTP 请求，然后经过计算（向不同的用户推送不同的内容），返回 HTTP 请求，返回的内容如下：\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n其实就是一堆 HMTL 格式的字符串，因为只有 HTML 格式浏览器才能正确解析，这是 W3C 标准的要求。接下来就是浏览器的渲染过程。\n\n### **渲染过程**\n\n要点如下：\n\n*   根据 HTML 结构生成 DOM 树\n*   根据 CSS 生成 CSSOM\n*   将 DOM 和 CSSOM 整合形成 RenderTree\n*   根据 RenderTree 开始渲染和展示\n*   遇到`<script>`时，会执行并阻塞渲染\n\n上文中，浏览器已经拿到了 server 端返回的 HTML 内容，开始解析并渲染。最初拿到的内容就是一堆字符串，必须先结构化成计算机擅长处理的基本数据结构，因此要把 HTML 字符串转化成 DOM 树 —— 树是最基本的数据结构之一。\n\n解析过程中，如果遇到`<link href=\"...\">`和`<script src=\"...\">`这种外链加载 CSS 和 JS 的标签，浏览器会异步下载，下载过程和上文中下载 HTML 的流程一样。只不过，这里下载下来的字符串是 CSS 或者 JS 格式的。\n\n浏览器将 CSS 生成 CSSOM，再将 DOM 和 CSSOM 整合成 RenderTree ，然后针对 RenderTree 即可进行渲染了。大家可以想一下，有 DOM 结构、有样式，此时就能满足渲染的条件了。另外，这里也可以解释一个问题 —— **为何要将 CSS 放在 HTML 头部？**—— 这样会让浏览器尽早拿到 CSS 尽早生成 CSSOM，然后在解析 HTML 之后可一次性生成最终的 RenderTree，渲染一次即可。如果 CSS 放在 HTML 底部，会出现渲染卡顿的情况，影响性能和体验。\n\n最后，渲染过程中，如果遇到`<script>`就停止渲染，执行 JS 代码。因为浏览器渲染和 JS 执行共用一个线程，而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。待`<script>`内容执行完之后，浏览器继续渲染。最后再思考一个问题 —— **为何要将 JS 放在 HTML 底部？**—— JS 放在底部可以保证让浏览器优先渲染完现有的 HTML 内容，让用户先看到内容，体验好。另外，JS 执行如果涉及 DOM 操作，得等待 DOM 解析完成才行，JS 放在底部执行时，HTML 肯定都解析成了 DOM 结构。JS 如果放在 HTML 顶部，JS 执行的时候 HTML 还没来得及转换为 DOM 结构，可能会报错。\n\n关于浏览器整个流程，百度的多益大神有更加详细的文章，推荐阅读下：《[从输入 URL 到页面加载完成的过程中都发生了什么事情？](https://link.juejin.im?target=http%3A%2F%2Ffex.baidu.com%2Fblog%2F2014%2F05%2Fwhat-happen%2F) 》。\n\n* * *\n\n**性能优化**\n--------\n\n性能优化的题目也是面试常考的，这类题目有很大的扩展性，能够扩展出来很多小细节，而且对个人的技术视野和业务能力有很大的挑战。这部分笔者会重点讲下常用的性能优化方案。\n\n> 题目：总结前端性能优化的解决方案\n\n### **优化原则和方向**\n\n性能优化的原则是**以更好的用户体验为标准**，具体就是实现下面的目标：\n\n1.  多使用内存、缓存或者其他方法\n2.  减少 CPU 和GPU 计算，更快展现\n\n优化的方向有两个：\n\n*   **减少页面体积，提升网络加载**\n*   **优化页面渲染**\n\n### **减少页面体积，提升网络加载**\n\n*   静态资源的压缩合并（JS 代码压缩合并、CSS 代码压缩合并、雪碧图）\n*   静态资源缓存（资源名称加 MD5 戳）\n*   使用 CDN 让资源加载更快\n\n### **优化页面渲染**\n\n*   CSS 放前面，JS 放后面\n*   懒加载（图片懒加载、下拉加载更多）\n*   减少DOM 查询，对 DOM 查询做缓存\n*   减少DOM 操作，多个操作尽量合并在一起执行（`DocumentFragment`）\n*   事件节流\n*   尽早执行操作（`DOMContentLoaded`）\n*   使用 SSR 后端渲染，数据直接输出到 HTML 中，减少浏览器使用 JS 模板渲染页面 HTML 的时间\n\n### **详细解释**\n\n#### **静态资源的压缩合并**\n\n如果不合并，每个都会走一遍之前介绍的请求过程\n\n    <script src=\"a.js\"></script>\n    <script src=\"b.js\"></script>\n    <script src=\"c.js\"></script>\n    \n    \n\n复制\n\n如果合并了，就只走一遍请求过程\n\n    <script src=\"abc.js\"></script>\n    \n    \n\n复制\n\n#### **静态资源缓存**\n\n通过链接名称控制缓存\n\n    <script src=\"abc_1.js\"></script>\n    \n    \n\n复制\n\n只有内容改变的时候，链接名称才会改变\n\n    <script src=\"abc_2.js\"></script>\n    \n    \n\n复制\n\n这个名称不用手动改，可通过前端构建工具根据文件内容，为文件名称添加 MD5 后缀。\n\n#### **使用 CDN 让资源加载更快**\n\nCDN 会提供专业的加载优化方案，静态资源要尽量放在 CDN 上。例如：\n\n    <script src=\"https://cdn.bootcss.com/zepto/1.0rc1/zepto.min.js\"></script>\n    \n    \n\n复制\n\n#### **使用 SSR 后端渲染**\n\n可一次性输出 HTML 内容，不用在页面渲染完成之后，再通过 Ajax 加载数据、再渲染。例如使用 smarty、Vue SSR 等。\n\n#### **CSS 放前面，JS 放后面**\n\n上文讲述浏览器渲染过程时已经提过，不再赘述。\n\n#### **懒加载**\n\n一开始先给为 `src` 赋值成一个通用的预览图，下拉时候再动态赋值成正式的图片。如下，`preview.png`是预览图片，比较小，加载很快，而且很多图片都共用这个`preview.png`，加载一次即可。待页面下拉，图片显示出来时，再去替换`src`为`data-realsrc`的值。\n\n    <img src=\"preview.png\" data-realsrc=\"abc.png\"/>\n    \n    \n\n复制\n\n另外，这里为何要用`data-`开头的属性值？—— 所有 HTML 中自定义的属性，都应该用`data-`开头，因为`data-`开头的属性浏览器渲染的时候会忽略掉，提高渲染性能。\n\n#### **DOM 查询做缓存**\n\n两段代码做一下对比：\n\n    var pList = document.getElementsByTagName('p')  // 只查询一个 DOM ，缓存在 pList 中了\n    var i\n    for (i = 0; i < pList.length; i++) {\n    }\n    \n    \n\n复制\n\n    var i\n    for (i = 0; i < document.getElementsByTagName('p').length; i++) {  // 每次循环，都会查询 DOM ，耗费性能\n    }\n    \n    \n\n复制\n\n总结：DOM 操作，无论查询还是修改，都是非常耗费性能的，应尽量减少。\n\n#### **合并 DOM 插入**\n\nDOM 操作是非常耗费性能的，因此插入多个标签时，先插入 Fragment 然后再统一插入 DOM。\n\n    var listNode = document.getElementById('list')\n    // 要插入 10 个 li 标签\n    var frag = document.createDocumentFragment();\n    var x, li;\n    for(x = 0; x < 10; x++) {\n        li = document.createElement(\"li\");\n        li.innerHTML = \"List item \" + x;\n        frag.appendChild(li);  // 先放在 frag 中，最后一次性插入到 DOM 结构中。\n    }\n    listNode.appendChild(frag);\n    \n    \n\n复制\n\n#### **事件节流**\n\n例如要在文字改变时触发一个 change 事件，通过 keyup 来监听。使用节流。\n\n    var textarea = document.getElementById('text')\n    var timeoutId\n    textarea.addEventListener('keyup', function () {\n        if (timeoutId) {\n            clearTimeout(timeoutId)\n        }\n        timeoutId = setTimeout(function () {\n            // 触发 change 事件\n        }, 100)\n    })\n    \n    \n\n复制\n\n#### **尽早执行操作**\n\n    window.addEventListener('load', function () {\n        // 页面的全部资源加载完才会执行，包括图片、视频等\n    })\n    document.addEventListener('DOMContentLoaded', function () {\n        // DOM 渲染完即可执行，此时图片、视频还可能没有加载完\n    })\n    \n    \n\n复制\n\n#### **性能优化怎么做**\n\n上面提到的都是性能优化的单个点，性能优化项目具体实施起来，应该按照下面步骤推进：\n\n1.  建立性能数据收集平台，摸底当前性能数据，通过性能打点，将上述整个页面打开过程消耗时间记录下来\n2.  分析耗时较长时间段原因，寻找优化点，确定优化目标\n3.  开始优化\n4.  通过数据手机平台记录优化效果\n5.  不断调整优化点和预期目标，循环2~4步骤\n\n性能优化是个长期的事情，不是一蹴而就的，应该本着先摸底、再分析、后优化的原则逐步来做。\n\n* * *\n\n**Web 安全**\n----------\n\n> 题目：前端常见的安全问题有哪些？\n\nWeb 前端的安全问题，能回答出下文的两个问题，这个题目就能基本过关了。开始之前，先说一个最简单的攻击方式 —— SQL 注入。\n\n上学的时候就知道有一个「SQL注入」的攻击方式。例如做一个系统的登录界面，输入用户名和密码，提交之后，后端直接拿到数据就拼接 SQL 语句去查询数据库。如果在输入时进行了恶意的 SQL 拼装，那么最后生成的 SQL 就会有问题。但是现在稍微大型一点的系统，都不会这么做，从提交登录信息到最后拿到授权，要经过层层的验证。因此，SQL 注入都只出现在比较低端小型的系统上。\n\n### **XSS（Cross Site Scripting，跨站脚本攻击）**\n\n这是前端最常见的攻击方式，很多大型网站（如 Facebook）都被 XSS 攻击过。\n\n举一个例子，我在一个博客网站正常发表一篇文章，输入汉字、英文和图片，完全没有问题。但是如果我写的是恶意的 JS 脚本，例如获取到`document.cookie`然后传输到自己的服务器上，那我这篇博客的每一次浏览都会执行这个脚本，都会把访客 cookie 中的信息偷偷传递到我的服务器上来。\n\n其实原理上就是黑客通过某种方式（发布文章、发布评论等）将一段特定的 JS 代码隐蔽地输入进去。然后别人再看这篇文章或者评论时，之前注入的这段 JS 代码就执行了。**JS 代码一旦执行，那可就不受控制了，因为它跟网页原有的 JS 有同样的权限**，例如可以获取 server 端数据、可以获取 cookie 等。于是，攻击就这样发生了。\n\n#### **XSS的危害**\n\nXSS 的危害相当大，如果页面可以随意执行别人不安全的 JS 代码，轻则会让页面错乱、功能缺失，重则会造成用户的信息泄露。\n\n比如早些年社交网站经常爆出 XSS 蠕虫，通过发布的文章内插入 JS，用户访问了感染不安全 JS 注入的文章，会自动重新发布新的文章，这样的文章会通过推荐系统进入到每个用户的文章列表面前，很快就会造成大规模的感染。\n\n还有利用获取 cookie 的方式，将 cookie 传入入侵者的服务器上，入侵者就可以模拟 cookie 登录网站，对用户的信息进行篡改。\n\n#### **XSS的预防**\n\n那么如何预防 XSS 攻击呢？—— 最根本的方式，就是对用户输入的内容进行验证和替换，需要替换的字符有：\n\n    & 替换为：&amp;\n    < 替换为：&lt;\n    > 替换为：&gt;\n    ” 替换为：&quot;\n    ‘ 替换为：&#x27;\n    / 替换为：&#x2f;\n    \n    \n\n复制\n\n替换了这些字符之后，黑客输入的攻击代码就会失效，XSS 攻击将不会轻易发生。\n\n除此之外，还可以通过对 cookie 进行较强的控制，比如对敏感的 cookie 增加`http-only`限制，让 JS 获取不到 cookie 的内容。\n\n### **CSRF（Cross-site request forgery，跨站请求伪造）**\n\nCSRF 是借用了当前操作者的权限来偷偷地完成某个操作，而不是拿到用户的信息。\n\n例如，一个支付类网站，给他人转账的接口是`http://buy.com/pay?touid=999&money=100`，而这个接口在使用时没有任何密码或者 token 的验证，只要打开访问就直接给他人转账。一个用户已经登录了`http://buy.com`，在选择商品时，突然收到一封邮件，而这封邮件正文有这么一行代码`<img src=\"http://buy.com/pay?touid=999&money=100\"/>`，他访问了邮件之后，其实就已经完成了购买。\n\nCSRF 的发生其实是借助了一个 cookie 的特性。我们知道，登录了`http://buy.com`之后，cookie 就会有登录过的标记了，此时请求`http://buy.com/pay?touid=999&money=100`是会带着 cookie 的，因此 server 端就知道已经登录了。而如果在`http://buy.com`去请求其他域名的 API 例如`http://abc.com/api`时，是不会带 cookie 的，这是浏览器的同源策略的限制。但是 —— **此时在其他域名的页面中，请求`http://buy.com/pay?touid=999&money=100`，会带着`buy.com`的 cookie ，这是发生 CSRF 攻击的理论基础。**\n\n预防 CSRF 就是加入各个层级的权限验证，例如现在的购物网站，只要涉及现金交易，肯定要输入密码或者指纹才行。除此之外，敏感的接口使用`POST`请求而不是`GET`也是很重要的。\n\n* * *\n\n**小结**\n------\n\n本小节总结了前端运行环境（即浏览器）的一些常考查知识点，包括页面加载过程、如何性能优化以及需要注意的安全问题。\n\n上一篇：[一面 4：从容应对算法题目](541674)下一篇：[一面 6：开发环境相关知识点与高频考题解析](541676)\n\n**一面 6：开发环境相关知识点与高频考题解析**\n=========================\n\n工程师的开发环境决定其开发效率，常用的开发环境配置也是面试考查点之一。\n\n**知识点梳理**\n---------\n\n*   IDE\n*   Git\n*   Linux 基础命令\n*   前端构建工具\n*   调试方法\n\n本小节会重点介绍 Git 的基本用法、代码部署和开发中常用的 Linux 命令，然后以 webpack 为例介绍下前端构建工具，最后介绍怎么抓包解决线上问题。这些都是日常开发和面试中常用到的知识。\n\n* * *\n\n**IDE**\n-------\n\n> 题目：你平时都使用什么 IDE 编程？有何提高效率的方法？\n\n前端最常用的 IDE 有 [Webstorm](https://link.juejin.im?target=https%3A%2F%2Fwww.jetbrains.com%2Fwebstorm%2F)、[Sublime](https://link.juejin.im?target=https%3A%2F%2Fwww.sublimetext.com%2F)、[Atom](https://link.juejin.im?target=https%3A%2F%2Fatom.io%2F) 和 [VSCode](https://link.juejin.im?target=https%3A%2F%2Fcode.visualstudio.com%2F)，我们可以分别去它们的官网看一下。\n\nWebstorm 是最强大的编辑器，因为它拥有各种强大的插件和功能，但是我没有用过，因为它收费。不是我舍不得花钱，而是因为我觉得免费的 Sublime 已经够我用了。跟面试官聊到 Webstorm 的时候，没用过没事儿，但一定要知道它：第一，强大；第二，收费。\n\nSublime 是我日常用的编辑器，第一它免费，第二它轻量、高效，第三它插件非常多。用 Sublime 一定要安装各种插件配合使用，可以去网上搜一下“sublime”常用插件的安装以及用法，还有它的各种快捷键，并且亲自使用它。这里就不一一演示了，网上的教程也很傻瓜式。\n\nAtom 是 GitHub 出品的编辑器，跟 Sublime 差不多，免费并且插件丰富，而且跟 Sublime 相比风格上还有些小清新。但是我用过几次就不用了，因此它打开的时候会比较慢，卡一下才打开。当然总体来说也是很好用的，只是个人习惯问题。\n\nVSCode 是微软出品的轻量级（相对于 Visual Studio 来说）编辑器，微软做 IDE 那是出了名的好，出了名的大而全，因此 VSCode 也有上述 Sublime 和 Atom 的各种优点，但是我也是因为个人习惯问题（本人不愿意尝试没有新意的新东西），用过几次就不用了。\n\n总结一下：\n\n*   如果你要走大牛、大咖、逼格的路线，就用 Webstorm\n*   如果你走普通、屌丝、低调路线，就用 Sublime\n*   如果你走小清新、个性路线，就用 VSCode 或者 Atom\n*   如果你面试，最好有一个用的熟悉，其他都会一点\n\n最后注意：千万不要说你使用 Dreamweaver 或者 notepad++ 写前端代码，会被人鄙视的。如果你不做 .NET 也不要用 Visual Studio ，不做 Java 也不要用 Eclipse。\n\n* * *\n\n**Git**\n-------\n\n你此前做过的项目一定要用过 Git，而且必须是命令行，如果没用过，你自己也得恶补一下。对 Git 的基本应用比较熟悉的同学，可以跳过这一部分了。macOS 自带 Git，Windows 需要安装 Git 客户端，去 [Git 官网](https://link.juejin.im?target=https%3A%2F%2Fgit-scm.com%2Fdownload%2Fwin) 下载即可。\n\n国内比较好的 Git 服务商有 [coding.net](http://coding.net)，国外有大名鼎鼎的 GitHub，但是有时会有网络问题，因此建议大家注册一个 [coding.net](http://coding.net) 账号然后创建项目，来练练手。\n\n> 题目：常用的 Git 命令有哪些？如何使用 Git 多人协作开发？\n\n### **常用的 Git 命令**\n\n首先，通过`git clone <项目远程地址>`下载下来最新的代码，例如`git clone git@git.coding.net:username/project-name.git`，默认会下载`master`分支。\n\n然后修改代码，修改过程中可以通过`git status`看到自己的修改情况，通过`git diff <文件名>`可查阅单个文件的差异。\n\n最后，将修改的内容提交到远程服务器，做如下操作\n\n    git add .\n    git commit -m \"xxx\"\n    git push origin master\n    \n    \n\n复制\n\n如果别人也提交了代码，你想同步别人提交的内容，执行`git pull origin master`即可。\n\n### **如何多人协作开发**\n\n多人协作开发，就不能使用`master`分支了，而是要每个开发者单独拉一个分支，使用`git checkout -b <branchname>`，运行`git branch`可以看到本地所有的分支名称。\n\n自己的分支，如果想同步`master`分支的内容，可运行`git merge master`。切换分支可使用`git checkout <branchname>`。\n\n在自己的分支上修改了内容，可以将自己的分支提交到远程服务器\n\n    git add .\n    git commit -m \"xxx\"\n    git push origin <branchname>\n    \n    \n\n复制\n\n最后，待代码测试没问题，再将自己分支的内容合并到`master`分支，然后提交到远程服务器。\n\n    git checkout master\n    git merge <branchname>\n    git push origin master\n    \n    \n\n复制\n\n### **关于 SVN**\n\n关于 SVN 笔者的态度和针对 IE 低版本浏览器的态度一样，你只需要查询资料简单了解一下。面试的时候可能会问到，但你只要熟悉了 Git 的操作，面试官不会因为你不熟悉 SVN 而难为你。前提是你要知道一点 SVN 的基本命令，自己上网一查就行。\n\n不过 SVN 和 Git 的区别你得了解。SVN 是每一步操作都离不开服务器，创建分支、提交代码都需要连接服务器。而 Git 就不一样了，你可以在本地创建分支、提交代码，最后再一起 push 到服务器上。因此，Git 拥有 SVN 的所有功能，但是却比 SVN 强大得多。（Git 是 Linux 的创始人 Linus 发明的东西，因此也倍得推崇。）\n\n* * *\n\nLinux 基础命令\n----------\n\n目前互联网公司的线上服务器都使用 Linux 系统，测试环境为了保证和线上一致，肯定也是使用 Linux 系统，而且都是命令行的，没有桌面，不能用鼠标操作。因此，掌握基础的 Linux 命令是非常必要的。下面总结一些最常用的 Linux 命令，建议大家在真实的 Linux 系统下亲自试一下。\n\n关于如何得到 Linux 系统，有两种选择：第一，在自己电脑的虚拟机中安装一个 Linux 系统，例如 Ubuntu/CentOS 等，下载这些都不用花钱；第二，花钱去阿里云等云服务商租一个最便宜的 Linux 虚拟机。推荐第二种。一般正式入职之后，公司都会给你分配开发机或者测试机，给你账号和密码，你自己可以远程登录。\n\n> 题目：常见 linux 命令有哪些？\n\n### **登录**\n\n入职之后，一般会有现有的用户名和密码给你，你拿来之后直接登录就行。运行 `ssh name@server` 然后输入密码即可登录。\n\n### **目录操作**\n\n*   创建目录 `mkdir <目录名称>`\n*   删除目录 `rm <目录名称>`\n*   定位目录 `cd <目录名称>`\n*   查看目录文件 `ls``ll`\n*   修改目录名 `mv <目录名称> <新目录名称>`\n*   拷贝目录 `cp <目录名称> <新目录名称>`\n\n### **文件操作**\n\n*   创建文件 `touch <文件名称>``vi <文件名称>`\n*   删除文件 `rm <文件名称>`\n*   修改文件名 `mv <文件名称> <新文件名称>`\n*   拷贝文件 `cp <文件名称> <新文件名称>`\n\n### **文件内容操作**\n\n*   查看文件 `cat <文件名称>``head <文件名称>``tail <文件名称>`\n*   编辑文件内容 `vi <文件名称>`\n*   查找文件内容 `grep '关键字' <文件名称>`\n\n* * *\n\n**前端构建工具**\n----------\n\n构建工具是前端工程化中不可缺少的一环，非常重要，而在面试中却有其特殊性 —— **面试官会通过询问构建工具的作用、目的来询问你对构建工具的了解，只要这些你都知道，不会再追问细节**。因为，在实际工作中，真正能让你编写构建工具配置文件的机会非常少，一个项目就配置一次，后面就很少改动了。而且，如果是大众使用的框架（如 React、Vue 等），还会直接有现成的脚手架工具，一键创建开发环境，不用手动配置。\n\n> 题目：前端为何要使用构建工具？它解决了什么问题？\n\n### **何为构建工具**\n\n“构建”也可理解为“编译”，就是将开发环境的代码转换成运行环境代码的过程。**开发环境的代码是为了更好地阅读，而运行环境的代码是为了更快地执行，两者目的不一样，因此代码形式也不一样**。例如，开发环境写的 JS 代码，要通过混淆压缩之后才能放在线上运行，因为这样代码体积更小，而且对代码执行不会有任何影响。总结一下需要构建工具处理的几种情况：\n\n*   **处理模块化**：CSS 和 JS 的模块化语法，目前都无法被浏览器兼容。因此，开发环境可以使用既定的模块化语法，但是需要构建工具将模块化语法编译为浏览器可识别形式。例如，使用 webpack、Rollup 等处理 JS 模块化。\n*   **编译语法**：编写 CSS 时使用 Less、Sass，编写 JS 时使用 ES6、TypeScript 等。这些标准目前也都无法被浏览器兼容，因此需要构建工具编译，例如使用 Babel 编译 ES6 语法。\n*   **代码压缩**：将 CSS、JS 代码混淆压缩，为了让代码体积更小，加载更快。\n\n### **构建工具介绍**\n\n最早普及使用的构建工具是 [Grunt](https://link.juejin.im?target=http%3A%2F%2Fwww.gruntjs.net%2F) ，不久又被 [Gulp](https://link.juejin.im?target=https%3A%2F%2Fwww.gulpjs.com.cn%2F) 给追赶上。Gulp 因其简单的配置以及高效的性能而被大家所接受，也是笔者个人比较推荐的构建工具之一。如果你做一些简单的 JS 开发，可以考虑使用。\n\n如果你的项目比较复杂，而且是多人开发，那么你就需要掌握目前构建工具届的神器 —— webpack 。不过神器也有一个缺点，就是学习成本比较高，需要拿出专门的时间来专心学习，而不是三言两语就能讲完的。我们下面就演示一下 webpack 最简单的使用，全面的学习还得靠大家去认真查阅相关文档，或者参考专门讲解 webpack 的教程。\n\n### **webpack 演示**\n\n接下来我们演示一下 webpack 处理模块化和混淆压缩代码这两个基本功能。\n\n首先，你需要安装 Node.js，没有安装的可以去 [Node.js 官网](https://link.juejin.im?target=http%3A%2F%2Fnodejs.cn%2Fdownload%2F) 下载并安装。安装完成后运行如下命令来验证是否安装成功。\n\n    node -v\n    npm -v\n    \n    \n\n复制\n\n然后，新建一个目录，进入该目录，运行`npm init`，按照提示输入名称、版本、描述等信息。完成之后，该目录下出现了一个`package.json`文件，是一个 JSON 文件。\n\n接下来，安装 wepback，运行`npm i --save-dev webpack`，网络原因需要耐心等待几分钟。\n\n接下来，编写源代码，在该目录下创建`src`文件夹，并在其中创建`app.js`和`dt.js`两个文件，文件内容分别是：\n\n    // dt.js 内容\n    module.exports = {\n        getDateNow: function () {\n            return Date.now()\n        }\n    }\n    \n    // app.js 内容\n    var dt = require('./dt.js')\n    alert(dt.getDateNow())\n    \n    \n\n复制\n\n然后，再返回上一层目录，新建`index.html`文件（该文件和`src`属于同一层级），内容是\n\n    <!DOCTYPE html>\n    <html>\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>test</title>\n    </head>\n    <body>\n        <div>test</div>\n    \n        <script src='./dist/bundle.js'></script>\n    </body>\n    </html>\n    \n    \n\n复制\n\n然后，编写 webpack 配置文件，新建`webpack.config.js`，内容是\n\n    const path = require('path');\n    const webpack = require('webpack');\n    module.exports = {\n      context: path.resolve(__dirname, './src'),\n      entry: {\n        app: './app.js',\n      },\n      output: {\n        path: path.resolve(__dirname, './dist'),\n        filename: 'bundle.js',\n      },\n      plugins: [\n        new webpack.optimize.UglifyJsPlugin({\n            compress: {\n              //supresses warnings, usually from module minification\n              warnings: false\n            }\n        }),\n      ]\n    };\n    \n    \n\n复制\n\n总结一下，目前项目的文件目录是：\n\n    src\n      +-- app.js\n      +-- dt.js\n    index.html\n    package.json\n    webpack.config.js\n    \n    \n\n复制\n\n接下来，打开`package.json`，然后修改其中`scripts`的内容为：\n\n      \"scripts\": {\n        \"start\": \"webpack\"\n      }\n    \n    \n\n复制\n\n在命令行中运行`npm start`，即可看到编译的结果，最后在浏览器中打开`index.html`，即可弹出`Date.now()`的值。\n\n### **总结**\n\n最后再次强调，**深刻理解构建工具存在的价值，比你多会一些配置代码更加有意义，特别是对于应对面试来说**。\n\n* * *\n\n**调试方法**\n--------\n\n调试方法这块被考查最多的就是如何进行抓包。\n\n> 题目：如何抓取数据？如何使用工具来配置代理？\n\nPC 端的网页，我们可以通过 Chrome、Firefox 等浏览器自带的开发者工具来查看网页的所有网络请求，以帮助排查 bug。这种监听、查看网络请求的操作称为**抓包**。\n\n针对移动端的抓包工具，Mac 系统下推荐使用 Charles 这个工具，首先 [下载](https://link.juejin.im?target=https%3A%2F%2Fwww.charlesproxy.com%2Fdownload%2F) 并安装，打开。Windows 系统推荐使用 [Fiddler](https://link.juejin.im?target=http%3A%2F%2Frj.baidu.com%2Fsoft%2Fdetail%2F10963.html)，下载安装打开。两者使用基本一致，下面以 Charles 为例介绍。\n\n接下来，将安装好 Charles 的电脑和要抓包的手机，连接到同一个网络（一般为公司统一提供的内网，由专业网络工程师搭建），保证 IP 段相同。然后，将手机设置网络代理（每种不同手机如何设置网络代理，网上都有傻瓜式教程），代理的 IP 为电脑的 IP，代理的端口为`8888`。然后，Charles 可能会有一个弹框提示是否允许连接代理，这里选择“允许”即可。这样，使用手机端访问的网页或者联网的请求，Charles 就能监听到了。\n\n在开发过程中，经常用到抓包工具来做代理，将线上的地址代理到测试环境，Charles 和 Fiddler 都可实现这个功能。以 Charles 为例，点击菜单栏中 Tools 菜单，然后二级菜单中点击 Map Remote，会弹出配置框。首先，选中 Enable Map Remote 复选框，然后点击 Add 按钮，添加一个代理项。例如，如果要将线上的`https://www.aaa.com/api/getuser?name=xxx`这个地址代理到测试地址`http://168.1.1.100:8080/api/getuser?name=xxx`，配置如下图\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n* * *\n\n**小结**\n------\n\n本小节总结了前端开发环境常考查的知识，这些知识也是前端程序员必须掌握的，否则会影响开发效率。\n\n上一篇：[一面 5：浏览器相关知识点与高频考题解析](541675)下一篇：[二面 1：如何回答常见的软技能问题](541677)\n\n**二面 1：如何回答常见的软技能问题**\n=====================\n\n面试是个技术活，不仅仅是技术，各种软技能的面试技巧也是非常重要的，尤其是程序员一般对于自己的软技能不是很看重，其实**软技能才是决定你职场能够走多远的关键**。\n\n**程序员应该具备的软技能**\n---------------\n\n程序员除了业务技能外，应该具有下面的软技能：\n\n1.  韧性：抗压能力，在一定项目压力下能够迎难而上，比如勇于主动承担和解决技术难题\n2.  责任心：对于自己做过的项目，能够出现 bug 之类主动解决\n3.  持续学习能力：IT 行业是个需要不断充电的行业，尤其 Web 前端这些年一直在巨变，所以持续学习能力很重要\n4.  团队合作能力：做项目不能个人英雄主义，应该融入团队，跟团队一起打仗\n5.  交流沟通能力：经常会遇见沟通需求和交互设计的工作，应该乐于沟通分享\n\n另外在《软技能：代码之外的生存指南》这本书里提到了下面一些软技能：\n\n1.  职业\n2.  自我营销\n3.  学习能力\n4.  提升工作效率\n5.  理财\n6.  健身\n7.  积极的人生观\n\n**常见的软技能问题和提升**\n---------------\n\n回答软技能类的问题，应该注意在回答过程中体现自己具备的软技能。下面列举几个常见的软技能类的问题。\n\n### **回想下你遇见过最难打交道的同事，你是如何跟他沟通的**\n\n一般来说，工作中总会遇见一两个自己不喜欢的人，这种情况应该尽量避免冲突，从自己做起慢慢让对方感觉到自己的合作精神。\n\n所以，遇见难打交道的同事，不要急于上报领导，应该自己主动多做一些事情，比如规划好工作安排，让他选择自己做的事情，有了结论记得发邮件确认下来，这样你们的领导和其他成员都会了解到工作的安排，在鞭笞对方的同时，也做到了职责明确。在项目当中，多主动检查项目进展，提前发现逾期的问题。\n\n重点是突出：自己主动沟通解决问题的意识，而不是遇见问题就找领导。\n\n### **当你被分配一个几乎不可能完成的任务时，你会怎么做**\n\n这种情况下，一般通过下面方式来解决：\n\n1.  自己先查找资料，寻找解决方案，评估自己需要怎样的资源来完成，需要多长时间\n2.  能不能借助周围同事来解决问题\n3.  拿着分析结果跟上级反馈，寻求帮助或者资源\n\n突出的软技能：分析和解决问题，沟通寻求帮助。\n\n### **业余时间都做什么？除了写码之外还有什么爱好**\n\n这类问题也是面试官的高频问题，「一个人的业余时间决定了他的未来」，如果回答周末都在追剧打游戏之类的，未免显得太不上进。\n\n一般来说，推荐下面的回答：\n\n> 周末一般会有三种状态：\n> \n> 1.  和朋友一起去做做运动，也会聚会聊天，探讨下新技术之类的；\n> 2.  也会看一些书籍充充电，比如我最近看的 xx，有什么的想法；\n> 3.  有时候会闷在家用最近比较火的技术做个小项目或者实现个小功能之类的。\n\n这样的回答，既能表现自己阳光善于社交沟通的一面，又能表现自己的上进心。\n\n**小结**\n------\n\n本小节介绍了程序员除了业务技术能力之外应该日常修炼的软技能，在面试中，软技能会被以各种形式问起，候选人应该先了解有哪些软技能可以修炼，才能在回答软技能问题的时候，尽量提到自己具备的软技能。\n\n上一篇：[一面 6：开发环境相关知识点与高频考题解析](541676)下一篇：[二面 2：如何介绍项目及应对项目细节追问](541678)\n\n**二面 2：如何介绍项目及应对项目细节追问**\n========================\n\n一个标准的面试流程中，肯定会在一面二面中问到你具体做过的项目，然后追问项目的细节。这类问题往往会通过下面形式来提问：\n\n1.  发现你简历的一个项目，直接让你介绍下这个项目\n2.  让你回忆下你做过的项目中，最值得分享（最大型/最困难/最能体现技术能力/最难忘）的\n3.  如果让你设计 xx 系统/项目，你会怎么着手干\n\n这类跟项目相关的综合性问题，既能体现候选人的技术水平、业务水平和架构能力，也能够辨别候选人是不是真的做过项目，还能够发现候选人的一些软技能。\n\n下面分享下，遇见这类问题应该怎样回答。\n\n**怎样介绍自己做过的一个项目**\n-----------------\n\n按照第 1 小节说的，简历当中的项目，你要精挑细选，既要体现技术难度，又要想好细节。具体要介绍一个项目（包括梳理一个项目），可以按照下面几个阶段来做。\n\n###\\*\\* 1\\. 介绍项目背景**\n\n这个项目为什么做，当初大的环境背景是什么？还是为了解决一个什么问题而设立的项目？背景是很重要的，如果不了解背景，一上来就听一个结论性的项目，面试官可能对于项目的技术选型、技术难度会有理解偏差，甚至怀疑是否真的有过这样的项目。\n\n> 比如一上来就说：我们的项目采用了「backbone」来做框架，然后。。。而「backbone」已经是三四年前比较新鲜的技术，现在会有更好的选择方案，如果不介绍项目的时间背景，面试官肯定一脸懵逼。\n\n### **2\\. 承担角色**\n\n项目涉及的人员角色有哪些，自己在其中扮演的角色是什么？\n\n这里候选往往人会自己给自己挖坑，比如把自己在项目中起到的作用夸大等。一般来说，面试官细节追问的时候，如果候选人能够把细节或者技术方案等讲明白、讲清楚，不管他是真的做过还是跟别人做过，或者自己认真思考过，都能体现候选人的技术水平和技术视野。前提还是在你能够兜得住的可控范围之内做适当的「美化」。\n\n### **3\\. 最终的结果和收益**\n\n项目介绍过程中，应该介绍项目最终的结果和收益，比如项目最后经过多久的开发上线了，上线后的数据是怎样的，是否达到预期，还是带来了新的问题，遇见了问题自己后续又是怎样补救的。\n\n### 4\\. 有始有终：项目总结和反思\n\n有总结和反思，才会有进步。 项目做完了往往会有一些心得和体会，这时候应该跟面试官说出来。在梳理项目的总结和反思时，可以按照下面的列表来梳理：\n\n*   收获有哪些？\n*   是否有做得不足的地方，怎么改进？\n*   是否具有可迁移性？\n\n比如，之前详细介绍了某个项目，这个项目当时看来没有什么问题，但是现在有更好的解决方案了，候选人就应该在这里提出来：现在看来，这个项目还有 xx 的问题，我可以通过 xx 的方式来解决。\n\n再比如：做这个项目的时候，你做得比较出彩的地方，可以迁移到其他项目中直接使用，小到代码片段，大到解决方案，总会有你值得总结和梳理的地方。\n\n介绍完项目总结这部分，也可以引导面试官往自己擅长的领域思考。比如上面提到项目中的问题，可以往你擅长的方面引导，即使面试官没有问到，你也介绍到了。\n\n按照上面的四段体介绍项目，会让面试官感觉候选人有清晰的思路，对整个项目也有理解和想法，还能够总结反思项目的收益和问题，可谓「一箭三雕」。\n\n**没有做过大型项目怎么办**\n---------------\n\n对于刚刚找工作的应届生，或者面试官让你进行一个大型项目的设计，候选人可能没有类似的经验。这时候不要用「我不会、没做过」一句话就带过。\n\n如果是实在没有项目可以说，那么可以提自己日常做的练手项目，或者看到一个解决方案的文章/书，提到的某个项目，抒发下自己的想法。\n\n如果是对于面试官提出来需要你设计的项目/系统，可以按照下面几步思考：\n\n1.  有没有遇见过类似的项目\n2.  有没有读过类似解决方案的文章\n3.  项目能不能拆解，拆解过程中能不能发现自己做过的项目可以用\n4.  项目解决的问题是什么，这类问题有没有更好的解决方案\n\n总之，切记不要一句「不知道、没做过」就放弃，每一次提问都是自己表现的机会。\n\n**项目细节和技术点的追问**\n---------------\n\n介绍项目的过程中，面试官可能会追问技术细节，所以我们在准备面试的时候，应该尽量把技术细节梳理清楚，技术细节包括：\n\n1.  技术选型方案：当时做技术选型所面临的状况\n2.  技术解决方案：最终确定某种技术方案的原因，比如：选择用 Vue 而没有用 React 是为什么？\n3.  项目数据和收益\n4.  项目中最难的地方\n5.  遇见的坑：如使用某种框架遇见哪些坑\n\n一般来说，做技术选型的时候需要考虑下面几个因素：\n\n1.  时代：现在比较火的技术是什么，为什么火起来，解决了什么问题，能否用到我的项目中？\n2.  团队：个人或者团队对某种技术的熟悉程度是怎样的，学习成本又是怎样的？\n3.  业务需求：需求是怎样的，能否套用现在的成熟解决方案/库来快速解决？\n4.  维护成本：一个解决方案的是否再能够 cover 住的范围之内？\n\n在项目中遇见的数据和收益应该做好跟踪，保证数据的真实性和可信性。另外，遇见的坑可能是面试官问得比较多的，尤其现在比较火的一些技术（Vue、React、webpack），一般团队都在使用，所以一定要提前准备下。\n\n**小结**\n------\n\n本小节介绍了面试中关于项目类问题的回答方法，介绍项目要使用四段体的方式，从背景、承担角色、收益效果和总结反思四个部分来介绍项目。\n\n准备这个面试环节的时候，利用笔者一直提倡的「思维导图」法，好好回顾和梳理自己的项目。\n","source":"_posts/前端知识点190111.md","raw":"---\ntitle: 前端知识点1901\ndate: 2019-01-11 14:11:16\ntags:\n---\n**一面 1：ES 基础知识点与高频考题解析**\n========================\n\nJavaScript 是 ECMAScript 规范的一种实现，本小节重点梳理下 ECMAScript 中的常考知识点，然后就一些容易出现的题目进行解析。\n\n**知识点梳理**\n---------\n\n*   变量类型\n    *   JS 的数据类型分类和判断\n    *   值类型和引用类型\n*   原型与原型链（继承）\n    *   原型和原型链定义\n    *   继承写法\n*   作用域和闭包\n    *   执行上下文\n    *   this\n    *   闭包是什么\n*   异步\n    *   同步 vs 异步\n    *   异步和单线程\n    *   前端异步的场景\n*   ES6/7 新标准的考查\n    *   箭头函数\n    *   Module\n    *   Class\n    *   Set 和 Map\n    *   Promise\n\n* * *\n\n**变量类型**\n--------\n\nJavaScript 是一种弱类型脚本语言，所谓弱类型指的是定义变量时，不需要什么类型，在程序运行过程中会自动判断类型。\n\nECMAScript 中定义了 6 种原始类型：\n\n*   Boolean\n*   String\n*   Number\n*   Null\n*   Undefined\n*   Symbol（ES6 新定义）\n\n**注意**：原始类型不包含 Object。\n\n> 题目：类型判断用到哪些方法？\n\n### **`typeof`**\n\n`typeof xxx`得到的值有以下几种类型：`undefined``boolean``number``string``object``function`、`symbol` ，比较简单，不再一一演示了。这里需要注意的有三点：\n\n*   `typeof null`结果是`object` ，实际这是`typeof`的一个bug，null是原始值，非引用类型\n*   `typeof [1, 2]`结果是`object`，结果中没有`array`这一项，引用类型除了`function`其他的全部都是`object`\n*   `typeof Symbol()` 用`typeof`获取`symbol`类型的值得到的是`symbol`，这是 ES6 新增的知识点\n\n### **`instanceof`**\n\n用于实例和构造函数的对应。例如判断一个变量是否是数组，使用`typeof`无法判断，但可以使用`[1, 2] instanceof Array`来判断。因为，`[1, 2]`是数组，它的构造函数就是`Array`。同理：\n\n    function Foo(name) {\n        this.name = name\n    }\n    var foo = new Foo('bar')\n    console.log(foo instanceof Foo) // true\n    \n    \n\n复制\n\n> 题目：值类型和引用类型的区别\n\n### **值类型 vs 引用类型**\n\n除了原始类型，ES 还有引用类型，上文提到的`typeof`识别出来的类型中，只有`object`和`function`是引用类型，其他都是值类型。\n\n根据 JavaScript 中的变量类型传递方式，又分为**值类型**和**引用类型**，值类型变量包括 Boolean、String、Number、Undefined、Null，引用类型包括了 Object 类的所有，如 Date、Array、Function 等。在参数传递方式上，值类型是按值传递，引用类型是按共享传递。\n\n下面通过一个小题目，来看下两者的主要区别，以及实际开发中需要注意的地方。\n\n    // 值类型\n    var a = 10\n    var b = a\n    b = 20\n    console.log(a)  // 10\n    console.log(b)  // 20\n    \n    \n\n复制\n\n上述代码中，`a``b`都是值类型，两者分别修改赋值，相互之间没有任何影响。再看引用类型的例子：\n\n    // 引用类型\n    var a = {x: 10, y: 20}\n    var b = a\n    b.x = 100\n    b.y = 200\n    console.log(a)  // {x: 100, y: 200}\n    console.log(b)  // {x: 100, y: 200}\n    \n    \n\n复制\n\n上述代码中，`a``b`都是引用类型。在执行了`b = a`之后，修改`b`的属性值，`a`的也跟着变化。因为`a`和`b`都是引用类型，指向了同一个内存地址，即两者引用的是同一个值，因此`b`修改属性时，`a`的值随之改动。\n\n再借助题目进一步讲解一下。\n\n> 说出下面代码的执行结果，并分析其原因。\n\n    function foo(a){\n        a = a * 10;\n    }\n    function bar(b){\n        b.value = 'new';\n    }\n    var a = 1;\n    var b = {value: 'old'};\n    foo(a);\n    bar(b);\n    console.log(a); // 1\n    console.log(b); // value: new\n    \n    \n\n复制\n\n通过代码执行，会发现：\n\n*   `a`的值没有发生改变\n*   而`b`的值发生了改变\n\n这就是因为`Number`类型的`a`是按值传递的，而`Object`类型的`b`是按共享传递的。\n\nJS 中这种设计的原因是：按值传递的类型，复制一份存入栈内存，这类类型一般不占用太多内存，而且按值传递保证了其访问速度。按共享传递的类型，是复制其引用，而不是整个复制其值（C 语言中的指针），保证过大的对象等不会因为不停复制内容而造成内存的浪费。\n\n引用类型经常会在代码中按照下面的写法使用，或者说**容易不知不觉中造成错误**！\n\n    var obj = {\n        a: 1,\n        b: [1,2,3]\n    }\n    var a = obj.a\n    var b = obj.b\n    a = 2\n    b.push(4)\n    console.log(obj, a, b)\n    \n    \n\n复制\n\n虽然`obj`本身是个引用类型的变量（对象），但是内部的`a`和`b`一个是值类型一个是引用类型，`a`的赋值不会改变`obj.a`，但是`b`的操作却会反映到`obj`对象上。\n\n* * *\n\n**原型和原型链**\n----------\n\nJavaScript 是基于原型的语言，原型理解起来非常简单，但却特别重要，下面还是通过题目来理解下JavaScript 的原型概念。\n\n> 题目：如何理解 JavaScript 的原型\n\n对于这个问题，可以从下面这几个要点来理解和回答，**下面几条必须记住并且理解**\n\n*   **所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（`null`除外）**\n*   **所有的引用类型（数组、对象、函数），都有一个`__proto__`属性，属性值是一个普通的对象**\n*   **所有的函数，都有一个`prototype`属性，属性值也是一个普通的对象**\n*   **所有的引用类型（数组、对象、函数），`__proto__`属性值指向它的构造函数的`prototype`属性值**\n\n通过代码解释一下，大家可自行运行以下代码，看结果。\n\n    // 要点一：自由扩展属性\n    var obj = {}; obj.a = 100;\n    var arr = []; arr.a = 100;\n    function fn () {}\n    fn.a = 100;\n    \n    // 要点二：__proto__\n    console.log(obj.__proto__);\n    console.log(arr.__proto__);\n    console.log(fn.__proto__);\n    \n    // 要点三：函数有 prototype\n    console.log(fn.prototype)\n    \n    // 要点四：引用类型的 __proto__ 属性值指向它的构造函数的 prototype 属性值\n    console.log(obj.__proto__ === Object.prototype)\n    \n    \n\n复制\n\n### **原型**\n\n先写一个简单的代码示例。\n\n    // 构造函数\n    function Foo(name, age) {\n        this.name = name\n    }\n    Foo.prototype.alertName = function () {\n        alert(this.name)\n    }\n    // 创建示例\n    var f = new Foo('zhangsan')\n    f.printName = function () {\n        console.log(this.name)\n    }\n    // 测试\n    f.printName()\n    f.alertName()\n    \n    \n\n复制\n\n执行`printName`时很好理解，但是执行`alertName`时发生了什么？这里再记住一个重点 **当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的`__proto__`（即它的构造函数的`prototype`）中寻找**，因此`f.alertName`就会找到`Foo.prototype.alertName`。\n\n那么如何判断这个属性是不是对象本身的属性呢？使用`hasOwnProperty`，常用的地方是遍历一个对象的时候。\n\n    var item\n    for (item in f) {\n        // 高级浏览器已经在 for in 中屏蔽了来自原型的属性，但是这里建议大家还是加上这个判断，保证程序的健壮性\n        if (f.hasOwnProperty(item)) {\n            console.log(item)\n        }\n    }\n    \n    \n\n复制\n\n> 题目：如何理解 JS 的原型链\n\n### **原型链**\n\n还是接着上面的示例，如果执行`f.toString()`时，又发生了什么？\n\n    // 省略 N 行\n    \n    // 测试\n    f.printName()\n    f.alertName()\n    f.toString()\n    \n    \n\n复制\n\n因为`f`本身没有`toString()`，并且`f.__proto__`（即`Foo.prototype`）中也没有`toString`。这个问题还是得拿出刚才那句话——**当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的`__proto__`（即它的构造函数的`prototype`）中寻找**。\n\n如果在`f.__proto__`中没有找到`toString`，那么就继续去`f.__proto__.__proto__`中寻找，因为`f.__proto__`就是一个普通的对象而已嘛！\n\n*   `f.__proto__`即`Foo.prototype`，没有找到`toString`，继续往上找\n*   `f.__proto__.__proto__`即`Foo.prototype.__proto__`。`Foo.prototype`就是一个普通的对象，因此`Foo.prototype.__proto__`就是`Object.prototype`，在这里可以找到`toString`\n*   因此`f.toString`最终对应到了`Object.prototype.toString`\n\n这样一直往上找，你会发现是一个链式的结构，所以叫做“原型链”。如果一直找到最上层都没有找到，那么就宣告失败，返回`undefined`。最上层是什么 —— `Object.prototype.__proto__ === null`\n\n### **原型链中的`this`**\n\n所有从原型或更高级原型中得到、执行的方法，其中的`this`在执行时，就指向了当前这个触发事件执行的对象。因此`printName`和`alertName`中的`this`都是`f`。\n\n* * *\n\n**作用域和闭包**\n----------\n\n作用域和闭包是前端面试中，最可能考查的知识点。例如下面的题目：\n\n> 题目：现在有个 HTML 片段，要求编写代码，点击编号为几的链接就`alert`弹出其编号\n\n    <ul>\n        <li>编号1，点击我请弹出1</li>\n        <li>2</li>\n        <li>3</li>\n        <li>4</li>\n        <li>5</li>\n    </ul>\n    \n    \n\n复制\n\n一般不知道这个题目用闭包的话，会写出下面的代码：\n\n    var list = document.getElementsByTagName('li');\n    for (var i = 0; i < list.length; i++) {\n        list[i].addEventListener('click', function(){\n            alert(i + 1)\n        }, true)\n    }\n    \n    \n\n复制\n\n实际上执行才会发现始终弹出的是`6`，这时候就应该通过闭包来解决：\n\n    var list = document.getElementsByTagName('li');\n    for (var i = 0; i < list.length; i++) {\n        list[i].addEventListener('click', function(i){\n            return function(){\n                alert(i + 1)\n            }\n        }(i), true)\n    }\n    \n    \n\n复制\n\n要理解闭包，就需要我们从「执行上下文」开始讲起。\n\n### **执行上下文**\n\n先讲一个关于 **变量提升** 的知识点，面试中可能会遇见下面的问题，很多候选人都回答错误：\n\n> 题目：说出下面执行的结果（这里笔者直接注释输出了）\n\n    console.log(a)  // undefined\n    var a = 100\n    \n    fn('zhangsan')  // 'zhangsan' 20\n    function fn(name) {\n        age = 20\n        console.log(name, age)\n        var age\n    }\n    \n    console.log(b); // 这里报错\n    // Uncaught ReferenceError: b is not defined\n    b = 100;\n    \n    \n\n复制\n\n在一段 JS 脚本（即一个`<script>`标签中）执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个 **全局执行上下文** 环境，先把代码中即将执行的（内部函数的不算，因为你不知道函数何时执行）变量、函数声明都拿出来。变量先暂时赋值为`undefined`，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。再次强调，这是在代码执行之前才开始的工作。\n\n我们来看下上面的面试小题目，为什么`a`是`undefined`，而`b`却报错了，实际 JS 在代码执行之前，要「全文解析」，发现`var a`，知道有个`a`的变量，存入了执行上下文，而`b`没有找到`var`关键字，这时候没有在执行上下文提前「占位」，所以代码执行的时候，提前报到的`a`是有记录的，只不过值暂时还没有赋值，即为`undefined`，而`b`在执行上下文没有找到，自然会报错（没有找到`b`的引用）。\n\n另外，一个函数在执行之前，也会创建一个 **函数执行上下文** 环境，跟 **全局上下文** 差不多，不过 **函数执行上下文** 中会多出`this``arguments`和函数的参数。参数和`arguments`好理解，这里的`this`咱们需要专门讲解。\n\n总结一下：\n\n*   范围：一段`<script>`、js 文件或者一个函数\n*   全局上下文：变量定义，函数声明\n*   函数上下文：变量定义，函数声明，`this`，`arguments`\n\n### **`this`**\n\n先搞明白一个很重要的概念 —— **`this`的值是在执行的时候才能确认，定义的时候不能确认！** 为什么呢 —— 因为`this`是执行上下文环境的一部分，而执行上下文需要在代码执行之前确定，而不是定义的时候。看如下例子\n\n    var a = {\n        name: 'A',\n        fn: function () {\n            console.log(this.name)\n        }\n    }\n    a.fn()  // this === a\n    a.fn.call({name: 'B'})  // this === {name: 'B'}\n    var fn1 = a.fn\n    fn1()  // this === window\n    \n    \n\n复制\n\n`this`执行会有不同，主要集中在这几个场景中\n\n*   作为构造函数执行，构造函数中\n*   作为对象属性执行，上述代码中`a.fn()`\n*   作为普通函数执行，上述代码中`fn1()`\n*   用于`call``apply``bind`，上述代码中`a.fn.call({name: 'B'})`\n\n下面再来讲解下什么是作用域和作用域链，作用域链和作用域也是常考的题目。\n\n> 题目：如何理解 JS 的作用域和作用域链\n\n### **作用域**\n\nES6 之前 JS 没有块级作用域。例如\n\n    if (true) {\n        var name = 'zhangsan'\n    }\n    console.log(name)\n    \n    \n\n复制\n\n从上面的例子可以体会到作用域的概念，作用域就是一个独立的地盘，让变量不会外泄、暴露出去。上面的`name`就被暴露出去了，因此，**JS 没有块级作用域，只有全局作用域和函数作用域**。\n\n    var a = 100\n    function fn() {\n        var a = 200\n        console.log('fn', a)\n    }\n    console.log('global', a)\n    fn()\n    \n    \n\n复制\n\n全局作用域就是最外层的作用域，如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样的坏处就是很容易撞车、冲突。\n\n    // 张三写的代码中\n    var data = {a: 100}\n    \n    // 李四写的代码中\n    var data = {x: true}\n    \n    \n\n复制\n\n这就是为何 jQuery、Zepto 等库的源码，所有的代码都会放在`(function(){....})()`中。因为放在里面的所有变量，都不会被外泄和暴露，不会污染到外面，不会对其他的库或者 JS 脚本造成影响。这是函数作用域的一个体现。\n\n附：ES6 中开始加入了块级作用域，使用`let`定义变量即可，如下：\n\n    if (true) {\n        let name = 'zhangsan'\n    }\n    console.log(name)  // undefined\n    \n    \n\n复制\n\n### **作用域链**\n\n首先认识一下什么叫做 **自由变量** 。如下代码中，`console.log(a)`要得到`a`变量，但是在当前的作用域中没有定义`a`（可对比一下`b`）。当前作用域没有定义的变量，这成为 **自由变量** 。自由变量如何得到 —— 向父级作用域寻找。\n\n    var a = 100\n    function fn() {\n        var b = 200\n        console.log(a)\n        console.log(b)\n    }\n    fn()\n    \n    \n\n复制\n\n如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 **作用域链** 。\n\n    var a = 100\n    function F1() {\n        var b = 200\n        function F2() {\n            var c = 300\n            console.log(a) // 自由变量，顺作用域链向父作用域找\n            console.log(b) // 自由变量，顺作用域链向父作用域找\n            console.log(c) // 本作用域的变量\n        }\n        F2()\n    }\n    F1()\n    \n    \n\n复制\n\n### **闭包**\n\n讲完这些内容，我们再来看一个例子，通过例子来理解闭包。\n\n    function F1() {\n        var a = 100\n        return function () {\n            console.log(a)\n        }\n    }\n    var f1 = F1()\n    var a = 200\n    f1()\n    \n    \n\n复制\n\n自由变量将从作用域链中去寻找，但是 **依据的是函数定义时的作用域链，而不是函数执行时**，以上这个例子就是闭包。闭包主要有两个应用场景：\n\n*   **函数作为返回值**，上面的例子就是\n*   **函数作为参数传递**，看以下例子\n\n    function F1() {\n        var a = 100\n        return function () {\n            console.log(a)\n        }\n    }\n    function F2(f1) {\n        var a = 200\n        console.log(f1())\n    }\n    var f1 = F1()\n    F2(f1)\n    \n    \n\n复制\n\n至此，对应着「作用域和闭包」这部分一开始的点击弹出`alert`的代码再看闭包，就很好理解了。\n\n* * *\n\n**异步**\n------\n\n异步和同步也是面试中常考的内容，下面笔者来讲解下同步和异步的区别。\n\n### **同步 vs 异步**\n\n先看下面的 demo，根据程序阅读起来表达的意思，应该是先打印`100`，1秒钟之后打印`200`，最后打印`300`。但是实际运行根本不是那么回事。\n\n    console.log(100)\n    setTimeout(function () {\n        console.log(200)\n    }, 1000)\n    console.log(300)\n    \n    \n\n复制\n\n再对比以下程序。先打印`100`，再弹出`200`（等待用户确认），最后打印`300`。这个运行效果就符合预期要求。\n\n    console.log(100)\n    alert(200)  // 1秒钟之后点击确认\n    console.log(300)\n    \n    \n\n复制\n\n这俩到底有何区别？—— 第一个示例中间的步骤根本没有阻塞接下来程序的运行，而第二个示例却阻塞了后面程序的运行。前面这种表现就叫做 **异步**（后面这个叫做 **同步** ），即**不会阻塞后面程序的运行**。\n\n### **异步和单线程**\n\nJS 需要异步的根本原因是 **JS 是单线程运行的**，即在同一时间只能做一件事，不能“一心二用”。\n\n一个 Ajax 请求由于网络比较慢，请求需要 5 秒钟。如果是同步，这 5 秒钟页面就卡死在这里啥也干不了了。异步的话，就好很多了，5 秒等待就等待了，其他事情不耽误做，至于那 5 秒钟等待是网速太慢，不是因为 JS 的原因。\n\n讲到单线程，我们再来看个真题：\n\n> 题目：讲解下面代码的执行过程和结果\n\n    var a = true;\n    setTimeout(function(){\n        a = false;\n    }, 100)\n    while(a){\n        console.log('while执行了')\n    }\n    \n    \n\n复制\n\n这是一个很有迷惑性的题目，不少候选人认为`100ms`之后，由于`a`变成了`false`，所以`while`就中止了，实际不是这样，因为JS是单线程的，所以进入`while`循环之后，没有「时间」（线程）去跑定时器了，所以这个代码跑起来是个死循环！\n\n### **前端异步的场景**\n\n*   定时 `setTimeout``setInverval`\n*   网络请求，如 `Ajax``<img>`加载\n\nAjax 代码示例\n\n    console.log('start')\n    $.get('./data1.json', function (data1) {\n        console.log(data1)\n    })\n    console.log('end')\n    \n    \n\n复制\n\nimg 代码示例（常用于打点统计）\n\n    console.log('start')\n    var img = document.createElement('img')\n    // 或者 img = new Image()\n    img.onload = function () {\n        console.log('loaded')\n        img.onload = null\n    }\n    img.src = '/xxx.png'\n    console.log('end')\n    \n    \n\n复制\n\n* * *\n\n**ES6/7 新标准的考查**\n----------------\n\n> 题目：ES6 箭头函数中的`this`和普通函数中的有什么不同\n\n### **箭头函数**\n\n箭头函数是 ES6 中新的函数定义形式，`function name(arg1, arg2) {...}`可以使用`(arg1, arg2) => {...}`来定义。示例如下：\n\n    // JS 普通函数\n    var arr = [1, 2, 3]\n    arr.map(function (item) {\n        console.log(index)\n        return item + 1\n    })\n    \n    // ES6 箭头函数\n    const arr = [1, 2, 3]\n    arr.map((item, index) => {\n        console.log(index)\n        return item + 1\n    })\n    \n    \n\n复制\n\n箭头函数存在的意义，第一写起来更加简洁，第二可以解决 ES6 之前函数执行中`this`是全局变量的问题，看如下代码\n\n    function fn() {\n        console.log('real', this)  // {a: 100} ，该作用域下的 this 的真实的值\n        var arr = [1, 2, 3]\n        // 普通 JS\n        arr.map(function (item) {\n            console.log('js', this)  // window 。普通函数，这里打印出来的是全局变量，令人费解\n            return item + 1\n        })\n        // 箭头函数\n        arr.map(item => {\n            console.log('es6', this)  // {a: 100} 。箭头函数，这里打印的就是父作用域的 this\n            return item + 1\n        })\n    }\n    fn.call({a: 100})\n    \n    \n\n复制\n\n> 题目：ES6 模块化如何使用？\n\n### **Module**\n\nES6 中模块化语法更加简洁，直接看示例。\n\n如果只是输出一个唯一的对象，使用`export default`即可，代码如下\n\n    // 创建 util1.js 文件，内容如\n    export default {\n        a: 100\n    }\n    \n    // 创建 index.js 文件，内容如\n    import obj from './util1.js'\n    console.log(obj)\n    \n    \n\n复制\n\n如果想要输出许多个对象，就不能用`default`了，且`import`时候要加`{...}`，代码如下\n\n    // 创建 util2.js 文件，内容如\n    export function fn1() {\n        alert('fn1')\n    }\n    export function fn2() {\n        alert('fn2')\n    }\n    \n    // 创建 index.js 文件，内容如\n    import { fn1, fn2 } from './util2.js'\n    fn1()\n    fn2()\n    \n    \n\n复制\n\n> 题目：ES6 class 和普通构造函数的区别\n\n### **class**\n\nclass 其实一直是 JS 的关键字（保留字），但是一直没有正式使用，直到 ES6 。 ES6 的 class 就是取代之前构造函数初始化对象的形式，从语法上更加符合面向对象的写法。例如：\n\nJS 构造函数的写法\n\n    function MathHandle(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n    \n    MathHandle.prototype.add = function () {\n      return this.x + this.y;\n    };\n    \n    var m = new MathHandle(1, 2);\n    console.log(m.add())\n    \n    \n\n复制\n\n用 ES6 class 的写法\n\n    class MathHandle {\n      constructor(x, y) {\n        this.x = x;\n        this.y = y;\n      }\n    \n      add() {\n        return this.x + this.y;\n      }\n    }\n    const m = new MathHandle(1, 2);\n    console.log(m.add())\n    \n    \n\n复制\n\n注意以下几点，全都是关于 class 语法的：\n\n*   class 是一种新的语法形式，是`class Name {...}`这种形式，和函数的写法完全不一样\n*   两者对比，构造函数函数体的内容要放在 class 中的`constructor`函数中，`constructor`即构造器，初始化实例时默认执行\n*   class 中函数的写法是`add() {...}`这种形式，并没有`function`关键字\n\n使用 class 来实现继承就更加简单了，至少比构造函数实现继承简单很多。看下面例子\n\nJS 构造函数实现继承\n\n    // 动物\n    function Animal() {\n        this.eat = function () {\n            console.log('animal eat')\n        }\n    }\n    // 狗\n    function Dog() {\n        this.bark = function () {\n            console.log('dog bark')\n        }\n    }\n    Dog.prototype = new Animal()\n    // 哈士奇\n    var hashiqi = new Dog()\n    \n    \n\n复制\n\nES6 class 实现继承\n\n    class Animal {\n        constructor(name) {\n            this.name = name\n        }\n        eat() {\n            console.log(`${this.name} eat`)\n        }\n    }\n    \n    class Dog extends Animal {\n        constructor(name) {\n            super(name)\n            this.name = name\n        }\n        say() {\n            console.log(`${this.name} say`)\n        }\n    }\n    const dog = new Dog('哈士奇')\n    dog.say()\n    dog.eat()\n    \n    \n\n复制\n\n注意以下两点：\n\n*   使用`extends`即可实现继承，更加符合经典面向对象语言的写法，如 Java\n*   子类的`constructor`一定要执行`super()`，以调用父类的`constructor`\n\n> 题目：ES6 中新增的数据类型有哪些？\n\n### **Set 和 Map**\n\nSet 和 Map 都是 ES6 中新增的数据结构，是对当前 JS 数组和对象这两种重要数据结构的扩展。由于是新增的数据结构，目前尚未被大规模使用，但是作为前端程序员，提前了解是必须做到的。先总结一下两者最关键的地方：\n\n*   Set 类似于数组，但数组可以允许元素重复，Set 不允许元素重复\n*   Map 类似于对象，但普通对象的 key 必须是字符串或者数字，而 Map 的 key 可以是任何数据类型\n\n**Set**\n\nSet 实例不允许元素有重复，可以通过以下示例证明。可以通过一个数组初始化一个 Set 实例，或者通过`add`添加元素，元素不能重复，重复的会被忽略。\n\n    // 例1\n    const set = new Set([1, 2, 3, 4, 4]);\n    console.log(set) // Set(4) {1, 2, 3, 4}\n    \n    // 例2\n    const set = new Set();\n    [2, 3, 5, 4, 5, 8, 8].forEach(item => set.add(item));\n    for (let item of set) {\n      console.log(item);\n    }\n    // 2 3 5 4 8\n    \n    \n\n复制\n\nSet 实例的属性和方法有\n\n*   `size`：获取元素数量。\n*   `add(value)`：添加元素，返回 Set 实例本身。\n*   `delete(value)`：删除元素，返回一个布尔值，表示删除是否成功。\n*   `has(value)`：返回一个布尔值，表示该值是否是 Set 实例的元素。\n*   `clear()`：清除所有元素，没有返回值。\n\n    const s = new Set();\n    s.add(1).add(2).add(2); // 添加元素\n    \n    s.size // 2\n    \n    s.has(1) // true\n    s.has(2) // true\n    s.has(3) // false\n    \n    s.delete(2);\n    s.has(2) // false\n    \n    s.clear();\n    console.log(s);  // Set(0) {}\n    \n    \n\n复制\n\nSet 实例的遍历，可使用如下方法\n\n*   `keys()`：返回键名的遍历器。\n*   `values()`：返回键值的遍历器。不过由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以`keys()`和`values()`返回结果一致。\n*   `entries()`：返回键值对的遍历器。\n*   `forEach()`：使用回调函数遍历每个成员。\n\n    let set = new Set(['aaa', 'bbb', 'ccc']);\n    \n    for (let item of set.keys()) {\n      console.log(item);\n    }\n    // aaa\n    // bbb\n    // ccc\n    \n    for (let item of set.values()) {\n      console.log(item);\n    }\n    // aaa\n    // bbb\n    // ccc\n    \n    for (let item of set.entries()) {\n      console.log(item);\n    }\n    // [\"aaa\", \"aaa\"]\n    // [\"bbb\", \"bbb\"]\n    // [\"ccc\", \"ccc\"]\n    \n    set.forEach((value, key) => console.log(key + ' : ' + value))\n    // aaa : aaa\n    // bbb : bbb\n    // ccc : ccc\n    \n    \n\n复制\n\n**Map**\n\nMap 的用法和普通对象基本一致，先看一下它能用非字符串或者数字作为 key 的特性。\n\n    const map = new Map();\n    const obj = {p: 'Hello World'};\n    \n    map.set(obj, 'OK')\n    map.get(obj) // \"OK\"\n    \n    map.has(obj) // true\n    map.delete(obj) // true\n    map.has(obj) // false\n    \n    \n\n复制\n\n需要使用`new Map()`初始化一个实例，下面代码中`set``get``has``delete`顾名即可思义（下文也会演示）。其中，`map.set(obj, 'OK')`就是用对象作为的 key （不光可以是对象，任何数据类型都可以），并且后面通过`map.get(obj)`正确获取了。\n\nMap 实例的属性和方法如下：\n\n*   `size`：获取成员的数量\n*   `set`：设置成员 key 和 value\n*   `get`：获取成员属性值\n*   `has`：判断成员是否存在\n*   `delete`：删除成员\n*   `clear`：清空所有\n\n    const map = new Map();\n    map.set('aaa', 100);\n    map.set('bbb', 200);\n    \n    map.size // 2\n    \n    map.get('aaa') // 100\n    \n    map.has('aaa') // true\n    \n    map.delete('aaa')\n    map.has('aaa') // false\n    \n    map.clear()\n    \n    \n\n复制\n\nMap 实例的遍历方法有：\n\n*   `keys()`：返回键名的遍历器。\n*   `values()`：返回键值的遍历器。\n*   `entries()`：返回所有成员的遍历器。\n*   `forEach()`：遍历 Map 的所有成员。\n\n    const map = new Map();\n    map.set('aaa', 100);\n    map.set('bbb', 200);\n    \n    for (let key of map.keys()) {\n      console.log(key);\n    }\n    // \"aaa\"\n    // \"bbb\"\n    \n    for (let value of map.values()) {\n      console.log(value);\n    }\n    // 100\n    // 200\n    \n    for (let item of map.entries()) {\n      console.log(item[0], item[1]);\n    }\n    // aaa 100\n    // bbb 200\n    \n    // 或者\n    for (let [key, value] of map.entries()) {\n      console.log(key, value);\n    }\n    // aaa 100\n    // bbb 200\n    \n    \n\n复制\n\n### **Promise**\n\n`Promise`是 CommonJS 提出来的这一种规范，有多个版本，在 ES6 当中已经纳入规范，原生支持 Promise 对象，非 ES6 环境可以用类似 Bluebird、Q 这类库来支持。\n\n`Promise` 可以将回调变成链式调用写法，流程更加清晰，代码更加优雅。\n\n简单归纳下 Promise：**三个状态、两个过程、一个方法**，快速记忆方法：**3-2-1**\n\n三个状态：`pending`、`fulfilled`、`rejected`\n\n两个过程：\n\n*   pending→fulfilled（resolve）\n*   pending→rejected（reject）\n\n一个方法：`then`\n\n当然还有其他概念，如`catch`、 `Promise.all/race`，这里就不展开了。\n\n关于 ES6/7 的考查内容还有很多，本小节就不逐一介绍了，如果想继续深入学习，可以在线看《[ES6入门](https://link.juejin.im?target=http%3A%2F%2Fes6.ruanyifeng.com%2F)》。\n\n**小结**\n------\n\n本小节主要总结了 ES 基础语法中面试经常考查的知识点，包括之前就考查较多的原型、异步、作用域，以及 ES6 的一些新内容，这些知识点希望大家都要掌握。\n\n上一篇：[准备：简历编写和面试前准备](541670)下一篇：[一面 2：JS-Web-API 知识点与高频考题解析](541672)\n\n**一面 2：JS-Web-API 知识点与高频考题解析**\n==============================\n\n除 ES 基础之外，Web 前端经常会用到一些跟浏览器相关的 API，接下来我们一起梳理一下。\n\n**知识点梳理**\n---------\n\n*   BOM 操作\n*   DOM 操作\n*   事件绑定\n*   Ajax\n*   存储\n\n* * *\n\n**BOM**\n-------\n\nBOM（浏览器对象模型）是浏览器本身的一些信息的设置和获取，例如获取浏览器的宽度、高度，设置让浏览器跳转到哪个地址。\n\n*   `navigator`\n*   `screen`\n*   `location`\n*   `history`\n\n这些对象就是一堆非常简单粗暴的 API，没任何技术含量，讲起来一点意思都没有，大家去 MDN 或者 w3school 这种网站一查就都明白了。面试的时候，面试官基本不会出太多这方面的题目，因为只要基础知识过关了，这些 API 即便你记不住，上网一查也都知道了。下面列举一下常用功能的代码示例\n\n获取浏览器特性（即俗称的`UA`）然后识别客户端，例如判断是不是 Chrome 浏览器\n\n    var ua = navigator.userAgent\n    var isChrome = ua.indexOf('Chrome')\n    console.log(isChrome)\n    \n    \n\n复制\n\n获取屏幕的宽度和高度\n\n    console.log(screen.width)\n    console.log(screen.height)\n    \n    \n\n复制\n\n获取网址、协议、path、参数、hash 等\n\n    // 例如当前网址是 https://juejin.im/timeline/frontend?a=10&b=10#some\n    console.log(location.href)  // https://juejin.im/timeline/frontend?a=10&b=10#some\n    console.log(location.protocol) // https:\n    console.log(location.pathname) // /timeline/frontend\n    console.log(location.search) // ?a=10&b=10\n    console.log(location.hash) // #some\n    \n    \n\n复制\n\n另外，还有调用浏览器的前进、后退功能等\n\n    history.back()\n    history.forward()\n    \n    \n\n复制\n\n* * *\n\n**DOM**\n-------\n\n> 题目：DOM 和 HTML 区别和联系\n\n### **什么是 DOM**\n\n讲 DOM 先从 HTML 讲起，讲 HTML 先从 XML 讲起。XML 是一种可扩展的标记语言，所谓可扩展就是它可以描述任何结构化的数据，它是一棵树！\n\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <note>\n      <to>Tove</to>\n      <from>Jani</from>\n      <heading>Reminder</heading>\n      <body>Don't forget me this weekend!</body>\n      <other>\n        <a></a>\n        <b></b>\n      </other>\n    </note>\n    \n    \n\n复制\n\nHTML 是一个有既定标签标准的 XML 格式，标签的名字、层级关系和属性，都被标准化（否则浏览器无法解析）。同样，它也是一棵树。\n\n    <!DOCTYPE html>\n    <html>\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Document</title>\n    </head>\n    <body>\n        <div>\n            <p>this is p</p>\n        </div>\n    </body>\n    </html>\n    \n    \n\n复制\n\n我们开发完的 HTML 代码会保存到一个文档中（一般以`.html`或者`.htm`结尾），文档放在服务器上，浏览器请求服务器，这个文档被返回。因此，最终浏览器拿到的是一个文档而已，文档的内容就是 HTML 格式的代码。\n\n但是浏览器要把这个文档中的 HTML 按照标准渲染成一个页面，此时浏览器就需要将这堆代码处理成自己能理解的东西，也得处理成 JS 能理解的东西，因为还得允许 JS 修改页面内容呢。\n\n基于以上需求，浏览器就需要把 HTML 转变成 DOM，HTML 是一棵树，DOM 也是一棵树。对 DOM 的理解，可以暂时先抛开浏览器的内部因素，先从 JS 着手，即可以认为 DOM 就是 JS 能识别的 HTML 结构，一个普通的 JS 对象或者数组。\n\n!\\[DOM图示\\](data:image/svg+xml;utf8,)\n\n### **获取 DOM 节点**\n\n最常用的 DOM API 就是获取节点，其中常用的获取方法如下面代码示例：\n\n    // 通过 id 获取\n    var div1 = document.getElementById('div1') // 元素\n    \n    // 通过 tagname 获取\n    var divList = document.getElementsByTagName('div')  // 集合\n    console.log(divList.length)\n    console.log(divList[0])\n    \n    // 通过 class 获取\n    var containerList = document.getElementsByClassName('container') // 集合\n    \n    // 通过 CSS 选择器获取\n    var pList = document.querySelectorAll('p') // 集合\n    \n    \n\n复制\n\n> 题目：property 和 attribute 的区别是什么？\n\n### **property**\n\nDOM 节点就是一个 JS 对象，它符合之前讲述的对象的特征 —— 可扩展属性，因为 DOM 节点本质上也是一个 JS 对象。因此，如下代码所示，`p`可以有`style`属性，有`className``nodeName``nodeType`属性。注意，**这些都是 JS 范畴的属性，符合 JS 语法标准的**。\n\n    var pList = document.querySelectorAll('p')\n    var p = pList[0]\n    console.log(p.style.width)  // 获取样式\n    p.style.width = '100px'  // 修改样式\n    console.log(p.className)  // 获取 class\n    p.className = 'p1'  // 修改 class\n    \n    // 获取 nodeName 和 nodeType\n    console.log(p.nodeName)\n    console.log(p.nodeType)\n    \n    \n\n复制\n\n### **attribute**\n\nproperty 的获取和修改，是直接改变 JS 对象，而 attribute 是直接改变 HTML 的属性，两种有很大的区别。attribute 就是对 HTML 属性的 get 和 set，和 DOM 节点的 JS 范畴的 property 没有关系。\n\n    var pList = document.querySelectorAll('p')\n    var p = pList[0]\n    p.getAttribute('data-name')\n    p.setAttribute('data-name', 'juejin')\n    p.getAttribute('style')\n    p.setAttribute('style', 'font-size:30px;')\n    \n    \n\n复制\n\n而且，get 和 set attribute 时，还会触发 DOM 的查询或者重绘、重排，频繁操作会影响页面性能。\n\n> 题目：DOM 操作的基本 API 有哪些？\n\n### **DOM 树操作**\n\n新增节点\n\n    var div1 = document.getElementById('div1')\n    \n    // 添加新节点\n    var p1 = document.createElement('p')\n    p1.innerHTML = 'this is p1'\n    div1.appendChild(p1) // 添加新创建的元素\n    \n    // 移动已有节点。注意，这里是“移动”，并不是拷贝\n    var p2 = document.getElementById('p2')\n    div1.appendChild(p2)\n    \n    \n\n复制\n\n获取父元素\n\n    var div1 = document.getElementById('div1')\n    var parent = div1.parentElement\n    \n    \n\n复制\n\n获取子元素\n\n    var div1 = document.getElementById('div1')\n    var child = div1.childNodes\n    \n    \n\n复制\n\n删除节点\n\n    var div1 = document.getElementById('div1')\n    var child = div1.childNodes\n    div1.removeChild(child[0])\n    \n    \n\n复制\n\n还有其他操作的API，例如获取前一个节点、获取后一个节点等，但是面试过程中经常考到的就是上面几个。\n\n* * *\n\n**事件**\n------\n\n### **事件绑定**\n\n普通的事件绑定写法如下：\n\n    var btn = document.getElementById('btn1')\n    btn.addEventListener('click', function (event) {\n        // event.preventDefault() // 阻止默认行为\n        // event.stopPropagation() // 阻止冒泡\n        console.log('clicked')\n    })\n    \n    \n\n复制\n\n为了编写简单的事件绑定，可以编写通用的事件绑定函数。这里虽然比较简单，但是会随着后文的讲解，来继续完善和丰富这个函数。\n\n    // 通用的事件绑定函数\n    function bindEvent(elem, type, fn) {\n        elem.addEventListener(type, fn)\n    }\n    var a = document.getElementById('link1')\n    // 写起来更加简单了\n    bindEvent(a, 'click', function(e) {\n        e.preventDefault() // 阻止默认行为\n        alert('clicked')\n    })\n    \n    \n\n复制\n\n最后，**如果面试被问到 IE 低版本兼容性问题，我劝你果断放弃这份工作机会**。现在互联网流量都在 App 上， IE 占比越来越少，再去为 IE 浪费青春不值得，要尽量去做 App 相关的工作。\n\n> 题目：什么是事件冒泡？\n\n### **事件冒泡**\n\n    <body>\n        <div id=\"div1\">\n            <p id=\"p1\">激活</p>\n            <p id=\"p2\">取消</p>\n            <p id=\"p3\">取消</p>\n            <p id=\"p4\">取消</p>\n        </div>\n        <div id=\"div2\">\n            <p id=\"p5\">取消</p>\n            <p id=\"p6\">取消</p>\n        </div>\n    </body>\n    \n    \n\n复制\n\n对于以上 HTML 代码结构，要求点击`p1`时候进入激活状态，点击其他任何`<p>`都取消激活状态，如何实现？代码如下，注意看注释：\n\n    var body = document.body\n    bindEvent(body, 'click', function (e) {\n        // 所有 p 的点击都会冒泡到 body 上，因为 DOM 结构中 body 是 p 的上级节点，事件会沿着 DOM 树向上冒泡\n        alert('取消')\n    })\n    \n    var p1 = document.getElementById('p1')\n    bindEvent(p1, 'click', function (e) {\n        e.stopPropagation() // 阻止冒泡\n        alert('激活')\n    })\n    \n    \n\n复制\n\n如果我们在`p1``div1``body`中都绑定了事件，它是会根据 DOM 的结构来冒泡，从下到上挨个执行的。但是我们使用`e.stopPropagation()`就可以阻止冒泡\n\n> 题目：如何使用事件代理？有何好处？\n\n### **事件代理**\n\n我们设定一种场景，如下代码，一个`<div>`中包含了若干个`<a>`，而且还能继续增加。那如何快捷方便地为所有`<a>`绑定事件呢？\n\n    <div id=\"div1\">\n        <a href=\"#\">a1</a>\n        <a href=\"#\">a2</a>\n        <a href=\"#\">a3</a>\n        <a href=\"#\">a4</a>\n    </div>\n    <button>点击增加一个 a 标签</button>\n    \n    \n\n复制\n\n这里就会用到事件代理。我们要监听`<a>`的事件，但要把具体的事件绑定到`<div>`上，然后看事件的触发点是不是`<a>`。\n\n    var div1 = document.getElementById('div1')\n    div1.addEventListener('click', function (e) {\n        // e.target 可以监听到触发点击事件的元素是哪一个\n        var target = e.target\n        if (e.nodeName === 'A') {\n            // 点击的是 <a> 元素\n            alert(target.innerHTML)\n        }\n    })\n    \n    \n\n复制\n\n我们现在完善一下之前写的通用事件绑定函数，加上事件代理。\n\n    function bindEvent(elem, type, selector, fn) {\n        // 这样处理，可接收两种调用方式 bindEvent(div1, 'click', 'a', function () {...}) 和 bindEvent(div1, 'click', function () {...}) 这两种\n        if (fn == null) {\n            fn = selector\n            selector = null\n        }\n    \n        // 绑定事件\n        elem.addEventListener(type, function (e) {\n            var target\n            if (selector) {\n                // 有 selector 说明需要做事件代理\n                // 获取触发时间的元素，即 e.target\n                target = e.target\n                // 看是否符合 selector 这个条件\n                if (target.matches(selector)) {\n                    fn.call(target, e)\n                }\n            } else {\n                // 无 selector ，说明不需要事件代理\n                fn(e)\n            }\n        })\n    }\n    \n    \n\n复制\n\n然后这样使用，简单很多。\n\n    // 使用代理，bindEvent 多一个 'a' 参数\n    var div1 = document.getElementById('div1')\n    bindEvent(div1, 'click', 'a', function (e) {\n        console.log(this.innerHTML)\n    })\n    \n    // 不使用代理\n    var a = document.getElementById('a1')\n    bindEvent(div1, 'click', function (e) {\n        console.log(a.innerHTML)\n    })\n    \n    \n\n复制\n\n最后，使用代理的优点如下：\n\n*   使代码简洁\n*   减少浏览器的内存占用\n\n* * *\n\n**Ajax**\n--------\n\n### **XMLHttpRequest**\n\n> 题目：手写 XMLHttpRequest 不借助任何库\n\n这是很多奇葩的、个性的面试官经常用的手段。这种考查方式存在很多争议，但是你不能完全说它是错误的，毕竟也是考查对最基础知识的掌握情况。\n\n    var xhr = new XMLHttpRequest()\n    xhr.open(\"GET\", \"/api\", false)\n    xhr.onreadystatechange = function () {\n        // 这里的函数异步执行，可参考之前 JS 基础中的异步模块\n        if (xhr.readyState == 4) {\n            if (xhr.status == 200) {\n                alert(xhr.responseText)\n            }\n        }\n    }\n    xhr.send(null)\n    \n    \n\n复制\n\n当然，使用 jQuery、Zepto 或 Fetch 等库来写就更加简单了，这里不再赘述。\n\n### **状态码说明**\n\n上述代码中，有两处状态码需要说明。`xhr.readyState`是浏览器判断请求过程中各个阶段的，`xhr.status`是 HTTP 协议中规定的不同结果的返回状态说明。\n\n`xhr.readyState`的状态码说明：\n\n*   0 - (未初始化）还没有调用`send()`方法\n*   1 -（载入）已调用`send()`方法，正在发送请求\n*   2 -（载入完成）`send()`方法执行完成，已经接收到全部响应内容\n*   3 -（交互）正在解析响应内容\n*   4 -（完成）响应内容解析完成，可以在客户端调用了\n\n> 题目：HTTP 协议中，response 的状态码，常见的有哪些？\n\n`xhr.status`即 HTTP 状态码，有 `2xx``3xx``4xx``5xx` 这几种，比较常用的有以下几种：\n\n*   `200` 正常\n*   `3xx`\n    *   `301` 永久重定向。如`http://xxx.com`这个 GET 请求（最后没有`/`），就会被`301`到`http://xxx.com/`（最后是`/`）\n    *   `302` 临时重定向。临时的，不是永久的\n    *   `304` 资源找到但是不符合请求条件，不会返回任何主体。如发送 GET 请求时，head 中有`If-Modified-Since: xxx`（要求返回更新时间是`xxx`时间之后的资源），如果此时服务器 端资源未更新，则会返回`304`，即不符合要求\n*   `404` 找不到资源\n*   `5xx` 服务器端出错了\n\n看完要明白，为何上述代码中要同时满足`xhr.readyState == 4`和`xhr.status == 200`。\n\n### **Fetch API**\n\n目前已经有一个获取 HTTP 请求更加方便的 API：`Fetch`，通过`Fetch`提供的`fetch()`这个全局函数方法可以很简单地发起异步请求，并且支持`Promise`的回调。但是 Fetch API 是比较新的 API，具体使用的时候还需要查查 [caniuse](https://link.juejin.im?target=https%3A%2F%2Fcaniuse.com%2F)，看下其浏览器兼容情况。\n\n看一个简单的例子：\n\n    fetch('some/api/data.json', {\n      method:'POST', //请求类型 GET、POST\n      headers:{}, // 请求的头信息，形式为 Headers 对象或 ByteString\n      body:{}, //请求发送的数据 blob、BufferSource、FormData、URLSearchParams（get 或head 方法中不能包含 body）\n      mode:'', //请求的模式，是否跨域等，如 cors、 no-cors 或 same-origin\n      credentials:'', //cookie 的跨域策略，如 omit、same-origin 或 include\n      cache:'', //请求的 cache 模式: default、no-store、reload、no-cache、 force-cache 或 only-if-cached\n    }).then(function(response) { ... });\n    \n    \n\n复制\n\n`Fetch` 支持`headers`定义，通过`headers`自定义可以方便地实现多种请求方法（ PUT、GET、POST 等）、请求头（包括跨域）和`cache`策略等；除此之外还支持 response（返回数据）多种类型，比如支持二进制文件、字符串和`formData`等。\n\n### **跨域**\n\n> 题目：如何实现跨域？\n\n浏览器中有 **同源策略** ，即一个域下的页面中，无法通过 Ajax 获取到其他域的接口。例如有一个接口`http://m.juejin.com/course/ajaxcourserecom?cid=459`，你自己的一个页面`http://www.yourname.com/page1.html`中的 Ajax 无法获取这个接口。这正是命中了“同源策略”。如果浏览器哪些地方忽略了同源策略，那就是浏览器的安全漏洞，需要紧急修复。\n\nurl 哪些地方不同算作跨域？\n\n*   协议\n*   域名\n*   端口\n\n但是 HTML 中几个标签能逃避过同源策略——`<script src=\"xxx\">`、`<img src=\"xxxx\"/>`、`<link href=\"xxxx\">`，这三个标签的`src/href`可以加载其他域的资源，不受同源策略限制。\n\n因此，这使得这三个标签可以做一些特殊的事情。\n\n*   `<img>`可以做打点统计，因为统计方并不一定是同域的，在讲解 JS 基础知识异步的时候有过代码示例。除了能跨域之外，`<img>`几乎没有浏览器兼容问题，它是一个非常古老的标签。\n*   `<script>`和`<link>`可以使用 CDN，CDN 基本都是其他域的链接。\n*   另外`<script>`还可以实现 JSONP，能获取其他域接口的信息，接下来马上讲解。\n\n但是请注意，所有的跨域请求方式，最终都需要信息提供方来做出相应的支持和改动，也就是要经过信息提供方的同意才行，否则接收方是无法得到它们的信息的，浏览器是不允许的。\n\n### **解决跨域 \\- JSONP**\n\n首先，有一个概念你要明白，例如访问`http://coding.m.juejin.com/classindex.html`的时候，服务器端就一定有一个`classindex.html`文件吗？—— 不一定，服务器可以拿到这个请求，动态生成一个文件，然后返回。 同理，`<script src=\"http://coding.m.juejin.com/api.js\">`也不一定加载一个服务器端的静态文件，服务器也可以动态生成文件并返回。OK，接下来正式开始。\n\n例如我们的网站和掘金网，肯定不是一个域。我们需要掘金网提供一个接口，供我们来获取。首先，我们在自己的页面这样定义\n\n    <script>\n    window.callback = function (data) {\n        // 这是我们跨域得到信息\n        console.log(data)\n    }\n    </script>\n    \n    \n\n复制\n\n然后掘金网给我提供了一个`http://coding.m.juejin.com/api.js`，内容如下（之前说过，服务器可动态生成内容）\n\n    callback({x:100, y:200})\n    \n    \n\n复制\n\n最后我们在页面中加入`<script src=\"http://coding.m.juejin.com/api.js\"></script>`，那么这个js加载之后，就会执行内容，我们就得到内容了。\n\n### **解决跨域 \\- 服务器端设置 http header**\n\n这是需要在服务器端设置的，作为前端工程师我们不用详细掌握，但是要知道有这么个解决方案。而且，现在推崇的跨域解决方案是这一种，比 JSONP 简单许多。\n\n    response.setHeader(\"Access-Control-Allow-Origin\", \"http://m.juejin.com/\");  // 第二个参数填写允许跨域的域名称，不建议直接写 \"*\"\n    response.setHeader(\"Access-Control-Allow-Headers\", \"X-Requested-With\");\n    response.setHeader(\"Access-Control-Allow-Methods\", \"PUT,POST,GET,DELETE,OPTIONS\");\n    \n    // 接收跨域的cookie\n    response.setHeader(\"Access-Control-Allow-Credentials\", \"true\");\n    \n    \n\n复制\n\n* * *\n\n**存储**\n------\n\n> 题目：cookie 和 localStorage 有何区别？\n\n### **cookie**\n\ncookie 本身不是用来做服务器端存储的（计算机领域有很多这种“狗拿耗子”的例子，例如 CSS 中的 float），它是设计用来在服务器和客户端进行信息传递的，因此我们的每个 HTTP 请求都带着 cookie。但是 cookie 也具备浏览器端存储的能力（例如记住用户名和密码），因此就被开发者用上了。\n\n使用起来也非常简单，`document.cookie = ....`即可。\n\n但是 cookie 有它致命的缺点：\n\n*   存储量太小，只有 4KB\n*   所有 HTTP 请求都带着，会影响获取资源的效率\n*   API 简单，需要封装才能用\n\n### **locationStorage 和 sessionStorage**\n\n后来，HTML5 标准就带来了`sessionStorage`和`localStorage`，先拿`localStorage`来说，它是专门为了浏览器端缓存而设计的。其优点有：\n\n*   存储量增大到 5MB\n*   不会带到 HTTP 请求中\n*   API 适用于数据存储 `localStorage.setItem(key, value)``localStorage.getItem(key)`\n\n`sessionStorage`的区别就在于它是根据 session 过去时间而实现，而`localStorage`会永久有效，应用场景不同。例如，一些需要及时失效的重要信息放在`sessionStorage`中，一些不重要但是不经常设置的信息，放在`localStorage`中。\n\n另外告诉大家一个小技巧，针对`localStorage.setItem`，使用时尽量加入到`try-catch`中，某些浏览器是禁用这个 API 的，要注意。\n\n* * *\n\n**小结**\n------\n\n本小节总结了 W3C 标准中 Web-API 部分，面试中常考的知识点，这些也是日常开发中最常用的 API 和知识。\n\n上一篇：[一面 1：ES 基础知识点与高频考题解析](541671)下一篇：[一面 3：CSS-HTML 知识点与高频考题解析](541673)\n\n**一面 3：CSS-HTML 知识点与高频考题解析**\n============================\n\nCSS 和 HTML 是网页开发中布局相关的组成部分，涉及的内容比较多和杂乱，本小节重点介绍下常考的知识点。\n\n**知识点梳理**\n---------\n\n*   选择器的权重和优先级\n*   盒模型\n    *   盒子大小计算\n    *   margin 的重叠计算\n*   浮动`float`\n    *   浮动布局概念\n    *   清理浮动\n*   定位`position`\n    *   文档流概念\n    *   定位分类\n    *   fixed 定位特点\n    *   绝对定位计算方式\n*   `flex`布局\n*   如何实现居中对齐？\n*   理解语义化\n*   CSS3 动画\n*   重绘和回流\n\n* * *\n\n**选择器的权重和优先级**\n--------------\n\nCSS 选择器有很多，不同的选择器的权重和优先级不一样，对于一个元素，如果存在多个选择器，那么就需要根据权重来计算其优先级。\n\n权重分为四级，分别是：\n\n1.  代表内联样式，如`style=\"xxx\"`，权值为 1000；\n2.  代表 ID 选择器，如`#content`，权值为 100；\n3.  代表类、伪类和属性选择器，如`.content`、`:hover`、`[attribute]`，权值为 10；\n4.  代表元素选择器和伪元素选择器，如`div`、`p`，权值为 1。\n\n**需要注意的是：通用选择器（*）、子选择器（>）和相邻同胞选择器（+）并不在这四个等级中，所以他们的权值都为 0**。 权重值大的选择器其优先级也高，相同权重的优先级又遵循后定义覆盖前面定义的情况。\n\n**盒模型**\n-------\n\n### **什么是“盒子”**\n\n初学 CSS 的朋友，一开始学 CSS 基础知识的时候一定学过`padding``border`和`margin`，即内边距、边框和外边距。它们三者就构成了一个“盒子”。就像我们收到的快递，本来买了一部小小的手机，收到的却是那么大一个盒子。因为手机白色的包装盒和手机机器之间有间隔层（内边距），手机白色盒子有厚度，虽然很薄（边框），盒子和快递箱子之间还有一层泡沫板（外边距）。这就是一个典型的盒子。\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n如上图，真正的内容就是这些文字，文字外围有 10px 的内边距，5px 的边框，10px 的外边距。看到盒子了吧？\n\n> 题目：盒子模型的宽度如何计算\n\n### **固定宽度的盒子**\n\n    <div style=\"padding:10px; border:5px solid blue; margin: 10px; width:300px;\">\n        之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》，\n        文章言简意赅的介绍的浏览器的工作过程，web前端\n    </div>\n    \n    \n\n复制\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n如上图，得到网页效果之后，我们可以用截图工具来量一下文字内容的宽度。发现，文字内容的宽度刚好是 300px，也就是我们设置的宽度。\n\n因此，**在盒子模型中，我们设置的宽度都是内容宽度，不是整个盒子的宽度。而整个盒子的宽度是：（内容宽度 \\+ `border`宽度 \\+ `padding`宽度 \\+ `margin`宽度）之和**。这样我们改四个中的其中一个，都会导致盒子宽度的改变。这对我们来说不友好。\n\n没关系，这个东西不友好早就有人发现了，而且已经解决，下文再说。\n\n### **充满父容器的盒子**\n\n默认情况下，`div`是`display:block`，宽度会充满整个父容器。如下图：\n\n    <div style=\"padding:10px; border:5px solid blue; margin: 10px; width:300px;\">\n        之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》，\n        文章言简意赅的介绍的浏览器的工作过程，web前端\n        之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》，\n        文章言简意赅的介绍的浏览器的工作过程，web前端\n    </div>\n    \n    \n\n复制\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n但是别忘记，这个 div 是个盒子模型，它的整个宽度包括（内容宽度 + `border`宽度 \\+ `padding`宽度 \\+ `margin`宽度），整个的宽度充满父容器。\n\n问题就在这里。如果父容器宽度不变，我们手动增大`margin`、`border`或`padding`其中一项的宽度值，都会导致内容宽度的减少。极端情况下，如果内容的宽度压缩到不能再压缩了（例如一个字的宽度），那么浏览器会强迫增加父容器的宽度。这可不是我们想要看到的。\n\n### **包裹内容的盒子**\n\n这种情况下比较简单，内容的宽度按照内容计算，盒子的宽度将在内容宽度的基础上再增加（`padding`宽度 \\+ `border`宽度 \\+ `margin`宽度）之和。\n\n    <div style=\"padding:10px; border:5px solid blue; margin: 10px; width:300px;\">\n        之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》\n    </div>\n    \n    \n\n复制\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n### `box-sizing:border-box`\n\n前面提到，为盒子模型设置宽度，结果只是设置了内容的宽度，这个不合理。如何解决这一问题？答案就是为盒子指定样式：**`box-sizing:border-box`**。\n\n    <div style=\"padding:10px; border:5px solid blue; margin: 10px; width:300px; box-sizing:border-box;\">\n        之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》\n    </div>\n    \n    \n\n复制\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n上图中，为`div`设置了`box-sizing:border-box`之后，300px 的**宽度是内容 \\+ `border` \\+ 边框的宽度（不包括`margin`）**，这样就比较符合我们的实际要求了。建议大家在为系统写 CSS 时候，第一个样式是：\n\n    * {\n        box-sizing:border-box;\n    }\n    \n    \n\n复制\n\n大名鼎鼎的 Bootstrap 也把`box-sizing:border-box`加入到它的`*`选择器中，我们为什么不这样做呢？\n\n### **纵向 margin 重叠**\n\n这里提到 margin，就不得不提一下 margin 的这一特性——纵向重叠。如`<p>`的纵向 margin 是 16px，那么两个`<p>`之间纵向的距离是多少？—— 按常理来说应该是 16 + 16 = 32px，但是答案仍然是 16px。因为纵向的 margin 是会重叠的，如果两者不一样大的话，大的会把小的“吃掉”。\n\n* * *\n\n**浮动`float`**\n-------------\n\nfloat 用于网页布局比较多，使用起来也比较简单，这里总结了一些比较重要、需要注意的知识点，供大家参考。\n\n### **误解和误用**\n\nfloat 被设计出来的初衷是用于**文字环绕效果**，即一个图片一段文字，图片`float:left`之后，文字会环绕图片。\n\n    <div>\n        <img src=\"image/1.png\" style=\"float:left\">\n        一段文字一段文字一段文字一段文字一段文字一段文字一段文字一段文字一段文字\n    </div>\n    \n    \n\n复制\n\n但是，后来大家发现结合`float + div`可以实现之前通过`table`实现的网页布局，因此就被“误用”于网页布局了。\n\n> 题目：为何 float 会导致父元素塌陷？\n\n### **破坏性**\n\n!\\[\\](data:image/svg+xml;utf8,)\n\nfloat 的**破坏性** —— float 破坏了父标签的原本结构，使得父标签出现了坍塌现象。导致这一现象的最根本原因在于：**被设置了 float 的元素会脱离文档流**。其根本原因在于 float 的设计初衷是解决文字环绕图片的问题。大家要记住 float 的这个影响。\n\n### **包裹性**\n\n**包裹性**也是 float 的一个非常重要的特性，大家用 float 时一定要熟知这一特性。咱们还是先从一个小例子看起：\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n如上图，普通的 div 如果没有设置宽度，它会撑满整个屏幕，在之前的盒子模型那一节也讲到过。而如果给 div 增加`float:left`之后，它突然变得紧凑了，宽度发生了变化，把内容中的三个字包裹了——这就是包裹性。为 div 设置了 float 之后，其宽度会自动调整为包裹住内容宽度，而不是撑满整个父容器。\n\n注意，此时 div 虽然体现了包裹性，但是它的 display 样式是没有变化的，还是`display: block`。\n\nfloat 为什么要具有包裹性？其实答案还是得从 float 的设计初衷来寻找，float 是被设计用于实现文字环绕效果的。文字环绕图片比较好理解，但是如果想要让文字环绕一个 div 呢？此时 div 不被“包裹”起来的话，就无法实现环绕效果了。\n\n### **清空格**\n\nfloat 还有一个大家可能不是很熟悉的特性——清空格。按照惯例，咱还是先举例子说明。\n\n    <div style=\"border: 2px solid blue; padding:3px;\">\n        <img src=\"image/1.png\"/>\n        <img src=\"image/2.png\"/>\n        <img src=\"image/3.png\"/>\n        <img src=\"image/4.png\"/>\n    </div>\n    \n    \n\n复制\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n加上`float:left`之后：\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n上面第一张图中，正常的 img 中间是会有空格的，因为多个 img 标签会有换行，而浏览器识别换行为空格，这也是很正常的。第二张图中，为 img 增加了`float:left`的样式，这就使得 img 之间没有了空格，4 个 img 紧紧挨着。\n\n如果大家之前没注意，现在想想之前写过的程序，是不是有这个特性。为什么 float 适合用于网页排版（俗称“砌砖头”）？就是因为 float 排版出来的网页严丝合缝，中间连个苍蝇都飞不进去。\n\n“清空格”这一特性的根本原因是 float 会导致节点脱离文档流结构。它都不属于文档流结构了，那么它身边的什么换行、空格就都和它没了关系，它就尽量往一边靠拢，能靠多近就靠多近，这就是清空格的本质。\n\n> 题目：手写 clearfix\n\n### **`clearfix`**\n\n清除浮动的影响，一般使用的样式如下，统称`clearfix`代码。所有 float 元素的父容器，一般情况下都应该加`clearfix`这个 class。\n\n    .clearfix:after {\n        content: '';\n        display: table;\n        clear: both;\n    }\n    .clearfix {\n        *zoom: 1; /* 兼容 IE 低版本 */\n    }\n    \n    \n\n复制\n\n    <div class=\"clearfix\">\n        <img src=\"image/1.png\" style=\"float: left\"/>\n        <img src=\"image/2.png\" style=\"float: left\"/>\n    </div>\n    \n    \n\n复制\n\n### **小结**\n\nfloat 的设计初衷是解决文字环绕图片的问题，后来误打误撞用于做布局，因此有许多不合适或者需要注意的地方，上文基本都讲到了需要的知识点。如果是刚开始接触 float 的同学，学完上面的基础知识之后，还应该做一些练习实战一下 —— 经典的“圣杯布局”和“双飞翼布局”。这里就不再展开讲了，网上资料非常多，例如[浅谈面试中常考的两种经典布局——圣杯与双飞翼](https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fentry%2F5a8868cdf265da4e7e10c133%3Futm_source%3Dgold_browser_extension)（此文的最后两张图清晰地展示了这两种布局）。\n\n* * *\n\n**定位`position`**\n----------------\n\nposition 用于网页元素的定位，可设置 static/relative/absolute/fixed 这些值，其中 static 是默认值，不用介绍。\n\n> 题目：relative 和 absolute 有何区别？\n\n### **relative**\n\n相对定位 relative 可以用一个例子很轻松地演示出来。例如我们写 4 个`<p>`，出来的样子大家不用看也能知道。\n\n    <p>第一段文字</p>\n    <p>第二段文字</p>\n    <p>第三段文字</p>\n    <p>第四段文字</p>\n    \n    \n\n复制\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n然后我们在第三个`<p>`上面，加上`position:relative`并且设置`left`和`top`值，看这个`<p>`有什么变化。\n\n    <p>第一段文字</p>\n    <p>第二段文字</p>\n    <p style=\"position:relative; top: 10px; left: 10px\">第三段文字</p>\n    <p>第四段文字</p>\n    \n    \n\n复制\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n上图中，大家应该要识别出两个信息（相信大部分人会忽略第二个信息）\n\n*   第三个`<p>`发生了位置变化，分别向右向下移动了10px；\n*   其他的三个`<p>`位置没有发生变化，这一点也很重要。\n\n可见，**relative 会导致自身位置的相对变化，而不会影响其他元素的位置、大小**。这是 relative 的要点之一。还有第二个要点，就是 relative 产生一个新的定位上下文。下文有关于定位上下文的详细介绍，这里可以先通过一个例子来展示一下区别：\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n注意看这两图的区别，下文将有解释。\n\n### **absolute**\n\n还是先写一个基本的 demo。\n\n    <p>第一段文字</p>\n    <p>第二段文字</p>\n    <p style=\"background: yellow\">第三段文字</p>\n    <p>第四段文字</p>\n    \n    \n\n复制\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n然后，我们把第三个`<p>`改为`position:absolute;`，看看会发生什么变化。\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n从上面的结果中，我们能看出几点信息：\n\n*   absolute 元素脱离了文档结构。和 relative 不同，其他三个元素的位置重新排列了。只要元素会脱离文档结构，它就会产生破坏性，导致父元素坍塌。（此时你应该能立刻想起来，float 元素也会脱离文档结构。）\n*   absolute 元素具有“包裹性”。之前`<p>`的宽度是撑满整个屏幕的，而此时`<p>`的宽度刚好是内容的宽度。\n*   absolute 元素具有“跟随性”。虽然 absolute 元素脱离了文档结构，但是它的位置并没有发生变化，还是老老实实地呆在它原本的位置，因为我们此时没有设置 top、left 的值。\n*   absolute 元素会悬浮在页面上方，会遮挡住下方的页面内容。\n\n最后，通过给 absolute元素设置 top、left 值，可自定义其内容，这个都是平时比较常用的了。这里需要注意的是，设置了 top、left 值时，元素是相对于最近的定位上下文来定位的，而不是相对于浏览器定位。\n\n### **fixed**\n\n其实 fixed 和 absolute 是一样的，唯一的区别在于：absolute 元素是根据最近的定位上下文确定位置，而 fixed 根据浏览器确定位置。\n\n> 题目：relative、absolute 和 fixed 分别依据谁来定位？\n\n### **定位上下文**\n\nrelative 元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。\n\n!\\[\\](data:image/svg+xml;utf8,)\n\nfixed 元素的定位是相对于浏览器边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。\n\n!\\[\\](data:image/svg+xml;utf8,)\n\nabsolute 的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了`position:relative/absolute/fixed`的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。如下两个图所示：\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n* * *\n\n**`flex`布局**\n------------\n\n布局的传统解决方案基于盒子模型，依赖 `display` 属性 \\+ `position` 属性 \\+ `float` 属性。它对于那些特殊布局非常不方便，比如，垂直居中（下文会专门讲解）就不容易实现。在目前主流的移动端页面中，使用 flex 布局能更好地完成需求，因此 flex 布局的知识是必须要掌握的。\n\n### **基本使用**\n\n任何一个容器都可以使用 flex 布局，代码也很简单。\n\n    <style type=\"text/css\">\n        .container {\n          display: flex;\n        }\n        .item {\n            border: 1px solid #000;\n            flex: 1;\n        }\n    </style>\n    \n    <div class=\"container\">\n        <div class=\"item\">aaa</div>\n        <div class=\"item\" style=\"flex: 2\">bbb</div>\n        <div class=\"item\">ccc</div>\n        <div class=\"item\">ddd</div>\n    </div>\n    \n    \n\n复制\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n注意，第三个`<div>`的`flex: 2`，其他的`<div>`的`flex: 1`，这样第二个`<div>`的宽度就是其他的`<div>`的两倍。\n\n### **设计原理**\n\n设置了`display: flex`的元素，我们称为“容器”（flex container），其所有的子节点我们称为“成员”（flex item）。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n将以上文字和图片结合起来，再详细看一遍，这样就能理解 flex 的设计原理，才能更好地实际使用。\n\n### **设置主轴的方向**\n\n`flex-direction`可决定主轴的方向，有四个可选值：\n\n*   row（默认值）：主轴为水平方向，起点在左端。\n*   row-reverse：主轴为水平方向，起点在右端。\n*   column：主轴为垂直方向，起点在上沿。\n*   column-reverse：主轴为垂直方向，起点在下沿。\n\n    .box {\n      flex-direction: column-reverse| column | row | row-reverse;\n    }\n    \n    \n\n复制\n\n以上代码设置的主轴方向，将依次对应下图：\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n### **设置主轴的对齐方式**\n\n`justify-content`属性定义了项目在主轴上的对齐方式，值如下：\n\n*   flex-start（默认值）：向主轴开始方向对齐。\n*   flex-end：向主轴结束方向对齐。\n*   center： 居中。\n*   space-between：两端对齐，项目之间的间隔都相等。\n*   space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n    .box {\n        justify-content: flex-start | flex-end | center | space-between | space-around;\n    }\n    \n    \n\n复制\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n### **交叉轴的对齐方式**\n\n`align-items`属性定义项目在交叉轴上如何对齐，值如下：\n\n*   flex-start：交叉轴的起点对齐。\n*   flex-end：交叉轴的终点对齐。\n*   center：交叉轴的中点对齐。\n*   baseline: 项目的第一行文字的基线对齐。\n*   stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。\n\n    .box {\n        align-items: flex-start | flex-end | center | baseline | stretch;\n    }\n    \n    \n\n复制\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n* * *\n\n**如何实现居中对齐？**\n-------------\n\n> 题目：如何实现水平居中？\n\n### **水平居中**\n\ninline 元素用`text-align: center;`即可，如下：\n\n    .container {\n       text-align: center;\n    }\n    \n    \n\n复制\n\nblock 元素可使用`margin: auto;`，PC 时代的很多网站都这么搞。\n\n    .container {\n        text-align: center; \n    }\n    .item {\n        width: 1000px;\n        margin: auto; \n    }\n    \n    \n\n复制\n\n绝对定位元素可结合`left`和`margin`实现，但是必须知道宽度。\n\n    .container {\n        position: relative;\n        width: 500px;\n    }\n    .item {\n        width: 300px;\n        height: 100px;\n        position: absolute;\n        left: 50%;\n        margin: -150px;\n    }\n    \n    \n\n复制\n\n> 题目：如何实现垂直居中？\n\n### **垂直居中**\n\ninline 元素可设置`line-height`的值等于`height`值，如单行文字垂直居中：\n\n    .container {\n       height: 50px;\n       line-height: 50px;\n    }\n    \n    \n\n复制\n\n绝对定位元素，可结合`left`和`margin`实现，但是必须知道尺寸。\n\n*   优点：兼容性好\n*   缺点：需要提前知道尺寸\n\n    .container {\n        position: relative;\n        height: 200px;\n    }\n    .item {\n        width: 80px;\n        height: 40px;\n        position: absolute;\n        left: 50%;\n        top: 50%;\n        margin-top: -20px;\n        margin-left: -40px;\n    }\n    \n    \n\n复制\n\n绝对定位可结合`transform`实现居中。\n\n*   优点：不需要提前知道尺寸\n*   缺点：兼容性不好\n\n    .container {\n        position: relative;\n        height: 200px;\n    }\n    .item {\n        width: 80px;\n        height: 40px;\n        position: absolute;\n        left: 50%;\n        top: 50%;\n        transform: translate(-50%, -50%);\n        background: blue;\n    }\n    \n    \n\n复制\n\n绝对定位结合`margin: auto`，不需要提前知道尺寸，兼容性好。\n\n    .container {\n        position: relative;\n        height: 300px;\n    }\n    .item {\n        width: 100px;\n        height: 50px;\n        position: absolute;\n        left: 0;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        margin: auto;\n    }\n    \n    \n\n复制\n\n其他的解决方案还有，不过没必要掌握太多，能说出上文的这几个解决方案即可。\n\n* * *\n\n**理解语义化**\n---------\n\n> 题目：如何理解 HTML 语义化？\n\n所谓“语义”就是为了更易读懂，这要分两部分：\n\n*   让人（写程序、读程序）更易读懂\n*   让机器（浏览器、搜索引擎）更易读懂\n\n### **让人更易读懂**\n\n对于人来说，代码可读性、语义化就是一个非常广泛的概念了，例如定义 JS 变量的时候使用更易读懂的名称，定义 CSS class 的时候也一样，例如`length``list`等，而不是使用`a``b`这种谁都看不懂的名称。\n\n不过我们平常考查的“语义化”并不会考查这么广义、这么泛的问题，而是考查 HTML 的语义化，是为了更好地让机器读懂 HTML。\n\n### **让机器更易读懂**\n\nHTML 符合 XML 标准，但又和 XML 不一样 —— HTML 不允许像 XML 那样自定义标签名称，HTML 有自己规定的标签名称。问题就在这里 —— HTML 为何要自己规定那么多标签名称呢，例如`p``div``h1``ul`等 —— 就是为了语义化。其实，如果你精通 CSS 的话，你完全可以全部用`<div>`标签来实现所有的网页效果，其他的`p``h1``ul`等标签可以一个都不用。但是我们不推荐这么做，这样做就失去了 HTML 语义化的意义。\n\n拿搜索引擎来说，爬虫下载到我们网页的 HTML 代码，它如何更好地去理解网页的内容呢？—— 就是根据 HTML 既定的标签。`h1`标签就代表是标题；`p`里面的就是段落详细内容，权重肯定没有标题高；`ul`里面就是列表；`strong`就是加粗的强调的内容 …… 如果我们不按照 HTML 语义化来写，全部都用`<div>`标签，那搜索引擎将很难理解我们网页的内容。\n\n为了加强 HTML 语义化，HTML5 标准中又增加了`header``section``artical`等标签。因此，书写 HTML 时，语义化是非常重要的，否则 W3C 也没必要辛辛苦苦制定出这些标准来。\n\n* * *\n\n**CSS3 动画**\n-----------\n\nCSS3 可以实现动画，代替原来的 Flash 和 JavaScript 方案。\n\n首先，使用`@keyframes`定义一个动画，名称为`testAnimation`，如下代码，通过百分比来设置不同的 CSS 样式，规定动画的变化。所有的动画变化都可以这么定义出来。\n\n    @keyframes testAnimation\n    {\n        0%   {background: red; left:0; top:0;}\n        25%  {background: yellow; left:200px; top:0;}\n        50%  {background: blue; left:200px; top:200px;}\n        75%  {background: green; left:0; top:200px;}\n        100% {background: red; left:0; top:0;}\n    }\n    \n    \n\n复制\n\n然后，针对一个 CSS 选择器来设置动画，例如针对`div`元素设置动画，如下：\n\n    div {\n        width: 100px;\n        height: 50px;\n        position: absolute;\n    \n        animation-name: myfirst;\n        animation-duration: 5s;\n    }\n    \n    \n\n复制\n\n`animation-name`对应到动画名称，`animation-duration`是动画时长，还有其他属性：\n\n*   `animation-timing-function`：规定动画的速度曲线。默认是`ease`\n*   `animation-delay`：规定动画何时开始。默认是 0\n*   `animation-iteration-count`：规定动画被播放的次数。默认是 1\n*   `animation-direction`：规定动画是否在下一周期逆向地播放。默认是`normal`\n*   `animation-play-state` ：规定动画是否正在运行或暂停。默认是`running`\n*   `animation-fill-mode`：规定动画执行之前和之后如何给动画的目标应用，默认是`none`，保留在最后一帧可以用`forwards`\n\n> 题目：CSS 的`transition`和`animation`有何区别？\n\n首先`transition`和`animation`都可以做动效，从语义上来理解，`transition`是过渡，由一个状态过渡到另一个状态，比如高度`100px`过渡到`200px`；而`animation`是动画，即更专业做动效的，`animation`有帧的概念，可以设置关键帧`keyframe`，一个动画可以由多个关键帧多个状态过渡组成，另外`animation`也包含上面提到的多个属性。\n\n**重绘和回流**\n---------\n\n重绘和回流是面试题经常考的题目，也是性能优化当中应该注意的点，下面笔者简单介绍下。\n\n*   **重绘**：指的是当页面中的元素不脱离文档流，而简单地进行样式的变化，比如修改颜色、背景等，浏览器重新绘制样式\n*   **回流**：指的是处于文档流中 DOM 的尺寸大小、位置或者某些属性发生变化时，导致浏览器重新渲染部分或全部文档的情况\n\n相比之下，**回流要比重绘消耗性能开支更大**。另外，一些属性的读取也会引起回流，比如读取某个 DOM 的高度和宽度，或者使用`getComputedStyle`方法。在写代码的时候要避免回流和重绘。比如在笔试中可能会遇见下面的题目：\n\n> 题目：找出下面代码的优化点，并且优化它\n\n    var data = ['string1', 'string2', 'string3'];\n    for(var i = 0; i < data.length; i++){\n        var dom = document.getElementById('list');\n        dom.innerHTML += '<li>' + data[i] + '</li>';\n    }\n    \n    \n\n复制\n\n上面的代码在循环中每次都获取`dom`，然后对其内部的 HTML 进行累加`li`，每次都会操作 DOM 结构，可以改成使用`documentFragment`或者先遍历组成 HTML 的字符串，最后操作一次`innerHTML`。\n\n* * *\n\n**小结**\n------\n\n本小节总结了 CSS 和 HTML 常考的知识点，包括 CSS 中比较重要的定位、布局的知识，也介绍了一些 CSS3 的知识点概念和题目，以及 HTML 的语义化。\n\n上一篇：[一面 2：JS-Web-API 知识点与高频考题解析](541672)下一篇：[一面 4：从容应对算法题目](541674)\n\n**一面 4：从容应对算法题目**\n=================\n\n由冯·诺依曼机组成我们知道：数据存储和运算是计算机工作的主要内容。`程序=数据结构+算法`，所以计算机类工程师必须掌握一定的数据结构和算法知识。\n\n**知识点梳理**\n---------\n\n*   常见的数据结构\n    *   栈、队列、链表\n    *   集合、字典、散列集\n*   常见算法\n    *   递归\n    *   排序\n    *   枚举\n*   算法复杂度分析\n*   算法思维\n    *   分治\n    *   贪心\n    *   动态规划\n*   高级数据结构\n    *   树、图\n    *   深度优先和广度优先搜索\n\n本小节会带领大家快速过一遍数据结构和算法，重点讲解一些常考、前端会用到的算法和数据结构。\n\n* * *\n\n**数据结构**\n--------\n\n数据结构决定了数据存储的空间和时间效率问题，数据的写入和提取速度要求也决定了应该选择怎样的数据结构。\n\n根据对场景需求的不同，我们设计不同的数据结构，比如：\n\n*   读得多的数据结构，应该想办法提高数据的读取效率，比如 IP 数据库，只需要写一次，剩下的都是读取；\n*   读写都多的数据结构，要兼顾两者的需求平衡，比如 LRU Cache 算法。\n\n算法是数据加工处理的方式，一定的算法会提升数据的处理效率。比如有序数组的二分查找，要比普通的顺序查找快很多，尤其是在处理大量数据的时候。\n\n数据结构和算法是程序开发的通用技能，所以在任何面试中都可能会遇见。随着近几年 AI、大数据、小游戏越来越火，Web 前端职位难免会跟数据结构和算法打交道，面试中也会出现越来越多的算法题目。学习数据结构和算法也能够帮助我们打开思路，突破技能瓶颈。\n\n**前端常遇见的数据结构问题**\n----------------\n\n现在我来梳理下前端常遇见的数据结构：\n\n*   简单数据结构（必须理解掌握）\n    *   有序数据结构：栈、队列、链表，有序数据结构省空间（存储空间小）\n    *   无序数据结构：集合、字典、散列表，无序数据结构省时间（读取时间快）\n*   复杂数据结构\n    *   树、堆\n    *   图\n\n对于简单数据结构，在 ES 中对应的是数组（`Array`）和对象（`Object`）。可以想一下，数组的存储是有序的，对象的存储是无序的，但是我要在对象中根据`key`找到一个值是立即返回的，数组则需要查找的过程。\n\n这里我通过一个真实面试题目来说明介绍下数据结构设计。\n\n> 题目：使用 ECMAScript（JS）代码实现一个事件类`Event`，包含下面功能：绑定事件、解绑事件和派发事件。\n\n在稍微复杂点的页面中，比如组件化开发的页面，同一个页面由两三个人来开发，为了保证组件的独立性和降低组件间耦合度，我们往往使用「订阅发布模式」，即组件间通信使用事件监听和派发的方式，而不是直接相互调用组件方法，这就是题目要求写的`Event`类。\n\n这个题目的核心是一个事件类型对应回调函数的数据设计。为了实现绑定事件，我们需要一个`_cache`对象来记录绑定了哪些事件。而事件发生的时候，我们需要从`_cache`中读取出来事件回调，依次执行它们。一般页面中事件派发（读）要比事件绑定（写）多。所以我们设计的数据结构应该尽量地能够在事件发生时，更加快速地找到对应事件的回调函数们，然后执行。\n\n经过这样一番考虑，我简单写了下代码实现：\n\n    class Event {\n        constructor() {\n            // 存储事件的数据结构\n            // 为了查找迅速，使用了对象（字典）\n            this._cache = {};\n        }\n        // 绑定\n        on(type, callback) {\n            // 为了按类查找方便和节省空间，\n            // 将同一类型事件放到一个数组中\n            // 这里的数组是队列，遵循先进先出\n            // 即先绑定的事件先触发\n            let fns = (this._cache[type] = this._cache[type] || []);\n            if (fns.indexOf(callback) === -1) {\n                fns.push(callback);\n            }\n            return this;\n        }\n        // 触发\n        trigger(type, data) {\n            let fns = this._cache[type];\n            if (Array.isArray(fns)) {\n                fns.forEach((fn) => {\n                    fn(data);\n                });\n            }\n            return this;\n        }\n        // 解绑\n        off(type, callback) {\n            let fns = this._cache[type];\n            if (Array.isArray(fns)) {\n                if (callback) {\n                    let index = fns.indexOf(callback);\n                    if (index !== -1) {\n                        fns.splice(index, 1);\n                    }\n                } else {\n                    //全部清空\n                    fns.length = 0;\n                }\n            }\n            return this;\n        }\n    }\n    // 测试用例\n    const event = new Event();\n    event.on('test', (a) => {\n        console.log(a);\n    });\n    event.trigger('test', 'hello world');\n    \n    event.off('test');\n    event.trigger('test', 'hello world');\n    \n    \n\n复制\n\n类似于树、堆、图这些高级数据结构，前端一般也不会考查太多，但是它们的查找方法却常考，后面介绍。高级数据应该平时多积累，好好理解，比如理解了堆是什么样的数据结构，在面试中遇见的「查找最大的 K 个数」这类算法问题，就会迎刃而解。\n\n**算法的效率是通过算法复杂度来衡量的**\n---------------------\n\n算法的好坏可以通过算法复杂度来衡量，算法复杂度包括时间复杂度和空间复杂度两个。时间复杂度由于好估算、好评估等特点，是面试中考查的重点。空间复杂度在面试中考查得不多。\n\n常见的时间复杂度有：\n\n*   常数阶 `O(1)`\n*   对数阶 `O(logN)`\n*   线性阶 `O(n)`\n*   线性对数阶 `O(nlogN)`\n*   平方阶 `O(n^2)`\n*   立方阶 `O(n^3)`\n*   !k次方阶 `O(n^k)`\n*   指数阶`O(2^n)`\n\n随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低。\n\n一般做算法复杂度分析的时候，遵循下面的技巧：\n\n1.  看看有几重循环，一般来说一重就是`O(n)`，两重就是 `O(n^2)`，以此类推\n2.  如果有二分，则为`O(logN)`\n3.  保留最高项，去除常数项\n\n> 题目：分析下面代码的算法复杂度（为了方便，我已经在注释中加了代码分析）\n\n    let i =0; // 语句执行一次 \n    while (i < n) { // 语句执行 n 次 \n      console.log(`Current i is ${i}`); //语句执行 n 次\n      i++; // 语句执行 n 次\n    }\n    \n    \n\n复制\n\n根据注释可以得到，算法复杂度为`1 + n + n + n = 1 + 3n`，去除常数项，为`O(n)`。\n\n    let number = 1; // 语句执行一次 \n    while (number < n) { // 语句执行 logN 次\n      number *= 2; // 语句执行 logN 次\n    }\n    \n    \n\n复制\n\n上面代码`while`的跳出判断条件是`number<n`，而循环体内`number`增长速度是`(2^n)`，所以循环代码实际执行`logN`次，复杂度为：`1 + 2 * logN = O(logN)`\n\n    for (let i = 0; i < n; i++) {// 语句执行 n 次\n      for (let j = 0; j < n; j++) {// 语句执行 n^2 次\n        console.log('I am here!'); // 语句执行 n^2 次\n      }\n    }\n    \n    \n\n复制\n\n上面代码是两个`for`循环嵌套，很容易得出复杂度为：`O(n^2)`\n\n**人人都要掌握的基础算法**\n---------------\n\n枚举和递归是最最简单的算法，也是复杂算法的基础，人人都应该掌握！枚举相对比较简单，我们重点说下递归。\n\n递归由下面两部分组成：\n\n1.  递归主体，就是要循环解决问题的代码\n2.  递归的跳出条件，递归不能一直递归下去，需要完成一定条件后跳出\n\n关于递归有个经典的面试题目是：\n\n> 实现 JS 对象的深拷贝\n\n**什么是深拷贝？**\n\n「深拷贝」就是在拷贝数据的时候，将数据的所有**引用结构**都拷贝一份。简单的说就是，在内存中存在两个数据结构完全相同又相互独立的数据，将引用型类型进行复制，而不是只复制其引用关系。\n\n分析下怎么做「深拷贝」：\n\n1.  首先假设深拷贝这个方法已经完成，为 deepClone\n2.  要拷贝一个数据，我们肯定要去遍历它的属性，如果这个对象的属性仍是对象，继续使用这个方法，如此往复\n\n    function deepClone(o1, o2) {\n        for (let k in o2) {\n            if (typeof o2[k] === 'object') {\n                o1[k] = {};\n                deepClone(o1[k], o2[k]);\n            } else {\n                o1[k] = o2[k];\n            }\n        }\n    }\n    // 测试用例\n    let obj = {\n        a: 1,\n        b: [1, 2, 3],\n        c: {}\n    };\n    let emptyObj = Object.create(null);\n    deepClone(emptyObj, obj);\n    console.log(emptyObj.a == obj.a);\n    console.log(emptyObj.b == obj.b);\n    \n    \n\n复制\n\n递归容易造成爆栈，尾部调用可以解决递归的这个问题，Chrome 的 V8 引擎做了尾部调用优化，我们在写代码的时候也要注意尾部调用写法。递归的爆栈问题可以通过将递归改写成枚举的方式来解决，就是通过`for`或者`while`来代替递归。\n\n我们在使用递归的时候，要注意做优化，比如下面的题目。\n\n> 题目：求斐波那契数列（兔子数列） 1,1,2,3,5,8,13,21,34,55,89...中的第 n 项\n\n下面的代码中`count`记录递归的次数，我们看下两种差异性的代码中的`count`的值：\n\n    let count = 0;\n    function fn(n) {\n        let cache = {};\n        function _fn(n) {\n            if (cache[n]) {\n                return cache[n];\n            }\n            count++;\n            if (n == 1 || n == 2) {\n                return 1;\n            }\n            let prev = _fn(n - 1);\n            cache[n - 1] = prev;\n            let next = _fn(n - 2);\n            cache[n - 2] = next;\n            return prev + next;\n        }\n        return _fn(n);\n    }\n    \n    let count2 = 0;\n    function fn2(n) {\n        count2++;\n        if (n == 1 || n == 2) {\n            return 1;\n        }\n        return fn2(n - 1) + fn2(n - 2);\n    }\n    \n    console.log(fn(20), count); // 6765 20\n    console.log(fn2(20), count2); // 6765 13529\n    \n    \n\n复制\n\n**快排和二分查找**\n-----------\n\n前端中面试排序和查找的可能性比较小，因为 JS 引擎已经把这些常用操作优化得很好了，可能项目中你费劲写的一个排序方法，都不如`Array.sort`速度快且代码少。因此，掌握快排和二分查找就可以了。\n\n快排和二分查找都基于一种叫做「分治」的算法思想，通过对数据进行分类处理，不断降低数量级，实现`O(logN)`（对数级别，比`O(n)`这种线性复杂度更低的一种）的复杂度。\n\n### **快速排序**\n\n快排大概的流程是：\n\n1.  随机选择数组中的一个数 A，以这个数为基准\n2.  其他数字跟这个数进行比较，比这个数小的放在其左边，大的放到其右边\n3.  经过一次循环之后，A 左边为小于 A 的，右边为大于 A 的\n4.  这时候将左边和右边的数再递归上面的过程\n\n具体代码如下：\n\n    const Arr = [85, 24, 63, 45, 17, 31, 96, 50];\n    function quickSort(arr) {\n        if (arr.length <= 1) {\n            return arr;\n        }\n        let pivotIndex = Math.floor(arr.length / 2);\n        let pivot = arr.splice(pivotIndex, 1)[0];\n        let left = [];\n        let right = [];\n        for (let i = 0; i < arr.length; i++) {\n            if (arr[i] < pivot) {\n                left.push(arr[i]);\n            } else {\n                right.push(arr[i]);\n            }\n        }\n        // 递归\n        return quickSort(left).concat([pivot], quickSort(right));\n    }\n    \n    console.log(quickSort(Arr));\n    \n    \n\n复制\n\n### **二分查找**\n\n二分查找法主要是解决「在一堆有序的数中找出指定的数」这类问题，不管这些数是一维数组还是多维数组，只要有序，就可以用二分查找来优化。\n\n二分查找是一种「分治」思想的算法，大概流程如下：\n\n1.  数组中排在中间的数字 A，与要找的数字比较大小\n2.  因为数组是有序的，所以： a) A 较大则说明要查找的数字应该从前半部分查找 b) A 较小则说明应该从查找数字的后半部分查找\n3.  这样不断查找缩小数量级（扔掉一半数据），直到找完数组为止\n\n> 题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n    function Find(target, array) {\n        let i = 0;\n        let j = array[i].length - 1;\n        while (i < array.length && j >= 0) {\n            if (array[i][j] < target) {\n                i++;\n            } else if (array[i][j] > target) {\n                j--;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    //测试用例\n    console.log(Find(10, [\n        [1, 2, 3, 4], \n        [5, 9, 10, 11], \n        [13, 20, 21, 23]\n        ])\n    );\n    \n    \n\n复制\n\n另外笔者在面试中遇见过下面的问题：\n\n> 题目：现在我有一个 1~1000 区间中的正整数，需要你猜下这个数字是几，你只能问一个问题：大了还是小了？问需要猜几次才能猜对？\n\n拿到这个题目，笔者想到的就是电视上面有个「猜价格」的购物节目，在规定时间内猜对价格就可以把实物抱回家。所以问题就是让面试官不停地回答我猜的数字比这个数字大了还是小了。这就是二分查找！\n\n猜几次呢？其实这个问题就是个二分查找的算法时间复杂度问题，二分查找的时间复杂度是`O(logN)`，所以求`log1000`的解就是猜的次数。我们知道`2^10=1024`，所以可以快速估算出：`log1000`约等于 10，最多问 10 次就能得到这个数！\n\n**面试遇见不会的算法问题怎么办**\n------------------\n\n面试的时候，在遇见算法题目的时候，应该揣摩面试官的意图，听好关键词，比如：有序的数列做查找、要求算法复杂度是`O(logN)`这类一般就是用二分的思想。\n\n一般来说算法题目的解题思路分以下四步：\n\n1.  先降低数量级，拿可以计算出来的情况（数据）来构思解题步骤\n2.  根据解题步骤编写程序，优先将特殊情况做好判断处理，比如一个大数组的问题，如果数组为两个数长度的情况\n3.  检验程序正确性\n4.  是否可以优化（由浅到深），有能力的话可以故意预留优化点，这样可以体现个人技术能力\n\n**正则匹配解题**\n----------\n\n很多算法题目利用 ES 语法的特性来回答更加简单，比如正则匹配就是常用的一种方式。笔者简单通过几个真题来汇总下正则的知识点。\n\n> 题目：字符串中第一个出现一次的字符\n\n请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符「go」时，第一个只出现一次的字符是「g」。当从该字符流中读出前六个字符「google」时，第一个只出现一次的字符是「l」。\n\n这个如果用纯算法来解答需要遍历字符串，统计每个字符出现的次数，然后按照字符串的顺序来找出第一次出现一次的字符，整个过程比较繁琐，如果用正则就简单多了。\n\n    function find(str){\n        for (var i = 0; i < str.length; i++) {\n            let char = str[i]\n            let reg = new RegExp(char, 'g');\n            let l = str.match(reg).length\n            if(l===1){\n                return char\n            }\n        }\n    }\n    \n    \n\n复制\n\n当然，使用`indexOf/lastIndexOf`也是一个取巧的方式。再来看一个千分位问题。\n\n> 题目：将`1234567` 变成 `1,234,567`，即千分位标注\n\n这个题目可以用算法直接来解，如果候选人使用正则来回答，这样主动展现了自己其他方面的优势，即使不是算法解答出来的，面试官一般也不会太难为他。这道题目可以利用正则的「零宽断言」`(?=exp)`，意思是它断言自身出现的位置的后面能匹配表达式 exp。数字千分位的特点是，第一个逗号后面数字的个数是3的倍数，正则：`/(\\d{3})+$/`；第一个逗号前最多可以有 1~3 个数字，正则：`/\\d{1,3}/`。加起来就是`/\\d{1,3}(\\d{3})+$/`，分隔符要从前往后加。\n\n对于零宽断言的详细介绍可以阅读「[零宽断言](https://link.juejin.im?target=https%3A%2F%2Fdeerchao.net%2Ftutorials%2Fregex%2Fregex.htm%23lookaround)」这篇文章。\n\n    function exchange(num) {\n        num += ''; //转成字符串\n        if (num.length <= 3) {\n            return num;\n        }\n    \n        num = num.replace(/\\d{1,3}(?=(\\d{3})+$)/g, (v) => {\n            console.log(v)\n            return v + ',';\n        });\n        return num;\n    }\n    \n    console.log(exchange(1234567));\n    \n    \n\n复制\n\n当然上面讲到的多数是算法题目取巧的方式，下面这个题目是纯正则考查，笔者在面试的过程中碰见过，这里顺便提一下。\n\n> 题目，请写出下面的代码执行结果\n\n    var str = 'google';\n    var reg = /o/g;\n    console.log(reg.test(str))\n    console.log(reg.test(str))\n    console.log(reg.test(str))\n    \n    \n\n复制\n\n代码执行后，会发现，最后一个不是为`true`，而是`false`，这是因为`reg`这个正则有个`g`，即`global`全局的属性，这种情况下`lastIndex`就发挥作用了，可以看下面的代码执行结果就明白了。\n\n    console.log(reg.test(str), reg.lastIndex)\n    console.log(reg.test(str), reg.lastIndex)\n    console.log(reg.test(str), reg.lastIndex)\n    \n    \n\n复制\n\n实际开发中也会犯这样的错误，比如为了减少变量每次都重新定义，会把用到的变量提前定义好，这样在使用的时候容易掉进坑里，比如下面代码：\n\n    (function(){\n        const reg = /o/g;\n        function isHasO(str){\n            // reg.lastIndex = 0; 这样就可以避免这种情况\n            return reg.test(str)\n        }\n        var str = 'google';\n        console.log(isHasO(str))\n        console.log(isHasO(str))\n        console.log(isHasO(str))\n    }())\n    \n    \n\n复制\n\n**小结**\n------\n\n本小节介绍了数据结构和算法的关系，作为普通的前端也应该学习数据结构和算法知识，并且顺带介绍了下正则匹配。具体来说，本小节梳理了以下几部分数据结构和算法知识点：\n\n1.  经常用到的数据结构有哪些，它们的特点有哪些\n2.  递归和枚举是最基础的算法，必须牢牢掌握\n3.  排序里面理解并掌握快速排序算法，其他排序算法可以根据个人实际情况大概了解\n4.  有序查找用二分查找\n5.  遇见不会的算法问题，先缩小数量级，然后分析推导\n\n当然算法部分还有很多知识，比如动态规划这些算法思想，还有图和树常用到的广度优先搜索和深度优先搜索。这些知识在前端面试和项目中遇见得不多，感兴趣的读者可以在梳理知识点的时候根据个人情况自行决定是否复习。\n\n上一篇：[一面 3：CSS-HTML 知识点与高频考题解析](541673)下一篇：[一面 5：浏览器相关知识点与高频考题解析](541675)\n\n**一面 5：浏览器相关知识点与高频考题解析**\n========================\n\nWeb 前端工程师写的页面要跑在浏览器里面，所以面试中也会出现很多跟浏览器相关的面试题目。\n\n**知识点梳理**\\*\\*\\*\\*\n-----------------\n\n*   浏览器加载页面和渲染过程\n*   性能优化\n*   Web 安全\n\n本小节会从浏览器的加载过程开始讲解，然后介绍如何进行性能优化，最后介绍下 Web 开发中常见的安全问题和预防。\n\n* * *\n\n**加载页面和渲染过程**\n-------------\n\n可将加载过程和渲染过程分开说。回答问题的时候，关键要抓住核心的要点，把要点说全面，稍加解析即可，简明扼要不拖沓。\n\n> 题目：浏览器从加载页面到渲染页面的过程\n\n### **加载过程**\n\n要点如下：\n\n*   浏览器根据 DNS 服务器得到域名的 IP 地址\n*   向这个 IP 的机器发送 HTTP 请求\n*   服务器收到、处理并返回 HTTP 请求\n*   浏览器得到返回内容\n\n例如在浏览器输入`https://juejin.im/timeline`，然后经过 DNS 解析，`juejin.im`对应的 IP 是`36.248.217.149`（不同时间、地点对应的 IP 可能会不同）。然后浏览器向该 IP 发送 HTTP 请求。\n\nserver 端接收到 HTTP 请求，然后经过计算（向不同的用户推送不同的内容），返回 HTTP 请求，返回的内容如下：\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n其实就是一堆 HMTL 格式的字符串，因为只有 HTML 格式浏览器才能正确解析，这是 W3C 标准的要求。接下来就是浏览器的渲染过程。\n\n### **渲染过程**\n\n要点如下：\n\n*   根据 HTML 结构生成 DOM 树\n*   根据 CSS 生成 CSSOM\n*   将 DOM 和 CSSOM 整合形成 RenderTree\n*   根据 RenderTree 开始渲染和展示\n*   遇到`<script>`时，会执行并阻塞渲染\n\n上文中，浏览器已经拿到了 server 端返回的 HTML 内容，开始解析并渲染。最初拿到的内容就是一堆字符串，必须先结构化成计算机擅长处理的基本数据结构，因此要把 HTML 字符串转化成 DOM 树 —— 树是最基本的数据结构之一。\n\n解析过程中，如果遇到`<link href=\"...\">`和`<script src=\"...\">`这种外链加载 CSS 和 JS 的标签，浏览器会异步下载，下载过程和上文中下载 HTML 的流程一样。只不过，这里下载下来的字符串是 CSS 或者 JS 格式的。\n\n浏览器将 CSS 生成 CSSOM，再将 DOM 和 CSSOM 整合成 RenderTree ，然后针对 RenderTree 即可进行渲染了。大家可以想一下，有 DOM 结构、有样式，此时就能满足渲染的条件了。另外，这里也可以解释一个问题 —— **为何要将 CSS 放在 HTML 头部？**—— 这样会让浏览器尽早拿到 CSS 尽早生成 CSSOM，然后在解析 HTML 之后可一次性生成最终的 RenderTree，渲染一次即可。如果 CSS 放在 HTML 底部，会出现渲染卡顿的情况，影响性能和体验。\n\n最后，渲染过程中，如果遇到`<script>`就停止渲染，执行 JS 代码。因为浏览器渲染和 JS 执行共用一个线程，而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。待`<script>`内容执行完之后，浏览器继续渲染。最后再思考一个问题 —— **为何要将 JS 放在 HTML 底部？**—— JS 放在底部可以保证让浏览器优先渲染完现有的 HTML 内容，让用户先看到内容，体验好。另外，JS 执行如果涉及 DOM 操作，得等待 DOM 解析完成才行，JS 放在底部执行时，HTML 肯定都解析成了 DOM 结构。JS 如果放在 HTML 顶部，JS 执行的时候 HTML 还没来得及转换为 DOM 结构，可能会报错。\n\n关于浏览器整个流程，百度的多益大神有更加详细的文章，推荐阅读下：《[从输入 URL 到页面加载完成的过程中都发生了什么事情？](https://link.juejin.im?target=http%3A%2F%2Ffex.baidu.com%2Fblog%2F2014%2F05%2Fwhat-happen%2F) 》。\n\n* * *\n\n**性能优化**\n--------\n\n性能优化的题目也是面试常考的，这类题目有很大的扩展性，能够扩展出来很多小细节，而且对个人的技术视野和业务能力有很大的挑战。这部分笔者会重点讲下常用的性能优化方案。\n\n> 题目：总结前端性能优化的解决方案\n\n### **优化原则和方向**\n\n性能优化的原则是**以更好的用户体验为标准**，具体就是实现下面的目标：\n\n1.  多使用内存、缓存或者其他方法\n2.  减少 CPU 和GPU 计算，更快展现\n\n优化的方向有两个：\n\n*   **减少页面体积，提升网络加载**\n*   **优化页面渲染**\n\n### **减少页面体积，提升网络加载**\n\n*   静态资源的压缩合并（JS 代码压缩合并、CSS 代码压缩合并、雪碧图）\n*   静态资源缓存（资源名称加 MD5 戳）\n*   使用 CDN 让资源加载更快\n\n### **优化页面渲染**\n\n*   CSS 放前面，JS 放后面\n*   懒加载（图片懒加载、下拉加载更多）\n*   减少DOM 查询，对 DOM 查询做缓存\n*   减少DOM 操作，多个操作尽量合并在一起执行（`DocumentFragment`）\n*   事件节流\n*   尽早执行操作（`DOMContentLoaded`）\n*   使用 SSR 后端渲染，数据直接输出到 HTML 中，减少浏览器使用 JS 模板渲染页面 HTML 的时间\n\n### **详细解释**\n\n#### **静态资源的压缩合并**\n\n如果不合并，每个都会走一遍之前介绍的请求过程\n\n    <script src=\"a.js\"></script>\n    <script src=\"b.js\"></script>\n    <script src=\"c.js\"></script>\n    \n    \n\n复制\n\n如果合并了，就只走一遍请求过程\n\n    <script src=\"abc.js\"></script>\n    \n    \n\n复制\n\n#### **静态资源缓存**\n\n通过链接名称控制缓存\n\n    <script src=\"abc_1.js\"></script>\n    \n    \n\n复制\n\n只有内容改变的时候，链接名称才会改变\n\n    <script src=\"abc_2.js\"></script>\n    \n    \n\n复制\n\n这个名称不用手动改，可通过前端构建工具根据文件内容，为文件名称添加 MD5 后缀。\n\n#### **使用 CDN 让资源加载更快**\n\nCDN 会提供专业的加载优化方案，静态资源要尽量放在 CDN 上。例如：\n\n    <script src=\"https://cdn.bootcss.com/zepto/1.0rc1/zepto.min.js\"></script>\n    \n    \n\n复制\n\n#### **使用 SSR 后端渲染**\n\n可一次性输出 HTML 内容，不用在页面渲染完成之后，再通过 Ajax 加载数据、再渲染。例如使用 smarty、Vue SSR 等。\n\n#### **CSS 放前面，JS 放后面**\n\n上文讲述浏览器渲染过程时已经提过，不再赘述。\n\n#### **懒加载**\n\n一开始先给为 `src` 赋值成一个通用的预览图，下拉时候再动态赋值成正式的图片。如下，`preview.png`是预览图片，比较小，加载很快，而且很多图片都共用这个`preview.png`，加载一次即可。待页面下拉，图片显示出来时，再去替换`src`为`data-realsrc`的值。\n\n    <img src=\"preview.png\" data-realsrc=\"abc.png\"/>\n    \n    \n\n复制\n\n另外，这里为何要用`data-`开头的属性值？—— 所有 HTML 中自定义的属性，都应该用`data-`开头，因为`data-`开头的属性浏览器渲染的时候会忽略掉，提高渲染性能。\n\n#### **DOM 查询做缓存**\n\n两段代码做一下对比：\n\n    var pList = document.getElementsByTagName('p')  // 只查询一个 DOM ，缓存在 pList 中了\n    var i\n    for (i = 0; i < pList.length; i++) {\n    }\n    \n    \n\n复制\n\n    var i\n    for (i = 0; i < document.getElementsByTagName('p').length; i++) {  // 每次循环，都会查询 DOM ，耗费性能\n    }\n    \n    \n\n复制\n\n总结：DOM 操作，无论查询还是修改，都是非常耗费性能的，应尽量减少。\n\n#### **合并 DOM 插入**\n\nDOM 操作是非常耗费性能的，因此插入多个标签时，先插入 Fragment 然后再统一插入 DOM。\n\n    var listNode = document.getElementById('list')\n    // 要插入 10 个 li 标签\n    var frag = document.createDocumentFragment();\n    var x, li;\n    for(x = 0; x < 10; x++) {\n        li = document.createElement(\"li\");\n        li.innerHTML = \"List item \" + x;\n        frag.appendChild(li);  // 先放在 frag 中，最后一次性插入到 DOM 结构中。\n    }\n    listNode.appendChild(frag);\n    \n    \n\n复制\n\n#### **事件节流**\n\n例如要在文字改变时触发一个 change 事件，通过 keyup 来监听。使用节流。\n\n    var textarea = document.getElementById('text')\n    var timeoutId\n    textarea.addEventListener('keyup', function () {\n        if (timeoutId) {\n            clearTimeout(timeoutId)\n        }\n        timeoutId = setTimeout(function () {\n            // 触发 change 事件\n        }, 100)\n    })\n    \n    \n\n复制\n\n#### **尽早执行操作**\n\n    window.addEventListener('load', function () {\n        // 页面的全部资源加载完才会执行，包括图片、视频等\n    })\n    document.addEventListener('DOMContentLoaded', function () {\n        // DOM 渲染完即可执行，此时图片、视频还可能没有加载完\n    })\n    \n    \n\n复制\n\n#### **性能优化怎么做**\n\n上面提到的都是性能优化的单个点，性能优化项目具体实施起来，应该按照下面步骤推进：\n\n1.  建立性能数据收集平台，摸底当前性能数据，通过性能打点，将上述整个页面打开过程消耗时间记录下来\n2.  分析耗时较长时间段原因，寻找优化点，确定优化目标\n3.  开始优化\n4.  通过数据手机平台记录优化效果\n5.  不断调整优化点和预期目标，循环2~4步骤\n\n性能优化是个长期的事情，不是一蹴而就的，应该本着先摸底、再分析、后优化的原则逐步来做。\n\n* * *\n\n**Web 安全**\n----------\n\n> 题目：前端常见的安全问题有哪些？\n\nWeb 前端的安全问题，能回答出下文的两个问题，这个题目就能基本过关了。开始之前，先说一个最简单的攻击方式 —— SQL 注入。\n\n上学的时候就知道有一个「SQL注入」的攻击方式。例如做一个系统的登录界面，输入用户名和密码，提交之后，后端直接拿到数据就拼接 SQL 语句去查询数据库。如果在输入时进行了恶意的 SQL 拼装，那么最后生成的 SQL 就会有问题。但是现在稍微大型一点的系统，都不会这么做，从提交登录信息到最后拿到授权，要经过层层的验证。因此，SQL 注入都只出现在比较低端小型的系统上。\n\n### **XSS（Cross Site Scripting，跨站脚本攻击）**\n\n这是前端最常见的攻击方式，很多大型网站（如 Facebook）都被 XSS 攻击过。\n\n举一个例子，我在一个博客网站正常发表一篇文章，输入汉字、英文和图片，完全没有问题。但是如果我写的是恶意的 JS 脚本，例如获取到`document.cookie`然后传输到自己的服务器上，那我这篇博客的每一次浏览都会执行这个脚本，都会把访客 cookie 中的信息偷偷传递到我的服务器上来。\n\n其实原理上就是黑客通过某种方式（发布文章、发布评论等）将一段特定的 JS 代码隐蔽地输入进去。然后别人再看这篇文章或者评论时，之前注入的这段 JS 代码就执行了。**JS 代码一旦执行，那可就不受控制了，因为它跟网页原有的 JS 有同样的权限**，例如可以获取 server 端数据、可以获取 cookie 等。于是，攻击就这样发生了。\n\n#### **XSS的危害**\n\nXSS 的危害相当大，如果页面可以随意执行别人不安全的 JS 代码，轻则会让页面错乱、功能缺失，重则会造成用户的信息泄露。\n\n比如早些年社交网站经常爆出 XSS 蠕虫，通过发布的文章内插入 JS，用户访问了感染不安全 JS 注入的文章，会自动重新发布新的文章，这样的文章会通过推荐系统进入到每个用户的文章列表面前，很快就会造成大规模的感染。\n\n还有利用获取 cookie 的方式，将 cookie 传入入侵者的服务器上，入侵者就可以模拟 cookie 登录网站，对用户的信息进行篡改。\n\n#### **XSS的预防**\n\n那么如何预防 XSS 攻击呢？—— 最根本的方式，就是对用户输入的内容进行验证和替换，需要替换的字符有：\n\n    & 替换为：&amp;\n    < 替换为：&lt;\n    > 替换为：&gt;\n    ” 替换为：&quot;\n    ‘ 替换为：&#x27;\n    / 替换为：&#x2f;\n    \n    \n\n复制\n\n替换了这些字符之后，黑客输入的攻击代码就会失效，XSS 攻击将不会轻易发生。\n\n除此之外，还可以通过对 cookie 进行较强的控制，比如对敏感的 cookie 增加`http-only`限制，让 JS 获取不到 cookie 的内容。\n\n### **CSRF（Cross-site request forgery，跨站请求伪造）**\n\nCSRF 是借用了当前操作者的权限来偷偷地完成某个操作，而不是拿到用户的信息。\n\n例如，一个支付类网站，给他人转账的接口是`http://buy.com/pay?touid=999&money=100`，而这个接口在使用时没有任何密码或者 token 的验证，只要打开访问就直接给他人转账。一个用户已经登录了`http://buy.com`，在选择商品时，突然收到一封邮件，而这封邮件正文有这么一行代码`<img src=\"http://buy.com/pay?touid=999&money=100\"/>`，他访问了邮件之后，其实就已经完成了购买。\n\nCSRF 的发生其实是借助了一个 cookie 的特性。我们知道，登录了`http://buy.com`之后，cookie 就会有登录过的标记了，此时请求`http://buy.com/pay?touid=999&money=100`是会带着 cookie 的，因此 server 端就知道已经登录了。而如果在`http://buy.com`去请求其他域名的 API 例如`http://abc.com/api`时，是不会带 cookie 的，这是浏览器的同源策略的限制。但是 —— **此时在其他域名的页面中，请求`http://buy.com/pay?touid=999&money=100`，会带着`buy.com`的 cookie ，这是发生 CSRF 攻击的理论基础。**\n\n预防 CSRF 就是加入各个层级的权限验证，例如现在的购物网站，只要涉及现金交易，肯定要输入密码或者指纹才行。除此之外，敏感的接口使用`POST`请求而不是`GET`也是很重要的。\n\n* * *\n\n**小结**\n------\n\n本小节总结了前端运行环境（即浏览器）的一些常考查知识点，包括页面加载过程、如何性能优化以及需要注意的安全问题。\n\n上一篇：[一面 4：从容应对算法题目](541674)下一篇：[一面 6：开发环境相关知识点与高频考题解析](541676)\n\n**一面 6：开发环境相关知识点与高频考题解析**\n=========================\n\n工程师的开发环境决定其开发效率，常用的开发环境配置也是面试考查点之一。\n\n**知识点梳理**\n---------\n\n*   IDE\n*   Git\n*   Linux 基础命令\n*   前端构建工具\n*   调试方法\n\n本小节会重点介绍 Git 的基本用法、代码部署和开发中常用的 Linux 命令，然后以 webpack 为例介绍下前端构建工具，最后介绍怎么抓包解决线上问题。这些都是日常开发和面试中常用到的知识。\n\n* * *\n\n**IDE**\n-------\n\n> 题目：你平时都使用什么 IDE 编程？有何提高效率的方法？\n\n前端最常用的 IDE 有 [Webstorm](https://link.juejin.im?target=https%3A%2F%2Fwww.jetbrains.com%2Fwebstorm%2F)、[Sublime](https://link.juejin.im?target=https%3A%2F%2Fwww.sublimetext.com%2F)、[Atom](https://link.juejin.im?target=https%3A%2F%2Fatom.io%2F) 和 [VSCode](https://link.juejin.im?target=https%3A%2F%2Fcode.visualstudio.com%2F)，我们可以分别去它们的官网看一下。\n\nWebstorm 是最强大的编辑器，因为它拥有各种强大的插件和功能，但是我没有用过，因为它收费。不是我舍不得花钱，而是因为我觉得免费的 Sublime 已经够我用了。跟面试官聊到 Webstorm 的时候，没用过没事儿，但一定要知道它：第一，强大；第二，收费。\n\nSublime 是我日常用的编辑器，第一它免费，第二它轻量、高效，第三它插件非常多。用 Sublime 一定要安装各种插件配合使用，可以去网上搜一下“sublime”常用插件的安装以及用法，还有它的各种快捷键，并且亲自使用它。这里就不一一演示了，网上的教程也很傻瓜式。\n\nAtom 是 GitHub 出品的编辑器，跟 Sublime 差不多，免费并且插件丰富，而且跟 Sublime 相比风格上还有些小清新。但是我用过几次就不用了，因此它打开的时候会比较慢，卡一下才打开。当然总体来说也是很好用的，只是个人习惯问题。\n\nVSCode 是微软出品的轻量级（相对于 Visual Studio 来说）编辑器，微软做 IDE 那是出了名的好，出了名的大而全，因此 VSCode 也有上述 Sublime 和 Atom 的各种优点，但是我也是因为个人习惯问题（本人不愿意尝试没有新意的新东西），用过几次就不用了。\n\n总结一下：\n\n*   如果你要走大牛、大咖、逼格的路线，就用 Webstorm\n*   如果你走普通、屌丝、低调路线，就用 Sublime\n*   如果你走小清新、个性路线，就用 VSCode 或者 Atom\n*   如果你面试，最好有一个用的熟悉，其他都会一点\n\n最后注意：千万不要说你使用 Dreamweaver 或者 notepad++ 写前端代码，会被人鄙视的。如果你不做 .NET 也不要用 Visual Studio ，不做 Java 也不要用 Eclipse。\n\n* * *\n\n**Git**\n-------\n\n你此前做过的项目一定要用过 Git，而且必须是命令行，如果没用过，你自己也得恶补一下。对 Git 的基本应用比较熟悉的同学，可以跳过这一部分了。macOS 自带 Git，Windows 需要安装 Git 客户端，去 [Git 官网](https://link.juejin.im?target=https%3A%2F%2Fgit-scm.com%2Fdownload%2Fwin) 下载即可。\n\n国内比较好的 Git 服务商有 [coding.net](http://coding.net)，国外有大名鼎鼎的 GitHub，但是有时会有网络问题，因此建议大家注册一个 [coding.net](http://coding.net) 账号然后创建项目，来练练手。\n\n> 题目：常用的 Git 命令有哪些？如何使用 Git 多人协作开发？\n\n### **常用的 Git 命令**\n\n首先，通过`git clone <项目远程地址>`下载下来最新的代码，例如`git clone git@git.coding.net:username/project-name.git`，默认会下载`master`分支。\n\n然后修改代码，修改过程中可以通过`git status`看到自己的修改情况，通过`git diff <文件名>`可查阅单个文件的差异。\n\n最后，将修改的内容提交到远程服务器，做如下操作\n\n    git add .\n    git commit -m \"xxx\"\n    git push origin master\n    \n    \n\n复制\n\n如果别人也提交了代码，你想同步别人提交的内容，执行`git pull origin master`即可。\n\n### **如何多人协作开发**\n\n多人协作开发，就不能使用`master`分支了，而是要每个开发者单独拉一个分支，使用`git checkout -b <branchname>`，运行`git branch`可以看到本地所有的分支名称。\n\n自己的分支，如果想同步`master`分支的内容，可运行`git merge master`。切换分支可使用`git checkout <branchname>`。\n\n在自己的分支上修改了内容，可以将自己的分支提交到远程服务器\n\n    git add .\n    git commit -m \"xxx\"\n    git push origin <branchname>\n    \n    \n\n复制\n\n最后，待代码测试没问题，再将自己分支的内容合并到`master`分支，然后提交到远程服务器。\n\n    git checkout master\n    git merge <branchname>\n    git push origin master\n    \n    \n\n复制\n\n### **关于 SVN**\n\n关于 SVN 笔者的态度和针对 IE 低版本浏览器的态度一样，你只需要查询资料简单了解一下。面试的时候可能会问到，但你只要熟悉了 Git 的操作，面试官不会因为你不熟悉 SVN 而难为你。前提是你要知道一点 SVN 的基本命令，自己上网一查就行。\n\n不过 SVN 和 Git 的区别你得了解。SVN 是每一步操作都离不开服务器，创建分支、提交代码都需要连接服务器。而 Git 就不一样了，你可以在本地创建分支、提交代码，最后再一起 push 到服务器上。因此，Git 拥有 SVN 的所有功能，但是却比 SVN 强大得多。（Git 是 Linux 的创始人 Linus 发明的东西，因此也倍得推崇。）\n\n* * *\n\nLinux 基础命令\n----------\n\n目前互联网公司的线上服务器都使用 Linux 系统，测试环境为了保证和线上一致，肯定也是使用 Linux 系统，而且都是命令行的，没有桌面，不能用鼠标操作。因此，掌握基础的 Linux 命令是非常必要的。下面总结一些最常用的 Linux 命令，建议大家在真实的 Linux 系统下亲自试一下。\n\n关于如何得到 Linux 系统，有两种选择：第一，在自己电脑的虚拟机中安装一个 Linux 系统，例如 Ubuntu/CentOS 等，下载这些都不用花钱；第二，花钱去阿里云等云服务商租一个最便宜的 Linux 虚拟机。推荐第二种。一般正式入职之后，公司都会给你分配开发机或者测试机，给你账号和密码，你自己可以远程登录。\n\n> 题目：常见 linux 命令有哪些？\n\n### **登录**\n\n入职之后，一般会有现有的用户名和密码给你，你拿来之后直接登录就行。运行 `ssh name@server` 然后输入密码即可登录。\n\n### **目录操作**\n\n*   创建目录 `mkdir <目录名称>`\n*   删除目录 `rm <目录名称>`\n*   定位目录 `cd <目录名称>`\n*   查看目录文件 `ls``ll`\n*   修改目录名 `mv <目录名称> <新目录名称>`\n*   拷贝目录 `cp <目录名称> <新目录名称>`\n\n### **文件操作**\n\n*   创建文件 `touch <文件名称>``vi <文件名称>`\n*   删除文件 `rm <文件名称>`\n*   修改文件名 `mv <文件名称> <新文件名称>`\n*   拷贝文件 `cp <文件名称> <新文件名称>`\n\n### **文件内容操作**\n\n*   查看文件 `cat <文件名称>``head <文件名称>``tail <文件名称>`\n*   编辑文件内容 `vi <文件名称>`\n*   查找文件内容 `grep '关键字' <文件名称>`\n\n* * *\n\n**前端构建工具**\n----------\n\n构建工具是前端工程化中不可缺少的一环，非常重要，而在面试中却有其特殊性 —— **面试官会通过询问构建工具的作用、目的来询问你对构建工具的了解，只要这些你都知道，不会再追问细节**。因为，在实际工作中，真正能让你编写构建工具配置文件的机会非常少，一个项目就配置一次，后面就很少改动了。而且，如果是大众使用的框架（如 React、Vue 等），还会直接有现成的脚手架工具，一键创建开发环境，不用手动配置。\n\n> 题目：前端为何要使用构建工具？它解决了什么问题？\n\n### **何为构建工具**\n\n“构建”也可理解为“编译”，就是将开发环境的代码转换成运行环境代码的过程。**开发环境的代码是为了更好地阅读，而运行环境的代码是为了更快地执行，两者目的不一样，因此代码形式也不一样**。例如，开发环境写的 JS 代码，要通过混淆压缩之后才能放在线上运行，因为这样代码体积更小，而且对代码执行不会有任何影响。总结一下需要构建工具处理的几种情况：\n\n*   **处理模块化**：CSS 和 JS 的模块化语法，目前都无法被浏览器兼容。因此，开发环境可以使用既定的模块化语法，但是需要构建工具将模块化语法编译为浏览器可识别形式。例如，使用 webpack、Rollup 等处理 JS 模块化。\n*   **编译语法**：编写 CSS 时使用 Less、Sass，编写 JS 时使用 ES6、TypeScript 等。这些标准目前也都无法被浏览器兼容，因此需要构建工具编译，例如使用 Babel 编译 ES6 语法。\n*   **代码压缩**：将 CSS、JS 代码混淆压缩，为了让代码体积更小，加载更快。\n\n### **构建工具介绍**\n\n最早普及使用的构建工具是 [Grunt](https://link.juejin.im?target=http%3A%2F%2Fwww.gruntjs.net%2F) ，不久又被 [Gulp](https://link.juejin.im?target=https%3A%2F%2Fwww.gulpjs.com.cn%2F) 给追赶上。Gulp 因其简单的配置以及高效的性能而被大家所接受，也是笔者个人比较推荐的构建工具之一。如果你做一些简单的 JS 开发，可以考虑使用。\n\n如果你的项目比较复杂，而且是多人开发，那么你就需要掌握目前构建工具届的神器 —— webpack 。不过神器也有一个缺点，就是学习成本比较高，需要拿出专门的时间来专心学习，而不是三言两语就能讲完的。我们下面就演示一下 webpack 最简单的使用，全面的学习还得靠大家去认真查阅相关文档，或者参考专门讲解 webpack 的教程。\n\n### **webpack 演示**\n\n接下来我们演示一下 webpack 处理模块化和混淆压缩代码这两个基本功能。\n\n首先，你需要安装 Node.js，没有安装的可以去 [Node.js 官网](https://link.juejin.im?target=http%3A%2F%2Fnodejs.cn%2Fdownload%2F) 下载并安装。安装完成后运行如下命令来验证是否安装成功。\n\n    node -v\n    npm -v\n    \n    \n\n复制\n\n然后，新建一个目录，进入该目录，运行`npm init`，按照提示输入名称、版本、描述等信息。完成之后，该目录下出现了一个`package.json`文件，是一个 JSON 文件。\n\n接下来，安装 wepback，运行`npm i --save-dev webpack`，网络原因需要耐心等待几分钟。\n\n接下来，编写源代码，在该目录下创建`src`文件夹，并在其中创建`app.js`和`dt.js`两个文件，文件内容分别是：\n\n    // dt.js 内容\n    module.exports = {\n        getDateNow: function () {\n            return Date.now()\n        }\n    }\n    \n    // app.js 内容\n    var dt = require('./dt.js')\n    alert(dt.getDateNow())\n    \n    \n\n复制\n\n然后，再返回上一层目录，新建`index.html`文件（该文件和`src`属于同一层级），内容是\n\n    <!DOCTYPE html>\n    <html>\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>test</title>\n    </head>\n    <body>\n        <div>test</div>\n    \n        <script src='./dist/bundle.js'></script>\n    </body>\n    </html>\n    \n    \n\n复制\n\n然后，编写 webpack 配置文件，新建`webpack.config.js`，内容是\n\n    const path = require('path');\n    const webpack = require('webpack');\n    module.exports = {\n      context: path.resolve(__dirname, './src'),\n      entry: {\n        app: './app.js',\n      },\n      output: {\n        path: path.resolve(__dirname, './dist'),\n        filename: 'bundle.js',\n      },\n      plugins: [\n        new webpack.optimize.UglifyJsPlugin({\n            compress: {\n              //supresses warnings, usually from module minification\n              warnings: false\n            }\n        }),\n      ]\n    };\n    \n    \n\n复制\n\n总结一下，目前项目的文件目录是：\n\n    src\n      +-- app.js\n      +-- dt.js\n    index.html\n    package.json\n    webpack.config.js\n    \n    \n\n复制\n\n接下来，打开`package.json`，然后修改其中`scripts`的内容为：\n\n      \"scripts\": {\n        \"start\": \"webpack\"\n      }\n    \n    \n\n复制\n\n在命令行中运行`npm start`，即可看到编译的结果，最后在浏览器中打开`index.html`，即可弹出`Date.now()`的值。\n\n### **总结**\n\n最后再次强调，**深刻理解构建工具存在的价值，比你多会一些配置代码更加有意义，特别是对于应对面试来说**。\n\n* * *\n\n**调试方法**\n--------\n\n调试方法这块被考查最多的就是如何进行抓包。\n\n> 题目：如何抓取数据？如何使用工具来配置代理？\n\nPC 端的网页，我们可以通过 Chrome、Firefox 等浏览器自带的开发者工具来查看网页的所有网络请求，以帮助排查 bug。这种监听、查看网络请求的操作称为**抓包**。\n\n针对移动端的抓包工具，Mac 系统下推荐使用 Charles 这个工具，首先 [下载](https://link.juejin.im?target=https%3A%2F%2Fwww.charlesproxy.com%2Fdownload%2F) 并安装，打开。Windows 系统推荐使用 [Fiddler](https://link.juejin.im?target=http%3A%2F%2Frj.baidu.com%2Fsoft%2Fdetail%2F10963.html)，下载安装打开。两者使用基本一致，下面以 Charles 为例介绍。\n\n接下来，将安装好 Charles 的电脑和要抓包的手机，连接到同一个网络（一般为公司统一提供的内网，由专业网络工程师搭建），保证 IP 段相同。然后，将手机设置网络代理（每种不同手机如何设置网络代理，网上都有傻瓜式教程），代理的 IP 为电脑的 IP，代理的端口为`8888`。然后，Charles 可能会有一个弹框提示是否允许连接代理，这里选择“允许”即可。这样，使用手机端访问的网页或者联网的请求，Charles 就能监听到了。\n\n在开发过程中，经常用到抓包工具来做代理，将线上的地址代理到测试环境，Charles 和 Fiddler 都可实现这个功能。以 Charles 为例，点击菜单栏中 Tools 菜单，然后二级菜单中点击 Map Remote，会弹出配置框。首先，选中 Enable Map Remote 复选框，然后点击 Add 按钮，添加一个代理项。例如，如果要将线上的`https://www.aaa.com/api/getuser?name=xxx`这个地址代理到测试地址`http://168.1.1.100:8080/api/getuser?name=xxx`，配置如下图\n\n!\\[\\](data:image/svg+xml;utf8,)\n\n* * *\n\n**小结**\n------\n\n本小节总结了前端开发环境常考查的知识，这些知识也是前端程序员必须掌握的，否则会影响开发效率。\n\n上一篇：[一面 5：浏览器相关知识点与高频考题解析](541675)下一篇：[二面 1：如何回答常见的软技能问题](541677)\n\n**二面 1：如何回答常见的软技能问题**\n=====================\n\n面试是个技术活，不仅仅是技术，各种软技能的面试技巧也是非常重要的，尤其是程序员一般对于自己的软技能不是很看重，其实**软技能才是决定你职场能够走多远的关键**。\n\n**程序员应该具备的软技能**\n---------------\n\n程序员除了业务技能外，应该具有下面的软技能：\n\n1.  韧性：抗压能力，在一定项目压力下能够迎难而上，比如勇于主动承担和解决技术难题\n2.  责任心：对于自己做过的项目，能够出现 bug 之类主动解决\n3.  持续学习能力：IT 行业是个需要不断充电的行业，尤其 Web 前端这些年一直在巨变，所以持续学习能力很重要\n4.  团队合作能力：做项目不能个人英雄主义，应该融入团队，跟团队一起打仗\n5.  交流沟通能力：经常会遇见沟通需求和交互设计的工作，应该乐于沟通分享\n\n另外在《软技能：代码之外的生存指南》这本书里提到了下面一些软技能：\n\n1.  职业\n2.  自我营销\n3.  学习能力\n4.  提升工作效率\n5.  理财\n6.  健身\n7.  积极的人生观\n\n**常见的软技能问题和提升**\n---------------\n\n回答软技能类的问题，应该注意在回答过程中体现自己具备的软技能。下面列举几个常见的软技能类的问题。\n\n### **回想下你遇见过最难打交道的同事，你是如何跟他沟通的**\n\n一般来说，工作中总会遇见一两个自己不喜欢的人，这种情况应该尽量避免冲突，从自己做起慢慢让对方感觉到自己的合作精神。\n\n所以，遇见难打交道的同事，不要急于上报领导，应该自己主动多做一些事情，比如规划好工作安排，让他选择自己做的事情，有了结论记得发邮件确认下来，这样你们的领导和其他成员都会了解到工作的安排，在鞭笞对方的同时，也做到了职责明确。在项目当中，多主动检查项目进展，提前发现逾期的问题。\n\n重点是突出：自己主动沟通解决问题的意识，而不是遇见问题就找领导。\n\n### **当你被分配一个几乎不可能完成的任务时，你会怎么做**\n\n这种情况下，一般通过下面方式来解决：\n\n1.  自己先查找资料，寻找解决方案，评估自己需要怎样的资源来完成，需要多长时间\n2.  能不能借助周围同事来解决问题\n3.  拿着分析结果跟上级反馈，寻求帮助或者资源\n\n突出的软技能：分析和解决问题，沟通寻求帮助。\n\n### **业余时间都做什么？除了写码之外还有什么爱好**\n\n这类问题也是面试官的高频问题，「一个人的业余时间决定了他的未来」，如果回答周末都在追剧打游戏之类的，未免显得太不上进。\n\n一般来说，推荐下面的回答：\n\n> 周末一般会有三种状态：\n> \n> 1.  和朋友一起去做做运动，也会聚会聊天，探讨下新技术之类的；\n> 2.  也会看一些书籍充充电，比如我最近看的 xx，有什么的想法；\n> 3.  有时候会闷在家用最近比较火的技术做个小项目或者实现个小功能之类的。\n\n这样的回答，既能表现自己阳光善于社交沟通的一面，又能表现自己的上进心。\n\n**小结**\n------\n\n本小节介绍了程序员除了业务技术能力之外应该日常修炼的软技能，在面试中，软技能会被以各种形式问起，候选人应该先了解有哪些软技能可以修炼，才能在回答软技能问题的时候，尽量提到自己具备的软技能。\n\n上一篇：[一面 6：开发环境相关知识点与高频考题解析](541676)下一篇：[二面 2：如何介绍项目及应对项目细节追问](541678)\n\n**二面 2：如何介绍项目及应对项目细节追问**\n========================\n\n一个标准的面试流程中，肯定会在一面二面中问到你具体做过的项目，然后追问项目的细节。这类问题往往会通过下面形式来提问：\n\n1.  发现你简历的一个项目，直接让你介绍下这个项目\n2.  让你回忆下你做过的项目中，最值得分享（最大型/最困难/最能体现技术能力/最难忘）的\n3.  如果让你设计 xx 系统/项目，你会怎么着手干\n\n这类跟项目相关的综合性问题，既能体现候选人的技术水平、业务水平和架构能力，也能够辨别候选人是不是真的做过项目，还能够发现候选人的一些软技能。\n\n下面分享下，遇见这类问题应该怎样回答。\n\n**怎样介绍自己做过的一个项目**\n-----------------\n\n按照第 1 小节说的，简历当中的项目，你要精挑细选，既要体现技术难度，又要想好细节。具体要介绍一个项目（包括梳理一个项目），可以按照下面几个阶段来做。\n\n###\\*\\* 1\\. 介绍项目背景**\n\n这个项目为什么做，当初大的环境背景是什么？还是为了解决一个什么问题而设立的项目？背景是很重要的，如果不了解背景，一上来就听一个结论性的项目，面试官可能对于项目的技术选型、技术难度会有理解偏差，甚至怀疑是否真的有过这样的项目。\n\n> 比如一上来就说：我们的项目采用了「backbone」来做框架，然后。。。而「backbone」已经是三四年前比较新鲜的技术，现在会有更好的选择方案，如果不介绍项目的时间背景，面试官肯定一脸懵逼。\n\n### **2\\. 承担角色**\n\n项目涉及的人员角色有哪些，自己在其中扮演的角色是什么？\n\n这里候选往往人会自己给自己挖坑，比如把自己在项目中起到的作用夸大等。一般来说，面试官细节追问的时候，如果候选人能够把细节或者技术方案等讲明白、讲清楚，不管他是真的做过还是跟别人做过，或者自己认真思考过，都能体现候选人的技术水平和技术视野。前提还是在你能够兜得住的可控范围之内做适当的「美化」。\n\n### **3\\. 最终的结果和收益**\n\n项目介绍过程中，应该介绍项目最终的结果和收益，比如项目最后经过多久的开发上线了，上线后的数据是怎样的，是否达到预期，还是带来了新的问题，遇见了问题自己后续又是怎样补救的。\n\n### 4\\. 有始有终：项目总结和反思\n\n有总结和反思，才会有进步。 项目做完了往往会有一些心得和体会，这时候应该跟面试官说出来。在梳理项目的总结和反思时，可以按照下面的列表来梳理：\n\n*   收获有哪些？\n*   是否有做得不足的地方，怎么改进？\n*   是否具有可迁移性？\n\n比如，之前详细介绍了某个项目，这个项目当时看来没有什么问题，但是现在有更好的解决方案了，候选人就应该在这里提出来：现在看来，这个项目还有 xx 的问题，我可以通过 xx 的方式来解决。\n\n再比如：做这个项目的时候，你做得比较出彩的地方，可以迁移到其他项目中直接使用，小到代码片段，大到解决方案，总会有你值得总结和梳理的地方。\n\n介绍完项目总结这部分，也可以引导面试官往自己擅长的领域思考。比如上面提到项目中的问题，可以往你擅长的方面引导，即使面试官没有问到，你也介绍到了。\n\n按照上面的四段体介绍项目，会让面试官感觉候选人有清晰的思路，对整个项目也有理解和想法，还能够总结反思项目的收益和问题，可谓「一箭三雕」。\n\n**没有做过大型项目怎么办**\n---------------\n\n对于刚刚找工作的应届生，或者面试官让你进行一个大型项目的设计，候选人可能没有类似的经验。这时候不要用「我不会、没做过」一句话就带过。\n\n如果是实在没有项目可以说，那么可以提自己日常做的练手项目，或者看到一个解决方案的文章/书，提到的某个项目，抒发下自己的想法。\n\n如果是对于面试官提出来需要你设计的项目/系统，可以按照下面几步思考：\n\n1.  有没有遇见过类似的项目\n2.  有没有读过类似解决方案的文章\n3.  项目能不能拆解，拆解过程中能不能发现自己做过的项目可以用\n4.  项目解决的问题是什么，这类问题有没有更好的解决方案\n\n总之，切记不要一句「不知道、没做过」就放弃，每一次提问都是自己表现的机会。\n\n**项目细节和技术点的追问**\n---------------\n\n介绍项目的过程中，面试官可能会追问技术细节，所以我们在准备面试的时候，应该尽量把技术细节梳理清楚，技术细节包括：\n\n1.  技术选型方案：当时做技术选型所面临的状况\n2.  技术解决方案：最终确定某种技术方案的原因，比如：选择用 Vue 而没有用 React 是为什么？\n3.  项目数据和收益\n4.  项目中最难的地方\n5.  遇见的坑：如使用某种框架遇见哪些坑\n\n一般来说，做技术选型的时候需要考虑下面几个因素：\n\n1.  时代：现在比较火的技术是什么，为什么火起来，解决了什么问题，能否用到我的项目中？\n2.  团队：个人或者团队对某种技术的熟悉程度是怎样的，学习成本又是怎样的？\n3.  业务需求：需求是怎样的，能否套用现在的成熟解决方案/库来快速解决？\n4.  维护成本：一个解决方案的是否再能够 cover 住的范围之内？\n\n在项目中遇见的数据和收益应该做好跟踪，保证数据的真实性和可信性。另外，遇见的坑可能是面试官问得比较多的，尤其现在比较火的一些技术（Vue、React、webpack），一般团队都在使用，所以一定要提前准备下。\n\n**小结**\n------\n\n本小节介绍了面试中关于项目类问题的回答方法，介绍项目要使用四段体的方式，从背景、承担角色、收益效果和总结反思四个部分来介绍项目。\n\n准备这个面试环节的时候，利用笔者一直提倡的「思维导图」法，好好回顾和梳理自己的项目。\n","slug":"前端知识点190111","published":1,"updated":"2019-04-10T02:31:49.178Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuanzkq0000wjgf2q9ef936z","content":"<h1 id=\"一面-1：ES-基础知识点与高频考题解析\"><a href=\"#一面-1：ES-基础知识点与高频考题解析\" class=\"headerlink\" title=\"一面 1：ES 基础知识点与高频考题解析\"></a><strong>一面 1：ES 基础知识点与高频考题解析</strong></h1><p>JavaScript 是 ECMAScript 规范的一种实现，本小节重点梳理下 ECMAScript 中的常考知识点，然后就一些容易出现的题目进行解析。</p>\n<h2 id=\"知识点梳理\"><a href=\"#知识点梳理\" class=\"headerlink\" title=\"知识点梳理\"></a><strong>知识点梳理</strong></h2><ul>\n<li>变量类型<ul>\n<li>JS 的数据类型分类和判断</li>\n<li>值类型和引用类型</li>\n</ul>\n</li>\n<li>原型与原型链（继承）<ul>\n<li>原型和原型链定义</li>\n<li>继承写法</li>\n</ul>\n</li>\n<li>作用域和闭包<ul>\n<li>执行上下文</li>\n<li>this</li>\n<li>闭包是什么</li>\n</ul>\n</li>\n<li>异步<ul>\n<li>同步 vs 异步</li>\n<li>异步和单线程</li>\n<li>前端异步的场景</li>\n</ul>\n</li>\n<li>ES6/7 新标准的考查<ul>\n<li>箭头函数</li>\n<li>Module</li>\n<li>Class</li>\n<li>Set 和 Map</li>\n<li>Promise</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"变量类型\"><a href=\"#变量类型\" class=\"headerlink\" title=\"变量类型\"></a><strong>变量类型</strong></h2><p>JavaScript 是一种弱类型脚本语言，所谓弱类型指的是定义变量时，不需要什么类型，在程序运行过程中会自动判断类型。</p>\n<p>ECMAScript 中定义了 6 种原始类型：</p>\n<ul>\n<li>Boolean</li>\n<li>String</li>\n<li>Number</li>\n<li>Null</li>\n<li>Undefined</li>\n<li>Symbol（ES6 新定义）</li>\n</ul>\n<p><strong>注意</strong>：原始类型不包含 Object。</p>\n<blockquote>\n<p>题目：类型判断用到哪些方法？</p>\n</blockquote>\n<h3 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a><strong><code>typeof</code></strong></h3><p><code>typeof xxx</code>得到的值有以下几种类型：<code>undefined`</code>boolean<code>number</code>string<code>object</code>function<code>、</code>symbol` ，比较简单，不再一一演示了。这里需要注意的有三点：</p>\n<ul>\n<li><code>typeof null</code>结果是<code>object</code> ，实际这是<code>typeof</code>的一个bug，null是原始值，非引用类型</li>\n<li><code>typeof [1, 2]</code>结果是<code>object</code>，结果中没有<code>array</code>这一项，引用类型除了<code>function</code>其他的全部都是<code>object</code></li>\n<li><code>typeof Symbol()</code> 用<code>typeof</code>获取<code>symbol</code>类型的值得到的是<code>symbol</code>，这是 ES6 新增的知识点</li>\n</ul>\n<h3 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a><strong><code>instanceof</code></strong></h3><p>用于实例和构造函数的对应。例如判断一个变量是否是数组，使用<code>typeof</code>无法判断，但可以使用<code>[1, 2] instanceof Array</code>来判断。因为，<code>[1, 2]</code>是数组，它的构造函数就是<code>Array</code>。同理：</p>\n<pre><code>function Foo(name) {\n    this.name = name\n}\nvar foo = new Foo(&apos;bar&apos;)\nconsole.log(foo instanceof Foo) // true\n</code></pre><p>复制</p>\n<blockquote>\n<p>题目：值类型和引用类型的区别</p>\n</blockquote>\n<h3 id=\"值类型-vs-引用类型\"><a href=\"#值类型-vs-引用类型\" class=\"headerlink\" title=\"值类型 vs 引用类型\"></a><strong>值类型 vs 引用类型</strong></h3><p>除了原始类型，ES 还有引用类型，上文提到的<code>typeof</code>识别出来的类型中，只有<code>object</code>和<code>function</code>是引用类型，其他都是值类型。</p>\n<p>根据 JavaScript 中的变量类型传递方式，又分为<strong>值类型</strong>和<strong>引用类型</strong>，值类型变量包括 Boolean、String、Number、Undefined、Null，引用类型包括了 Object 类的所有，如 Date、Array、Function 等。在参数传递方式上，值类型是按值传递，引用类型是按共享传递。</p>\n<p>下面通过一个小题目，来看下两者的主要区别，以及实际开发中需要注意的地方。</p>\n<pre><code>// 值类型\nvar a = 10\nvar b = a\nb = 20\nconsole.log(a)  // 10\nconsole.log(b)  // 20\n</code></pre><p>复制</p>\n<p>上述代码中，<code>a`</code>b`都是值类型，两者分别修改赋值，相互之间没有任何影响。再看引用类型的例子：</p>\n<pre><code>// 引用类型\nvar a = {x: 10, y: 20}\nvar b = a\nb.x = 100\nb.y = 200\nconsole.log(a)  // {x: 100, y: 200}\nconsole.log(b)  // {x: 100, y: 200}\n</code></pre><p>复制</p>\n<p>上述代码中，<code>a`</code>b<code>都是引用类型。在执行了</code>b = a<code>之后，修改</code>b<code>的属性值，</code>a<code>的也跟着变化。因为</code>a<code>和</code>b<code>都是引用类型，指向了同一个内存地址，即两者引用的是同一个值，因此</code>b<code>修改属性时，</code>a`的值随之改动。</p>\n<p>再借助题目进一步讲解一下。</p>\n<blockquote>\n<p>说出下面代码的执行结果，并分析其原因。</p>\n</blockquote>\n<pre><code>function foo(a){\n    a = a * 10;\n}\nfunction bar(b){\n    b.value = &apos;new&apos;;\n}\nvar a = 1;\nvar b = {value: &apos;old&apos;};\nfoo(a);\nbar(b);\nconsole.log(a); // 1\nconsole.log(b); // value: new\n</code></pre><p>复制</p>\n<p>通过代码执行，会发现：</p>\n<ul>\n<li><code>a</code>的值没有发生改变</li>\n<li>而<code>b</code>的值发生了改变</li>\n</ul>\n<p>这就是因为<code>Number</code>类型的<code>a</code>是按值传递的，而<code>Object</code>类型的<code>b</code>是按共享传递的。</p>\n<p>JS 中这种设计的原因是：按值传递的类型，复制一份存入栈内存，这类类型一般不占用太多内存，而且按值传递保证了其访问速度。按共享传递的类型，是复制其引用，而不是整个复制其值（C 语言中的指针），保证过大的对象等不会因为不停复制内容而造成内存的浪费。</p>\n<p>引用类型经常会在代码中按照下面的写法使用，或者说<strong>容易不知不觉中造成错误</strong>！</p>\n<pre><code>var obj = {\n    a: 1,\n    b: [1,2,3]\n}\nvar a = obj.a\nvar b = obj.b\na = 2\nb.push(4)\nconsole.log(obj, a, b)\n</code></pre><p>复制</p>\n<p>虽然<code>obj</code>本身是个引用类型的变量（对象），但是内部的<code>a</code>和<code>b</code>一个是值类型一个是引用类型，<code>a</code>的赋值不会改变<code>obj.a</code>，但是<code>b</code>的操作却会反映到<code>obj</code>对象上。</p>\n<hr>\n<h2 id=\"原型和原型链\"><a href=\"#原型和原型链\" class=\"headerlink\" title=\"原型和原型链\"></a><strong>原型和原型链</strong></h2><p>JavaScript 是基于原型的语言，原型理解起来非常简单，但却特别重要，下面还是通过题目来理解下JavaScript 的原型概念。</p>\n<blockquote>\n<p>题目：如何理解 JavaScript 的原型</p>\n</blockquote>\n<p>对于这个问题，可以从下面这几个要点来理解和回答，<strong>下面几条必须记住并且理解</strong></p>\n<ul>\n<li><strong>所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（<code>null</code>除外）</strong></li>\n<li><strong>所有的引用类型（数组、对象、函数），都有一个<code>__proto__</code>属性，属性值是一个普通的对象</strong></li>\n<li><strong>所有的函数，都有一个<code>prototype</code>属性，属性值也是一个普通的对象</strong></li>\n<li><strong>所有的引用类型（数组、对象、函数），<code>__proto__</code>属性值指向它的构造函数的<code>prototype</code>属性值</strong></li>\n</ul>\n<p>通过代码解释一下，大家可自行运行以下代码，看结果。</p>\n<pre><code>// 要点一：自由扩展属性\nvar obj = {}; obj.a = 100;\nvar arr = []; arr.a = 100;\nfunction fn () {}\nfn.a = 100;\n\n// 要点二：__proto__\nconsole.log(obj.__proto__);\nconsole.log(arr.__proto__);\nconsole.log(fn.__proto__);\n\n// 要点三：函数有 prototype\nconsole.log(fn.prototype)\n\n// 要点四：引用类型的 __proto__ 属性值指向它的构造函数的 prototype 属性值\nconsole.log(obj.__proto__ === Object.prototype)\n</code></pre><p>复制</p>\n<h3 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a><strong>原型</strong></h3><p>先写一个简单的代码示例。</p>\n<pre><code>// 构造函数\nfunction Foo(name, age) {\n    this.name = name\n}\nFoo.prototype.alertName = function () {\n    alert(this.name)\n}\n// 创建示例\nvar f = new Foo(&apos;zhangsan&apos;)\nf.printName = function () {\n    console.log(this.name)\n}\n// 测试\nf.printName()\nf.alertName()\n</code></pre><p>复制</p>\n<p>执行<code>printName</code>时很好理解，但是执行<code>alertName</code>时发生了什么？这里再记住一个重点 <strong>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的<code>__proto__</code>（即它的构造函数的<code>prototype</code>）中寻找</strong>，因此<code>f.alertName</code>就会找到<code>Foo.prototype.alertName</code>。</p>\n<p>那么如何判断这个属性是不是对象本身的属性呢？使用<code>hasOwnProperty</code>，常用的地方是遍历一个对象的时候。</p>\n<pre><code>var item\nfor (item in f) {\n    // 高级浏览器已经在 for in 中屏蔽了来自原型的属性，但是这里建议大家还是加上这个判断，保证程序的健壮性\n    if (f.hasOwnProperty(item)) {\n        console.log(item)\n    }\n}\n</code></pre><p>复制</p>\n<blockquote>\n<p>题目：如何理解 JS 的原型链</p>\n</blockquote>\n<h3 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a><strong>原型链</strong></h3><p>还是接着上面的示例，如果执行<code>f.toString()</code>时，又发生了什么？</p>\n<pre><code>// 省略 N 行\n\n// 测试\nf.printName()\nf.alertName()\nf.toString()\n</code></pre><p>复制</p>\n<p>因为<code>f</code>本身没有<code>toString()</code>，并且<code>f.__proto__</code>（即<code>Foo.prototype</code>）中也没有<code>toString</code>。这个问题还是得拿出刚才那句话——<strong>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的<code>__proto__</code>（即它的构造函数的<code>prototype</code>）中寻找</strong>。</p>\n<p>如果在<code>f.__proto__</code>中没有找到<code>toString</code>，那么就继续去<code>f.__proto__.__proto__</code>中寻找，因为<code>f.__proto__</code>就是一个普通的对象而已嘛！</p>\n<ul>\n<li><code>f.__proto__</code>即<code>Foo.prototype</code>，没有找到<code>toString</code>，继续往上找</li>\n<li><code>f.__proto__.__proto__</code>即<code>Foo.prototype.__proto__</code>。<code>Foo.prototype</code>就是一个普通的对象，因此<code>Foo.prototype.__proto__</code>就是<code>Object.prototype</code>，在这里可以找到<code>toString</code></li>\n<li>因此<code>f.toString</code>最终对应到了<code>Object.prototype.toString</code></li>\n</ul>\n<p>这样一直往上找，你会发现是一个链式的结构，所以叫做“原型链”。如果一直找到最上层都没有找到，那么就宣告失败，返回<code>undefined</code>。最上层是什么 —— <code>Object.prototype.__proto__ === null</code></p>\n<h3 id=\"原型链中的this\"><a href=\"#原型链中的this\" class=\"headerlink\" title=\"原型链中的this\"></a><strong>原型链中的<code>this</code></strong></h3><p>所有从原型或更高级原型中得到、执行的方法，其中的<code>this</code>在执行时，就指向了当前这个触发事件执行的对象。因此<code>printName</code>和<code>alertName</code>中的<code>this</code>都是<code>f</code>。</p>\n<hr>\n<h2 id=\"作用域和闭包\"><a href=\"#作用域和闭包\" class=\"headerlink\" title=\"作用域和闭包\"></a><strong>作用域和闭包</strong></h2><p>作用域和闭包是前端面试中，最可能考查的知识点。例如下面的题目：</p>\n<blockquote>\n<p>题目：现在有个 HTML 片段，要求编写代码，点击编号为几的链接就<code>alert</code>弹出其编号</p>\n</blockquote>\n<pre><code>&lt;ul&gt;\n    &lt;li&gt;编号1，点击我请弹出1&lt;/li&gt;\n    &lt;li&gt;2&lt;/li&gt;\n    &lt;li&gt;3&lt;/li&gt;\n    &lt;li&gt;4&lt;/li&gt;\n    &lt;li&gt;5&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre><p>复制</p>\n<p>一般不知道这个题目用闭包的话，会写出下面的代码：</p>\n<pre><code>var list = document.getElementsByTagName(&apos;li&apos;);\nfor (var i = 0; i &lt; list.length; i++) {\n    list[i].addEventListener(&apos;click&apos;, function(){\n        alert(i + 1)\n    }, true)\n}\n</code></pre><p>复制</p>\n<p>实际上执行才会发现始终弹出的是<code>6</code>，这时候就应该通过闭包来解决：</p>\n<pre><code>var list = document.getElementsByTagName(&apos;li&apos;);\nfor (var i = 0; i &lt; list.length; i++) {\n    list[i].addEventListener(&apos;click&apos;, function(i){\n        return function(){\n            alert(i + 1)\n        }\n    }(i), true)\n}\n</code></pre><p>复制</p>\n<p>要理解闭包，就需要我们从「执行上下文」开始讲起。</p>\n<h3 id=\"执行上下文\"><a href=\"#执行上下文\" class=\"headerlink\" title=\"执行上下文\"></a><strong>执行上下文</strong></h3><p>先讲一个关于 <strong>变量提升</strong> 的知识点，面试中可能会遇见下面的问题，很多候选人都回答错误：</p>\n<blockquote>\n<p>题目：说出下面执行的结果（这里笔者直接注释输出了）</p>\n</blockquote>\n<pre><code>console.log(a)  // undefined\nvar a = 100\n\nfn(&apos;zhangsan&apos;)  // &apos;zhangsan&apos; 20\nfunction fn(name) {\n    age = 20\n    console.log(name, age)\n    var age\n}\n\nconsole.log(b); // 这里报错\n// Uncaught ReferenceError: b is not defined\nb = 100;\n</code></pre><p>复制</p>\n<p>在一段 JS 脚本（即一个<code>&lt;script&gt;</code>标签中）执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个 <strong>全局执行上下文</strong> 环境，先把代码中即将执行的（内部函数的不算，因为你不知道函数何时执行）变量、函数声明都拿出来。变量先暂时赋值为<code>undefined</code>，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。再次强调，这是在代码执行之前才开始的工作。</p>\n<p>我们来看下上面的面试小题目，为什么<code>a</code>是<code>undefined</code>，而<code>b</code>却报错了，实际 JS 在代码执行之前，要「全文解析」，发现<code>var a</code>，知道有个<code>a</code>的变量，存入了执行上下文，而<code>b</code>没有找到<code>var</code>关键字，这时候没有在执行上下文提前「占位」，所以代码执行的时候，提前报到的<code>a</code>是有记录的，只不过值暂时还没有赋值，即为<code>undefined</code>，而<code>b</code>在执行上下文没有找到，自然会报错（没有找到<code>b</code>的引用）。</p>\n<p>另外，一个函数在执行之前，也会创建一个 <strong>函数执行上下文</strong> 环境，跟 <strong>全局上下文</strong> 差不多，不过 <strong>函数执行上下文</strong> 中会多出<code>this`</code>arguments<code>和函数的参数。参数和</code>arguments<code>好理解，这里的</code>this`咱们需要专门讲解。</p>\n<p>总结一下：</p>\n<ul>\n<li>范围：一段<code>&lt;script&gt;</code>、js 文件或者一个函数</li>\n<li>全局上下文：变量定义，函数声明</li>\n<li>函数上下文：变量定义，函数声明，<code>this</code>，<code>arguments</code></li>\n</ul>\n<h3 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a><strong><code>this</code></strong></h3><p>先搞明白一个很重要的概念 —— <strong><code>this</code>的值是在执行的时候才能确认，定义的时候不能确认！</strong> 为什么呢 —— 因为<code>this</code>是执行上下文环境的一部分，而执行上下文需要在代码执行之前确定，而不是定义的时候。看如下例子</p>\n<pre><code>var a = {\n    name: &apos;A&apos;,\n    fn: function () {\n        console.log(this.name)\n    }\n}\na.fn()  // this === a\na.fn.call({name: &apos;B&apos;})  // this === {name: &apos;B&apos;}\nvar fn1 = a.fn\nfn1()  // this === window\n</code></pre><p>复制</p>\n<p><code>this</code>执行会有不同，主要集中在这几个场景中</p>\n<ul>\n<li>作为构造函数执行，构造函数中</li>\n<li>作为对象属性执行，上述代码中<code>a.fn()</code></li>\n<li>作为普通函数执行，上述代码中<code>fn1()</code></li>\n<li>用于<code>call`</code>apply<code></code>bind<code>，上述代码中</code>a.fn.call({name: ‘B’})`</li>\n</ul>\n<p>下面再来讲解下什么是作用域和作用域链，作用域链和作用域也是常考的题目。</p>\n<blockquote>\n<p>题目：如何理解 JS 的作用域和作用域链</p>\n</blockquote>\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a><strong>作用域</strong></h3><p>ES6 之前 JS 没有块级作用域。例如</p>\n<pre><code>if (true) {\n    var name = &apos;zhangsan&apos;\n}\nconsole.log(name)\n</code></pre><p>复制</p>\n<p>从上面的例子可以体会到作用域的概念，作用域就是一个独立的地盘，让变量不会外泄、暴露出去。上面的<code>name</code>就被暴露出去了，因此，<strong>JS 没有块级作用域，只有全局作用域和函数作用域</strong>。</p>\n<pre><code>var a = 100\nfunction fn() {\n    var a = 200\n    console.log(&apos;fn&apos;, a)\n}\nconsole.log(&apos;global&apos;, a)\nfn()\n</code></pre><p>复制</p>\n<p>全局作用域就是最外层的作用域，如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样的坏处就是很容易撞车、冲突。</p>\n<pre><code>// 张三写的代码中\nvar data = {a: 100}\n\n// 李四写的代码中\nvar data = {x: true}\n</code></pre><p>复制</p>\n<p>这就是为何 jQuery、Zepto 等库的源码，所有的代码都会放在<code>(function(){....})()</code>中。因为放在里面的所有变量，都不会被外泄和暴露，不会污染到外面，不会对其他的库或者 JS 脚本造成影响。这是函数作用域的一个体现。</p>\n<p>附：ES6 中开始加入了块级作用域，使用<code>let</code>定义变量即可，如下：</p>\n<pre><code>if (true) {\n    let name = &apos;zhangsan&apos;\n}\nconsole.log(name)  // undefined\n</code></pre><p>复制</p>\n<h3 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a><strong>作用域链</strong></h3><p>首先认识一下什么叫做 <strong>自由变量</strong> 。如下代码中，<code>console.log(a)</code>要得到<code>a</code>变量，但是在当前的作用域中没有定义<code>a</code>（可对比一下<code>b</code>）。当前作用域没有定义的变量，这成为 <strong>自由变量</strong> 。自由变量如何得到 —— 向父级作用域寻找。</p>\n<pre><code>var a = 100\nfunction fn() {\n    var b = 200\n    console.log(a)\n    console.log(b)\n}\nfn()\n</code></pre><p>复制</p>\n<p>如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 <strong>作用域链</strong> 。</p>\n<pre><code>var a = 100\nfunction F1() {\n    var b = 200\n    function F2() {\n        var c = 300\n        console.log(a) // 自由变量，顺作用域链向父作用域找\n        console.log(b) // 自由变量，顺作用域链向父作用域找\n        console.log(c) // 本作用域的变量\n    }\n    F2()\n}\nF1()\n</code></pre><p>复制</p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a><strong>闭包</strong></h3><p>讲完这些内容，我们再来看一个例子，通过例子来理解闭包。</p>\n<pre><code>function F1() {\n    var a = 100\n    return function () {\n        console.log(a)\n    }\n}\nvar f1 = F1()\nvar a = 200\nf1()\n</code></pre><p>复制</p>\n<p>自由变量将从作用域链中去寻找，但是 <strong>依据的是函数定义时的作用域链，而不是函数执行时</strong>，以上这个例子就是闭包。闭包主要有两个应用场景：</p>\n<ul>\n<li><strong>函数作为返回值</strong>，上面的例子就是</li>\n<li><p><strong>函数作为参数传递</strong>，看以下例子</p>\n<p>function F1() {</p>\n<pre><code>var a = 100\nreturn function () {\n    console.log(a)\n}\n</code></pre><p>}<br>function F2(f1) {</p>\n<pre><code>var a = 200\nconsole.log(f1())\n</code></pre><p>}<br>var f1 = F1()<br>F2(f1)</p>\n</li>\n</ul>\n<p>复制</p>\n<p>至此，对应着「作用域和闭包」这部分一开始的点击弹出<code>alert</code>的代码再看闭包，就很好理解了。</p>\n<hr>\n<h2 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a><strong>异步</strong></h2><p>异步和同步也是面试中常考的内容，下面笔者来讲解下同步和异步的区别。</p>\n<h3 id=\"同步-vs-异步\"><a href=\"#同步-vs-异步\" class=\"headerlink\" title=\"同步 vs 异步\"></a><strong>同步 vs 异步</strong></h3><p>先看下面的 demo，根据程序阅读起来表达的意思，应该是先打印<code>100</code>，1秒钟之后打印<code>200</code>，最后打印<code>300</code>。但是实际运行根本不是那么回事。</p>\n<pre><code>console.log(100)\nsetTimeout(function () {\n    console.log(200)\n}, 1000)\nconsole.log(300)\n</code></pre><p>复制</p>\n<p>再对比以下程序。先打印<code>100</code>，再弹出<code>200</code>（等待用户确认），最后打印<code>300</code>。这个运行效果就符合预期要求。</p>\n<pre><code>console.log(100)\nalert(200)  // 1秒钟之后点击确认\nconsole.log(300)\n</code></pre><p>复制</p>\n<p>这俩到底有何区别？—— 第一个示例中间的步骤根本没有阻塞接下来程序的运行，而第二个示例却阻塞了后面程序的运行。前面这种表现就叫做 <strong>异步</strong>（后面这个叫做 <strong>同步</strong> ），即<strong>不会阻塞后面程序的运行</strong>。</p>\n<h3 id=\"异步和单线程\"><a href=\"#异步和单线程\" class=\"headerlink\" title=\"异步和单线程\"></a><strong>异步和单线程</strong></h3><p>JS 需要异步的根本原因是 <strong>JS 是单线程运行的</strong>，即在同一时间只能做一件事，不能“一心二用”。</p>\n<p>一个 Ajax 请求由于网络比较慢，请求需要 5 秒钟。如果是同步，这 5 秒钟页面就卡死在这里啥也干不了了。异步的话，就好很多了，5 秒等待就等待了，其他事情不耽误做，至于那 5 秒钟等待是网速太慢，不是因为 JS 的原因。</p>\n<p>讲到单线程，我们再来看个真题：</p>\n<blockquote>\n<p>题目：讲解下面代码的执行过程和结果</p>\n</blockquote>\n<pre><code>var a = true;\nsetTimeout(function(){\n    a = false;\n}, 100)\nwhile(a){\n    console.log(&apos;while执行了&apos;)\n}\n</code></pre><p>复制</p>\n<p>这是一个很有迷惑性的题目，不少候选人认为<code>100ms</code>之后，由于<code>a</code>变成了<code>false</code>，所以<code>while</code>就中止了，实际不是这样，因为JS是单线程的，所以进入<code>while</code>循环之后，没有「时间」（线程）去跑定时器了，所以这个代码跑起来是个死循环！</p>\n<h3 id=\"前端异步的场景\"><a href=\"#前端异步的场景\" class=\"headerlink\" title=\"前端异步的场景\"></a><strong>前端异步的场景</strong></h3><ul>\n<li>定时 <code>setTimeout`</code>setInverval`</li>\n<li>网络请求，如 <code>Ajax`</code><img>`加载</li>\n</ul>\n<p>Ajax 代码示例</p>\n<pre><code>console.log(&apos;start&apos;)\n$.get(&apos;./data1.json&apos;, function (data1) {\n    console.log(data1)\n})\nconsole.log(&apos;end&apos;)\n</code></pre><p>复制</p>\n<p>img 代码示例（常用于打点统计）</p>\n<pre><code>console.log(&apos;start&apos;)\nvar img = document.createElement(&apos;img&apos;)\n// 或者 img = new Image()\nimg.onload = function () {\n    console.log(&apos;loaded&apos;)\n    img.onload = null\n}\nimg.src = &apos;/xxx.png&apos;\nconsole.log(&apos;end&apos;)\n</code></pre><p>复制</p>\n<hr>\n<h2 id=\"ES6-7-新标准的考查\"><a href=\"#ES6-7-新标准的考查\" class=\"headerlink\" title=\"ES6/7 新标准的考查\"></a><strong>ES6/7 新标准的考查</strong></h2><blockquote>\n<p>题目：ES6 箭头函数中的<code>this</code>和普通函数中的有什么不同</p>\n</blockquote>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a><strong>箭头函数</strong></h3><p>箭头函数是 ES6 中新的函数定义形式，<code>function name(arg1, arg2) {...}</code>可以使用<code>(arg1, arg2) =&gt; {...}</code>来定义。示例如下：</p>\n<pre><code>// JS 普通函数\nvar arr = [1, 2, 3]\narr.map(function (item) {\n    console.log(index)\n    return item + 1\n})\n\n// ES6 箭头函数\nconst arr = [1, 2, 3]\narr.map((item, index) =&gt; {\n    console.log(index)\n    return item + 1\n})\n</code></pre><p>复制</p>\n<p>箭头函数存在的意义，第一写起来更加简洁，第二可以解决 ES6 之前函数执行中<code>this</code>是全局变量的问题，看如下代码</p>\n<pre><code>function fn() {\n    console.log(&apos;real&apos;, this)  // {a: 100} ，该作用域下的 this 的真实的值\n    var arr = [1, 2, 3]\n    // 普通 JS\n    arr.map(function (item) {\n        console.log(&apos;js&apos;, this)  // window 。普通函数，这里打印出来的是全局变量，令人费解\n        return item + 1\n    })\n    // 箭头函数\n    arr.map(item =&gt; {\n        console.log(&apos;es6&apos;, this)  // {a: 100} 。箭头函数，这里打印的就是父作用域的 this\n        return item + 1\n    })\n}\nfn.call({a: 100})\n</code></pre><p>复制</p>\n<blockquote>\n<p>题目：ES6 模块化如何使用？</p>\n</blockquote>\n<h3 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a><strong>Module</strong></h3><p>ES6 中模块化语法更加简洁，直接看示例。</p>\n<p>如果只是输出一个唯一的对象，使用<code>export default</code>即可，代码如下</p>\n<pre><code>// 创建 util1.js 文件，内容如\nexport default {\n    a: 100\n}\n\n// 创建 index.js 文件，内容如\nimport obj from &apos;./util1.js&apos;\nconsole.log(obj)\n</code></pre><p>复制</p>\n<p>如果想要输出许多个对象，就不能用<code>default</code>了，且<code>import</code>时候要加<code>{...}</code>，代码如下</p>\n<pre><code>// 创建 util2.js 文件，内容如\nexport function fn1() {\n    alert(&apos;fn1&apos;)\n}\nexport function fn2() {\n    alert(&apos;fn2&apos;)\n}\n\n// 创建 index.js 文件，内容如\nimport { fn1, fn2 } from &apos;./util2.js&apos;\nfn1()\nfn2()\n</code></pre><p>复制</p>\n<blockquote>\n<p>题目：ES6 class 和普通构造函数的区别</p>\n</blockquote>\n<h3 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a><strong>class</strong></h3><p>class 其实一直是 JS 的关键字（保留字），但是一直没有正式使用，直到 ES6 。 ES6 的 class 就是取代之前构造函数初始化对象的形式，从语法上更加符合面向对象的写法。例如：</p>\n<p>JS 构造函数的写法</p>\n<pre><code>function MathHandle(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nMathHandle.prototype.add = function () {\n  return this.x + this.y;\n};\n\nvar m = new MathHandle(1, 2);\nconsole.log(m.add())\n</code></pre><p>复制</p>\n<p>用 ES6 class 的写法</p>\n<pre><code>class MathHandle {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  add() {\n    return this.x + this.y;\n  }\n}\nconst m = new MathHandle(1, 2);\nconsole.log(m.add())\n</code></pre><p>复制</p>\n<p>注意以下几点，全都是关于 class 语法的：</p>\n<ul>\n<li>class 是一种新的语法形式，是<code>class Name {...}</code>这种形式，和函数的写法完全不一样</li>\n<li>两者对比，构造函数函数体的内容要放在 class 中的<code>constructor</code>函数中，<code>constructor</code>即构造器，初始化实例时默认执行</li>\n<li>class 中函数的写法是<code>add() {...}</code>这种形式，并没有<code>function</code>关键字</li>\n</ul>\n<p>使用 class 来实现继承就更加简单了，至少比构造函数实现继承简单很多。看下面例子</p>\n<p>JS 构造函数实现继承</p>\n<pre><code>// 动物\nfunction Animal() {\n    this.eat = function () {\n        console.log(&apos;animal eat&apos;)\n    }\n}\n// 狗\nfunction Dog() {\n    this.bark = function () {\n        console.log(&apos;dog bark&apos;)\n    }\n}\nDog.prototype = new Animal()\n// 哈士奇\nvar hashiqi = new Dog()\n</code></pre><p>复制</p>\n<p>ES6 class 实现继承</p>\n<pre><code>class Animal {\n    constructor(name) {\n        this.name = name\n    }\n    eat() {\n        console.log(`${this.name} eat`)\n    }\n}\n\nclass Dog extends Animal {\n    constructor(name) {\n        super(name)\n        this.name = name\n    }\n    say() {\n        console.log(`${this.name} say`)\n    }\n}\nconst dog = new Dog(&apos;哈士奇&apos;)\ndog.say()\ndog.eat()\n</code></pre><p>复制</p>\n<p>注意以下两点：</p>\n<ul>\n<li>使用<code>extends</code>即可实现继承，更加符合经典面向对象语言的写法，如 Java</li>\n<li>子类的<code>constructor</code>一定要执行<code>super()</code>，以调用父类的<code>constructor</code></li>\n</ul>\n<blockquote>\n<p>题目：ES6 中新增的数据类型有哪些？</p>\n</blockquote>\n<h3 id=\"Set-和-Map\"><a href=\"#Set-和-Map\" class=\"headerlink\" title=\"Set 和 Map\"></a><strong>Set 和 Map</strong></h3><p>Set 和 Map 都是 ES6 中新增的数据结构，是对当前 JS 数组和对象这两种重要数据结构的扩展。由于是新增的数据结构，目前尚未被大规模使用，但是作为前端程序员，提前了解是必须做到的。先总结一下两者最关键的地方：</p>\n<ul>\n<li>Set 类似于数组，但数组可以允许元素重复，Set 不允许元素重复</li>\n<li>Map 类似于对象，但普通对象的 key 必须是字符串或者数字，而 Map 的 key 可以是任何数据类型</li>\n</ul>\n<p><strong>Set</strong></p>\n<p>Set 实例不允许元素有重复，可以通过以下示例证明。可以通过一个数组初始化一个 Set 实例，或者通过<code>add</code>添加元素，元素不能重复，重复的会被忽略。</p>\n<pre><code>// 例1\nconst set = new Set([1, 2, 3, 4, 4]);\nconsole.log(set) // Set(4) {1, 2, 3, 4}\n\n// 例2\nconst set = new Set();\n[2, 3, 5, 4, 5, 8, 8].forEach(item =&gt; set.add(item));\nfor (let item of set) {\n  console.log(item);\n}\n// 2 3 5 4 8\n</code></pre><p>复制</p>\n<p>Set 实例的属性和方法有</p>\n<ul>\n<li><code>size</code>：获取元素数量。</li>\n<li><code>add(value)</code>：添加元素，返回 Set 实例本身。</li>\n<li><code>delete(value)</code>：删除元素，返回一个布尔值，表示删除是否成功。</li>\n<li><code>has(value)</code>：返回一个布尔值，表示该值是否是 Set 实例的元素。</li>\n<li><p><code>clear()</code>：清除所有元素，没有返回值。</p>\n<p>const s = new Set();<br>s.add(1).add(2).add(2); // 添加元素</p>\n<p>s.size // 2</p>\n<p>s.has(1) // true<br>s.has(2) // true<br>s.has(3) // false</p>\n<p>s.delete(2);<br>s.has(2) // false</p>\n<p>s.clear();<br>console.log(s);  // Set(0) {}</p>\n</li>\n</ul>\n<p>复制</p>\n<p>Set 实例的遍历，可使用如下方法</p>\n<ul>\n<li><code>keys()</code>：返回键名的遍历器。</li>\n<li><code>values()</code>：返回键值的遍历器。不过由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys()</code>和<code>values()</code>返回结果一致。</li>\n<li><code>entries()</code>：返回键值对的遍历器。</li>\n<li><p><code>forEach()</code>：使用回调函数遍历每个成员。</p>\n<p>let set = new Set([‘aaa’, ‘bbb’, ‘ccc’]);</p>\n<p>for (let item of set.keys()) {<br>  console.log(item);<br>}<br>// aaa<br>// bbb<br>// ccc</p>\n<p>for (let item of set.values()) {<br>  console.log(item);<br>}<br>// aaa<br>// bbb<br>// ccc</p>\n<p>for (let item of set.entries()) {<br>  console.log(item);<br>}<br>// [“aaa”, “aaa”]<br>// [“bbb”, “bbb”]<br>// [“ccc”, “ccc”]</p>\n<p>set.forEach((value, key) =&gt; console.log(key + ‘ : ‘ + value))<br>// aaa : aaa<br>// bbb : bbb<br>// ccc : ccc</p>\n</li>\n</ul>\n<p>复制</p>\n<p><strong>Map</strong></p>\n<p>Map 的用法和普通对象基本一致，先看一下它能用非字符串或者数字作为 key 的特性。</p>\n<pre><code>const map = new Map();\nconst obj = {p: &apos;Hello World&apos;};\n\nmap.set(obj, &apos;OK&apos;)\nmap.get(obj) // &quot;OK&quot;\n\nmap.has(obj) // true\nmap.delete(obj) // true\nmap.has(obj) // false\n</code></pre><p>复制</p>\n<p>需要使用<code>new Map()</code>初始化一个实例，下面代码中<code>set`</code>get<code>has</code>delete<code>顾名即可思义（下文也会演示）。其中，</code>map.set(obj, ‘OK’)<code>就是用对象作为的 key （不光可以是对象，任何数据类型都可以），并且后面通过</code>map.get(obj)`正确获取了。</p>\n<p>Map 实例的属性和方法如下：</p>\n<ul>\n<li><code>size</code>：获取成员的数量</li>\n<li><code>set</code>：设置成员 key 和 value</li>\n<li><code>get</code>：获取成员属性值</li>\n<li><code>has</code>：判断成员是否存在</li>\n<li><code>delete</code>：删除成员</li>\n<li><p><code>clear</code>：清空所有</p>\n<p>const map = new Map();<br>map.set(‘aaa’, 100);<br>map.set(‘bbb’, 200);</p>\n<p>map.size // 2</p>\n<p>map.get(‘aaa’) // 100</p>\n<p>map.has(‘aaa’) // true</p>\n<p>map.delete(‘aaa’)<br>map.has(‘aaa’) // false</p>\n<p>map.clear()</p>\n</li>\n</ul>\n<p>复制</p>\n<p>Map 实例的遍历方法有：</p>\n<ul>\n<li><code>keys()</code>：返回键名的遍历器。</li>\n<li><code>values()</code>：返回键值的遍历器。</li>\n<li><code>entries()</code>：返回所有成员的遍历器。</li>\n<li><p><code>forEach()</code>：遍历 Map 的所有成员。</p>\n<p>const map = new Map();<br>map.set(‘aaa’, 100);<br>map.set(‘bbb’, 200);</p>\n<p>for (let key of map.keys()) {<br>  console.log(key);<br>}<br>// “aaa”<br>// “bbb”</p>\n<p>for (let value of map.values()) {<br>  console.log(value);<br>}<br>// 100<br>// 200</p>\n<p>for (let item of map.entries()) {<br>  console.log(item[0], item[1]);<br>}<br>// aaa 100<br>// bbb 200</p>\n<p>// 或者<br>for (let [key, value] of map.entries()) {<br>  console.log(key, value);<br>}<br>// aaa 100<br>// bbb 200</p>\n</li>\n</ul>\n<p>复制</p>\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a><strong>Promise</strong></h3><p><code>Promise</code>是 CommonJS 提出来的这一种规范，有多个版本，在 ES6 当中已经纳入规范，原生支持 Promise 对象，非 ES6 环境可以用类似 Bluebird、Q 这类库来支持。</p>\n<p><code>Promise</code> 可以将回调变成链式调用写法，流程更加清晰，代码更加优雅。</p>\n<p>简单归纳下 Promise：<strong>三个状态、两个过程、一个方法</strong>，快速记忆方法：<strong>3-2-1</strong></p>\n<p>三个状态：<code>pending</code>、<code>fulfilled</code>、<code>rejected</code></p>\n<p>两个过程：</p>\n<ul>\n<li>pending→fulfilled（resolve）</li>\n<li>pending→rejected（reject）</li>\n</ul>\n<p>一个方法：<code>then</code></p>\n<p>当然还有其他概念，如<code>catch</code>、 <code>Promise.all/race</code>，这里就不展开了。</p>\n<p>关于 ES6/7 的考查内容还有很多，本小节就不逐一介绍了，如果想继续深入学习，可以在线看《<a href=\"https://link.juejin.im?target=http%3A%2F%2Fes6.ruanyifeng.com%2F\" target=\"_blank\" rel=\"noopener\">ES6入门</a>》。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h2><p>本小节主要总结了 ES 基础语法中面试经常考查的知识点，包括之前就考查较多的原型、异步、作用域，以及 ES6 的一些新内容，这些知识点希望大家都要掌握。</p>\n<p>上一篇：<a href=\"541670\">准备：简历编写和面试前准备</a>下一篇：<a href=\"541672\">一面 2：JS-Web-API 知识点与高频考题解析</a></p>\n<h1 id=\"一面-2：JS-Web-API-知识点与高频考题解析\"><a href=\"#一面-2：JS-Web-API-知识点与高频考题解析\" class=\"headerlink\" title=\"一面 2：JS-Web-API 知识点与高频考题解析\"></a><strong>一面 2：JS-Web-API 知识点与高频考题解析</strong></h1><p>除 ES 基础之外，Web 前端经常会用到一些跟浏览器相关的 API，接下来我们一起梳理一下。</p>\n<h2 id=\"知识点梳理-1\"><a href=\"#知识点梳理-1\" class=\"headerlink\" title=\"知识点梳理\"></a><strong>知识点梳理</strong></h2><ul>\n<li>BOM 操作</li>\n<li>DOM 操作</li>\n<li>事件绑定</li>\n<li>Ajax</li>\n<li>存储</li>\n</ul>\n<hr>\n<h2 id=\"BOM\"><a href=\"#BOM\" class=\"headerlink\" title=\"BOM\"></a><strong>BOM</strong></h2><p>BOM（浏览器对象模型）是浏览器本身的一些信息的设置和获取，例如获取浏览器的宽度、高度，设置让浏览器跳转到哪个地址。</p>\n<ul>\n<li><code>navigator</code></li>\n<li><code>screen</code></li>\n<li><code>location</code></li>\n<li><code>history</code></li>\n</ul>\n<p>这些对象就是一堆非常简单粗暴的 API，没任何技术含量，讲起来一点意思都没有，大家去 MDN 或者 w3school 这种网站一查就都明白了。面试的时候，面试官基本不会出太多这方面的题目，因为只要基础知识过关了，这些 API 即便你记不住，上网一查也都知道了。下面列举一下常用功能的代码示例</p>\n<p>获取浏览器特性（即俗称的<code>UA</code>）然后识别客户端，例如判断是不是 Chrome 浏览器</p>\n<pre><code>var ua = navigator.userAgent\nvar isChrome = ua.indexOf(&apos;Chrome&apos;)\nconsole.log(isChrome)\n</code></pre><p>复制</p>\n<p>获取屏幕的宽度和高度</p>\n<pre><code>console.log(screen.width)\nconsole.log(screen.height)\n</code></pre><p>复制</p>\n<p>获取网址、协议、path、参数、hash 等</p>\n<pre><code>// 例如当前网址是 https://juejin.im/timeline/frontend?a=10&amp;b=10#some\nconsole.log(location.href)  // https://juejin.im/timeline/frontend?a=10&amp;b=10#some\nconsole.log(location.protocol) // https:\nconsole.log(location.pathname) // /timeline/frontend\nconsole.log(location.search) // ?a=10&amp;b=10\nconsole.log(location.hash) // #some\n</code></pre><p>复制</p>\n<p>另外，还有调用浏览器的前进、后退功能等</p>\n<pre><code>history.back()\nhistory.forward()\n</code></pre><p>复制</p>\n<hr>\n<h2 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a><strong>DOM</strong></h2><blockquote>\n<p>题目：DOM 和 HTML 区别和联系</p>\n</blockquote>\n<h3 id=\"什么是-DOM\"><a href=\"#什么是-DOM\" class=\"headerlink\" title=\"什么是 DOM\"></a><strong>什么是 DOM</strong></h3><p>讲 DOM 先从 HTML 讲起，讲 HTML 先从 XML 讲起。XML 是一种可扩展的标记语言，所谓可扩展就是它可以描述任何结构化的数据，它是一棵树！</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;note&gt;\n  &lt;to&gt;Tove&lt;/to&gt;\n  &lt;from&gt;Jani&lt;/from&gt;\n  &lt;heading&gt;Reminder&lt;/heading&gt;\n  &lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt;\n  &lt;other&gt;\n    &lt;a&gt;&lt;/a&gt;\n    &lt;b&gt;&lt;/b&gt;\n  &lt;/other&gt;\n&lt;/note&gt;\n</code></pre><p>复制</p>\n<p>HTML 是一个有既定标签标准的 XML 格式，标签的名字、层级关系和属性，都被标准化（否则浏览器无法解析）。同样，它也是一棵树。</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div&gt;\n        &lt;p&gt;this is p&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>复制</p>\n<p>我们开发完的 HTML 代码会保存到一个文档中（一般以<code>.html</code>或者<code>.htm</code>结尾），文档放在服务器上，浏览器请求服务器，这个文档被返回。因此，最终浏览器拿到的是一个文档而已，文档的内容就是 HTML 格式的代码。</p>\n<p>但是浏览器要把这个文档中的 HTML 按照标准渲染成一个页面，此时浏览器就需要将这堆代码处理成自己能理解的东西，也得处理成 JS 能理解的东西，因为还得允许 JS 修改页面内容呢。</p>\n<p>基于以上需求，浏览器就需要把 HTML 转变成 DOM，HTML 是一棵树，DOM 也是一棵树。对 DOM 的理解，可以暂时先抛开浏览器的内部因素，先从 JS 着手，即可以认为 DOM 就是 JS 能识别的 HTML 结构，一个普通的 JS 对象或者数组。</p>\n<p>![DOM图示](data:image/svg+xml;utf8,)</p>\n<h3 id=\"获取-DOM-节点\"><a href=\"#获取-DOM-节点\" class=\"headerlink\" title=\"获取 DOM 节点\"></a><strong>获取 DOM 节点</strong></h3><p>最常用的 DOM API 就是获取节点，其中常用的获取方法如下面代码示例：</p>\n<pre><code>// 通过 id 获取\nvar div1 = document.getElementById(&apos;div1&apos;) // 元素\n\n// 通过 tagname 获取\nvar divList = document.getElementsByTagName(&apos;div&apos;)  // 集合\nconsole.log(divList.length)\nconsole.log(divList[0])\n\n// 通过 class 获取\nvar containerList = document.getElementsByClassName(&apos;container&apos;) // 集合\n\n// 通过 CSS 选择器获取\nvar pList = document.querySelectorAll(&apos;p&apos;) // 集合\n</code></pre><p>复制</p>\n<blockquote>\n<p>题目：property 和 attribute 的区别是什么？</p>\n</blockquote>\n<h3 id=\"property\"><a href=\"#property\" class=\"headerlink\" title=\"property\"></a><strong>property</strong></h3><p>DOM 节点就是一个 JS 对象，它符合之前讲述的对象的特征 —— 可扩展属性，因为 DOM 节点本质上也是一个 JS 对象。因此，如下代码所示，<code>p</code>可以有<code>style</code>属性，有<code>className`</code>nodeName<code></code>nodeType`属性。注意，<strong>这些都是 JS 范畴的属性，符合 JS 语法标准的</strong>。</p>\n<pre><code>var pList = document.querySelectorAll(&apos;p&apos;)\nvar p = pList[0]\nconsole.log(p.style.width)  // 获取样式\np.style.width = &apos;100px&apos;  // 修改样式\nconsole.log(p.className)  // 获取 class\np.className = &apos;p1&apos;  // 修改 class\n\n// 获取 nodeName 和 nodeType\nconsole.log(p.nodeName)\nconsole.log(p.nodeType)\n</code></pre><p>复制</p>\n<h3 id=\"attribute\"><a href=\"#attribute\" class=\"headerlink\" title=\"attribute\"></a><strong>attribute</strong></h3><p>property 的获取和修改，是直接改变 JS 对象，而 attribute 是直接改变 HTML 的属性，两种有很大的区别。attribute 就是对 HTML 属性的 get 和 set，和 DOM 节点的 JS 范畴的 property 没有关系。</p>\n<pre><code>var pList = document.querySelectorAll(&apos;p&apos;)\nvar p = pList[0]\np.getAttribute(&apos;data-name&apos;)\np.setAttribute(&apos;data-name&apos;, &apos;juejin&apos;)\np.getAttribute(&apos;style&apos;)\np.setAttribute(&apos;style&apos;, &apos;font-size:30px;&apos;)\n</code></pre><p>复制</p>\n<p>而且，get 和 set attribute 时，还会触发 DOM 的查询或者重绘、重排，频繁操作会影响页面性能。</p>\n<blockquote>\n<p>题目：DOM 操作的基本 API 有哪些？</p>\n</blockquote>\n<h3 id=\"DOM-树操作\"><a href=\"#DOM-树操作\" class=\"headerlink\" title=\"DOM 树操作\"></a><strong>DOM 树操作</strong></h3><p>新增节点</p>\n<pre><code>var div1 = document.getElementById(&apos;div1&apos;)\n\n// 添加新节点\nvar p1 = document.createElement(&apos;p&apos;)\np1.innerHTML = &apos;this is p1&apos;\ndiv1.appendChild(p1) // 添加新创建的元素\n\n// 移动已有节点。注意，这里是“移动”，并不是拷贝\nvar p2 = document.getElementById(&apos;p2&apos;)\ndiv1.appendChild(p2)\n</code></pre><p>复制</p>\n<p>获取父元素</p>\n<pre><code>var div1 = document.getElementById(&apos;div1&apos;)\nvar parent = div1.parentElement\n</code></pre><p>复制</p>\n<p>获取子元素</p>\n<pre><code>var div1 = document.getElementById(&apos;div1&apos;)\nvar child = div1.childNodes\n</code></pre><p>复制</p>\n<p>删除节点</p>\n<pre><code>var div1 = document.getElementById(&apos;div1&apos;)\nvar child = div1.childNodes\ndiv1.removeChild(child[0])\n</code></pre><p>复制</p>\n<p>还有其他操作的API，例如获取前一个节点、获取后一个节点等，但是面试过程中经常考到的就是上面几个。</p>\n<hr>\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a><strong>事件</strong></h2><h3 id=\"事件绑定\"><a href=\"#事件绑定\" class=\"headerlink\" title=\"事件绑定\"></a><strong>事件绑定</strong></h3><p>普通的事件绑定写法如下：</p>\n<pre><code>var btn = document.getElementById(&apos;btn1&apos;)\nbtn.addEventListener(&apos;click&apos;, function (event) {\n    // event.preventDefault() // 阻止默认行为\n    // event.stopPropagation() // 阻止冒泡\n    console.log(&apos;clicked&apos;)\n})\n</code></pre><p>复制</p>\n<p>为了编写简单的事件绑定，可以编写通用的事件绑定函数。这里虽然比较简单，但是会随着后文的讲解，来继续完善和丰富这个函数。</p>\n<pre><code>// 通用的事件绑定函数\nfunction bindEvent(elem, type, fn) {\n    elem.addEventListener(type, fn)\n}\nvar a = document.getElementById(&apos;link1&apos;)\n// 写起来更加简单了\nbindEvent(a, &apos;click&apos;, function(e) {\n    e.preventDefault() // 阻止默认行为\n    alert(&apos;clicked&apos;)\n})\n</code></pre><p>复制</p>\n<p>最后，<strong>如果面试被问到 IE 低版本兼容性问题，我劝你果断放弃这份工作机会</strong>。现在互联网流量都在 App 上， IE 占比越来越少，再去为 IE 浪费青春不值得，要尽量去做 App 相关的工作。</p>\n<blockquote>\n<p>题目：什么是事件冒泡？</p>\n</blockquote>\n<h3 id=\"事件冒泡\"><a href=\"#事件冒泡\" class=\"headerlink\" title=\"事件冒泡\"></a><strong>事件冒泡</strong></h3><pre><code>&lt;body&gt;\n    &lt;div id=&quot;div1&quot;&gt;\n        &lt;p id=&quot;p1&quot;&gt;激活&lt;/p&gt;\n        &lt;p id=&quot;p2&quot;&gt;取消&lt;/p&gt;\n        &lt;p id=&quot;p3&quot;&gt;取消&lt;/p&gt;\n        &lt;p id=&quot;p4&quot;&gt;取消&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;div id=&quot;div2&quot;&gt;\n        &lt;p id=&quot;p5&quot;&gt;取消&lt;/p&gt;\n        &lt;p id=&quot;p6&quot;&gt;取消&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n</code></pre><p>复制</p>\n<p>对于以上 HTML 代码结构，要求点击<code>p1</code>时候进入激活状态，点击其他任何<code>&lt;p&gt;</code>都取消激活状态，如何实现？代码如下，注意看注释：</p>\n<pre><code>var body = document.body\nbindEvent(body, &apos;click&apos;, function (e) {\n    // 所有 p 的点击都会冒泡到 body 上，因为 DOM 结构中 body 是 p 的上级节点，事件会沿着 DOM 树向上冒泡\n    alert(&apos;取消&apos;)\n})\n\nvar p1 = document.getElementById(&apos;p1&apos;)\nbindEvent(p1, &apos;click&apos;, function (e) {\n    e.stopPropagation() // 阻止冒泡\n    alert(&apos;激活&apos;)\n})\n</code></pre><p>复制</p>\n<p>如果我们在<code>p1`</code>div1<code></code>body<code>中都绑定了事件，它是会根据 DOM 的结构来冒泡，从下到上挨个执行的。但是我们使用</code>e.stopPropagation()`就可以阻止冒泡</p>\n<blockquote>\n<p>题目：如何使用事件代理？有何好处？</p>\n</blockquote>\n<h3 id=\"事件代理\"><a href=\"#事件代理\" class=\"headerlink\" title=\"事件代理\"></a><strong>事件代理</strong></h3><p>我们设定一种场景，如下代码，一个<code>&lt;div&gt;</code>中包含了若干个<code>&lt;a&gt;</code>，而且还能继续增加。那如何快捷方便地为所有<code>&lt;a&gt;</code>绑定事件呢？</p>\n<pre><code>&lt;div id=&quot;div1&quot;&gt;\n    &lt;a href=&quot;#&quot;&gt;a1&lt;/a&gt;\n    &lt;a href=&quot;#&quot;&gt;a2&lt;/a&gt;\n    &lt;a href=&quot;#&quot;&gt;a3&lt;/a&gt;\n    &lt;a href=&quot;#&quot;&gt;a4&lt;/a&gt;\n&lt;/div&gt;\n&lt;button&gt;点击增加一个 a 标签&lt;/button&gt;\n</code></pre><p>复制</p>\n<p>这里就会用到事件代理。我们要监听<code>&lt;a&gt;</code>的事件，但要把具体的事件绑定到<code>&lt;div&gt;</code>上，然后看事件的触发点是不是<code>&lt;a&gt;</code>。</p>\n<pre><code>var div1 = document.getElementById(&apos;div1&apos;)\ndiv1.addEventListener(&apos;click&apos;, function (e) {\n    // e.target 可以监听到触发点击事件的元素是哪一个\n    var target = e.target\n    if (e.nodeName === &apos;A&apos;) {\n        // 点击的是 &lt;a&gt; 元素\n        alert(target.innerHTML)\n    }\n})\n</code></pre><p>复制</p>\n<p>我们现在完善一下之前写的通用事件绑定函数，加上事件代理。</p>\n<pre><code>function bindEvent(elem, type, selector, fn) {\n    // 这样处理，可接收两种调用方式 bindEvent(div1, &apos;click&apos;, &apos;a&apos;, function () {...}) 和 bindEvent(div1, &apos;click&apos;, function () {...}) 这两种\n    if (fn == null) {\n        fn = selector\n        selector = null\n    }\n\n    // 绑定事件\n    elem.addEventListener(type, function (e) {\n        var target\n        if (selector) {\n            // 有 selector 说明需要做事件代理\n            // 获取触发时间的元素，即 e.target\n            target = e.target\n            // 看是否符合 selector 这个条件\n            if (target.matches(selector)) {\n                fn.call(target, e)\n            }\n        } else {\n            // 无 selector ，说明不需要事件代理\n            fn(e)\n        }\n    })\n}\n</code></pre><p>复制</p>\n<p>然后这样使用，简单很多。</p>\n<pre><code>// 使用代理，bindEvent 多一个 &apos;a&apos; 参数\nvar div1 = document.getElementById(&apos;div1&apos;)\nbindEvent(div1, &apos;click&apos;, &apos;a&apos;, function (e) {\n    console.log(this.innerHTML)\n})\n\n// 不使用代理\nvar a = document.getElementById(&apos;a1&apos;)\nbindEvent(div1, &apos;click&apos;, function (e) {\n    console.log(a.innerHTML)\n})\n</code></pre><p>复制</p>\n<p>最后，使用代理的优点如下：</p>\n<ul>\n<li>使代码简洁</li>\n<li>减少浏览器的内存占用</li>\n</ul>\n<hr>\n<h2 id=\"Ajax\"><a href=\"#Ajax\" class=\"headerlink\" title=\"Ajax\"></a><strong>Ajax</strong></h2><h3 id=\"XMLHttpRequest\"><a href=\"#XMLHttpRequest\" class=\"headerlink\" title=\"XMLHttpRequest\"></a><strong>XMLHttpRequest</strong></h3><blockquote>\n<p>题目：手写 XMLHttpRequest 不借助任何库</p>\n</blockquote>\n<p>这是很多奇葩的、个性的面试官经常用的手段。这种考查方式存在很多争议，但是你不能完全说它是错误的，毕竟也是考查对最基础知识的掌握情况。</p>\n<pre><code>var xhr = new XMLHttpRequest()\nxhr.open(&quot;GET&quot;, &quot;/api&quot;, false)\nxhr.onreadystatechange = function () {\n    // 这里的函数异步执行，可参考之前 JS 基础中的异步模块\n    if (xhr.readyState == 4) {\n        if (xhr.status == 200) {\n            alert(xhr.responseText)\n        }\n    }\n}\nxhr.send(null)\n</code></pre><p>复制</p>\n<p>当然，使用 jQuery、Zepto 或 Fetch 等库来写就更加简单了，这里不再赘述。</p>\n<h3 id=\"状态码说明\"><a href=\"#状态码说明\" class=\"headerlink\" title=\"状态码说明\"></a><strong>状态码说明</strong></h3><p>上述代码中，有两处状态码需要说明。<code>xhr.readyState</code>是浏览器判断请求过程中各个阶段的，<code>xhr.status</code>是 HTTP 协议中规定的不同结果的返回状态说明。</p>\n<p><code>xhr.readyState</code>的状态码说明：</p>\n<ul>\n<li>0 - (未初始化）还没有调用<code>send()</code>方法</li>\n<li>1 -（载入）已调用<code>send()</code>方法，正在发送请求</li>\n<li>2 -（载入完成）<code>send()</code>方法执行完成，已经接收到全部响应内容</li>\n<li>3 -（交互）正在解析响应内容</li>\n<li>4 -（完成）响应内容解析完成，可以在客户端调用了</li>\n</ul>\n<blockquote>\n<p>题目：HTTP 协议中，response 的状态码，常见的有哪些？</p>\n</blockquote>\n<p><code>xhr.status</code>即 HTTP 状态码，有 <code>2xx`</code>3xx<code>4xx</code>5xx` 这几种，比较常用的有以下几种：</p>\n<ul>\n<li><code>200</code> 正常</li>\n<li><code>3xx</code><ul>\n<li><code>301</code> 永久重定向。如<code>http://xxx.com</code>这个 GET 请求（最后没有<code>/</code>），就会被<code>301</code>到<code>http://xxx.com/</code>（最后是<code>/</code>）</li>\n<li><code>302</code> 临时重定向。临时的，不是永久的</li>\n<li><code>304</code> 资源找到但是不符合请求条件，不会返回任何主体。如发送 GET 请求时，head 中有<code>If-Modified-Since: xxx</code>（要求返回更新时间是<code>xxx</code>时间之后的资源），如果此时服务器 端资源未更新，则会返回<code>304</code>，即不符合要求</li>\n</ul>\n</li>\n<li><code>404</code> 找不到资源</li>\n<li><code>5xx</code> 服务器端出错了</li>\n</ul>\n<p>看完要明白，为何上述代码中要同时满足<code>xhr.readyState == 4</code>和<code>xhr.status == 200</code>。</p>\n<h3 id=\"Fetch-API\"><a href=\"#Fetch-API\" class=\"headerlink\" title=\"Fetch API\"></a><strong>Fetch API</strong></h3><p>目前已经有一个获取 HTTP 请求更加方便的 API：<code>Fetch</code>，通过<code>Fetch</code>提供的<code>fetch()</code>这个全局函数方法可以很简单地发起异步请求，并且支持<code>Promise</code>的回调。但是 Fetch API 是比较新的 API，具体使用的时候还需要查查 <a href=\"https://link.juejin.im?target=https%3A%2F%2Fcaniuse.com%2F\" target=\"_blank\" rel=\"noopener\">caniuse</a>，看下其浏览器兼容情况。</p>\n<p>看一个简单的例子：</p>\n<pre><code>fetch(&apos;some/api/data.json&apos;, {\n  method:&apos;POST&apos;, //请求类型 GET、POST\n  headers:{}, // 请求的头信息，形式为 Headers 对象或 ByteString\n  body:{}, //请求发送的数据 blob、BufferSource、FormData、URLSearchParams（get 或head 方法中不能包含 body）\n  mode:&apos;&apos;, //请求的模式，是否跨域等，如 cors、 no-cors 或 same-origin\n  credentials:&apos;&apos;, //cookie 的跨域策略，如 omit、same-origin 或 include\n  cache:&apos;&apos;, //请求的 cache 模式: default、no-store、reload、no-cache、 force-cache 或 only-if-cached\n}).then(function(response) { ... });\n</code></pre><p>复制</p>\n<p><code>Fetch</code> 支持<code>headers</code>定义，通过<code>headers</code>自定义可以方便地实现多种请求方法（ PUT、GET、POST 等）、请求头（包括跨域）和<code>cache</code>策略等；除此之外还支持 response（返回数据）多种类型，比如支持二进制文件、字符串和<code>formData</code>等。</p>\n<h3 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a><strong>跨域</strong></h3><blockquote>\n<p>题目：如何实现跨域？</p>\n</blockquote>\n<p>浏览器中有 <strong>同源策略</strong> ，即一个域下的页面中，无法通过 Ajax 获取到其他域的接口。例如有一个接口<code>http://m.juejin.com/course/ajaxcourserecom?cid=459</code>，你自己的一个页面<code>http://www.yourname.com/page1.html</code>中的 Ajax 无法获取这个接口。这正是命中了“同源策略”。如果浏览器哪些地方忽略了同源策略，那就是浏览器的安全漏洞，需要紧急修复。</p>\n<p>url 哪些地方不同算作跨域？</p>\n<ul>\n<li>协议</li>\n<li>域名</li>\n<li>端口</li>\n</ul>\n<p>但是 HTML 中几个标签能逃避过同源策略——<code>&lt;script src=&quot;xxx&quot;&gt;</code>、<code>&lt;img src=&quot;xxxx&quot;/&gt;</code>、<code>&lt;link href=&quot;xxxx&quot;&gt;</code>，这三个标签的<code>src/href</code>可以加载其他域的资源，不受同源策略限制。</p>\n<p>因此，这使得这三个标签可以做一些特殊的事情。</p>\n<ul>\n<li><code>&lt;img&gt;</code>可以做打点统计，因为统计方并不一定是同域的，在讲解 JS 基础知识异步的时候有过代码示例。除了能跨域之外，<code>&lt;img&gt;</code>几乎没有浏览器兼容问题，它是一个非常古老的标签。</li>\n<li><code>&lt;script&gt;</code>和<code>&lt;link&gt;</code>可以使用 CDN，CDN 基本都是其他域的链接。</li>\n<li>另外<code>&lt;script&gt;</code>还可以实现 JSONP，能获取其他域接口的信息，接下来马上讲解。</li>\n</ul>\n<p>但是请注意，所有的跨域请求方式，最终都需要信息提供方来做出相应的支持和改动，也就是要经过信息提供方的同意才行，否则接收方是无法得到它们的信息的，浏览器是不允许的。</p>\n<h3 id=\"解决跨域-JSONP\"><a href=\"#解决跨域-JSONP\" class=\"headerlink\" title=\"解决跨域 - JSONP\"></a><strong>解决跨域 - JSONP</strong></h3><p>首先，有一个概念你要明白，例如访问<code>http://coding.m.juejin.com/classindex.html</code>的时候，服务器端就一定有一个<code>classindex.html</code>文件吗？—— 不一定，服务器可以拿到这个请求，动态生成一个文件，然后返回。 同理，<code>&lt;script src=&quot;http://coding.m.juejin.com/api.js&quot;&gt;</code>也不一定加载一个服务器端的静态文件，服务器也可以动态生成文件并返回。OK，接下来正式开始。</p>\n<p>例如我们的网站和掘金网，肯定不是一个域。我们需要掘金网提供一个接口，供我们来获取。首先，我们在自己的页面这样定义</p>\n<pre><code>&lt;script&gt;\nwindow.callback = function (data) {\n    // 这是我们跨域得到信息\n    console.log(data)\n}\n&lt;/script&gt;\n</code></pre><p>复制</p>\n<p>然后掘金网给我提供了一个<code>http://coding.m.juejin.com/api.js</code>，内容如下（之前说过，服务器可动态生成内容）</p>\n<pre><code>callback({x:100, y:200})\n</code></pre><p>复制</p>\n<p>最后我们在页面中加入<code>&lt;script src=&quot;http://coding.m.juejin.com/api.js&quot;&gt;&lt;/script&gt;</code>，那么这个js加载之后，就会执行内容，我们就得到内容了。</p>\n<h3 id=\"解决跨域-服务器端设置-http-header\"><a href=\"#解决跨域-服务器端设置-http-header\" class=\"headerlink\" title=\"解决跨域 - 服务器端设置 http header\"></a><strong>解决跨域 - 服务器端设置 http header</strong></h3><p>这是需要在服务器端设置的，作为前端工程师我们不用详细掌握，但是要知道有这么个解决方案。而且，现在推崇的跨域解决方案是这一种，比 JSONP 简单许多。</p>\n<pre><code>response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://m.juejin.com/&quot;);  // 第二个参数填写允许跨域的域名称，不建议直接写 &quot;*&quot;\nresponse.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;);\nresponse.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;);\n\n// 接收跨域的cookie\nresponse.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);\n</code></pre><p>复制</p>\n<hr>\n<h2 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a><strong>存储</strong></h2><blockquote>\n<p>题目：cookie 和 localStorage 有何区别？</p>\n</blockquote>\n<h3 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a><strong>cookie</strong></h3><p>cookie 本身不是用来做服务器端存储的（计算机领域有很多这种“狗拿耗子”的例子，例如 CSS 中的 float），它是设计用来在服务器和客户端进行信息传递的，因此我们的每个 HTTP 请求都带着 cookie。但是 cookie 也具备浏览器端存储的能力（例如记住用户名和密码），因此就被开发者用上了。</p>\n<p>使用起来也非常简单，<code>document.cookie = ....</code>即可。</p>\n<p>但是 cookie 有它致命的缺点：</p>\n<ul>\n<li>存储量太小，只有 4KB</li>\n<li>所有 HTTP 请求都带着，会影响获取资源的效率</li>\n<li>API 简单，需要封装才能用</li>\n</ul>\n<h3 id=\"locationStorage-和-sessionStorage\"><a href=\"#locationStorage-和-sessionStorage\" class=\"headerlink\" title=\"locationStorage 和 sessionStorage\"></a><strong>locationStorage 和 sessionStorage</strong></h3><p>后来，HTML5 标准就带来了<code>sessionStorage</code>和<code>localStorage</code>，先拿<code>localStorage</code>来说，它是专门为了浏览器端缓存而设计的。其优点有：</p>\n<ul>\n<li>存储量增大到 5MB</li>\n<li>不会带到 HTTP 请求中</li>\n<li>API 适用于数据存储 <code>localStorage.setItem(key, value)`</code>localStorage.getItem(key)`</li>\n</ul>\n<p><code>sessionStorage</code>的区别就在于它是根据 session 过去时间而实现，而<code>localStorage</code>会永久有效，应用场景不同。例如，一些需要及时失效的重要信息放在<code>sessionStorage</code>中，一些不重要但是不经常设置的信息，放在<code>localStorage</code>中。</p>\n<p>另外告诉大家一个小技巧，针对<code>localStorage.setItem</code>，使用时尽量加入到<code>try-catch</code>中，某些浏览器是禁用这个 API 的，要注意。</p>\n<hr>\n<h2 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h2><p>本小节总结了 W3C 标准中 Web-API 部分，面试中常考的知识点，这些也是日常开发中最常用的 API 和知识。</p>\n<p>上一篇：<a href=\"541671\">一面 1：ES 基础知识点与高频考题解析</a>下一篇：<a href=\"541673\">一面 3：CSS-HTML 知识点与高频考题解析</a></p>\n<h1 id=\"一面-3：CSS-HTML-知识点与高频考题解析\"><a href=\"#一面-3：CSS-HTML-知识点与高频考题解析\" class=\"headerlink\" title=\"一面 3：CSS-HTML 知识点与高频考题解析\"></a><strong>一面 3：CSS-HTML 知识点与高频考题解析</strong></h1><p>CSS 和 HTML 是网页开发中布局相关的组成部分，涉及的内容比较多和杂乱，本小节重点介绍下常考的知识点。</p>\n<h2 id=\"知识点梳理-2\"><a href=\"#知识点梳理-2\" class=\"headerlink\" title=\"知识点梳理\"></a><strong>知识点梳理</strong></h2><ul>\n<li>选择器的权重和优先级</li>\n<li>盒模型<ul>\n<li>盒子大小计算</li>\n<li>margin 的重叠计算</li>\n</ul>\n</li>\n<li>浮动<code>float</code><ul>\n<li>浮动布局概念</li>\n<li>清理浮动</li>\n</ul>\n</li>\n<li>定位<code>position</code><ul>\n<li>文档流概念</li>\n<li>定位分类</li>\n<li>fixed 定位特点</li>\n<li>绝对定位计算方式</li>\n</ul>\n</li>\n<li><code>flex</code>布局</li>\n<li>如何实现居中对齐？</li>\n<li>理解语义化</li>\n<li>CSS3 动画</li>\n<li>重绘和回流</li>\n</ul>\n<hr>\n<h2 id=\"选择器的权重和优先级\"><a href=\"#选择器的权重和优先级\" class=\"headerlink\" title=\"选择器的权重和优先级\"></a><strong>选择器的权重和优先级</strong></h2><p>CSS 选择器有很多，不同的选择器的权重和优先级不一样，对于一个元素，如果存在多个选择器，那么就需要根据权重来计算其优先级。</p>\n<p>权重分为四级，分别是：</p>\n<ol>\n<li>代表内联样式，如<code>style=&quot;xxx&quot;</code>，权值为 1000；</li>\n<li>代表 ID 选择器，如<code>#content</code>，权值为 100；</li>\n<li>代表类、伪类和属性选择器，如<code>.content</code>、<code>:hover</code>、<code>[attribute]</code>，权值为 10；</li>\n<li>代表元素选择器和伪元素选择器，如<code>div</code>、<code>p</code>，权值为 1。</li>\n</ol>\n<p><strong>需要注意的是：通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以他们的权值都为 0</strong>。 权重值大的选择器其优先级也高，相同权重的优先级又遵循后定义覆盖前面定义的情况。</p>\n<h2 id=\"盒模型\"><a href=\"#盒模型\" class=\"headerlink\" title=\"盒模型\"></a><strong>盒模型</strong></h2><h3 id=\"什么是“盒子”\"><a href=\"#什么是“盒子”\" class=\"headerlink\" title=\"什么是“盒子”\"></a><strong>什么是“盒子”</strong></h3><p>初学 CSS 的朋友，一开始学 CSS 基础知识的时候一定学过<code>padding`</code>border<code>和</code>margin`，即内边距、边框和外边距。它们三者就构成了一个“盒子”。就像我们收到的快递，本来买了一部小小的手机，收到的却是那么大一个盒子。因为手机白色的包装盒和手机机器之间有间隔层（内边距），手机白色盒子有厚度，虽然很薄（边框），盒子和快递箱子之间还有一层泡沫板（外边距）。这就是一个典型的盒子。</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>如上图，真正的内容就是这些文字，文字外围有 10px 的内边距，5px 的边框，10px 的外边距。看到盒子了吧？</p>\n<blockquote>\n<p>题目：盒子模型的宽度如何计算</p>\n</blockquote>\n<h3 id=\"固定宽度的盒子\"><a href=\"#固定宽度的盒子\" class=\"headerlink\" title=\"固定宽度的盒子\"></a><strong>固定宽度的盒子</strong></h3><pre><code>&lt;div style=&quot;padding:10px; border:5px solid blue; margin: 10px; width:300px;&quot;&gt;\n    之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》，\n    文章言简意赅的介绍的浏览器的工作过程，web前端\n&lt;/div&gt;\n</code></pre><p>复制</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>如上图，得到网页效果之后，我们可以用截图工具来量一下文字内容的宽度。发现，文字内容的宽度刚好是 300px，也就是我们设置的宽度。</p>\n<p>因此，<strong>在盒子模型中，我们设置的宽度都是内容宽度，不是整个盒子的宽度。而整个盒子的宽度是：（内容宽度 + <code>border</code>宽度 + <code>padding</code>宽度 + <code>margin</code>宽度）之和</strong>。这样我们改四个中的其中一个，都会导致盒子宽度的改变。这对我们来说不友好。</p>\n<p>没关系，这个东西不友好早就有人发现了，而且已经解决，下文再说。</p>\n<h3 id=\"充满父容器的盒子\"><a href=\"#充满父容器的盒子\" class=\"headerlink\" title=\"充满父容器的盒子\"></a><strong>充满父容器的盒子</strong></h3><p>默认情况下，<code>div</code>是<code>display:block</code>，宽度会充满整个父容器。如下图：</p>\n<pre><code>&lt;div style=&quot;padding:10px; border:5px solid blue; margin: 10px; width:300px;&quot;&gt;\n    之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》，\n    文章言简意赅的介绍的浏览器的工作过程，web前端\n    之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》，\n    文章言简意赅的介绍的浏览器的工作过程，web前端\n&lt;/div&gt;\n</code></pre><p>复制</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>但是别忘记，这个 div 是个盒子模型，它的整个宽度包括（内容宽度 + <code>border</code>宽度 + <code>padding</code>宽度 + <code>margin</code>宽度），整个的宽度充满父容器。</p>\n<p>问题就在这里。如果父容器宽度不变，我们手动增大<code>margin</code>、<code>border</code>或<code>padding</code>其中一项的宽度值，都会导致内容宽度的减少。极端情况下，如果内容的宽度压缩到不能再压缩了（例如一个字的宽度），那么浏览器会强迫增加父容器的宽度。这可不是我们想要看到的。</p>\n<h3 id=\"包裹内容的盒子\"><a href=\"#包裹内容的盒子\" class=\"headerlink\" title=\"包裹内容的盒子\"></a><strong>包裹内容的盒子</strong></h3><p>这种情况下比较简单，内容的宽度按照内容计算，盒子的宽度将在内容宽度的基础上再增加（<code>padding</code>宽度 + <code>border</code>宽度 + <code>margin</code>宽度）之和。</p>\n<pre><code>&lt;div style=&quot;padding:10px; border:5px solid blue; margin: 10px; width:300px;&quot;&gt;\n    之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》\n&lt;/div&gt;\n</code></pre><p>复制</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<h3 id=\"box-sizing-border-box\"><a href=\"#box-sizing-border-box\" class=\"headerlink\" title=\"box-sizing:border-box\"></a><code>box-sizing:border-box</code></h3><p>前面提到，为盒子模型设置宽度，结果只是设置了内容的宽度，这个不合理。如何解决这一问题？答案就是为盒子指定样式：<strong><code>box-sizing:border-box</code></strong>。</p>\n<pre><code>&lt;div style=&quot;padding:10px; border:5px solid blue; margin: 10px; width:300px; box-sizing:border-box;&quot;&gt;\n    之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》\n&lt;/div&gt;\n</code></pre><p>复制</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>上图中，为<code>div</code>设置了<code>box-sizing:border-box</code>之后，300px 的<strong>宽度是内容 + <code>border</code> + 边框的宽度（不包括<code>margin</code>）</strong>，这样就比较符合我们的实际要求了。建议大家在为系统写 CSS 时候，第一个样式是：</p>\n<pre><code>* {\n    box-sizing:border-box;\n}\n</code></pre><p>复制</p>\n<p>大名鼎鼎的 Bootstrap 也把<code>box-sizing:border-box</code>加入到它的<code>*</code>选择器中，我们为什么不这样做呢？</p>\n<h3 id=\"纵向-margin-重叠\"><a href=\"#纵向-margin-重叠\" class=\"headerlink\" title=\"纵向 margin 重叠\"></a><strong>纵向 margin 重叠</strong></h3><p>这里提到 margin，就不得不提一下 margin 的这一特性——纵向重叠。如<code>&lt;p&gt;</code>的纵向 margin 是 16px，那么两个<code>&lt;p&gt;</code>之间纵向的距离是多少？—— 按常理来说应该是 16 + 16 = 32px，但是答案仍然是 16px。因为纵向的 margin 是会重叠的，如果两者不一样大的话，大的会把小的“吃掉”。</p>\n<hr>\n<h2 id=\"浮动float\"><a href=\"#浮动float\" class=\"headerlink\" title=\"浮动float\"></a><strong>浮动<code>float</code></strong></h2><p>float 用于网页布局比较多，使用起来也比较简单，这里总结了一些比较重要、需要注意的知识点，供大家参考。</p>\n<h3 id=\"误解和误用\"><a href=\"#误解和误用\" class=\"headerlink\" title=\"误解和误用\"></a><strong>误解和误用</strong></h3><p>float 被设计出来的初衷是用于<strong>文字环绕效果</strong>，即一个图片一段文字，图片<code>float:left</code>之后，文字会环绕图片。</p>\n<pre><code>&lt;div&gt;\n    &lt;img src=&quot;image/1.png&quot; style=&quot;float:left&quot;&gt;\n    一段文字一段文字一段文字一段文字一段文字一段文字一段文字一段文字一段文字\n&lt;/div&gt;\n</code></pre><p>复制</p>\n<p>但是，后来大家发现结合<code>float + div</code>可以实现之前通过<code>table</code>实现的网页布局，因此就被“误用”于网页布局了。</p>\n<blockquote>\n<p>题目：为何 float 会导致父元素塌陷？</p>\n</blockquote>\n<h3 id=\"破坏性\"><a href=\"#破坏性\" class=\"headerlink\" title=\"破坏性\"></a><strong>破坏性</strong></h3><p>![](data:image/svg+xml;utf8,)</p>\n<p>float 的<strong>破坏性</strong> —— float 破坏了父标签的原本结构，使得父标签出现了坍塌现象。导致这一现象的最根本原因在于：<strong>被设置了 float 的元素会脱离文档流</strong>。其根本原因在于 float 的设计初衷是解决文字环绕图片的问题。大家要记住 float 的这个影响。</p>\n<h3 id=\"包裹性\"><a href=\"#包裹性\" class=\"headerlink\" title=\"包裹性\"></a><strong>包裹性</strong></h3><p><strong>包裹性</strong>也是 float 的一个非常重要的特性，大家用 float 时一定要熟知这一特性。咱们还是先从一个小例子看起：</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>如上图，普通的 div 如果没有设置宽度，它会撑满整个屏幕，在之前的盒子模型那一节也讲到过。而如果给 div 增加<code>float:left</code>之后，它突然变得紧凑了，宽度发生了变化，把内容中的三个字包裹了——这就是包裹性。为 div 设置了 float 之后，其宽度会自动调整为包裹住内容宽度，而不是撑满整个父容器。</p>\n<p>注意，此时 div 虽然体现了包裹性，但是它的 display 样式是没有变化的，还是<code>display: block</code>。</p>\n<p>float 为什么要具有包裹性？其实答案还是得从 float 的设计初衷来寻找，float 是被设计用于实现文字环绕效果的。文字环绕图片比较好理解，但是如果想要让文字环绕一个 div 呢？此时 div 不被“包裹”起来的话，就无法实现环绕效果了。</p>\n<h3 id=\"清空格\"><a href=\"#清空格\" class=\"headerlink\" title=\"清空格\"></a><strong>清空格</strong></h3><p>float 还有一个大家可能不是很熟悉的特性——清空格。按照惯例，咱还是先举例子说明。</p>\n<pre><code>&lt;div style=&quot;border: 2px solid blue; padding:3px;&quot;&gt;\n    &lt;img src=&quot;image/1.png&quot;/&gt;\n    &lt;img src=&quot;image/2.png&quot;/&gt;\n    &lt;img src=&quot;image/3.png&quot;/&gt;\n    &lt;img src=&quot;image/4.png&quot;/&gt;\n&lt;/div&gt;\n</code></pre><p>复制</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>加上<code>float:left</code>之后：</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>上面第一张图中，正常的 img 中间是会有空格的，因为多个 img 标签会有换行，而浏览器识别换行为空格，这也是很正常的。第二张图中，为 img 增加了<code>float:left</code>的样式，这就使得 img 之间没有了空格，4 个 img 紧紧挨着。</p>\n<p>如果大家之前没注意，现在想想之前写过的程序，是不是有这个特性。为什么 float 适合用于网页排版（俗称“砌砖头”）？就是因为 float 排版出来的网页严丝合缝，中间连个苍蝇都飞不进去。</p>\n<p>“清空格”这一特性的根本原因是 float 会导致节点脱离文档流结构。它都不属于文档流结构了，那么它身边的什么换行、空格就都和它没了关系，它就尽量往一边靠拢，能靠多近就靠多近，这就是清空格的本质。</p>\n<blockquote>\n<p>题目：手写 clearfix</p>\n</blockquote>\n<h3 id=\"clearfix\"><a href=\"#clearfix\" class=\"headerlink\" title=\"clearfix\"></a><strong><code>clearfix</code></strong></h3><p>清除浮动的影响，一般使用的样式如下，统称<code>clearfix</code>代码。所有 float 元素的父容器，一般情况下都应该加<code>clearfix</code>这个 class。</p>\n<pre><code>.clearfix:after {\n    content: &apos;&apos;;\n    display: table;\n    clear: both;\n}\n.clearfix {\n    *zoom: 1; /* 兼容 IE 低版本 */\n}\n</code></pre><p>复制</p>\n<pre><code>&lt;div class=&quot;clearfix&quot;&gt;\n    &lt;img src=&quot;image/1.png&quot; style=&quot;float: left&quot;/&gt;\n    &lt;img src=&quot;image/2.png&quot; style=&quot;float: left&quot;/&gt;\n&lt;/div&gt;\n</code></pre><p>复制</p>\n<h3 id=\"小结-2\"><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h3><p>float 的设计初衷是解决文字环绕图片的问题，后来误打误撞用于做布局，因此有许多不合适或者需要注意的地方，上文基本都讲到了需要的知识点。如果是刚开始接触 float 的同学，学完上面的基础知识之后，还应该做一些练习实战一下 —— 经典的“圣杯布局”和“双飞翼布局”。这里就不再展开讲了，网上资料非常多，例如<a href=\"https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fentry%2F5a8868cdf265da4e7e10c133%3Futm_source%3Dgold_browser_extension\" target=\"_blank\" rel=\"noopener\">浅谈面试中常考的两种经典布局——圣杯与双飞翼</a>（此文的最后两张图清晰地展示了这两种布局）。</p>\n<hr>\n<h2 id=\"定位position\"><a href=\"#定位position\" class=\"headerlink\" title=\"定位position\"></a><strong>定位<code>position</code></strong></h2><p>position 用于网页元素的定位，可设置 static/relative/absolute/fixed 这些值，其中 static 是默认值，不用介绍。</p>\n<blockquote>\n<p>题目：relative 和 absolute 有何区别？</p>\n</blockquote>\n<h3 id=\"relative\"><a href=\"#relative\" class=\"headerlink\" title=\"relative\"></a><strong>relative</strong></h3><p>相对定位 relative 可以用一个例子很轻松地演示出来。例如我们写 4 个<code>&lt;p&gt;</code>，出来的样子大家不用看也能知道。</p>\n<pre><code>&lt;p&gt;第一段文字&lt;/p&gt;\n&lt;p&gt;第二段文字&lt;/p&gt;\n&lt;p&gt;第三段文字&lt;/p&gt;\n&lt;p&gt;第四段文字&lt;/p&gt;\n</code></pre><p>复制</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>然后我们在第三个<code>&lt;p&gt;</code>上面，加上<code>position:relative</code>并且设置<code>left</code>和<code>top</code>值，看这个<code>&lt;p&gt;</code>有什么变化。</p>\n<pre><code>&lt;p&gt;第一段文字&lt;/p&gt;\n&lt;p&gt;第二段文字&lt;/p&gt;\n&lt;p style=&quot;position:relative; top: 10px; left: 10px&quot;&gt;第三段文字&lt;/p&gt;\n&lt;p&gt;第四段文字&lt;/p&gt;\n</code></pre><p>复制</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>上图中，大家应该要识别出两个信息（相信大部分人会忽略第二个信息）</p>\n<ul>\n<li>第三个<code>&lt;p&gt;</code>发生了位置变化，分别向右向下移动了10px；</li>\n<li>其他的三个<code>&lt;p&gt;</code>位置没有发生变化，这一点也很重要。</li>\n</ul>\n<p>可见，<strong>relative 会导致自身位置的相对变化，而不会影响其他元素的位置、大小</strong>。这是 relative 的要点之一。还有第二个要点，就是 relative 产生一个新的定位上下文。下文有关于定位上下文的详细介绍，这里可以先通过一个例子来展示一下区别：</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>注意看这两图的区别，下文将有解释。</p>\n<h3 id=\"absolute\"><a href=\"#absolute\" class=\"headerlink\" title=\"absolute\"></a><strong>absolute</strong></h3><p>还是先写一个基本的 demo。</p>\n<pre><code>&lt;p&gt;第一段文字&lt;/p&gt;\n&lt;p&gt;第二段文字&lt;/p&gt;\n&lt;p style=&quot;background: yellow&quot;&gt;第三段文字&lt;/p&gt;\n&lt;p&gt;第四段文字&lt;/p&gt;\n</code></pre><p>复制</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>然后，我们把第三个<code>&lt;p&gt;</code>改为<code>position:absolute;</code>，看看会发生什么变化。</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>从上面的结果中，我们能看出几点信息：</p>\n<ul>\n<li>absolute 元素脱离了文档结构。和 relative 不同，其他三个元素的位置重新排列了。只要元素会脱离文档结构，它就会产生破坏性，导致父元素坍塌。（此时你应该能立刻想起来，float 元素也会脱离文档结构。）</li>\n<li>absolute 元素具有“包裹性”。之前<code>&lt;p&gt;</code>的宽度是撑满整个屏幕的，而此时<code>&lt;p&gt;</code>的宽度刚好是内容的宽度。</li>\n<li>absolute 元素具有“跟随性”。虽然 absolute 元素脱离了文档结构，但是它的位置并没有发生变化，还是老老实实地呆在它原本的位置，因为我们此时没有设置 top、left 的值。</li>\n<li>absolute 元素会悬浮在页面上方，会遮挡住下方的页面内容。</li>\n</ul>\n<p>最后，通过给 absolute元素设置 top、left 值，可自定义其内容，这个都是平时比较常用的了。这里需要注意的是，设置了 top、left 值时，元素是相对于最近的定位上下文来定位的，而不是相对于浏览器定位。</p>\n<h3 id=\"fixed\"><a href=\"#fixed\" class=\"headerlink\" title=\"fixed\"></a><strong>fixed</strong></h3><p>其实 fixed 和 absolute 是一样的，唯一的区别在于：absolute 元素是根据最近的定位上下文确定位置，而 fixed 根据浏览器确定位置。</p>\n<blockquote>\n<p>题目：relative、absolute 和 fixed 分别依据谁来定位？</p>\n</blockquote>\n<h3 id=\"定位上下文\"><a href=\"#定位上下文\" class=\"headerlink\" title=\"定位上下文\"></a><strong>定位上下文</strong></h3><p>relative 元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>fixed 元素的定位是相对于浏览器边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>absolute 的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了<code>position:relative/absolute/fixed</code>的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。如下两个图所示：</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<hr>\n<h2 id=\"flex布局\"><a href=\"#flex布局\" class=\"headerlink\" title=\"flex布局\"></a><strong><code>flex</code>布局</strong></h2><p>布局的传统解决方案基于盒子模型，依赖 <code>display</code> 属性 + <code>position</code> 属性 + <code>float</code> 属性。它对于那些特殊布局非常不方便，比如，垂直居中（下文会专门讲解）就不容易实现。在目前主流的移动端页面中，使用 flex 布局能更好地完成需求，因此 flex 布局的知识是必须要掌握的。</p>\n<h3 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a><strong>基本使用</strong></h3><p>任何一个容器都可以使用 flex 布局，代码也很简单。</p>\n<pre><code>&lt;style type=&quot;text/css&quot;&gt;\n    .container {\n      display: flex;\n    }\n    .item {\n        border: 1px solid #000;\n        flex: 1;\n    }\n&lt;/style&gt;\n\n&lt;div class=&quot;container&quot;&gt;\n    &lt;div class=&quot;item&quot;&gt;aaa&lt;/div&gt;\n    &lt;div class=&quot;item&quot; style=&quot;flex: 2&quot;&gt;bbb&lt;/div&gt;\n    &lt;div class=&quot;item&quot;&gt;ccc&lt;/div&gt;\n    &lt;div class=&quot;item&quot;&gt;ddd&lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>复制</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>注意，第三个<code>&lt;div&gt;</code>的<code>flex: 2</code>，其他的<code>&lt;div&gt;</code>的<code>flex: 1</code>，这样第二个<code>&lt;div&gt;</code>的宽度就是其他的<code>&lt;div&gt;</code>的两倍。</p>\n<h3 id=\"设计原理\"><a href=\"#设计原理\" class=\"headerlink\" title=\"设计原理\"></a><strong>设计原理</strong></h3><p>设置了<code>display: flex</code>的元素，我们称为“容器”（flex container），其所有的子节点我们称为“成员”（flex item）。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>将以上文字和图片结合起来，再详细看一遍，这样就能理解 flex 的设计原理，才能更好地实际使用。</p>\n<h3 id=\"设置主轴的方向\"><a href=\"#设置主轴的方向\" class=\"headerlink\" title=\"设置主轴的方向\"></a><strong>设置主轴的方向</strong></h3><p><code>flex-direction</code>可决定主轴的方向，有四个可选值：</p>\n<ul>\n<li>row（默认值）：主轴为水平方向，起点在左端。</li>\n<li>row-reverse：主轴为水平方向，起点在右端。</li>\n<li>column：主轴为垂直方向，起点在上沿。</li>\n<li><p>column-reverse：主轴为垂直方向，起点在下沿。</p>\n<p>.box {<br>  flex-direction: column-reverse| column | row | row-reverse;<br>}</p>\n</li>\n</ul>\n<p>复制</p>\n<p>以上代码设置的主轴方向，将依次对应下图：</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<h3 id=\"设置主轴的对齐方式\"><a href=\"#设置主轴的对齐方式\" class=\"headerlink\" title=\"设置主轴的对齐方式\"></a><strong>设置主轴的对齐方式</strong></h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式，值如下：</p>\n<ul>\n<li>flex-start（默认值）：向主轴开始方向对齐。</li>\n<li>flex-end：向主轴结束方向对齐。</li>\n<li>center： 居中。</li>\n<li>space-between：两端对齐，项目之间的间隔都相等。</li>\n<li><p>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</p>\n<p>.box {</p>\n<pre><code>justify-content: flex-start | flex-end | center | space-between | space-around;\n</code></pre><p>}</p>\n</li>\n</ul>\n<p>复制</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<h3 id=\"交叉轴的对齐方式\"><a href=\"#交叉轴的对齐方式\" class=\"headerlink\" title=\"交叉轴的对齐方式\"></a><strong>交叉轴的对齐方式</strong></h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐，值如下：</p>\n<ul>\n<li>flex-start：交叉轴的起点对齐。</li>\n<li>flex-end：交叉轴的终点对齐。</li>\n<li>center：交叉轴的中点对齐。</li>\n<li>baseline: 项目的第一行文字的基线对齐。</li>\n<li><p>stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。</p>\n<p>.box {</p>\n<pre><code>align-items: flex-start | flex-end | center | baseline | stretch;\n</code></pre><p>}</p>\n</li>\n</ul>\n<p>复制</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<hr>\n<h2 id=\"如何实现居中对齐？\"><a href=\"#如何实现居中对齐？\" class=\"headerlink\" title=\"如何实现居中对齐？\"></a><strong>如何实现居中对齐？</strong></h2><blockquote>\n<p>题目：如何实现水平居中？</p>\n</blockquote>\n<h3 id=\"水平居中\"><a href=\"#水平居中\" class=\"headerlink\" title=\"水平居中\"></a><strong>水平居中</strong></h3><p>inline 元素用<code>text-align: center;</code>即可，如下：</p>\n<pre><code>.container {\n   text-align: center;\n}\n</code></pre><p>复制</p>\n<p>block 元素可使用<code>margin: auto;</code>，PC 时代的很多网站都这么搞。</p>\n<pre><code>.container {\n    text-align: center; \n}\n.item {\n    width: 1000px;\n    margin: auto; \n}\n</code></pre><p>复制</p>\n<p>绝对定位元素可结合<code>left</code>和<code>margin</code>实现，但是必须知道宽度。</p>\n<pre><code>.container {\n    position: relative;\n    width: 500px;\n}\n.item {\n    width: 300px;\n    height: 100px;\n    position: absolute;\n    left: 50%;\n    margin: -150px;\n}\n</code></pre><p>复制</p>\n<blockquote>\n<p>题目：如何实现垂直居中？</p>\n</blockquote>\n<h3 id=\"垂直居中\"><a href=\"#垂直居中\" class=\"headerlink\" title=\"垂直居中\"></a><strong>垂直居中</strong></h3><p>inline 元素可设置<code>line-height</code>的值等于<code>height</code>值，如单行文字垂直居中：</p>\n<pre><code>.container {\n   height: 50px;\n   line-height: 50px;\n}\n</code></pre><p>复制</p>\n<p>绝对定位元素，可结合<code>left</code>和<code>margin</code>实现，但是必须知道尺寸。</p>\n<ul>\n<li>优点：兼容性好</li>\n<li><p>缺点：需要提前知道尺寸</p>\n<p>.container {</p>\n<pre><code>position: relative;\nheight: 200px;\n</code></pre><p>}<br>.item {</p>\n<pre><code>width: 80px;\nheight: 40px;\nposition: absolute;\nleft: 50%;\ntop: 50%;\nmargin-top: -20px;\nmargin-left: -40px;\n</code></pre><p>}</p>\n</li>\n</ul>\n<p>复制</p>\n<p>绝对定位可结合<code>transform</code>实现居中。</p>\n<ul>\n<li>优点：不需要提前知道尺寸</li>\n<li><p>缺点：兼容性不好</p>\n<p>.container {</p>\n<pre><code>position: relative;\nheight: 200px;\n</code></pre><p>}<br>.item {</p>\n<pre><code>width: 80px;\nheight: 40px;\nposition: absolute;\nleft: 50%;\ntop: 50%;\ntransform: translate(-50%, -50%);\nbackground: blue;\n</code></pre><p>}</p>\n</li>\n</ul>\n<p>复制</p>\n<p>绝对定位结合<code>margin: auto</code>，不需要提前知道尺寸，兼容性好。</p>\n<pre><code>.container {\n    position: relative;\n    height: 300px;\n}\n.item {\n    width: 100px;\n    height: 50px;\n    position: absolute;\n    left: 0;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    margin: auto;\n}\n</code></pre><p>复制</p>\n<p>其他的解决方案还有，不过没必要掌握太多，能说出上文的这几个解决方案即可。</p>\n<hr>\n<h2 id=\"理解语义化\"><a href=\"#理解语义化\" class=\"headerlink\" title=\"理解语义化\"></a><strong>理解语义化</strong></h2><blockquote>\n<p>题目：如何理解 HTML 语义化？</p>\n</blockquote>\n<p>所谓“语义”就是为了更易读懂，这要分两部分：</p>\n<ul>\n<li>让人（写程序、读程序）更易读懂</li>\n<li>让机器（浏览器、搜索引擎）更易读懂</li>\n</ul>\n<h3 id=\"让人更易读懂\"><a href=\"#让人更易读懂\" class=\"headerlink\" title=\"让人更易读懂\"></a><strong>让人更易读懂</strong></h3><p>对于人来说，代码可读性、语义化就是一个非常广泛的概念了，例如定义 JS 变量的时候使用更易读懂的名称，定义 CSS class 的时候也一样，例如<code>length`</code>list<code>等，而不是使用</code>a<code></code>b`这种谁都看不懂的名称。</p>\n<p>不过我们平常考查的“语义化”并不会考查这么广义、这么泛的问题，而是考查 HTML 的语义化，是为了更好地让机器读懂 HTML。</p>\n<h3 id=\"让机器更易读懂\"><a href=\"#让机器更易读懂\" class=\"headerlink\" title=\"让机器更易读懂\"></a><strong>让机器更易读懂</strong></h3><p>HTML 符合 XML 标准，但又和 XML 不一样 —— HTML 不允许像 XML 那样自定义标签名称，HTML 有自己规定的标签名称。问题就在这里 —— HTML 为何要自己规定那么多标签名称呢，例如<code>p`</code>div<code>h1</code>ul<code>等 —— 就是为了语义化。其实，如果你精通 CSS 的话，你完全可以全部用</code><div><code>标签来实现所有的网页效果，其他的</code>p<code>h1</code>ul`等标签可以一个都不用。但是我们不推荐这么做，这样做就失去了 HTML 语义化的意义。</div></p>\n<p>拿搜索引擎来说，爬虫下载到我们网页的 HTML 代码，它如何更好地去理解网页的内容呢？—— 就是根据 HTML 既定的标签。<code>h1</code>标签就代表是标题；<code>p</code>里面的就是段落详细内容，权重肯定没有标题高；<code>ul</code>里面就是列表；<code>strong</code>就是加粗的强调的内容 …… 如果我们不按照 HTML 语义化来写，全部都用<code>&lt;div&gt;</code>标签，那搜索引擎将很难理解我们网页的内容。</p>\n<p>为了加强 HTML 语义化，HTML5 标准中又增加了<code>header`</code>section<code></code>artical`等标签。因此，书写 HTML 时，语义化是非常重要的，否则 W3C 也没必要辛辛苦苦制定出这些标准来。</p>\n<hr>\n<h2 id=\"CSS3-动画\"><a href=\"#CSS3-动画\" class=\"headerlink\" title=\"CSS3 动画\"></a><strong>CSS3 动画</strong></h2><p>CSS3 可以实现动画，代替原来的 Flash 和 JavaScript 方案。</p>\n<p>首先，使用<code>@keyframes</code>定义一个动画，名称为<code>testAnimation</code>，如下代码，通过百分比来设置不同的 CSS 样式，规定动画的变化。所有的动画变化都可以这么定义出来。</p>\n<pre><code>@keyframes testAnimation\n{\n    0%   {background: red; left:0; top:0;}\n    25%  {background: yellow; left:200px; top:0;}\n    50%  {background: blue; left:200px; top:200px;}\n    75%  {background: green; left:0; top:200px;}\n    100% {background: red; left:0; top:0;}\n}\n</code></pre><p>复制</p>\n<p>然后，针对一个 CSS 选择器来设置动画，例如针对<code>div</code>元素设置动画，如下：</p>\n<pre><code>div {\n    width: 100px;\n    height: 50px;\n    position: absolute;\n\n    animation-name: myfirst;\n    animation-duration: 5s;\n}\n</code></pre><p>复制</p>\n<p><code>animation-name</code>对应到动画名称，<code>animation-duration</code>是动画时长，还有其他属性：</p>\n<ul>\n<li><code>animation-timing-function</code>：规定动画的速度曲线。默认是<code>ease</code></li>\n<li><code>animation-delay</code>：规定动画何时开始。默认是 0</li>\n<li><code>animation-iteration-count</code>：规定动画被播放的次数。默认是 1</li>\n<li><code>animation-direction</code>：规定动画是否在下一周期逆向地播放。默认是<code>normal</code></li>\n<li><code>animation-play-state</code> ：规定动画是否正在运行或暂停。默认是<code>running</code></li>\n<li><code>animation-fill-mode</code>：规定动画执行之前和之后如何给动画的目标应用，默认是<code>none</code>，保留在最后一帧可以用<code>forwards</code></li>\n</ul>\n<blockquote>\n<p>题目：CSS 的<code>transition</code>和<code>animation</code>有何区别？</p>\n</blockquote>\n<p>首先<code>transition</code>和<code>animation</code>都可以做动效，从语义上来理解，<code>transition</code>是过渡，由一个状态过渡到另一个状态，比如高度<code>100px</code>过渡到<code>200px</code>；而<code>animation</code>是动画，即更专业做动效的，<code>animation</code>有帧的概念，可以设置关键帧<code>keyframe</code>，一个动画可以由多个关键帧多个状态过渡组成，另外<code>animation</code>也包含上面提到的多个属性。</p>\n<h2 id=\"重绘和回流\"><a href=\"#重绘和回流\" class=\"headerlink\" title=\"重绘和回流\"></a><strong>重绘和回流</strong></h2><p>重绘和回流是面试题经常考的题目，也是性能优化当中应该注意的点，下面笔者简单介绍下。</p>\n<ul>\n<li><strong>重绘</strong>：指的是当页面中的元素不脱离文档流，而简单地进行样式的变化，比如修改颜色、背景等，浏览器重新绘制样式</li>\n<li><strong>回流</strong>：指的是处于文档流中 DOM 的尺寸大小、位置或者某些属性发生变化时，导致浏览器重新渲染部分或全部文档的情况</li>\n</ul>\n<p>相比之下，<strong>回流要比重绘消耗性能开支更大</strong>。另外，一些属性的读取也会引起回流，比如读取某个 DOM 的高度和宽度，或者使用<code>getComputedStyle</code>方法。在写代码的时候要避免回流和重绘。比如在笔试中可能会遇见下面的题目：</p>\n<blockquote>\n<p>题目：找出下面代码的优化点，并且优化它</p>\n</blockquote>\n<pre><code>var data = [&apos;string1&apos;, &apos;string2&apos;, &apos;string3&apos;];\nfor(var i = 0; i &lt; data.length; i++){\n    var dom = document.getElementById(&apos;list&apos;);\n    dom.innerHTML += &apos;&lt;li&gt;&apos; + data[i] + &apos;&lt;/li&gt;&apos;;\n}\n</code></pre><p>复制</p>\n<p>上面的代码在循环中每次都获取<code>dom</code>，然后对其内部的 HTML 进行累加<code>li</code>，每次都会操作 DOM 结构，可以改成使用<code>documentFragment</code>或者先遍历组成 HTML 的字符串，最后操作一次<code>innerHTML</code>。</p>\n<hr>\n<h2 id=\"小结-3\"><a href=\"#小结-3\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h2><p>本小节总结了 CSS 和 HTML 常考的知识点，包括 CSS 中比较重要的定位、布局的知识，也介绍了一些 CSS3 的知识点概念和题目，以及 HTML 的语义化。</p>\n<p>上一篇：<a href=\"541672\">一面 2：JS-Web-API 知识点与高频考题解析</a>下一篇：<a href=\"541674\">一面 4：从容应对算法题目</a></p>\n<h1 id=\"一面-4：从容应对算法题目\"><a href=\"#一面-4：从容应对算法题目\" class=\"headerlink\" title=\"一面 4：从容应对算法题目\"></a><strong>一面 4：从容应对算法题目</strong></h1><p>由冯·诺依曼机组成我们知道：数据存储和运算是计算机工作的主要内容。<code>程序=数据结构+算法</code>，所以计算机类工程师必须掌握一定的数据结构和算法知识。</p>\n<h2 id=\"知识点梳理-3\"><a href=\"#知识点梳理-3\" class=\"headerlink\" title=\"知识点梳理\"></a><strong>知识点梳理</strong></h2><ul>\n<li>常见的数据结构<ul>\n<li>栈、队列、链表</li>\n<li>集合、字典、散列集</li>\n</ul>\n</li>\n<li>常见算法<ul>\n<li>递归</li>\n<li>排序</li>\n<li>枚举</li>\n</ul>\n</li>\n<li>算法复杂度分析</li>\n<li>算法思维<ul>\n<li>分治</li>\n<li>贪心</li>\n<li>动态规划</li>\n</ul>\n</li>\n<li>高级数据结构<ul>\n<li>树、图</li>\n<li>深度优先和广度优先搜索</li>\n</ul>\n</li>\n</ul>\n<p>本小节会带领大家快速过一遍数据结构和算法，重点讲解一些常考、前端会用到的算法和数据结构。</p>\n<hr>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a><strong>数据结构</strong></h2><p>数据结构决定了数据存储的空间和时间效率问题，数据的写入和提取速度要求也决定了应该选择怎样的数据结构。</p>\n<p>根据对场景需求的不同，我们设计不同的数据结构，比如：</p>\n<ul>\n<li>读得多的数据结构，应该想办法提高数据的读取效率，比如 IP 数据库，只需要写一次，剩下的都是读取；</li>\n<li>读写都多的数据结构，要兼顾两者的需求平衡，比如 LRU Cache 算法。</li>\n</ul>\n<p>算法是数据加工处理的方式，一定的算法会提升数据的处理效率。比如有序数组的二分查找，要比普通的顺序查找快很多，尤其是在处理大量数据的时候。</p>\n<p>数据结构和算法是程序开发的通用技能，所以在任何面试中都可能会遇见。随着近几年 AI、大数据、小游戏越来越火，Web 前端职位难免会跟数据结构和算法打交道，面试中也会出现越来越多的算法题目。学习数据结构和算法也能够帮助我们打开思路，突破技能瓶颈。</p>\n<h2 id=\"前端常遇见的数据结构问题\"><a href=\"#前端常遇见的数据结构问题\" class=\"headerlink\" title=\"前端常遇见的数据结构问题\"></a><strong>前端常遇见的数据结构问题</strong></h2><p>现在我来梳理下前端常遇见的数据结构：</p>\n<ul>\n<li>简单数据结构（必须理解掌握）<ul>\n<li>有序数据结构：栈、队列、链表，有序数据结构省空间（存储空间小）</li>\n<li>无序数据结构：集合、字典、散列表，无序数据结构省时间（读取时间快）</li>\n</ul>\n</li>\n<li>复杂数据结构<ul>\n<li>树、堆</li>\n<li>图</li>\n</ul>\n</li>\n</ul>\n<p>对于简单数据结构，在 ES 中对应的是数组（<code>Array</code>）和对象（<code>Object</code>）。可以想一下，数组的存储是有序的，对象的存储是无序的，但是我要在对象中根据<code>key</code>找到一个值是立即返回的，数组则需要查找的过程。</p>\n<p>这里我通过一个真实面试题目来说明介绍下数据结构设计。</p>\n<blockquote>\n<p>题目：使用 ECMAScript（JS）代码实现一个事件类<code>Event</code>，包含下面功能：绑定事件、解绑事件和派发事件。</p>\n</blockquote>\n<p>在稍微复杂点的页面中，比如组件化开发的页面，同一个页面由两三个人来开发，为了保证组件的独立性和降低组件间耦合度，我们往往使用「订阅发布模式」，即组件间通信使用事件监听和派发的方式，而不是直接相互调用组件方法，这就是题目要求写的<code>Event</code>类。</p>\n<p>这个题目的核心是一个事件类型对应回调函数的数据设计。为了实现绑定事件，我们需要一个<code>_cache</code>对象来记录绑定了哪些事件。而事件发生的时候，我们需要从<code>_cache</code>中读取出来事件回调，依次执行它们。一般页面中事件派发（读）要比事件绑定（写）多。所以我们设计的数据结构应该尽量地能够在事件发生时，更加快速地找到对应事件的回调函数们，然后执行。</p>\n<p>经过这样一番考虑，我简单写了下代码实现：</p>\n<pre><code>class Event {\n    constructor() {\n        // 存储事件的数据结构\n        // 为了查找迅速，使用了对象（字典）\n        this._cache = {};\n    }\n    // 绑定\n    on(type, callback) {\n        // 为了按类查找方便和节省空间，\n        // 将同一类型事件放到一个数组中\n        // 这里的数组是队列，遵循先进先出\n        // 即先绑定的事件先触发\n        let fns = (this._cache[type] = this._cache[type] || []);\n        if (fns.indexOf(callback) === -1) {\n            fns.push(callback);\n        }\n        return this;\n    }\n    // 触发\n    trigger(type, data) {\n        let fns = this._cache[type];\n        if (Array.isArray(fns)) {\n            fns.forEach((fn) =&gt; {\n                fn(data);\n            });\n        }\n        return this;\n    }\n    // 解绑\n    off(type, callback) {\n        let fns = this._cache[type];\n        if (Array.isArray(fns)) {\n            if (callback) {\n                let index = fns.indexOf(callback);\n                if (index !== -1) {\n                    fns.splice(index, 1);\n                }\n            } else {\n                //全部清空\n                fns.length = 0;\n            }\n        }\n        return this;\n    }\n}\n// 测试用例\nconst event = new Event();\nevent.on(&apos;test&apos;, (a) =&gt; {\n    console.log(a);\n});\nevent.trigger(&apos;test&apos;, &apos;hello world&apos;);\n\nevent.off(&apos;test&apos;);\nevent.trigger(&apos;test&apos;, &apos;hello world&apos;);\n</code></pre><p>复制</p>\n<p>类似于树、堆、图这些高级数据结构，前端一般也不会考查太多，但是它们的查找方法却常考，后面介绍。高级数据应该平时多积累，好好理解，比如理解了堆是什么样的数据结构，在面试中遇见的「查找最大的 K 个数」这类算法问题，就会迎刃而解。</p>\n<h2 id=\"算法的效率是通过算法复杂度来衡量的\"><a href=\"#算法的效率是通过算法复杂度来衡量的\" class=\"headerlink\" title=\"算法的效率是通过算法复杂度来衡量的\"></a><strong>算法的效率是通过算法复杂度来衡量的</strong></h2><p>算法的好坏可以通过算法复杂度来衡量，算法复杂度包括时间复杂度和空间复杂度两个。时间复杂度由于好估算、好评估等特点，是面试中考查的重点。空间复杂度在面试中考查得不多。</p>\n<p>常见的时间复杂度有：</p>\n<ul>\n<li>常数阶 <code>O(1)</code></li>\n<li>对数阶 <code>O(logN)</code></li>\n<li>线性阶 <code>O(n)</code></li>\n<li>线性对数阶 <code>O(nlogN)</code></li>\n<li>平方阶 <code>O(n^2)</code></li>\n<li>立方阶 <code>O(n^3)</code></li>\n<li>!k次方阶 <code>O(n^k)</code></li>\n<li>指数阶<code>O(2^n)</code></li>\n</ul>\n<p>随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低。</p>\n<p>一般做算法复杂度分析的时候，遵循下面的技巧：</p>\n<ol>\n<li>看看有几重循环，一般来说一重就是<code>O(n)</code>，两重就是 <code>O(n^2)</code>，以此类推</li>\n<li>如果有二分，则为<code>O(logN)</code></li>\n<li>保留最高项，去除常数项</li>\n</ol>\n<blockquote>\n<p>题目：分析下面代码的算法复杂度（为了方便，我已经在注释中加了代码分析）</p>\n</blockquote>\n<pre><code>let i =0; // 语句执行一次 \nwhile (i &lt; n) { // 语句执行 n 次 \n  console.log(`Current i is ${i}`); //语句执行 n 次\n  i++; // 语句执行 n 次\n}\n</code></pre><p>复制</p>\n<p>根据注释可以得到，算法复杂度为<code>1 + n + n + n = 1 + 3n</code>，去除常数项，为<code>O(n)</code>。</p>\n<pre><code>let number = 1; // 语句执行一次 \nwhile (number &lt; n) { // 语句执行 logN 次\n  number *= 2; // 语句执行 logN 次\n}\n</code></pre><p>复制</p>\n<p>上面代码<code>while</code>的跳出判断条件是<code>number&lt;n</code>，而循环体内<code>number</code>增长速度是<code>(2^n)</code>，所以循环代码实际执行<code>logN</code>次，复杂度为：<code>1 + 2 * logN = O(logN)</code></p>\n<pre><code>for (let i = 0; i &lt; n; i++) {// 语句执行 n 次\n  for (let j = 0; j &lt; n; j++) {// 语句执行 n^2 次\n    console.log(&apos;I am here!&apos;); // 语句执行 n^2 次\n  }\n}\n</code></pre><p>复制</p>\n<p>上面代码是两个<code>for</code>循环嵌套，很容易得出复杂度为：<code>O(n^2)</code></p>\n<h2 id=\"人人都要掌握的基础算法\"><a href=\"#人人都要掌握的基础算法\" class=\"headerlink\" title=\"人人都要掌握的基础算法\"></a><strong>人人都要掌握的基础算法</strong></h2><p>枚举和递归是最最简单的算法，也是复杂算法的基础，人人都应该掌握！枚举相对比较简单，我们重点说下递归。</p>\n<p>递归由下面两部分组成：</p>\n<ol>\n<li>递归主体，就是要循环解决问题的代码</li>\n<li>递归的跳出条件，递归不能一直递归下去，需要完成一定条件后跳出</li>\n</ol>\n<p>关于递归有个经典的面试题目是：</p>\n<blockquote>\n<p>实现 JS 对象的深拷贝</p>\n</blockquote>\n<p><strong>什么是深拷贝？</strong></p>\n<p>「深拷贝」就是在拷贝数据的时候，将数据的所有<strong>引用结构</strong>都拷贝一份。简单的说就是，在内存中存在两个数据结构完全相同又相互独立的数据，将引用型类型进行复制，而不是只复制其引用关系。</p>\n<p>分析下怎么做「深拷贝」：</p>\n<ol>\n<li>首先假设深拷贝这个方法已经完成，为 deepClone</li>\n<li><p>要拷贝一个数据，我们肯定要去遍历它的属性，如果这个对象的属性仍是对象，继续使用这个方法，如此往复</p>\n<p>function deepClone(o1, o2) {</p>\n<pre><code>for (let k in o2) {\n    if (typeof o2[k] === &apos;object&apos;) {\n        o1[k] = {};\n        deepClone(o1[k], o2[k]);\n    } else {\n        o1[k] = o2[k];\n    }\n}\n</code></pre><p>}<br>// 测试用例<br>let obj = {</p>\n<pre><code>a: 1,\nb: [1, 2, 3],\nc: {}\n</code></pre><p>};<br>let emptyObj = Object.create(null);<br>deepClone(emptyObj, obj);<br>console.log(emptyObj.a == obj.a);<br>console.log(emptyObj.b == obj.b);</p>\n</li>\n</ol>\n<p>复制</p>\n<p>递归容易造成爆栈，尾部调用可以解决递归的这个问题，Chrome 的 V8 引擎做了尾部调用优化，我们在写代码的时候也要注意尾部调用写法。递归的爆栈问题可以通过将递归改写成枚举的方式来解决，就是通过<code>for</code>或者<code>while</code>来代替递归。</p>\n<p>我们在使用递归的时候，要注意做优化，比如下面的题目。</p>\n<blockquote>\n<p>题目：求斐波那契数列（兔子数列） 1,1,2,3,5,8,13,21,34,55,89…中的第 n 项</p>\n</blockquote>\n<p>下面的代码中<code>count</code>记录递归的次数，我们看下两种差异性的代码中的<code>count</code>的值：</p>\n<pre><code>let count = 0;\nfunction fn(n) {\n    let cache = {};\n    function _fn(n) {\n        if (cache[n]) {\n            return cache[n];\n        }\n        count++;\n        if (n == 1 || n == 2) {\n            return 1;\n        }\n        let prev = _fn(n - 1);\n        cache[n - 1] = prev;\n        let next = _fn(n - 2);\n        cache[n - 2] = next;\n        return prev + next;\n    }\n    return _fn(n);\n}\n\nlet count2 = 0;\nfunction fn2(n) {\n    count2++;\n    if (n == 1 || n == 2) {\n        return 1;\n    }\n    return fn2(n - 1) + fn2(n - 2);\n}\n\nconsole.log(fn(20), count); // 6765 20\nconsole.log(fn2(20), count2); // 6765 13529\n</code></pre><p>复制</p>\n<h2 id=\"快排和二分查找\"><a href=\"#快排和二分查找\" class=\"headerlink\" title=\"快排和二分查找\"></a><strong>快排和二分查找</strong></h2><p>前端中面试排序和查找的可能性比较小，因为 JS 引擎已经把这些常用操作优化得很好了，可能项目中你费劲写的一个排序方法，都不如<code>Array.sort</code>速度快且代码少。因此，掌握快排和二分查找就可以了。</p>\n<p>快排和二分查找都基于一种叫做「分治」的算法思想，通过对数据进行分类处理，不断降低数量级，实现<code>O(logN)</code>（对数级别，比<code>O(n)</code>这种线性复杂度更低的一种）的复杂度。</p>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a><strong>快速排序</strong></h3><p>快排大概的流程是：</p>\n<ol>\n<li>随机选择数组中的一个数 A，以这个数为基准</li>\n<li>其他数字跟这个数进行比较，比这个数小的放在其左边，大的放到其右边</li>\n<li>经过一次循环之后，A 左边为小于 A 的，右边为大于 A 的</li>\n<li>这时候将左边和右边的数再递归上面的过程</li>\n</ol>\n<p>具体代码如下：</p>\n<pre><code>const Arr = [85, 24, 63, 45, 17, 31, 96, 50];\nfunction quickSort(arr) {\n    if (arr.length &lt;= 1) {\n        return arr;\n    }\n    let pivotIndex = Math.floor(arr.length / 2);\n    let pivot = arr.splice(pivotIndex, 1)[0];\n    let left = [];\n    let right = [];\n    for (let i = 0; i &lt; arr.length; i++) {\n        if (arr[i] &lt; pivot) {\n            left.push(arr[i]);\n        } else {\n            right.push(arr[i]);\n        }\n    }\n    // 递归\n    return quickSort(left).concat([pivot], quickSort(right));\n}\n\nconsole.log(quickSort(Arr));\n</code></pre><p>复制</p>\n<h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a><strong>二分查找</strong></h3><p>二分查找法主要是解决「在一堆有序的数中找出指定的数」这类问题，不管这些数是一维数组还是多维数组，只要有序，就可以用二分查找来优化。</p>\n<p>二分查找是一种「分治」思想的算法，大概流程如下：</p>\n<ol>\n<li>数组中排在中间的数字 A，与要找的数字比较大小</li>\n<li>因为数组是有序的，所以： a) A 较大则说明要查找的数字应该从前半部分查找 b) A 较小则说明应该从查找数字的后半部分查找</li>\n<li>这样不断查找缩小数量级（扔掉一半数据），直到找完数组为止</li>\n</ol>\n<blockquote>\n<p>题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>\n</blockquote>\n<pre><code>function Find(target, array) {\n    let i = 0;\n    let j = array[i].length - 1;\n    while (i &lt; array.length &amp;&amp; j &gt;= 0) {\n        if (array[i][j] &lt; target) {\n            i++;\n        } else if (array[i][j] &gt; target) {\n            j--;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\n\n//测试用例\nconsole.log(Find(10, [\n    [1, 2, 3, 4], \n    [5, 9, 10, 11], \n    [13, 20, 21, 23]\n    ])\n);\n</code></pre><p>复制</p>\n<p>另外笔者在面试中遇见过下面的问题：</p>\n<blockquote>\n<p>题目：现在我有一个 1~1000 区间中的正整数，需要你猜下这个数字是几，你只能问一个问题：大了还是小了？问需要猜几次才能猜对？</p>\n</blockquote>\n<p>拿到这个题目，笔者想到的就是电视上面有个「猜价格」的购物节目，在规定时间内猜对价格就可以把实物抱回家。所以问题就是让面试官不停地回答我猜的数字比这个数字大了还是小了。这就是二分查找！</p>\n<p>猜几次呢？其实这个问题就是个二分查找的算法时间复杂度问题，二分查找的时间复杂度是<code>O(logN)</code>，所以求<code>log1000</code>的解就是猜的次数。我们知道<code>2^10=1024</code>，所以可以快速估算出：<code>log1000</code>约等于 10，最多问 10 次就能得到这个数！</p>\n<h2 id=\"面试遇见不会的算法问题怎么办\"><a href=\"#面试遇见不会的算法问题怎么办\" class=\"headerlink\" title=\"面试遇见不会的算法问题怎么办\"></a><strong>面试遇见不会的算法问题怎么办</strong></h2><p>面试的时候，在遇见算法题目的时候，应该揣摩面试官的意图，听好关键词，比如：有序的数列做查找、要求算法复杂度是<code>O(logN)</code>这类一般就是用二分的思想。</p>\n<p>一般来说算法题目的解题思路分以下四步：</p>\n<ol>\n<li>先降低数量级，拿可以计算出来的情况（数据）来构思解题步骤</li>\n<li>根据解题步骤编写程序，优先将特殊情况做好判断处理，比如一个大数组的问题，如果数组为两个数长度的情况</li>\n<li>检验程序正确性</li>\n<li>是否可以优化（由浅到深），有能力的话可以故意预留优化点，这样可以体现个人技术能力</li>\n</ol>\n<h2 id=\"正则匹配解题\"><a href=\"#正则匹配解题\" class=\"headerlink\" title=\"正则匹配解题\"></a><strong>正则匹配解题</strong></h2><p>很多算法题目利用 ES 语法的特性来回答更加简单，比如正则匹配就是常用的一种方式。笔者简单通过几个真题来汇总下正则的知识点。</p>\n<blockquote>\n<p>题目：字符串中第一个出现一次的字符</p>\n</blockquote>\n<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符「go」时，第一个只出现一次的字符是「g」。当从该字符流中读出前六个字符「google」时，第一个只出现一次的字符是「l」。</p>\n<p>这个如果用纯算法来解答需要遍历字符串，统计每个字符出现的次数，然后按照字符串的顺序来找出第一次出现一次的字符，整个过程比较繁琐，如果用正则就简单多了。</p>\n<pre><code>function find(str){\n    for (var i = 0; i &lt; str.length; i++) {\n        let char = str[i]\n        let reg = new RegExp(char, &apos;g&apos;);\n        let l = str.match(reg).length\n        if(l===1){\n            return char\n        }\n    }\n}\n</code></pre><p>复制</p>\n<p>当然，使用<code>indexOf/lastIndexOf</code>也是一个取巧的方式。再来看一个千分位问题。</p>\n<blockquote>\n<p>题目：将<code>1234567</code> 变成 <code>1,234,567</code>，即千分位标注</p>\n</blockquote>\n<p>这个题目可以用算法直接来解，如果候选人使用正则来回答，这样主动展现了自己其他方面的优势，即使不是算法解答出来的，面试官一般也不会太难为他。这道题目可以利用正则的「零宽断言」<code>(?=exp)</code>，意思是它断言自身出现的位置的后面能匹配表达式 exp。数字千分位的特点是，第一个逗号后面数字的个数是3的倍数，正则：<code>/(\\d{3})+$/</code>；第一个逗号前最多可以有 1~3 个数字，正则：<code>/\\d{1,3}/</code>。加起来就是<code>/\\d{1,3}(\\d{3})+$/</code>，分隔符要从前往后加。</p>\n<p>对于零宽断言的详细介绍可以阅读「<a href=\"https://link.juejin.im?target=https%3A%2F%2Fdeerchao.net%2Ftutorials%2Fregex%2Fregex.htm%23lookaround\" target=\"_blank\" rel=\"noopener\">零宽断言</a>」这篇文章。</p>\n<pre><code>function exchange(num) {\n    num += &apos;&apos;; //转成字符串\n    if (num.length &lt;= 3) {\n        return num;\n    }\n\n    num = num.replace(/\\d{1,3}(?=(\\d{3})+$)/g, (v) =&gt; {\n        console.log(v)\n        return v + &apos;,&apos;;\n    });\n    return num;\n}\n\nconsole.log(exchange(1234567));\n</code></pre><p>复制</p>\n<p>当然上面讲到的多数是算法题目取巧的方式，下面这个题目是纯正则考查，笔者在面试的过程中碰见过，这里顺便提一下。</p>\n<blockquote>\n<p>题目，请写出下面的代码执行结果</p>\n</blockquote>\n<pre><code>var str = &apos;google&apos;;\nvar reg = /o/g;\nconsole.log(reg.test(str))\nconsole.log(reg.test(str))\nconsole.log(reg.test(str))\n</code></pre><p>复制</p>\n<p>代码执行后，会发现，最后一个不是为<code>true</code>，而是<code>false</code>，这是因为<code>reg</code>这个正则有个<code>g</code>，即<code>global</code>全局的属性，这种情况下<code>lastIndex</code>就发挥作用了，可以看下面的代码执行结果就明白了。</p>\n<pre><code>console.log(reg.test(str), reg.lastIndex)\nconsole.log(reg.test(str), reg.lastIndex)\nconsole.log(reg.test(str), reg.lastIndex)\n</code></pre><p>复制</p>\n<p>实际开发中也会犯这样的错误，比如为了减少变量每次都重新定义，会把用到的变量提前定义好，这样在使用的时候容易掉进坑里，比如下面代码：</p>\n<pre><code>(function(){\n    const reg = /o/g;\n    function isHasO(str){\n        // reg.lastIndex = 0; 这样就可以避免这种情况\n        return reg.test(str)\n    }\n    var str = &apos;google&apos;;\n    console.log(isHasO(str))\n    console.log(isHasO(str))\n    console.log(isHasO(str))\n}())\n</code></pre><p>复制</p>\n<h2 id=\"小结-4\"><a href=\"#小结-4\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h2><p>本小节介绍了数据结构和算法的关系，作为普通的前端也应该学习数据结构和算法知识，并且顺带介绍了下正则匹配。具体来说，本小节梳理了以下几部分数据结构和算法知识点：</p>\n<ol>\n<li>经常用到的数据结构有哪些，它们的特点有哪些</li>\n<li>递归和枚举是最基础的算法，必须牢牢掌握</li>\n<li>排序里面理解并掌握快速排序算法，其他排序算法可以根据个人实际情况大概了解</li>\n<li>有序查找用二分查找</li>\n<li>遇见不会的算法问题，先缩小数量级，然后分析推导</li>\n</ol>\n<p>当然算法部分还有很多知识，比如动态规划这些算法思想，还有图和树常用到的广度优先搜索和深度优先搜索。这些知识在前端面试和项目中遇见得不多，感兴趣的读者可以在梳理知识点的时候根据个人情况自行决定是否复习。</p>\n<p>上一篇：<a href=\"541673\">一面 3：CSS-HTML 知识点与高频考题解析</a>下一篇：<a href=\"541675\">一面 5：浏览器相关知识点与高频考题解析</a></p>\n<h1 id=\"一面-5：浏览器相关知识点与高频考题解析\"><a href=\"#一面-5：浏览器相关知识点与高频考题解析\" class=\"headerlink\" title=\"一面 5：浏览器相关知识点与高频考题解析\"></a><strong>一面 5：浏览器相关知识点与高频考题解析</strong></h1><p>Web 前端工程师写的页面要跑在浏览器里面，所以面试中也会出现很多跟浏览器相关的面试题目。</p>\n<h2 id=\"知识点梳理-4\"><a href=\"#知识点梳理-4\" class=\"headerlink\" title=\"知识点梳理****\"></a><strong>知识点梳理</strong>****</h2><ul>\n<li>浏览器加载页面和渲染过程</li>\n<li>性能优化</li>\n<li>Web 安全</li>\n</ul>\n<p>本小节会从浏览器的加载过程开始讲解，然后介绍如何进行性能优化，最后介绍下 Web 开发中常见的安全问题和预防。</p>\n<hr>\n<h2 id=\"加载页面和渲染过程\"><a href=\"#加载页面和渲染过程\" class=\"headerlink\" title=\"加载页面和渲染过程\"></a><strong>加载页面和渲染过程</strong></h2><p>可将加载过程和渲染过程分开说。回答问题的时候，关键要抓住核心的要点，把要点说全面，稍加解析即可，简明扼要不拖沓。</p>\n<blockquote>\n<p>题目：浏览器从加载页面到渲染页面的过程</p>\n</blockquote>\n<h3 id=\"加载过程\"><a href=\"#加载过程\" class=\"headerlink\" title=\"加载过程\"></a><strong>加载过程</strong></h3><p>要点如下：</p>\n<ul>\n<li>浏览器根据 DNS 服务器得到域名的 IP 地址</li>\n<li>向这个 IP 的机器发送 HTTP 请求</li>\n<li>服务器收到、处理并返回 HTTP 请求</li>\n<li>浏览器得到返回内容</li>\n</ul>\n<p>例如在浏览器输入<code>https://juejin.im/timeline</code>，然后经过 DNS 解析，<code>juejin.im</code>对应的 IP 是<code>36.248.217.149</code>（不同时间、地点对应的 IP 可能会不同）。然后浏览器向该 IP 发送 HTTP 请求。</p>\n<p>server 端接收到 HTTP 请求，然后经过计算（向不同的用户推送不同的内容），返回 HTTP 请求，返回的内容如下：</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>其实就是一堆 HMTL 格式的字符串，因为只有 HTML 格式浏览器才能正确解析，这是 W3C 标准的要求。接下来就是浏览器的渲染过程。</p>\n<h3 id=\"渲染过程\"><a href=\"#渲染过程\" class=\"headerlink\" title=\"渲染过程\"></a><strong>渲染过程</strong></h3><p>要点如下：</p>\n<ul>\n<li>根据 HTML 结构生成 DOM 树</li>\n<li>根据 CSS 生成 CSSOM</li>\n<li>将 DOM 和 CSSOM 整合形成 RenderTree</li>\n<li>根据 RenderTree 开始渲染和展示</li>\n<li>遇到<code>&lt;script&gt;</code>时，会执行并阻塞渲染</li>\n</ul>\n<p>上文中，浏览器已经拿到了 server 端返回的 HTML 内容，开始解析并渲染。最初拿到的内容就是一堆字符串，必须先结构化成计算机擅长处理的基本数据结构，因此要把 HTML 字符串转化成 DOM 树 —— 树是最基本的数据结构之一。</p>\n<p>解析过程中，如果遇到<code>&lt;link href=&quot;...&quot;&gt;</code>和<code>&lt;script src=&quot;...&quot;&gt;</code>这种外链加载 CSS 和 JS 的标签，浏览器会异步下载，下载过程和上文中下载 HTML 的流程一样。只不过，这里下载下来的字符串是 CSS 或者 JS 格式的。</p>\n<p>浏览器将 CSS 生成 CSSOM，再将 DOM 和 CSSOM 整合成 RenderTree ，然后针对 RenderTree 即可进行渲染了。大家可以想一下，有 DOM 结构、有样式，此时就能满足渲染的条件了。另外，这里也可以解释一个问题 —— <strong>为何要将 CSS 放在 HTML 头部？</strong>—— 这样会让浏览器尽早拿到 CSS 尽早生成 CSSOM，然后在解析 HTML 之后可一次性生成最终的 RenderTree，渲染一次即可。如果 CSS 放在 HTML 底部，会出现渲染卡顿的情况，影响性能和体验。</p>\n<p>最后，渲染过程中，如果遇到<code>&lt;script&gt;</code>就停止渲染，执行 JS 代码。因为浏览器渲染和 JS 执行共用一个线程，而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。待<code>&lt;script&gt;</code>内容执行完之后，浏览器继续渲染。最后再思考一个问题 —— <strong>为何要将 JS 放在 HTML 底部？</strong>—— JS 放在底部可以保证让浏览器优先渲染完现有的 HTML 内容，让用户先看到内容，体验好。另外，JS 执行如果涉及 DOM 操作，得等待 DOM 解析完成才行，JS 放在底部执行时，HTML 肯定都解析成了 DOM 结构。JS 如果放在 HTML 顶部，JS 执行的时候 HTML 还没来得及转换为 DOM 结构，可能会报错。</p>\n<p>关于浏览器整个流程，百度的多益大神有更加详细的文章，推荐阅读下：《<a href=\"https://link.juejin.im?target=http%3A%2F%2Ffex.baidu.com%2Fblog%2F2014%2F05%2Fwhat-happen%2F\" target=\"_blank\" rel=\"noopener\">从输入 URL 到页面加载完成的过程中都发生了什么事情？</a> 》。</p>\n<hr>\n<h2 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a><strong>性能优化</strong></h2><p>性能优化的题目也是面试常考的，这类题目有很大的扩展性，能够扩展出来很多小细节，而且对个人的技术视野和业务能力有很大的挑战。这部分笔者会重点讲下常用的性能优化方案。</p>\n<blockquote>\n<p>题目：总结前端性能优化的解决方案</p>\n</blockquote>\n<h3 id=\"优化原则和方向\"><a href=\"#优化原则和方向\" class=\"headerlink\" title=\"优化原则和方向\"></a><strong>优化原则和方向</strong></h3><p>性能优化的原则是<strong>以更好的用户体验为标准</strong>，具体就是实现下面的目标：</p>\n<ol>\n<li>多使用内存、缓存或者其他方法</li>\n<li>减少 CPU 和GPU 计算，更快展现</li>\n</ol>\n<p>优化的方向有两个：</p>\n<ul>\n<li><strong>减少页面体积，提升网络加载</strong></li>\n<li><strong>优化页面渲染</strong></li>\n</ul>\n<h3 id=\"减少页面体积，提升网络加载\"><a href=\"#减少页面体积，提升网络加载\" class=\"headerlink\" title=\"减少页面体积，提升网络加载\"></a><strong>减少页面体积，提升网络加载</strong></h3><ul>\n<li>静态资源的压缩合并（JS 代码压缩合并、CSS 代码压缩合并、雪碧图）</li>\n<li>静态资源缓存（资源名称加 MD5 戳）</li>\n<li>使用 CDN 让资源加载更快</li>\n</ul>\n<h3 id=\"优化页面渲染\"><a href=\"#优化页面渲染\" class=\"headerlink\" title=\"优化页面渲染\"></a><strong>优化页面渲染</strong></h3><ul>\n<li>CSS 放前面，JS 放后面</li>\n<li>懒加载（图片懒加载、下拉加载更多）</li>\n<li>减少DOM 查询，对 DOM 查询做缓存</li>\n<li>减少DOM 操作，多个操作尽量合并在一起执行（<code>DocumentFragment</code>）</li>\n<li>事件节流</li>\n<li>尽早执行操作（<code>DOMContentLoaded</code>）</li>\n<li>使用 SSR 后端渲染，数据直接输出到 HTML 中，减少浏览器使用 JS 模板渲染页面 HTML 的时间</li>\n</ul>\n<h3 id=\"详细解释\"><a href=\"#详细解释\" class=\"headerlink\" title=\"详细解释\"></a><strong>详细解释</strong></h3><h4 id=\"静态资源的压缩合并\"><a href=\"#静态资源的压缩合并\" class=\"headerlink\" title=\"静态资源的压缩合并\"></a><strong>静态资源的压缩合并</strong></h4><p>如果不合并，每个都会走一遍之前介绍的请求过程</p>\n<pre><code>&lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;b.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;c.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>复制</p>\n<p>如果合并了，就只走一遍请求过程</p>\n<pre><code>&lt;script src=&quot;abc.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>复制</p>\n<h4 id=\"静态资源缓存\"><a href=\"#静态资源缓存\" class=\"headerlink\" title=\"静态资源缓存\"></a><strong>静态资源缓存</strong></h4><p>通过链接名称控制缓存</p>\n<pre><code>&lt;script src=&quot;abc_1.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>复制</p>\n<p>只有内容改变的时候，链接名称才会改变</p>\n<pre><code>&lt;script src=&quot;abc_2.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>复制</p>\n<p>这个名称不用手动改，可通过前端构建工具根据文件内容，为文件名称添加 MD5 后缀。</p>\n<h4 id=\"使用-CDN-让资源加载更快\"><a href=\"#使用-CDN-让资源加载更快\" class=\"headerlink\" title=\"使用 CDN 让资源加载更快\"></a><strong>使用 CDN 让资源加载更快</strong></h4><p>CDN 会提供专业的加载优化方案，静态资源要尽量放在 CDN 上。例如：</p>\n<pre><code>&lt;script src=&quot;https://cdn.bootcss.com/zepto/1.0rc1/zepto.min.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>复制</p>\n<h4 id=\"使用-SSR-后端渲染\"><a href=\"#使用-SSR-后端渲染\" class=\"headerlink\" title=\"使用 SSR 后端渲染\"></a><strong>使用 SSR 后端渲染</strong></h4><p>可一次性输出 HTML 内容，不用在页面渲染完成之后，再通过 Ajax 加载数据、再渲染。例如使用 smarty、Vue SSR 等。</p>\n<h4 id=\"CSS-放前面，JS-放后面\"><a href=\"#CSS-放前面，JS-放后面\" class=\"headerlink\" title=\"CSS 放前面，JS 放后面\"></a><strong>CSS 放前面，JS 放后面</strong></h4><p>上文讲述浏览器渲染过程时已经提过，不再赘述。</p>\n<h4 id=\"懒加载\"><a href=\"#懒加载\" class=\"headerlink\" title=\"懒加载\"></a><strong>懒加载</strong></h4><p>一开始先给为 <code>src</code> 赋值成一个通用的预览图，下拉时候再动态赋值成正式的图片。如下，<code>preview.png</code>是预览图片，比较小，加载很快，而且很多图片都共用这个<code>preview.png</code>，加载一次即可。待页面下拉，图片显示出来时，再去替换<code>src</code>为<code>data-realsrc</code>的值。</p>\n<pre><code>&lt;img src=&quot;preview.png&quot; data-realsrc=&quot;abc.png&quot;/&gt;\n</code></pre><p>复制</p>\n<p>另外，这里为何要用<code>data-</code>开头的属性值？—— 所有 HTML 中自定义的属性，都应该用<code>data-</code>开头，因为<code>data-</code>开头的属性浏览器渲染的时候会忽略掉，提高渲染性能。</p>\n<h4 id=\"DOM-查询做缓存\"><a href=\"#DOM-查询做缓存\" class=\"headerlink\" title=\"DOM 查询做缓存\"></a><strong>DOM 查询做缓存</strong></h4><p>两段代码做一下对比：</p>\n<pre><code>var pList = document.getElementsByTagName(&apos;p&apos;)  // 只查询一个 DOM ，缓存在 pList 中了\nvar i\nfor (i = 0; i &lt; pList.length; i++) {\n}\n</code></pre><p>复制</p>\n<pre><code>var i\nfor (i = 0; i &lt; document.getElementsByTagName(&apos;p&apos;).length; i++) {  // 每次循环，都会查询 DOM ，耗费性能\n}\n</code></pre><p>复制</p>\n<p>总结：DOM 操作，无论查询还是修改，都是非常耗费性能的，应尽量减少。</p>\n<h4 id=\"合并-DOM-插入\"><a href=\"#合并-DOM-插入\" class=\"headerlink\" title=\"合并 DOM 插入\"></a><strong>合并 DOM 插入</strong></h4><p>DOM 操作是非常耗费性能的，因此插入多个标签时，先插入 Fragment 然后再统一插入 DOM。</p>\n<pre><code>var listNode = document.getElementById(&apos;list&apos;)\n// 要插入 10 个 li 标签\nvar frag = document.createDocumentFragment();\nvar x, li;\nfor(x = 0; x &lt; 10; x++) {\n    li = document.createElement(&quot;li&quot;);\n    li.innerHTML = &quot;List item &quot; + x;\n    frag.appendChild(li);  // 先放在 frag 中，最后一次性插入到 DOM 结构中。\n}\nlistNode.appendChild(frag);\n</code></pre><p>复制</p>\n<h4 id=\"事件节流\"><a href=\"#事件节流\" class=\"headerlink\" title=\"事件节流\"></a><strong>事件节流</strong></h4><p>例如要在文字改变时触发一个 change 事件，通过 keyup 来监听。使用节流。</p>\n<pre><code>var textarea = document.getElementById(&apos;text&apos;)\nvar timeoutId\ntextarea.addEventListener(&apos;keyup&apos;, function () {\n    if (timeoutId) {\n        clearTimeout(timeoutId)\n    }\n    timeoutId = setTimeout(function () {\n        // 触发 change 事件\n    }, 100)\n})\n</code></pre><p>复制</p>\n<h4 id=\"尽早执行操作\"><a href=\"#尽早执行操作\" class=\"headerlink\" title=\"尽早执行操作\"></a><strong>尽早执行操作</strong></h4><pre><code>window.addEventListener(&apos;load&apos;, function () {\n    // 页面的全部资源加载完才会执行，包括图片、视频等\n})\ndocument.addEventListener(&apos;DOMContentLoaded&apos;, function () {\n    // DOM 渲染完即可执行，此时图片、视频还可能没有加载完\n})\n</code></pre><p>复制</p>\n<h4 id=\"性能优化怎么做\"><a href=\"#性能优化怎么做\" class=\"headerlink\" title=\"性能优化怎么做\"></a><strong>性能优化怎么做</strong></h4><p>上面提到的都是性能优化的单个点，性能优化项目具体实施起来，应该按照下面步骤推进：</p>\n<ol>\n<li>建立性能数据收集平台，摸底当前性能数据，通过性能打点，将上述整个页面打开过程消耗时间记录下来</li>\n<li>分析耗时较长时间段原因，寻找优化点，确定优化目标</li>\n<li>开始优化</li>\n<li>通过数据手机平台记录优化效果</li>\n<li>不断调整优化点和预期目标，循环2~4步骤</li>\n</ol>\n<p>性能优化是个长期的事情，不是一蹴而就的，应该本着先摸底、再分析、后优化的原则逐步来做。</p>\n<hr>\n<h2 id=\"Web-安全\"><a href=\"#Web-安全\" class=\"headerlink\" title=\"Web 安全\"></a><strong>Web 安全</strong></h2><blockquote>\n<p>题目：前端常见的安全问题有哪些？</p>\n</blockquote>\n<p>Web 前端的安全问题，能回答出下文的两个问题，这个题目就能基本过关了。开始之前，先说一个最简单的攻击方式 —— SQL 注入。</p>\n<p>上学的时候就知道有一个「SQL注入」的攻击方式。例如做一个系统的登录界面，输入用户名和密码，提交之后，后端直接拿到数据就拼接 SQL 语句去查询数据库。如果在输入时进行了恶意的 SQL 拼装，那么最后生成的 SQL 就会有问题。但是现在稍微大型一点的系统，都不会这么做，从提交登录信息到最后拿到授权，要经过层层的验证。因此，SQL 注入都只出现在比较低端小型的系统上。</p>\n<h3 id=\"XSS（Cross-Site-Scripting，跨站脚本攻击）\"><a href=\"#XSS（Cross-Site-Scripting，跨站脚本攻击）\" class=\"headerlink\" title=\"XSS（Cross Site Scripting，跨站脚本攻击）\"></a><strong>XSS（Cross Site Scripting，跨站脚本攻击）</strong></h3><p>这是前端最常见的攻击方式，很多大型网站（如 Facebook）都被 XSS 攻击过。</p>\n<p>举一个例子，我在一个博客网站正常发表一篇文章，输入汉字、英文和图片，完全没有问题。但是如果我写的是恶意的 JS 脚本，例如获取到<code>document.cookie</code>然后传输到自己的服务器上，那我这篇博客的每一次浏览都会执行这个脚本，都会把访客 cookie 中的信息偷偷传递到我的服务器上来。</p>\n<p>其实原理上就是黑客通过某种方式（发布文章、发布评论等）将一段特定的 JS 代码隐蔽地输入进去。然后别人再看这篇文章或者评论时，之前注入的这段 JS 代码就执行了。<strong>JS 代码一旦执行，那可就不受控制了，因为它跟网页原有的 JS 有同样的权限</strong>，例如可以获取 server 端数据、可以获取 cookie 等。于是，攻击就这样发生了。</p>\n<h4 id=\"XSS的危害\"><a href=\"#XSS的危害\" class=\"headerlink\" title=\"XSS的危害\"></a><strong>XSS的危害</strong></h4><p>XSS 的危害相当大，如果页面可以随意执行别人不安全的 JS 代码，轻则会让页面错乱、功能缺失，重则会造成用户的信息泄露。</p>\n<p>比如早些年社交网站经常爆出 XSS 蠕虫，通过发布的文章内插入 JS，用户访问了感染不安全 JS 注入的文章，会自动重新发布新的文章，这样的文章会通过推荐系统进入到每个用户的文章列表面前，很快就会造成大规模的感染。</p>\n<p>还有利用获取 cookie 的方式，将 cookie 传入入侵者的服务器上，入侵者就可以模拟 cookie 登录网站，对用户的信息进行篡改。</p>\n<h4 id=\"XSS的预防\"><a href=\"#XSS的预防\" class=\"headerlink\" title=\"XSS的预防\"></a><strong>XSS的预防</strong></h4><p>那么如何预防 XSS 攻击呢？—— 最根本的方式，就是对用户输入的内容进行验证和替换，需要替换的字符有：</p>\n<pre><code>&amp; 替换为：&amp;amp;\n&lt; 替换为：&amp;lt;\n&gt; 替换为：&amp;gt;\n” 替换为：&amp;quot;\n‘ 替换为：&amp;#x27;\n/ 替换为：&amp;#x2f;\n</code></pre><p>复制</p>\n<p>替换了这些字符之后，黑客输入的攻击代码就会失效，XSS 攻击将不会轻易发生。</p>\n<p>除此之外，还可以通过对 cookie 进行较强的控制，比如对敏感的 cookie 增加<code>http-only</code>限制，让 JS 获取不到 cookie 的内容。</p>\n<h3 id=\"CSRF（Cross-site-request-forgery，跨站请求伪造）\"><a href=\"#CSRF（Cross-site-request-forgery，跨站请求伪造）\" class=\"headerlink\" title=\"CSRF（Cross-site request forgery，跨站请求伪造）\"></a><strong>CSRF（Cross-site request forgery，跨站请求伪造）</strong></h3><p>CSRF 是借用了当前操作者的权限来偷偷地完成某个操作，而不是拿到用户的信息。</p>\n<p>例如，一个支付类网站，给他人转账的接口是<code>http://buy.com/pay?touid=999&amp;money=100</code>，而这个接口在使用时没有任何密码或者 token 的验证，只要打开访问就直接给他人转账。一个用户已经登录了<code>http://buy.com</code>，在选择商品时，突然收到一封邮件，而这封邮件正文有这么一行代码<code>&lt;img src=&quot;http://buy.com/pay?touid=999&amp;money=100&quot;/&gt;</code>，他访问了邮件之后，其实就已经完成了购买。</p>\n<p>CSRF 的发生其实是借助了一个 cookie 的特性。我们知道，登录了<code>http://buy.com</code>之后，cookie 就会有登录过的标记了，此时请求<code>http://buy.com/pay?touid=999&amp;money=100</code>是会带着 cookie 的，因此 server 端就知道已经登录了。而如果在<code>http://buy.com</code>去请求其他域名的 API 例如<code>http://abc.com/api</code>时，是不会带 cookie 的，这是浏览器的同源策略的限制。但是 —— <strong>此时在其他域名的页面中，请求<code>http://buy.com/pay?touid=999&amp;money=100</code>，会带着<code>buy.com</code>的 cookie ，这是发生 CSRF 攻击的理论基础。</strong></p>\n<p>预防 CSRF 就是加入各个层级的权限验证，例如现在的购物网站，只要涉及现金交易，肯定要输入密码或者指纹才行。除此之外，敏感的接口使用<code>POST</code>请求而不是<code>GET</code>也是很重要的。</p>\n<hr>\n<h2 id=\"小结-5\"><a href=\"#小结-5\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h2><p>本小节总结了前端运行环境（即浏览器）的一些常考查知识点，包括页面加载过程、如何性能优化以及需要注意的安全问题。</p>\n<p>上一篇：<a href=\"541674\">一面 4：从容应对算法题目</a>下一篇：<a href=\"541676\">一面 6：开发环境相关知识点与高频考题解析</a></p>\n<h1 id=\"一面-6：开发环境相关知识点与高频考题解析\"><a href=\"#一面-6：开发环境相关知识点与高频考题解析\" class=\"headerlink\" title=\"一面 6：开发环境相关知识点与高频考题解析\"></a><strong>一面 6：开发环境相关知识点与高频考题解析</strong></h1><p>工程师的开发环境决定其开发效率，常用的开发环境配置也是面试考查点之一。</p>\n<h2 id=\"知识点梳理-5\"><a href=\"#知识点梳理-5\" class=\"headerlink\" title=\"知识点梳理\"></a><strong>知识点梳理</strong></h2><ul>\n<li>IDE</li>\n<li>Git</li>\n<li>Linux 基础命令</li>\n<li>前端构建工具</li>\n<li>调试方法</li>\n</ul>\n<p>本小节会重点介绍 Git 的基本用法、代码部署和开发中常用的 Linux 命令，然后以 webpack 为例介绍下前端构建工具，最后介绍怎么抓包解决线上问题。这些都是日常开发和面试中常用到的知识。</p>\n<hr>\n<h2 id=\"IDE\"><a href=\"#IDE\" class=\"headerlink\" title=\"IDE\"></a><strong>IDE</strong></h2><blockquote>\n<p>题目：你平时都使用什么 IDE 编程？有何提高效率的方法？</p>\n</blockquote>\n<p>前端最常用的 IDE 有 <a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.jetbrains.com%2Fwebstorm%2F\" target=\"_blank\" rel=\"noopener\">Webstorm</a>、<a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.sublimetext.com%2F\" target=\"_blank\" rel=\"noopener\">Sublime</a>、<a href=\"https://link.juejin.im?target=https%3A%2F%2Fatom.io%2F\" target=\"_blank\" rel=\"noopener\">Atom</a> 和 <a href=\"https://link.juejin.im?target=https%3A%2F%2Fcode.visualstudio.com%2F\" target=\"_blank\" rel=\"noopener\">VSCode</a>，我们可以分别去它们的官网看一下。</p>\n<p>Webstorm 是最强大的编辑器，因为它拥有各种强大的插件和功能，但是我没有用过，因为它收费。不是我舍不得花钱，而是因为我觉得免费的 Sublime 已经够我用了。跟面试官聊到 Webstorm 的时候，没用过没事儿，但一定要知道它：第一，强大；第二，收费。</p>\n<p>Sublime 是我日常用的编辑器，第一它免费，第二它轻量、高效，第三它插件非常多。用 Sublime 一定要安装各种插件配合使用，可以去网上搜一下“sublime”常用插件的安装以及用法，还有它的各种快捷键，并且亲自使用它。这里就不一一演示了，网上的教程也很傻瓜式。</p>\n<p>Atom 是 GitHub 出品的编辑器，跟 Sublime 差不多，免费并且插件丰富，而且跟 Sublime 相比风格上还有些小清新。但是我用过几次就不用了，因此它打开的时候会比较慢，卡一下才打开。当然总体来说也是很好用的，只是个人习惯问题。</p>\n<p>VSCode 是微软出品的轻量级（相对于 Visual Studio 来说）编辑器，微软做 IDE 那是出了名的好，出了名的大而全，因此 VSCode 也有上述 Sublime 和 Atom 的各种优点，但是我也是因为个人习惯问题（本人不愿意尝试没有新意的新东西），用过几次就不用了。</p>\n<p>总结一下：</p>\n<ul>\n<li>如果你要走大牛、大咖、逼格的路线，就用 Webstorm</li>\n<li>如果你走普通、屌丝、低调路线，就用 Sublime</li>\n<li>如果你走小清新、个性路线，就用 VSCode 或者 Atom</li>\n<li>如果你面试，最好有一个用的熟悉，其他都会一点</li>\n</ul>\n<p>最后注意：千万不要说你使用 Dreamweaver 或者 notepad++ 写前端代码，会被人鄙视的。如果你不做 .NET 也不要用 Visual Studio ，不做 Java 也不要用 Eclipse。</p>\n<hr>\n<h2 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a><strong>Git</strong></h2><p>你此前做过的项目一定要用过 Git，而且必须是命令行，如果没用过，你自己也得恶补一下。对 Git 的基本应用比较熟悉的同学，可以跳过这一部分了。macOS 自带 Git，Windows 需要安装 Git 客户端，去 <a href=\"https://link.juejin.im?target=https%3A%2F%2Fgit-scm.com%2Fdownload%2Fwin\" target=\"_blank\" rel=\"noopener\">Git 官网</a> 下载即可。</p>\n<p>国内比较好的 Git 服务商有 <a href=\"http://coding.net\" target=\"_blank\" rel=\"noopener\">coding.net</a>，国外有大名鼎鼎的 GitHub，但是有时会有网络问题，因此建议大家注册一个 <a href=\"http://coding.net\" target=\"_blank\" rel=\"noopener\">coding.net</a> 账号然后创建项目，来练练手。</p>\n<blockquote>\n<p>题目：常用的 Git 命令有哪些？如何使用 Git 多人协作开发？</p>\n</blockquote>\n<h3 id=\"常用的-Git-命令\"><a href=\"#常用的-Git-命令\" class=\"headerlink\" title=\"常用的 Git 命令\"></a><strong>常用的 Git 命令</strong></h3><p>首先，通过<code>git clone &lt;项目远程地址&gt;</code>下载下来最新的代码，例如<code>git clone git@git.coding.net:username/project-name.git</code>，默认会下载<code>master</code>分支。</p>\n<p>然后修改代码，修改过程中可以通过<code>git status</code>看到自己的修改情况，通过<code>git diff &lt;文件名&gt;</code>可查阅单个文件的差异。</p>\n<p>最后，将修改的内容提交到远程服务器，做如下操作</p>\n<pre><code>git add .\ngit commit -m &quot;xxx&quot;\ngit push origin master\n</code></pre><p>复制</p>\n<p>如果别人也提交了代码，你想同步别人提交的内容，执行<code>git pull origin master</code>即可。</p>\n<h3 id=\"如何多人协作开发\"><a href=\"#如何多人协作开发\" class=\"headerlink\" title=\"如何多人协作开发\"></a><strong>如何多人协作开发</strong></h3><p>多人协作开发，就不能使用<code>master</code>分支了，而是要每个开发者单独拉一个分支，使用<code>git checkout -b &lt;branchname&gt;</code>，运行<code>git branch</code>可以看到本地所有的分支名称。</p>\n<p>自己的分支，如果想同步<code>master</code>分支的内容，可运行<code>git merge master</code>。切换分支可使用<code>git checkout &lt;branchname&gt;</code>。</p>\n<p>在自己的分支上修改了内容，可以将自己的分支提交到远程服务器</p>\n<pre><code>git add .\ngit commit -m &quot;xxx&quot;\ngit push origin &lt;branchname&gt;\n</code></pre><p>复制</p>\n<p>最后，待代码测试没问题，再将自己分支的内容合并到<code>master</code>分支，然后提交到远程服务器。</p>\n<pre><code>git checkout master\ngit merge &lt;branchname&gt;\ngit push origin master\n</code></pre><p>复制</p>\n<h3 id=\"关于-SVN\"><a href=\"#关于-SVN\" class=\"headerlink\" title=\"关于 SVN\"></a><strong>关于 SVN</strong></h3><p>关于 SVN 笔者的态度和针对 IE 低版本浏览器的态度一样，你只需要查询资料简单了解一下。面试的时候可能会问到，但你只要熟悉了 Git 的操作，面试官不会因为你不熟悉 SVN 而难为你。前提是你要知道一点 SVN 的基本命令，自己上网一查就行。</p>\n<p>不过 SVN 和 Git 的区别你得了解。SVN 是每一步操作都离不开服务器，创建分支、提交代码都需要连接服务器。而 Git 就不一样了，你可以在本地创建分支、提交代码，最后再一起 push 到服务器上。因此，Git 拥有 SVN 的所有功能，但是却比 SVN 强大得多。（Git 是 Linux 的创始人 Linus 发明的东西，因此也倍得推崇。）</p>\n<hr>\n<h2 id=\"Linux-基础命令\"><a href=\"#Linux-基础命令\" class=\"headerlink\" title=\"Linux 基础命令\"></a>Linux 基础命令</h2><p>目前互联网公司的线上服务器都使用 Linux 系统，测试环境为了保证和线上一致，肯定也是使用 Linux 系统，而且都是命令行的，没有桌面，不能用鼠标操作。因此，掌握基础的 Linux 命令是非常必要的。下面总结一些最常用的 Linux 命令，建议大家在真实的 Linux 系统下亲自试一下。</p>\n<p>关于如何得到 Linux 系统，有两种选择：第一，在自己电脑的虚拟机中安装一个 Linux 系统，例如 Ubuntu/CentOS 等，下载这些都不用花钱；第二，花钱去阿里云等云服务商租一个最便宜的 Linux 虚拟机。推荐第二种。一般正式入职之后，公司都会给你分配开发机或者测试机，给你账号和密码，你自己可以远程登录。</p>\n<blockquote>\n<p>题目：常见 linux 命令有哪些？</p>\n</blockquote>\n<h3 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a><strong>登录</strong></h3><p>入职之后，一般会有现有的用户名和密码给你，你拿来之后直接登录就行。运行 <code>ssh name@server</code> 然后输入密码即可登录。</p>\n<h3 id=\"目录操作\"><a href=\"#目录操作\" class=\"headerlink\" title=\"目录操作\"></a><strong>目录操作</strong></h3><ul>\n<li>创建目录 <code>mkdir &lt;目录名称&gt;</code></li>\n<li>删除目录 <code>rm &lt;目录名称&gt;</code></li>\n<li>定位目录 <code>cd &lt;目录名称&gt;</code></li>\n<li>查看目录文件 <code>ls`</code>ll`</li>\n<li>修改目录名 <code>mv &lt;目录名称&gt; &lt;新目录名称&gt;</code></li>\n<li>拷贝目录 <code>cp &lt;目录名称&gt; &lt;新目录名称&gt;</code></li>\n</ul>\n<h3 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a><strong>文件操作</strong></h3><ul>\n<li>创建文件 <code>touch &lt;文件名称&gt;`</code>vi &lt;文件名称&gt;`</li>\n<li>删除文件 <code>rm &lt;文件名称&gt;</code></li>\n<li>修改文件名 <code>mv &lt;文件名称&gt; &lt;新文件名称&gt;</code></li>\n<li>拷贝文件 <code>cp &lt;文件名称&gt; &lt;新文件名称&gt;</code></li>\n</ul>\n<h3 id=\"文件内容操作\"><a href=\"#文件内容操作\" class=\"headerlink\" title=\"文件内容操作\"></a><strong>文件内容操作</strong></h3><ul>\n<li>查看文件 <code>cat &lt;文件名称&gt;`</code>head &lt;文件名称&gt;<code></code>tail &lt;文件名称&gt;`</li>\n<li>编辑文件内容 <code>vi &lt;文件名称&gt;</code></li>\n<li>查找文件内容 <code>grep &#39;关键字&#39; &lt;文件名称&gt;</code></li>\n</ul>\n<hr>\n<h2 id=\"前端构建工具\"><a href=\"#前端构建工具\" class=\"headerlink\" title=\"前端构建工具\"></a><strong>前端构建工具</strong></h2><p>构建工具是前端工程化中不可缺少的一环，非常重要，而在面试中却有其特殊性 —— <strong>面试官会通过询问构建工具的作用、目的来询问你对构建工具的了解，只要这些你都知道，不会再追问细节</strong>。因为，在实际工作中，真正能让你编写构建工具配置文件的机会非常少，一个项目就配置一次，后面就很少改动了。而且，如果是大众使用的框架（如 React、Vue 等），还会直接有现成的脚手架工具，一键创建开发环境，不用手动配置。</p>\n<blockquote>\n<p>题目：前端为何要使用构建工具？它解决了什么问题？</p>\n</blockquote>\n<h3 id=\"何为构建工具\"><a href=\"#何为构建工具\" class=\"headerlink\" title=\"何为构建工具\"></a><strong>何为构建工具</strong></h3><p>“构建”也可理解为“编译”，就是将开发环境的代码转换成运行环境代码的过程。<strong>开发环境的代码是为了更好地阅读，而运行环境的代码是为了更快地执行，两者目的不一样，因此代码形式也不一样</strong>。例如，开发环境写的 JS 代码，要通过混淆压缩之后才能放在线上运行，因为这样代码体积更小，而且对代码执行不会有任何影响。总结一下需要构建工具处理的几种情况：</p>\n<ul>\n<li><strong>处理模块化</strong>：CSS 和 JS 的模块化语法，目前都无法被浏览器兼容。因此，开发环境可以使用既定的模块化语法，但是需要构建工具将模块化语法编译为浏览器可识别形式。例如，使用 webpack、Rollup 等处理 JS 模块化。</li>\n<li><strong>编译语法</strong>：编写 CSS 时使用 Less、Sass，编写 JS 时使用 ES6、TypeScript 等。这些标准目前也都无法被浏览器兼容，因此需要构建工具编译，例如使用 Babel 编译 ES6 语法。</li>\n<li><strong>代码压缩</strong>：将 CSS、JS 代码混淆压缩，为了让代码体积更小，加载更快。</li>\n</ul>\n<h3 id=\"构建工具介绍\"><a href=\"#构建工具介绍\" class=\"headerlink\" title=\"构建工具介绍\"></a><strong>构建工具介绍</strong></h3><p>最早普及使用的构建工具是 <a href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.gruntjs.net%2F\" target=\"_blank\" rel=\"noopener\">Grunt</a> ，不久又被 <a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.gulpjs.com.cn%2F\" target=\"_blank\" rel=\"noopener\">Gulp</a> 给追赶上。Gulp 因其简单的配置以及高效的性能而被大家所接受，也是笔者个人比较推荐的构建工具之一。如果你做一些简单的 JS 开发，可以考虑使用。</p>\n<p>如果你的项目比较复杂，而且是多人开发，那么你就需要掌握目前构建工具届的神器 —— webpack 。不过神器也有一个缺点，就是学习成本比较高，需要拿出专门的时间来专心学习，而不是三言两语就能讲完的。我们下面就演示一下 webpack 最简单的使用，全面的学习还得靠大家去认真查阅相关文档，或者参考专门讲解 webpack 的教程。</p>\n<h3 id=\"webpack-演示\"><a href=\"#webpack-演示\" class=\"headerlink\" title=\"webpack 演示\"></a><strong>webpack 演示</strong></h3><p>接下来我们演示一下 webpack 处理模块化和混淆压缩代码这两个基本功能。</p>\n<p>首先，你需要安装 Node.js，没有安装的可以去 <a href=\"https://link.juejin.im?target=http%3A%2F%2Fnodejs.cn%2Fdownload%2F\" target=\"_blank\" rel=\"noopener\">Node.js 官网</a> 下载并安装。安装完成后运行如下命令来验证是否安装成功。</p>\n<pre><code>node -v\nnpm -v\n</code></pre><p>复制</p>\n<p>然后，新建一个目录，进入该目录，运行<code>npm init</code>，按照提示输入名称、版本、描述等信息。完成之后，该目录下出现了一个<code>package.json</code>文件，是一个 JSON 文件。</p>\n<p>接下来，安装 wepback，运行<code>npm i --save-dev webpack</code>，网络原因需要耐心等待几分钟。</p>\n<p>接下来，编写源代码，在该目录下创建<code>src</code>文件夹，并在其中创建<code>app.js</code>和<code>dt.js</code>两个文件，文件内容分别是：</p>\n<pre><code>// dt.js 内容\nmodule.exports = {\n    getDateNow: function () {\n        return Date.now()\n    }\n}\n\n// app.js 内容\nvar dt = require(&apos;./dt.js&apos;)\nalert(dt.getDateNow())\n</code></pre><p>复制</p>\n<p>然后，再返回上一层目录，新建<code>index.html</code>文件（该文件和<code>src</code>属于同一层级），内容是</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;test&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div&gt;test&lt;/div&gt;\n\n    &lt;script src=&apos;./dist/bundle.js&apos;&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>复制</p>\n<p>然后，编写 webpack 配置文件，新建<code>webpack.config.js</code>，内容是</p>\n<pre><code>const path = require(&apos;path&apos;);\nconst webpack = require(&apos;webpack&apos;);\nmodule.exports = {\n  context: path.resolve(__dirname, &apos;./src&apos;),\n  entry: {\n    app: &apos;./app.js&apos;,\n  },\n  output: {\n    path: path.resolve(__dirname, &apos;./dist&apos;),\n    filename: &apos;bundle.js&apos;,\n  },\n  plugins: [\n    new webpack.optimize.UglifyJsPlugin({\n        compress: {\n          //supresses warnings, usually from module minification\n          warnings: false\n        }\n    }),\n  ]\n};\n</code></pre><p>复制</p>\n<p>总结一下，目前项目的文件目录是：</p>\n<pre><code>src\n  +-- app.js\n  +-- dt.js\nindex.html\npackage.json\nwebpack.config.js\n</code></pre><p>复制</p>\n<p>接下来，打开<code>package.json</code>，然后修改其中<code>scripts</code>的内容为：</p>\n<pre><code>&quot;scripts&quot;: {\n  &quot;start&quot;: &quot;webpack&quot;\n}\n</code></pre><p>复制</p>\n<p>在命令行中运行<code>npm start</code>，即可看到编译的结果，最后在浏览器中打开<code>index.html</code>，即可弹出<code>Date.now()</code>的值。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>最后再次强调，<strong>深刻理解构建工具存在的价值，比你多会一些配置代码更加有意义，特别是对于应对面试来说</strong>。</p>\n<hr>\n<h2 id=\"调试方法\"><a href=\"#调试方法\" class=\"headerlink\" title=\"调试方法\"></a><strong>调试方法</strong></h2><p>调试方法这块被考查最多的就是如何进行抓包。</p>\n<blockquote>\n<p>题目：如何抓取数据？如何使用工具来配置代理？</p>\n</blockquote>\n<p>PC 端的网页，我们可以通过 Chrome、Firefox 等浏览器自带的开发者工具来查看网页的所有网络请求，以帮助排查 bug。这种监听、查看网络请求的操作称为<strong>抓包</strong>。</p>\n<p>针对移动端的抓包工具，Mac 系统下推荐使用 Charles 这个工具，首先 <a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.charlesproxy.com%2Fdownload%2F\" target=\"_blank\" rel=\"noopener\">下载</a> 并安装，打开。Windows 系统推荐使用 <a href=\"https://link.juejin.im?target=http%3A%2F%2Frj.baidu.com%2Fsoft%2Fdetail%2F10963.html\" target=\"_blank\" rel=\"noopener\">Fiddler</a>，下载安装打开。两者使用基本一致，下面以 Charles 为例介绍。</p>\n<p>接下来，将安装好 Charles 的电脑和要抓包的手机，连接到同一个网络（一般为公司统一提供的内网，由专业网络工程师搭建），保证 IP 段相同。然后，将手机设置网络代理（每种不同手机如何设置网络代理，网上都有傻瓜式教程），代理的 IP 为电脑的 IP，代理的端口为<code>8888</code>。然后，Charles 可能会有一个弹框提示是否允许连接代理，这里选择“允许”即可。这样，使用手机端访问的网页或者联网的请求，Charles 就能监听到了。</p>\n<p>在开发过程中，经常用到抓包工具来做代理，将线上的地址代理到测试环境，Charles 和 Fiddler 都可实现这个功能。以 Charles 为例，点击菜单栏中 Tools 菜单，然后二级菜单中点击 Map Remote，会弹出配置框。首先，选中 Enable Map Remote 复选框，然后点击 Add 按钮，添加一个代理项。例如，如果要将线上的<code>https://www.aaa.com/api/getuser?name=xxx</code>这个地址代理到测试地址<code>http://168.1.1.100:8080/api/getuser?name=xxx</code>，配置如下图</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<hr>\n<h2 id=\"小结-6\"><a href=\"#小结-6\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h2><p>本小节总结了前端开发环境常考查的知识，这些知识也是前端程序员必须掌握的，否则会影响开发效率。</p>\n<p>上一篇：<a href=\"541675\">一面 5：浏览器相关知识点与高频考题解析</a>下一篇：<a href=\"541677\">二面 1：如何回答常见的软技能问题</a></p>\n<h1 id=\"二面-1：如何回答常见的软技能问题\"><a href=\"#二面-1：如何回答常见的软技能问题\" class=\"headerlink\" title=\"二面 1：如何回答常见的软技能问题\"></a><strong>二面 1：如何回答常见的软技能问题</strong></h1><p>面试是个技术活，不仅仅是技术，各种软技能的面试技巧也是非常重要的，尤其是程序员一般对于自己的软技能不是很看重，其实<strong>软技能才是决定你职场能够走多远的关键</strong>。</p>\n<h2 id=\"程序员应该具备的软技能\"><a href=\"#程序员应该具备的软技能\" class=\"headerlink\" title=\"程序员应该具备的软技能\"></a><strong>程序员应该具备的软技能</strong></h2><p>程序员除了业务技能外，应该具有下面的软技能：</p>\n<ol>\n<li>韧性：抗压能力，在一定项目压力下能够迎难而上，比如勇于主动承担和解决技术难题</li>\n<li>责任心：对于自己做过的项目，能够出现 bug 之类主动解决</li>\n<li>持续学习能力：IT 行业是个需要不断充电的行业，尤其 Web 前端这些年一直在巨变，所以持续学习能力很重要</li>\n<li>团队合作能力：做项目不能个人英雄主义，应该融入团队，跟团队一起打仗</li>\n<li>交流沟通能力：经常会遇见沟通需求和交互设计的工作，应该乐于沟通分享</li>\n</ol>\n<p>另外在《软技能：代码之外的生存指南》这本书里提到了下面一些软技能：</p>\n<ol>\n<li>职业</li>\n<li>自我营销</li>\n<li>学习能力</li>\n<li>提升工作效率</li>\n<li>理财</li>\n<li>健身</li>\n<li>积极的人生观</li>\n</ol>\n<h2 id=\"常见的软技能问题和提升\"><a href=\"#常见的软技能问题和提升\" class=\"headerlink\" title=\"常见的软技能问题和提升\"></a><strong>常见的软技能问题和提升</strong></h2><p>回答软技能类的问题，应该注意在回答过程中体现自己具备的软技能。下面列举几个常见的软技能类的问题。</p>\n<h3 id=\"回想下你遇见过最难打交道的同事，你是如何跟他沟通的\"><a href=\"#回想下你遇见过最难打交道的同事，你是如何跟他沟通的\" class=\"headerlink\" title=\"回想下你遇见过最难打交道的同事，你是如何跟他沟通的\"></a><strong>回想下你遇见过最难打交道的同事，你是如何跟他沟通的</strong></h3><p>一般来说，工作中总会遇见一两个自己不喜欢的人，这种情况应该尽量避免冲突，从自己做起慢慢让对方感觉到自己的合作精神。</p>\n<p>所以，遇见难打交道的同事，不要急于上报领导，应该自己主动多做一些事情，比如规划好工作安排，让他选择自己做的事情，有了结论记得发邮件确认下来，这样你们的领导和其他成员都会了解到工作的安排，在鞭笞对方的同时，也做到了职责明确。在项目当中，多主动检查项目进展，提前发现逾期的问题。</p>\n<p>重点是突出：自己主动沟通解决问题的意识，而不是遇见问题就找领导。</p>\n<h3 id=\"当你被分配一个几乎不可能完成的任务时，你会怎么做\"><a href=\"#当你被分配一个几乎不可能完成的任务时，你会怎么做\" class=\"headerlink\" title=\"当你被分配一个几乎不可能完成的任务时，你会怎么做\"></a><strong>当你被分配一个几乎不可能完成的任务时，你会怎么做</strong></h3><p>这种情况下，一般通过下面方式来解决：</p>\n<ol>\n<li>自己先查找资料，寻找解决方案，评估自己需要怎样的资源来完成，需要多长时间</li>\n<li>能不能借助周围同事来解决问题</li>\n<li>拿着分析结果跟上级反馈，寻求帮助或者资源</li>\n</ol>\n<p>突出的软技能：分析和解决问题，沟通寻求帮助。</p>\n<h3 id=\"业余时间都做什么？除了写码之外还有什么爱好\"><a href=\"#业余时间都做什么？除了写码之外还有什么爱好\" class=\"headerlink\" title=\"业余时间都做什么？除了写码之外还有什么爱好\"></a><strong>业余时间都做什么？除了写码之外还有什么爱好</strong></h3><p>这类问题也是面试官的高频问题，「一个人的业余时间决定了他的未来」，如果回答周末都在追剧打游戏之类的，未免显得太不上进。</p>\n<p>一般来说，推荐下面的回答：</p>\n<blockquote>\n<p>周末一般会有三种状态：</p>\n<ol>\n<li>和朋友一起去做做运动，也会聚会聊天，探讨下新技术之类的；</li>\n<li>也会看一些书籍充充电，比如我最近看的 xx，有什么的想法；</li>\n<li>有时候会闷在家用最近比较火的技术做个小项目或者实现个小功能之类的。</li>\n</ol>\n</blockquote>\n<p>这样的回答，既能表现自己阳光善于社交沟通的一面，又能表现自己的上进心。</p>\n<h2 id=\"小结-7\"><a href=\"#小结-7\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h2><p>本小节介绍了程序员除了业务技术能力之外应该日常修炼的软技能，在面试中，软技能会被以各种形式问起，候选人应该先了解有哪些软技能可以修炼，才能在回答软技能问题的时候，尽量提到自己具备的软技能。</p>\n<p>上一篇：<a href=\"541676\">一面 6：开发环境相关知识点与高频考题解析</a>下一篇：<a href=\"541678\">二面 2：如何介绍项目及应对项目细节追问</a></p>\n<h1 id=\"二面-2：如何介绍项目及应对项目细节追问\"><a href=\"#二面-2：如何介绍项目及应对项目细节追问\" class=\"headerlink\" title=\"二面 2：如何介绍项目及应对项目细节追问\"></a><strong>二面 2：如何介绍项目及应对项目细节追问</strong></h1><p>一个标准的面试流程中，肯定会在一面二面中问到你具体做过的项目，然后追问项目的细节。这类问题往往会通过下面形式来提问：</p>\n<ol>\n<li>发现你简历的一个项目，直接让你介绍下这个项目</li>\n<li>让你回忆下你做过的项目中，最值得分享（最大型/最困难/最能体现技术能力/最难忘）的</li>\n<li>如果让你设计 xx 系统/项目，你会怎么着手干</li>\n</ol>\n<p>这类跟项目相关的综合性问题，既能体现候选人的技术水平、业务水平和架构能力，也能够辨别候选人是不是真的做过项目，还能够发现候选人的一些软技能。</p>\n<p>下面分享下，遇见这类问题应该怎样回答。</p>\n<h2 id=\"怎样介绍自己做过的一个项目\"><a href=\"#怎样介绍自己做过的一个项目\" class=\"headerlink\" title=\"怎样介绍自己做过的一个项目\"></a><strong>怎样介绍自己做过的一个项目</strong></h2><p>按照第 1 小节说的，简历当中的项目，你要精挑细选，既要体现技术难度，又要想好细节。具体要介绍一个项目（包括梳理一个项目），可以按照下面几个阶段来做。</p>\n<p>###** 1. 介绍项目背景**</p>\n<p>这个项目为什么做，当初大的环境背景是什么？还是为了解决一个什么问题而设立的项目？背景是很重要的，如果不了解背景，一上来就听一个结论性的项目，面试官可能对于项目的技术选型、技术难度会有理解偏差，甚至怀疑是否真的有过这样的项目。</p>\n<blockquote>\n<p>比如一上来就说：我们的项目采用了「backbone」来做框架，然后。。。而「backbone」已经是三四年前比较新鲜的技术，现在会有更好的选择方案，如果不介绍项目的时间背景，面试官肯定一脸懵逼。</p>\n</blockquote>\n<h3 id=\"2-承担角色\"><a href=\"#2-承担角色\" class=\"headerlink\" title=\"2. 承担角色\"></a><strong>2. 承担角色</strong></h3><p>项目涉及的人员角色有哪些，自己在其中扮演的角色是什么？</p>\n<p>这里候选往往人会自己给自己挖坑，比如把自己在项目中起到的作用夸大等。一般来说，面试官细节追问的时候，如果候选人能够把细节或者技术方案等讲明白、讲清楚，不管他是真的做过还是跟别人做过，或者自己认真思考过，都能体现候选人的技术水平和技术视野。前提还是在你能够兜得住的可控范围之内做适当的「美化」。</p>\n<h3 id=\"3-最终的结果和收益\"><a href=\"#3-最终的结果和收益\" class=\"headerlink\" title=\"3. 最终的结果和收益\"></a><strong>3. 最终的结果和收益</strong></h3><p>项目介绍过程中，应该介绍项目最终的结果和收益，比如项目最后经过多久的开发上线了，上线后的数据是怎样的，是否达到预期，还是带来了新的问题，遇见了问题自己后续又是怎样补救的。</p>\n<h3 id=\"4-有始有终：项目总结和反思\"><a href=\"#4-有始有终：项目总结和反思\" class=\"headerlink\" title=\"4. 有始有终：项目总结和反思\"></a>4. 有始有终：项目总结和反思</h3><p>有总结和反思，才会有进步。 项目做完了往往会有一些心得和体会，这时候应该跟面试官说出来。在梳理项目的总结和反思时，可以按照下面的列表来梳理：</p>\n<ul>\n<li>收获有哪些？</li>\n<li>是否有做得不足的地方，怎么改进？</li>\n<li>是否具有可迁移性？</li>\n</ul>\n<p>比如，之前详细介绍了某个项目，这个项目当时看来没有什么问题，但是现在有更好的解决方案了，候选人就应该在这里提出来：现在看来，这个项目还有 xx 的问题，我可以通过 xx 的方式来解决。</p>\n<p>再比如：做这个项目的时候，你做得比较出彩的地方，可以迁移到其他项目中直接使用，小到代码片段，大到解决方案，总会有你值得总结和梳理的地方。</p>\n<p>介绍完项目总结这部分，也可以引导面试官往自己擅长的领域思考。比如上面提到项目中的问题，可以往你擅长的方面引导，即使面试官没有问到，你也介绍到了。</p>\n<p>按照上面的四段体介绍项目，会让面试官感觉候选人有清晰的思路，对整个项目也有理解和想法，还能够总结反思项目的收益和问题，可谓「一箭三雕」。</p>\n<h2 id=\"没有做过大型项目怎么办\"><a href=\"#没有做过大型项目怎么办\" class=\"headerlink\" title=\"没有做过大型项目怎么办\"></a><strong>没有做过大型项目怎么办</strong></h2><p>对于刚刚找工作的应届生，或者面试官让你进行一个大型项目的设计，候选人可能没有类似的经验。这时候不要用「我不会、没做过」一句话就带过。</p>\n<p>如果是实在没有项目可以说，那么可以提自己日常做的练手项目，或者看到一个解决方案的文章/书，提到的某个项目，抒发下自己的想法。</p>\n<p>如果是对于面试官提出来需要你设计的项目/系统，可以按照下面几步思考：</p>\n<ol>\n<li>有没有遇见过类似的项目</li>\n<li>有没有读过类似解决方案的文章</li>\n<li>项目能不能拆解，拆解过程中能不能发现自己做过的项目可以用</li>\n<li>项目解决的问题是什么，这类问题有没有更好的解决方案</li>\n</ol>\n<p>总之，切记不要一句「不知道、没做过」就放弃，每一次提问都是自己表现的机会。</p>\n<h2 id=\"项目细节和技术点的追问\"><a href=\"#项目细节和技术点的追问\" class=\"headerlink\" title=\"项目细节和技术点的追问\"></a><strong>项目细节和技术点的追问</strong></h2><p>介绍项目的过程中，面试官可能会追问技术细节，所以我们在准备面试的时候，应该尽量把技术细节梳理清楚，技术细节包括：</p>\n<ol>\n<li>技术选型方案：当时做技术选型所面临的状况</li>\n<li>技术解决方案：最终确定某种技术方案的原因，比如：选择用 Vue 而没有用 React 是为什么？</li>\n<li>项目数据和收益</li>\n<li>项目中最难的地方</li>\n<li>遇见的坑：如使用某种框架遇见哪些坑</li>\n</ol>\n<p>一般来说，做技术选型的时候需要考虑下面几个因素：</p>\n<ol>\n<li>时代：现在比较火的技术是什么，为什么火起来，解决了什么问题，能否用到我的项目中？</li>\n<li>团队：个人或者团队对某种技术的熟悉程度是怎样的，学习成本又是怎样的？</li>\n<li>业务需求：需求是怎样的，能否套用现在的成熟解决方案/库来快速解决？</li>\n<li>维护成本：一个解决方案的是否再能够 cover 住的范围之内？</li>\n</ol>\n<p>在项目中遇见的数据和收益应该做好跟踪，保证数据的真实性和可信性。另外，遇见的坑可能是面试官问得比较多的，尤其现在比较火的一些技术（Vue、React、webpack），一般团队都在使用，所以一定要提前准备下。</p>\n<h2 id=\"小结-8\"><a href=\"#小结-8\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h2><p>本小节介绍了面试中关于项目类问题的回答方法，介绍项目要使用四段体的方式，从背景、承担角色、收益效果和总结反思四个部分来介绍项目。</p>\n<p>准备这个面试环节的时候，利用笔者一直提倡的「思维导图」法，好好回顾和梳理自己的项目。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一面-1：ES-基础知识点与高频考题解析\"><a href=\"#一面-1：ES-基础知识点与高频考题解析\" class=\"headerlink\" title=\"一面 1：ES 基础知识点与高频考题解析\"></a><strong>一面 1：ES 基础知识点与高频考题解析</strong></h1><p>JavaScript 是 ECMAScript 规范的一种实现，本小节重点梳理下 ECMAScript 中的常考知识点，然后就一些容易出现的题目进行解析。</p>\n<h2 id=\"知识点梳理\"><a href=\"#知识点梳理\" class=\"headerlink\" title=\"知识点梳理\"></a><strong>知识点梳理</strong></h2><ul>\n<li>变量类型<ul>\n<li>JS 的数据类型分类和判断</li>\n<li>值类型和引用类型</li>\n</ul>\n</li>\n<li>原型与原型链（继承）<ul>\n<li>原型和原型链定义</li>\n<li>继承写法</li>\n</ul>\n</li>\n<li>作用域和闭包<ul>\n<li>执行上下文</li>\n<li>this</li>\n<li>闭包是什么</li>\n</ul>\n</li>\n<li>异步<ul>\n<li>同步 vs 异步</li>\n<li>异步和单线程</li>\n<li>前端异步的场景</li>\n</ul>\n</li>\n<li>ES6/7 新标准的考查<ul>\n<li>箭头函数</li>\n<li>Module</li>\n<li>Class</li>\n<li>Set 和 Map</li>\n<li>Promise</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"变量类型\"><a href=\"#变量类型\" class=\"headerlink\" title=\"变量类型\"></a><strong>变量类型</strong></h2><p>JavaScript 是一种弱类型脚本语言，所谓弱类型指的是定义变量时，不需要什么类型，在程序运行过程中会自动判断类型。</p>\n<p>ECMAScript 中定义了 6 种原始类型：</p>\n<ul>\n<li>Boolean</li>\n<li>String</li>\n<li>Number</li>\n<li>Null</li>\n<li>Undefined</li>\n<li>Symbol（ES6 新定义）</li>\n</ul>\n<p><strong>注意</strong>：原始类型不包含 Object。</p>\n<blockquote>\n<p>题目：类型判断用到哪些方法？</p>\n</blockquote>\n<h3 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a><strong><code>typeof</code></strong></h3><p><code>typeof xxx</code>得到的值有以下几种类型：<code>undefined`</code>boolean<code>number</code>string<code>object</code>function<code>、</code>symbol` ，比较简单，不再一一演示了。这里需要注意的有三点：</p>\n<ul>\n<li><code>typeof null</code>结果是<code>object</code> ，实际这是<code>typeof</code>的一个bug，null是原始值，非引用类型</li>\n<li><code>typeof [1, 2]</code>结果是<code>object</code>，结果中没有<code>array</code>这一项，引用类型除了<code>function</code>其他的全部都是<code>object</code></li>\n<li><code>typeof Symbol()</code> 用<code>typeof</code>获取<code>symbol</code>类型的值得到的是<code>symbol</code>，这是 ES6 新增的知识点</li>\n</ul>\n<h3 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a><strong><code>instanceof</code></strong></h3><p>用于实例和构造函数的对应。例如判断一个变量是否是数组，使用<code>typeof</code>无法判断，但可以使用<code>[1, 2] instanceof Array</code>来判断。因为，<code>[1, 2]</code>是数组，它的构造函数就是<code>Array</code>。同理：</p>\n<pre><code>function Foo(name) {\n    this.name = name\n}\nvar foo = new Foo(&apos;bar&apos;)\nconsole.log(foo instanceof Foo) // true\n</code></pre><p>复制</p>\n<blockquote>\n<p>题目：值类型和引用类型的区别</p>\n</blockquote>\n<h3 id=\"值类型-vs-引用类型\"><a href=\"#值类型-vs-引用类型\" class=\"headerlink\" title=\"值类型 vs 引用类型\"></a><strong>值类型 vs 引用类型</strong></h3><p>除了原始类型，ES 还有引用类型，上文提到的<code>typeof</code>识别出来的类型中，只有<code>object</code>和<code>function</code>是引用类型，其他都是值类型。</p>\n<p>根据 JavaScript 中的变量类型传递方式，又分为<strong>值类型</strong>和<strong>引用类型</strong>，值类型变量包括 Boolean、String、Number、Undefined、Null，引用类型包括了 Object 类的所有，如 Date、Array、Function 等。在参数传递方式上，值类型是按值传递，引用类型是按共享传递。</p>\n<p>下面通过一个小题目，来看下两者的主要区别，以及实际开发中需要注意的地方。</p>\n<pre><code>// 值类型\nvar a = 10\nvar b = a\nb = 20\nconsole.log(a)  // 10\nconsole.log(b)  // 20\n</code></pre><p>复制</p>\n<p>上述代码中，<code>a`</code>b`都是值类型，两者分别修改赋值，相互之间没有任何影响。再看引用类型的例子：</p>\n<pre><code>// 引用类型\nvar a = {x: 10, y: 20}\nvar b = a\nb.x = 100\nb.y = 200\nconsole.log(a)  // {x: 100, y: 200}\nconsole.log(b)  // {x: 100, y: 200}\n</code></pre><p>复制</p>\n<p>上述代码中，<code>a`</code>b<code>都是引用类型。在执行了</code>b = a<code>之后，修改</code>b<code>的属性值，</code>a<code>的也跟着变化。因为</code>a<code>和</code>b<code>都是引用类型，指向了同一个内存地址，即两者引用的是同一个值，因此</code>b<code>修改属性时，</code>a`的值随之改动。</p>\n<p>再借助题目进一步讲解一下。</p>\n<blockquote>\n<p>说出下面代码的执行结果，并分析其原因。</p>\n</blockquote>\n<pre><code>function foo(a){\n    a = a * 10;\n}\nfunction bar(b){\n    b.value = &apos;new&apos;;\n}\nvar a = 1;\nvar b = {value: &apos;old&apos;};\nfoo(a);\nbar(b);\nconsole.log(a); // 1\nconsole.log(b); // value: new\n</code></pre><p>复制</p>\n<p>通过代码执行，会发现：</p>\n<ul>\n<li><code>a</code>的值没有发生改变</li>\n<li>而<code>b</code>的值发生了改变</li>\n</ul>\n<p>这就是因为<code>Number</code>类型的<code>a</code>是按值传递的，而<code>Object</code>类型的<code>b</code>是按共享传递的。</p>\n<p>JS 中这种设计的原因是：按值传递的类型，复制一份存入栈内存，这类类型一般不占用太多内存，而且按值传递保证了其访问速度。按共享传递的类型，是复制其引用，而不是整个复制其值（C 语言中的指针），保证过大的对象等不会因为不停复制内容而造成内存的浪费。</p>\n<p>引用类型经常会在代码中按照下面的写法使用，或者说<strong>容易不知不觉中造成错误</strong>！</p>\n<pre><code>var obj = {\n    a: 1,\n    b: [1,2,3]\n}\nvar a = obj.a\nvar b = obj.b\na = 2\nb.push(4)\nconsole.log(obj, a, b)\n</code></pre><p>复制</p>\n<p>虽然<code>obj</code>本身是个引用类型的变量（对象），但是内部的<code>a</code>和<code>b</code>一个是值类型一个是引用类型，<code>a</code>的赋值不会改变<code>obj.a</code>，但是<code>b</code>的操作却会反映到<code>obj</code>对象上。</p>\n<hr>\n<h2 id=\"原型和原型链\"><a href=\"#原型和原型链\" class=\"headerlink\" title=\"原型和原型链\"></a><strong>原型和原型链</strong></h2><p>JavaScript 是基于原型的语言，原型理解起来非常简单，但却特别重要，下面还是通过题目来理解下JavaScript 的原型概念。</p>\n<blockquote>\n<p>题目：如何理解 JavaScript 的原型</p>\n</blockquote>\n<p>对于这个问题，可以从下面这几个要点来理解和回答，<strong>下面几条必须记住并且理解</strong></p>\n<ul>\n<li><strong>所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（<code>null</code>除外）</strong></li>\n<li><strong>所有的引用类型（数组、对象、函数），都有一个<code>__proto__</code>属性，属性值是一个普通的对象</strong></li>\n<li><strong>所有的函数，都有一个<code>prototype</code>属性，属性值也是一个普通的对象</strong></li>\n<li><strong>所有的引用类型（数组、对象、函数），<code>__proto__</code>属性值指向它的构造函数的<code>prototype</code>属性值</strong></li>\n</ul>\n<p>通过代码解释一下，大家可自行运行以下代码，看结果。</p>\n<pre><code>// 要点一：自由扩展属性\nvar obj = {}; obj.a = 100;\nvar arr = []; arr.a = 100;\nfunction fn () {}\nfn.a = 100;\n\n// 要点二：__proto__\nconsole.log(obj.__proto__);\nconsole.log(arr.__proto__);\nconsole.log(fn.__proto__);\n\n// 要点三：函数有 prototype\nconsole.log(fn.prototype)\n\n// 要点四：引用类型的 __proto__ 属性值指向它的构造函数的 prototype 属性值\nconsole.log(obj.__proto__ === Object.prototype)\n</code></pre><p>复制</p>\n<h3 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a><strong>原型</strong></h3><p>先写一个简单的代码示例。</p>\n<pre><code>// 构造函数\nfunction Foo(name, age) {\n    this.name = name\n}\nFoo.prototype.alertName = function () {\n    alert(this.name)\n}\n// 创建示例\nvar f = new Foo(&apos;zhangsan&apos;)\nf.printName = function () {\n    console.log(this.name)\n}\n// 测试\nf.printName()\nf.alertName()\n</code></pre><p>复制</p>\n<p>执行<code>printName</code>时很好理解，但是执行<code>alertName</code>时发生了什么？这里再记住一个重点 <strong>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的<code>__proto__</code>（即它的构造函数的<code>prototype</code>）中寻找</strong>，因此<code>f.alertName</code>就会找到<code>Foo.prototype.alertName</code>。</p>\n<p>那么如何判断这个属性是不是对象本身的属性呢？使用<code>hasOwnProperty</code>，常用的地方是遍历一个对象的时候。</p>\n<pre><code>var item\nfor (item in f) {\n    // 高级浏览器已经在 for in 中屏蔽了来自原型的属性，但是这里建议大家还是加上这个判断，保证程序的健壮性\n    if (f.hasOwnProperty(item)) {\n        console.log(item)\n    }\n}\n</code></pre><p>复制</p>\n<blockquote>\n<p>题目：如何理解 JS 的原型链</p>\n</blockquote>\n<h3 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a><strong>原型链</strong></h3><p>还是接着上面的示例，如果执行<code>f.toString()</code>时，又发生了什么？</p>\n<pre><code>// 省略 N 行\n\n// 测试\nf.printName()\nf.alertName()\nf.toString()\n</code></pre><p>复制</p>\n<p>因为<code>f</code>本身没有<code>toString()</code>，并且<code>f.__proto__</code>（即<code>Foo.prototype</code>）中也没有<code>toString</code>。这个问题还是得拿出刚才那句话——<strong>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的<code>__proto__</code>（即它的构造函数的<code>prototype</code>）中寻找</strong>。</p>\n<p>如果在<code>f.__proto__</code>中没有找到<code>toString</code>，那么就继续去<code>f.__proto__.__proto__</code>中寻找，因为<code>f.__proto__</code>就是一个普通的对象而已嘛！</p>\n<ul>\n<li><code>f.__proto__</code>即<code>Foo.prototype</code>，没有找到<code>toString</code>，继续往上找</li>\n<li><code>f.__proto__.__proto__</code>即<code>Foo.prototype.__proto__</code>。<code>Foo.prototype</code>就是一个普通的对象，因此<code>Foo.prototype.__proto__</code>就是<code>Object.prototype</code>，在这里可以找到<code>toString</code></li>\n<li>因此<code>f.toString</code>最终对应到了<code>Object.prototype.toString</code></li>\n</ul>\n<p>这样一直往上找，你会发现是一个链式的结构，所以叫做“原型链”。如果一直找到最上层都没有找到，那么就宣告失败，返回<code>undefined</code>。最上层是什么 —— <code>Object.prototype.__proto__ === null</code></p>\n<h3 id=\"原型链中的this\"><a href=\"#原型链中的this\" class=\"headerlink\" title=\"原型链中的this\"></a><strong>原型链中的<code>this</code></strong></h3><p>所有从原型或更高级原型中得到、执行的方法，其中的<code>this</code>在执行时，就指向了当前这个触发事件执行的对象。因此<code>printName</code>和<code>alertName</code>中的<code>this</code>都是<code>f</code>。</p>\n<hr>\n<h2 id=\"作用域和闭包\"><a href=\"#作用域和闭包\" class=\"headerlink\" title=\"作用域和闭包\"></a><strong>作用域和闭包</strong></h2><p>作用域和闭包是前端面试中，最可能考查的知识点。例如下面的题目：</p>\n<blockquote>\n<p>题目：现在有个 HTML 片段，要求编写代码，点击编号为几的链接就<code>alert</code>弹出其编号</p>\n</blockquote>\n<pre><code>&lt;ul&gt;\n    &lt;li&gt;编号1，点击我请弹出1&lt;/li&gt;\n    &lt;li&gt;2&lt;/li&gt;\n    &lt;li&gt;3&lt;/li&gt;\n    &lt;li&gt;4&lt;/li&gt;\n    &lt;li&gt;5&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre><p>复制</p>\n<p>一般不知道这个题目用闭包的话，会写出下面的代码：</p>\n<pre><code>var list = document.getElementsByTagName(&apos;li&apos;);\nfor (var i = 0; i &lt; list.length; i++) {\n    list[i].addEventListener(&apos;click&apos;, function(){\n        alert(i + 1)\n    }, true)\n}\n</code></pre><p>复制</p>\n<p>实际上执行才会发现始终弹出的是<code>6</code>，这时候就应该通过闭包来解决：</p>\n<pre><code>var list = document.getElementsByTagName(&apos;li&apos;);\nfor (var i = 0; i &lt; list.length; i++) {\n    list[i].addEventListener(&apos;click&apos;, function(i){\n        return function(){\n            alert(i + 1)\n        }\n    }(i), true)\n}\n</code></pre><p>复制</p>\n<p>要理解闭包，就需要我们从「执行上下文」开始讲起。</p>\n<h3 id=\"执行上下文\"><a href=\"#执行上下文\" class=\"headerlink\" title=\"执行上下文\"></a><strong>执行上下文</strong></h3><p>先讲一个关于 <strong>变量提升</strong> 的知识点，面试中可能会遇见下面的问题，很多候选人都回答错误：</p>\n<blockquote>\n<p>题目：说出下面执行的结果（这里笔者直接注释输出了）</p>\n</blockquote>\n<pre><code>console.log(a)  // undefined\nvar a = 100\n\nfn(&apos;zhangsan&apos;)  // &apos;zhangsan&apos; 20\nfunction fn(name) {\n    age = 20\n    console.log(name, age)\n    var age\n}\n\nconsole.log(b); // 这里报错\n// Uncaught ReferenceError: b is not defined\nb = 100;\n</code></pre><p>复制</p>\n<p>在一段 JS 脚本（即一个<code>&lt;script&gt;</code>标签中）执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个 <strong>全局执行上下文</strong> 环境，先把代码中即将执行的（内部函数的不算，因为你不知道函数何时执行）变量、函数声明都拿出来。变量先暂时赋值为<code>undefined</code>，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。再次强调，这是在代码执行之前才开始的工作。</p>\n<p>我们来看下上面的面试小题目，为什么<code>a</code>是<code>undefined</code>，而<code>b</code>却报错了，实际 JS 在代码执行之前，要「全文解析」，发现<code>var a</code>，知道有个<code>a</code>的变量，存入了执行上下文，而<code>b</code>没有找到<code>var</code>关键字，这时候没有在执行上下文提前「占位」，所以代码执行的时候，提前报到的<code>a</code>是有记录的，只不过值暂时还没有赋值，即为<code>undefined</code>，而<code>b</code>在执行上下文没有找到，自然会报错（没有找到<code>b</code>的引用）。</p>\n<p>另外，一个函数在执行之前，也会创建一个 <strong>函数执行上下文</strong> 环境，跟 <strong>全局上下文</strong> 差不多，不过 <strong>函数执行上下文</strong> 中会多出<code>this`</code>arguments<code>和函数的参数。参数和</code>arguments<code>好理解，这里的</code>this`咱们需要专门讲解。</p>\n<p>总结一下：</p>\n<ul>\n<li>范围：一段<code>&lt;script&gt;</code>、js 文件或者一个函数</li>\n<li>全局上下文：变量定义，函数声明</li>\n<li>函数上下文：变量定义，函数声明，<code>this</code>，<code>arguments</code></li>\n</ul>\n<h3 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a><strong><code>this</code></strong></h3><p>先搞明白一个很重要的概念 —— <strong><code>this</code>的值是在执行的时候才能确认，定义的时候不能确认！</strong> 为什么呢 —— 因为<code>this</code>是执行上下文环境的一部分，而执行上下文需要在代码执行之前确定，而不是定义的时候。看如下例子</p>\n<pre><code>var a = {\n    name: &apos;A&apos;,\n    fn: function () {\n        console.log(this.name)\n    }\n}\na.fn()  // this === a\na.fn.call({name: &apos;B&apos;})  // this === {name: &apos;B&apos;}\nvar fn1 = a.fn\nfn1()  // this === window\n</code></pre><p>复制</p>\n<p><code>this</code>执行会有不同，主要集中在这几个场景中</p>\n<ul>\n<li>作为构造函数执行，构造函数中</li>\n<li>作为对象属性执行，上述代码中<code>a.fn()</code></li>\n<li>作为普通函数执行，上述代码中<code>fn1()</code></li>\n<li>用于<code>call`</code>apply<code></code>bind<code>，上述代码中</code>a.fn.call({name: ‘B’})`</li>\n</ul>\n<p>下面再来讲解下什么是作用域和作用域链，作用域链和作用域也是常考的题目。</p>\n<blockquote>\n<p>题目：如何理解 JS 的作用域和作用域链</p>\n</blockquote>\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a><strong>作用域</strong></h3><p>ES6 之前 JS 没有块级作用域。例如</p>\n<pre><code>if (true) {\n    var name = &apos;zhangsan&apos;\n}\nconsole.log(name)\n</code></pre><p>复制</p>\n<p>从上面的例子可以体会到作用域的概念，作用域就是一个独立的地盘，让变量不会外泄、暴露出去。上面的<code>name</code>就被暴露出去了，因此，<strong>JS 没有块级作用域，只有全局作用域和函数作用域</strong>。</p>\n<pre><code>var a = 100\nfunction fn() {\n    var a = 200\n    console.log(&apos;fn&apos;, a)\n}\nconsole.log(&apos;global&apos;, a)\nfn()\n</code></pre><p>复制</p>\n<p>全局作用域就是最外层的作用域，如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样的坏处就是很容易撞车、冲突。</p>\n<pre><code>// 张三写的代码中\nvar data = {a: 100}\n\n// 李四写的代码中\nvar data = {x: true}\n</code></pre><p>复制</p>\n<p>这就是为何 jQuery、Zepto 等库的源码，所有的代码都会放在<code>(function(){....})()</code>中。因为放在里面的所有变量，都不会被外泄和暴露，不会污染到外面，不会对其他的库或者 JS 脚本造成影响。这是函数作用域的一个体现。</p>\n<p>附：ES6 中开始加入了块级作用域，使用<code>let</code>定义变量即可，如下：</p>\n<pre><code>if (true) {\n    let name = &apos;zhangsan&apos;\n}\nconsole.log(name)  // undefined\n</code></pre><p>复制</p>\n<h3 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a><strong>作用域链</strong></h3><p>首先认识一下什么叫做 <strong>自由变量</strong> 。如下代码中，<code>console.log(a)</code>要得到<code>a</code>变量，但是在当前的作用域中没有定义<code>a</code>（可对比一下<code>b</code>）。当前作用域没有定义的变量，这成为 <strong>自由变量</strong> 。自由变量如何得到 —— 向父级作用域寻找。</p>\n<pre><code>var a = 100\nfunction fn() {\n    var b = 200\n    console.log(a)\n    console.log(b)\n}\nfn()\n</code></pre><p>复制</p>\n<p>如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 <strong>作用域链</strong> 。</p>\n<pre><code>var a = 100\nfunction F1() {\n    var b = 200\n    function F2() {\n        var c = 300\n        console.log(a) // 自由变量，顺作用域链向父作用域找\n        console.log(b) // 自由变量，顺作用域链向父作用域找\n        console.log(c) // 本作用域的变量\n    }\n    F2()\n}\nF1()\n</code></pre><p>复制</p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a><strong>闭包</strong></h3><p>讲完这些内容，我们再来看一个例子，通过例子来理解闭包。</p>\n<pre><code>function F1() {\n    var a = 100\n    return function () {\n        console.log(a)\n    }\n}\nvar f1 = F1()\nvar a = 200\nf1()\n</code></pre><p>复制</p>\n<p>自由变量将从作用域链中去寻找，但是 <strong>依据的是函数定义时的作用域链，而不是函数执行时</strong>，以上这个例子就是闭包。闭包主要有两个应用场景：</p>\n<ul>\n<li><strong>函数作为返回值</strong>，上面的例子就是</li>\n<li><p><strong>函数作为参数传递</strong>，看以下例子</p>\n<p>function F1() {</p>\n<pre><code>var a = 100\nreturn function () {\n    console.log(a)\n}\n</code></pre><p>}<br>function F2(f1) {</p>\n<pre><code>var a = 200\nconsole.log(f1())\n</code></pre><p>}<br>var f1 = F1()<br>F2(f1)</p>\n</li>\n</ul>\n<p>复制</p>\n<p>至此，对应着「作用域和闭包」这部分一开始的点击弹出<code>alert</code>的代码再看闭包，就很好理解了。</p>\n<hr>\n<h2 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a><strong>异步</strong></h2><p>异步和同步也是面试中常考的内容，下面笔者来讲解下同步和异步的区别。</p>\n<h3 id=\"同步-vs-异步\"><a href=\"#同步-vs-异步\" class=\"headerlink\" title=\"同步 vs 异步\"></a><strong>同步 vs 异步</strong></h3><p>先看下面的 demo，根据程序阅读起来表达的意思，应该是先打印<code>100</code>，1秒钟之后打印<code>200</code>，最后打印<code>300</code>。但是实际运行根本不是那么回事。</p>\n<pre><code>console.log(100)\nsetTimeout(function () {\n    console.log(200)\n}, 1000)\nconsole.log(300)\n</code></pre><p>复制</p>\n<p>再对比以下程序。先打印<code>100</code>，再弹出<code>200</code>（等待用户确认），最后打印<code>300</code>。这个运行效果就符合预期要求。</p>\n<pre><code>console.log(100)\nalert(200)  // 1秒钟之后点击确认\nconsole.log(300)\n</code></pre><p>复制</p>\n<p>这俩到底有何区别？—— 第一个示例中间的步骤根本没有阻塞接下来程序的运行，而第二个示例却阻塞了后面程序的运行。前面这种表现就叫做 <strong>异步</strong>（后面这个叫做 <strong>同步</strong> ），即<strong>不会阻塞后面程序的运行</strong>。</p>\n<h3 id=\"异步和单线程\"><a href=\"#异步和单线程\" class=\"headerlink\" title=\"异步和单线程\"></a><strong>异步和单线程</strong></h3><p>JS 需要异步的根本原因是 <strong>JS 是单线程运行的</strong>，即在同一时间只能做一件事，不能“一心二用”。</p>\n<p>一个 Ajax 请求由于网络比较慢，请求需要 5 秒钟。如果是同步，这 5 秒钟页面就卡死在这里啥也干不了了。异步的话，就好很多了，5 秒等待就等待了，其他事情不耽误做，至于那 5 秒钟等待是网速太慢，不是因为 JS 的原因。</p>\n<p>讲到单线程，我们再来看个真题：</p>\n<blockquote>\n<p>题目：讲解下面代码的执行过程和结果</p>\n</blockquote>\n<pre><code>var a = true;\nsetTimeout(function(){\n    a = false;\n}, 100)\nwhile(a){\n    console.log(&apos;while执行了&apos;)\n}\n</code></pre><p>复制</p>\n<p>这是一个很有迷惑性的题目，不少候选人认为<code>100ms</code>之后，由于<code>a</code>变成了<code>false</code>，所以<code>while</code>就中止了，实际不是这样，因为JS是单线程的，所以进入<code>while</code>循环之后，没有「时间」（线程）去跑定时器了，所以这个代码跑起来是个死循环！</p>\n<h3 id=\"前端异步的场景\"><a href=\"#前端异步的场景\" class=\"headerlink\" title=\"前端异步的场景\"></a><strong>前端异步的场景</strong></h3><ul>\n<li>定时 <code>setTimeout`</code>setInverval`</li>\n<li>网络请求，如 <code>Ajax`</code><img>`加载</li>\n</ul>\n<p>Ajax 代码示例</p>\n<pre><code>console.log(&apos;start&apos;)\n$.get(&apos;./data1.json&apos;, function (data1) {\n    console.log(data1)\n})\nconsole.log(&apos;end&apos;)\n</code></pre><p>复制</p>\n<p>img 代码示例（常用于打点统计）</p>\n<pre><code>console.log(&apos;start&apos;)\nvar img = document.createElement(&apos;img&apos;)\n// 或者 img = new Image()\nimg.onload = function () {\n    console.log(&apos;loaded&apos;)\n    img.onload = null\n}\nimg.src = &apos;/xxx.png&apos;\nconsole.log(&apos;end&apos;)\n</code></pre><p>复制</p>\n<hr>\n<h2 id=\"ES6-7-新标准的考查\"><a href=\"#ES6-7-新标准的考查\" class=\"headerlink\" title=\"ES6/7 新标准的考查\"></a><strong>ES6/7 新标准的考查</strong></h2><blockquote>\n<p>题目：ES6 箭头函数中的<code>this</code>和普通函数中的有什么不同</p>\n</blockquote>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a><strong>箭头函数</strong></h3><p>箭头函数是 ES6 中新的函数定义形式，<code>function name(arg1, arg2) {...}</code>可以使用<code>(arg1, arg2) =&gt; {...}</code>来定义。示例如下：</p>\n<pre><code>// JS 普通函数\nvar arr = [1, 2, 3]\narr.map(function (item) {\n    console.log(index)\n    return item + 1\n})\n\n// ES6 箭头函数\nconst arr = [1, 2, 3]\narr.map((item, index) =&gt; {\n    console.log(index)\n    return item + 1\n})\n</code></pre><p>复制</p>\n<p>箭头函数存在的意义，第一写起来更加简洁，第二可以解决 ES6 之前函数执行中<code>this</code>是全局变量的问题，看如下代码</p>\n<pre><code>function fn() {\n    console.log(&apos;real&apos;, this)  // {a: 100} ，该作用域下的 this 的真实的值\n    var arr = [1, 2, 3]\n    // 普通 JS\n    arr.map(function (item) {\n        console.log(&apos;js&apos;, this)  // window 。普通函数，这里打印出来的是全局变量，令人费解\n        return item + 1\n    })\n    // 箭头函数\n    arr.map(item =&gt; {\n        console.log(&apos;es6&apos;, this)  // {a: 100} 。箭头函数，这里打印的就是父作用域的 this\n        return item + 1\n    })\n}\nfn.call({a: 100})\n</code></pre><p>复制</p>\n<blockquote>\n<p>题目：ES6 模块化如何使用？</p>\n</blockquote>\n<h3 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a><strong>Module</strong></h3><p>ES6 中模块化语法更加简洁，直接看示例。</p>\n<p>如果只是输出一个唯一的对象，使用<code>export default</code>即可，代码如下</p>\n<pre><code>// 创建 util1.js 文件，内容如\nexport default {\n    a: 100\n}\n\n// 创建 index.js 文件，内容如\nimport obj from &apos;./util1.js&apos;\nconsole.log(obj)\n</code></pre><p>复制</p>\n<p>如果想要输出许多个对象，就不能用<code>default</code>了，且<code>import</code>时候要加<code>{...}</code>，代码如下</p>\n<pre><code>// 创建 util2.js 文件，内容如\nexport function fn1() {\n    alert(&apos;fn1&apos;)\n}\nexport function fn2() {\n    alert(&apos;fn2&apos;)\n}\n\n// 创建 index.js 文件，内容如\nimport { fn1, fn2 } from &apos;./util2.js&apos;\nfn1()\nfn2()\n</code></pre><p>复制</p>\n<blockquote>\n<p>题目：ES6 class 和普通构造函数的区别</p>\n</blockquote>\n<h3 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a><strong>class</strong></h3><p>class 其实一直是 JS 的关键字（保留字），但是一直没有正式使用，直到 ES6 。 ES6 的 class 就是取代之前构造函数初始化对象的形式，从语法上更加符合面向对象的写法。例如：</p>\n<p>JS 构造函数的写法</p>\n<pre><code>function MathHandle(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nMathHandle.prototype.add = function () {\n  return this.x + this.y;\n};\n\nvar m = new MathHandle(1, 2);\nconsole.log(m.add())\n</code></pre><p>复制</p>\n<p>用 ES6 class 的写法</p>\n<pre><code>class MathHandle {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  add() {\n    return this.x + this.y;\n  }\n}\nconst m = new MathHandle(1, 2);\nconsole.log(m.add())\n</code></pre><p>复制</p>\n<p>注意以下几点，全都是关于 class 语法的：</p>\n<ul>\n<li>class 是一种新的语法形式，是<code>class Name {...}</code>这种形式，和函数的写法完全不一样</li>\n<li>两者对比，构造函数函数体的内容要放在 class 中的<code>constructor</code>函数中，<code>constructor</code>即构造器，初始化实例时默认执行</li>\n<li>class 中函数的写法是<code>add() {...}</code>这种形式，并没有<code>function</code>关键字</li>\n</ul>\n<p>使用 class 来实现继承就更加简单了，至少比构造函数实现继承简单很多。看下面例子</p>\n<p>JS 构造函数实现继承</p>\n<pre><code>// 动物\nfunction Animal() {\n    this.eat = function () {\n        console.log(&apos;animal eat&apos;)\n    }\n}\n// 狗\nfunction Dog() {\n    this.bark = function () {\n        console.log(&apos;dog bark&apos;)\n    }\n}\nDog.prototype = new Animal()\n// 哈士奇\nvar hashiqi = new Dog()\n</code></pre><p>复制</p>\n<p>ES6 class 实现继承</p>\n<pre><code>class Animal {\n    constructor(name) {\n        this.name = name\n    }\n    eat() {\n        console.log(`${this.name} eat`)\n    }\n}\n\nclass Dog extends Animal {\n    constructor(name) {\n        super(name)\n        this.name = name\n    }\n    say() {\n        console.log(`${this.name} say`)\n    }\n}\nconst dog = new Dog(&apos;哈士奇&apos;)\ndog.say()\ndog.eat()\n</code></pre><p>复制</p>\n<p>注意以下两点：</p>\n<ul>\n<li>使用<code>extends</code>即可实现继承，更加符合经典面向对象语言的写法，如 Java</li>\n<li>子类的<code>constructor</code>一定要执行<code>super()</code>，以调用父类的<code>constructor</code></li>\n</ul>\n<blockquote>\n<p>题目：ES6 中新增的数据类型有哪些？</p>\n</blockquote>\n<h3 id=\"Set-和-Map\"><a href=\"#Set-和-Map\" class=\"headerlink\" title=\"Set 和 Map\"></a><strong>Set 和 Map</strong></h3><p>Set 和 Map 都是 ES6 中新增的数据结构，是对当前 JS 数组和对象这两种重要数据结构的扩展。由于是新增的数据结构，目前尚未被大规模使用，但是作为前端程序员，提前了解是必须做到的。先总结一下两者最关键的地方：</p>\n<ul>\n<li>Set 类似于数组，但数组可以允许元素重复，Set 不允许元素重复</li>\n<li>Map 类似于对象，但普通对象的 key 必须是字符串或者数字，而 Map 的 key 可以是任何数据类型</li>\n</ul>\n<p><strong>Set</strong></p>\n<p>Set 实例不允许元素有重复，可以通过以下示例证明。可以通过一个数组初始化一个 Set 实例，或者通过<code>add</code>添加元素，元素不能重复，重复的会被忽略。</p>\n<pre><code>// 例1\nconst set = new Set([1, 2, 3, 4, 4]);\nconsole.log(set) // Set(4) {1, 2, 3, 4}\n\n// 例2\nconst set = new Set();\n[2, 3, 5, 4, 5, 8, 8].forEach(item =&gt; set.add(item));\nfor (let item of set) {\n  console.log(item);\n}\n// 2 3 5 4 8\n</code></pre><p>复制</p>\n<p>Set 实例的属性和方法有</p>\n<ul>\n<li><code>size</code>：获取元素数量。</li>\n<li><code>add(value)</code>：添加元素，返回 Set 实例本身。</li>\n<li><code>delete(value)</code>：删除元素，返回一个布尔值，表示删除是否成功。</li>\n<li><code>has(value)</code>：返回一个布尔值，表示该值是否是 Set 实例的元素。</li>\n<li><p><code>clear()</code>：清除所有元素，没有返回值。</p>\n<p>const s = new Set();<br>s.add(1).add(2).add(2); // 添加元素</p>\n<p>s.size // 2</p>\n<p>s.has(1) // true<br>s.has(2) // true<br>s.has(3) // false</p>\n<p>s.delete(2);<br>s.has(2) // false</p>\n<p>s.clear();<br>console.log(s);  // Set(0) {}</p>\n</li>\n</ul>\n<p>复制</p>\n<p>Set 实例的遍历，可使用如下方法</p>\n<ul>\n<li><code>keys()</code>：返回键名的遍历器。</li>\n<li><code>values()</code>：返回键值的遍历器。不过由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys()</code>和<code>values()</code>返回结果一致。</li>\n<li><code>entries()</code>：返回键值对的遍历器。</li>\n<li><p><code>forEach()</code>：使用回调函数遍历每个成员。</p>\n<p>let set = new Set([‘aaa’, ‘bbb’, ‘ccc’]);</p>\n<p>for (let item of set.keys()) {<br>  console.log(item);<br>}<br>// aaa<br>// bbb<br>// ccc</p>\n<p>for (let item of set.values()) {<br>  console.log(item);<br>}<br>// aaa<br>// bbb<br>// ccc</p>\n<p>for (let item of set.entries()) {<br>  console.log(item);<br>}<br>// [“aaa”, “aaa”]<br>// [“bbb”, “bbb”]<br>// [“ccc”, “ccc”]</p>\n<p>set.forEach((value, key) =&gt; console.log(key + ‘ : ‘ + value))<br>// aaa : aaa<br>// bbb : bbb<br>// ccc : ccc</p>\n</li>\n</ul>\n<p>复制</p>\n<p><strong>Map</strong></p>\n<p>Map 的用法和普通对象基本一致，先看一下它能用非字符串或者数字作为 key 的特性。</p>\n<pre><code>const map = new Map();\nconst obj = {p: &apos;Hello World&apos;};\n\nmap.set(obj, &apos;OK&apos;)\nmap.get(obj) // &quot;OK&quot;\n\nmap.has(obj) // true\nmap.delete(obj) // true\nmap.has(obj) // false\n</code></pre><p>复制</p>\n<p>需要使用<code>new Map()</code>初始化一个实例，下面代码中<code>set`</code>get<code>has</code>delete<code>顾名即可思义（下文也会演示）。其中，</code>map.set(obj, ‘OK’)<code>就是用对象作为的 key （不光可以是对象，任何数据类型都可以），并且后面通过</code>map.get(obj)`正确获取了。</p>\n<p>Map 实例的属性和方法如下：</p>\n<ul>\n<li><code>size</code>：获取成员的数量</li>\n<li><code>set</code>：设置成员 key 和 value</li>\n<li><code>get</code>：获取成员属性值</li>\n<li><code>has</code>：判断成员是否存在</li>\n<li><code>delete</code>：删除成员</li>\n<li><p><code>clear</code>：清空所有</p>\n<p>const map = new Map();<br>map.set(‘aaa’, 100);<br>map.set(‘bbb’, 200);</p>\n<p>map.size // 2</p>\n<p>map.get(‘aaa’) // 100</p>\n<p>map.has(‘aaa’) // true</p>\n<p>map.delete(‘aaa’)<br>map.has(‘aaa’) // false</p>\n<p>map.clear()</p>\n</li>\n</ul>\n<p>复制</p>\n<p>Map 实例的遍历方法有：</p>\n<ul>\n<li><code>keys()</code>：返回键名的遍历器。</li>\n<li><code>values()</code>：返回键值的遍历器。</li>\n<li><code>entries()</code>：返回所有成员的遍历器。</li>\n<li><p><code>forEach()</code>：遍历 Map 的所有成员。</p>\n<p>const map = new Map();<br>map.set(‘aaa’, 100);<br>map.set(‘bbb’, 200);</p>\n<p>for (let key of map.keys()) {<br>  console.log(key);<br>}<br>// “aaa”<br>// “bbb”</p>\n<p>for (let value of map.values()) {<br>  console.log(value);<br>}<br>// 100<br>// 200</p>\n<p>for (let item of map.entries()) {<br>  console.log(item[0], item[1]);<br>}<br>// aaa 100<br>// bbb 200</p>\n<p>// 或者<br>for (let [key, value] of map.entries()) {<br>  console.log(key, value);<br>}<br>// aaa 100<br>// bbb 200</p>\n</li>\n</ul>\n<p>复制</p>\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a><strong>Promise</strong></h3><p><code>Promise</code>是 CommonJS 提出来的这一种规范，有多个版本，在 ES6 当中已经纳入规范，原生支持 Promise 对象，非 ES6 环境可以用类似 Bluebird、Q 这类库来支持。</p>\n<p><code>Promise</code> 可以将回调变成链式调用写法，流程更加清晰，代码更加优雅。</p>\n<p>简单归纳下 Promise：<strong>三个状态、两个过程、一个方法</strong>，快速记忆方法：<strong>3-2-1</strong></p>\n<p>三个状态：<code>pending</code>、<code>fulfilled</code>、<code>rejected</code></p>\n<p>两个过程：</p>\n<ul>\n<li>pending→fulfilled（resolve）</li>\n<li>pending→rejected（reject）</li>\n</ul>\n<p>一个方法：<code>then</code></p>\n<p>当然还有其他概念，如<code>catch</code>、 <code>Promise.all/race</code>，这里就不展开了。</p>\n<p>关于 ES6/7 的考查内容还有很多，本小节就不逐一介绍了，如果想继续深入学习，可以在线看《<a href=\"https://link.juejin.im?target=http%3A%2F%2Fes6.ruanyifeng.com%2F\" target=\"_blank\" rel=\"noopener\">ES6入门</a>》。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h2><p>本小节主要总结了 ES 基础语法中面试经常考查的知识点，包括之前就考查较多的原型、异步、作用域，以及 ES6 的一些新内容，这些知识点希望大家都要掌握。</p>\n<p>上一篇：<a href=\"541670\">准备：简历编写和面试前准备</a>下一篇：<a href=\"541672\">一面 2：JS-Web-API 知识点与高频考题解析</a></p>\n<h1 id=\"一面-2：JS-Web-API-知识点与高频考题解析\"><a href=\"#一面-2：JS-Web-API-知识点与高频考题解析\" class=\"headerlink\" title=\"一面 2：JS-Web-API 知识点与高频考题解析\"></a><strong>一面 2：JS-Web-API 知识点与高频考题解析</strong></h1><p>除 ES 基础之外，Web 前端经常会用到一些跟浏览器相关的 API，接下来我们一起梳理一下。</p>\n<h2 id=\"知识点梳理-1\"><a href=\"#知识点梳理-1\" class=\"headerlink\" title=\"知识点梳理\"></a><strong>知识点梳理</strong></h2><ul>\n<li>BOM 操作</li>\n<li>DOM 操作</li>\n<li>事件绑定</li>\n<li>Ajax</li>\n<li>存储</li>\n</ul>\n<hr>\n<h2 id=\"BOM\"><a href=\"#BOM\" class=\"headerlink\" title=\"BOM\"></a><strong>BOM</strong></h2><p>BOM（浏览器对象模型）是浏览器本身的一些信息的设置和获取，例如获取浏览器的宽度、高度，设置让浏览器跳转到哪个地址。</p>\n<ul>\n<li><code>navigator</code></li>\n<li><code>screen</code></li>\n<li><code>location</code></li>\n<li><code>history</code></li>\n</ul>\n<p>这些对象就是一堆非常简单粗暴的 API，没任何技术含量，讲起来一点意思都没有，大家去 MDN 或者 w3school 这种网站一查就都明白了。面试的时候，面试官基本不会出太多这方面的题目，因为只要基础知识过关了，这些 API 即便你记不住，上网一查也都知道了。下面列举一下常用功能的代码示例</p>\n<p>获取浏览器特性（即俗称的<code>UA</code>）然后识别客户端，例如判断是不是 Chrome 浏览器</p>\n<pre><code>var ua = navigator.userAgent\nvar isChrome = ua.indexOf(&apos;Chrome&apos;)\nconsole.log(isChrome)\n</code></pre><p>复制</p>\n<p>获取屏幕的宽度和高度</p>\n<pre><code>console.log(screen.width)\nconsole.log(screen.height)\n</code></pre><p>复制</p>\n<p>获取网址、协议、path、参数、hash 等</p>\n<pre><code>// 例如当前网址是 https://juejin.im/timeline/frontend?a=10&amp;b=10#some\nconsole.log(location.href)  // https://juejin.im/timeline/frontend?a=10&amp;b=10#some\nconsole.log(location.protocol) // https:\nconsole.log(location.pathname) // /timeline/frontend\nconsole.log(location.search) // ?a=10&amp;b=10\nconsole.log(location.hash) // #some\n</code></pre><p>复制</p>\n<p>另外，还有调用浏览器的前进、后退功能等</p>\n<pre><code>history.back()\nhistory.forward()\n</code></pre><p>复制</p>\n<hr>\n<h2 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a><strong>DOM</strong></h2><blockquote>\n<p>题目：DOM 和 HTML 区别和联系</p>\n</blockquote>\n<h3 id=\"什么是-DOM\"><a href=\"#什么是-DOM\" class=\"headerlink\" title=\"什么是 DOM\"></a><strong>什么是 DOM</strong></h3><p>讲 DOM 先从 HTML 讲起，讲 HTML 先从 XML 讲起。XML 是一种可扩展的标记语言，所谓可扩展就是它可以描述任何结构化的数据，它是一棵树！</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;note&gt;\n  &lt;to&gt;Tove&lt;/to&gt;\n  &lt;from&gt;Jani&lt;/from&gt;\n  &lt;heading&gt;Reminder&lt;/heading&gt;\n  &lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt;\n  &lt;other&gt;\n    &lt;a&gt;&lt;/a&gt;\n    &lt;b&gt;&lt;/b&gt;\n  &lt;/other&gt;\n&lt;/note&gt;\n</code></pre><p>复制</p>\n<p>HTML 是一个有既定标签标准的 XML 格式，标签的名字、层级关系和属性，都被标准化（否则浏览器无法解析）。同样，它也是一棵树。</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div&gt;\n        &lt;p&gt;this is p&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>复制</p>\n<p>我们开发完的 HTML 代码会保存到一个文档中（一般以<code>.html</code>或者<code>.htm</code>结尾），文档放在服务器上，浏览器请求服务器，这个文档被返回。因此，最终浏览器拿到的是一个文档而已，文档的内容就是 HTML 格式的代码。</p>\n<p>但是浏览器要把这个文档中的 HTML 按照标准渲染成一个页面，此时浏览器就需要将这堆代码处理成自己能理解的东西，也得处理成 JS 能理解的东西，因为还得允许 JS 修改页面内容呢。</p>\n<p>基于以上需求，浏览器就需要把 HTML 转变成 DOM，HTML 是一棵树，DOM 也是一棵树。对 DOM 的理解，可以暂时先抛开浏览器的内部因素，先从 JS 着手，即可以认为 DOM 就是 JS 能识别的 HTML 结构，一个普通的 JS 对象或者数组。</p>\n<p>![DOM图示](data:image/svg+xml;utf8,)</p>\n<h3 id=\"获取-DOM-节点\"><a href=\"#获取-DOM-节点\" class=\"headerlink\" title=\"获取 DOM 节点\"></a><strong>获取 DOM 节点</strong></h3><p>最常用的 DOM API 就是获取节点，其中常用的获取方法如下面代码示例：</p>\n<pre><code>// 通过 id 获取\nvar div1 = document.getElementById(&apos;div1&apos;) // 元素\n\n// 通过 tagname 获取\nvar divList = document.getElementsByTagName(&apos;div&apos;)  // 集合\nconsole.log(divList.length)\nconsole.log(divList[0])\n\n// 通过 class 获取\nvar containerList = document.getElementsByClassName(&apos;container&apos;) // 集合\n\n// 通过 CSS 选择器获取\nvar pList = document.querySelectorAll(&apos;p&apos;) // 集合\n</code></pre><p>复制</p>\n<blockquote>\n<p>题目：property 和 attribute 的区别是什么？</p>\n</blockquote>\n<h3 id=\"property\"><a href=\"#property\" class=\"headerlink\" title=\"property\"></a><strong>property</strong></h3><p>DOM 节点就是一个 JS 对象，它符合之前讲述的对象的特征 —— 可扩展属性，因为 DOM 节点本质上也是一个 JS 对象。因此，如下代码所示，<code>p</code>可以有<code>style</code>属性，有<code>className`</code>nodeName<code></code>nodeType`属性。注意，<strong>这些都是 JS 范畴的属性，符合 JS 语法标准的</strong>。</p>\n<pre><code>var pList = document.querySelectorAll(&apos;p&apos;)\nvar p = pList[0]\nconsole.log(p.style.width)  // 获取样式\np.style.width = &apos;100px&apos;  // 修改样式\nconsole.log(p.className)  // 获取 class\np.className = &apos;p1&apos;  // 修改 class\n\n// 获取 nodeName 和 nodeType\nconsole.log(p.nodeName)\nconsole.log(p.nodeType)\n</code></pre><p>复制</p>\n<h3 id=\"attribute\"><a href=\"#attribute\" class=\"headerlink\" title=\"attribute\"></a><strong>attribute</strong></h3><p>property 的获取和修改，是直接改变 JS 对象，而 attribute 是直接改变 HTML 的属性，两种有很大的区别。attribute 就是对 HTML 属性的 get 和 set，和 DOM 节点的 JS 范畴的 property 没有关系。</p>\n<pre><code>var pList = document.querySelectorAll(&apos;p&apos;)\nvar p = pList[0]\np.getAttribute(&apos;data-name&apos;)\np.setAttribute(&apos;data-name&apos;, &apos;juejin&apos;)\np.getAttribute(&apos;style&apos;)\np.setAttribute(&apos;style&apos;, &apos;font-size:30px;&apos;)\n</code></pre><p>复制</p>\n<p>而且，get 和 set attribute 时，还会触发 DOM 的查询或者重绘、重排，频繁操作会影响页面性能。</p>\n<blockquote>\n<p>题目：DOM 操作的基本 API 有哪些？</p>\n</blockquote>\n<h3 id=\"DOM-树操作\"><a href=\"#DOM-树操作\" class=\"headerlink\" title=\"DOM 树操作\"></a><strong>DOM 树操作</strong></h3><p>新增节点</p>\n<pre><code>var div1 = document.getElementById(&apos;div1&apos;)\n\n// 添加新节点\nvar p1 = document.createElement(&apos;p&apos;)\np1.innerHTML = &apos;this is p1&apos;\ndiv1.appendChild(p1) // 添加新创建的元素\n\n// 移动已有节点。注意，这里是“移动”，并不是拷贝\nvar p2 = document.getElementById(&apos;p2&apos;)\ndiv1.appendChild(p2)\n</code></pre><p>复制</p>\n<p>获取父元素</p>\n<pre><code>var div1 = document.getElementById(&apos;div1&apos;)\nvar parent = div1.parentElement\n</code></pre><p>复制</p>\n<p>获取子元素</p>\n<pre><code>var div1 = document.getElementById(&apos;div1&apos;)\nvar child = div1.childNodes\n</code></pre><p>复制</p>\n<p>删除节点</p>\n<pre><code>var div1 = document.getElementById(&apos;div1&apos;)\nvar child = div1.childNodes\ndiv1.removeChild(child[0])\n</code></pre><p>复制</p>\n<p>还有其他操作的API，例如获取前一个节点、获取后一个节点等，但是面试过程中经常考到的就是上面几个。</p>\n<hr>\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a><strong>事件</strong></h2><h3 id=\"事件绑定\"><a href=\"#事件绑定\" class=\"headerlink\" title=\"事件绑定\"></a><strong>事件绑定</strong></h3><p>普通的事件绑定写法如下：</p>\n<pre><code>var btn = document.getElementById(&apos;btn1&apos;)\nbtn.addEventListener(&apos;click&apos;, function (event) {\n    // event.preventDefault() // 阻止默认行为\n    // event.stopPropagation() // 阻止冒泡\n    console.log(&apos;clicked&apos;)\n})\n</code></pre><p>复制</p>\n<p>为了编写简单的事件绑定，可以编写通用的事件绑定函数。这里虽然比较简单，但是会随着后文的讲解，来继续完善和丰富这个函数。</p>\n<pre><code>// 通用的事件绑定函数\nfunction bindEvent(elem, type, fn) {\n    elem.addEventListener(type, fn)\n}\nvar a = document.getElementById(&apos;link1&apos;)\n// 写起来更加简单了\nbindEvent(a, &apos;click&apos;, function(e) {\n    e.preventDefault() // 阻止默认行为\n    alert(&apos;clicked&apos;)\n})\n</code></pre><p>复制</p>\n<p>最后，<strong>如果面试被问到 IE 低版本兼容性问题，我劝你果断放弃这份工作机会</strong>。现在互联网流量都在 App 上， IE 占比越来越少，再去为 IE 浪费青春不值得，要尽量去做 App 相关的工作。</p>\n<blockquote>\n<p>题目：什么是事件冒泡？</p>\n</blockquote>\n<h3 id=\"事件冒泡\"><a href=\"#事件冒泡\" class=\"headerlink\" title=\"事件冒泡\"></a><strong>事件冒泡</strong></h3><pre><code>&lt;body&gt;\n    &lt;div id=&quot;div1&quot;&gt;\n        &lt;p id=&quot;p1&quot;&gt;激活&lt;/p&gt;\n        &lt;p id=&quot;p2&quot;&gt;取消&lt;/p&gt;\n        &lt;p id=&quot;p3&quot;&gt;取消&lt;/p&gt;\n        &lt;p id=&quot;p4&quot;&gt;取消&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;div id=&quot;div2&quot;&gt;\n        &lt;p id=&quot;p5&quot;&gt;取消&lt;/p&gt;\n        &lt;p id=&quot;p6&quot;&gt;取消&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n</code></pre><p>复制</p>\n<p>对于以上 HTML 代码结构，要求点击<code>p1</code>时候进入激活状态，点击其他任何<code>&lt;p&gt;</code>都取消激活状态，如何实现？代码如下，注意看注释：</p>\n<pre><code>var body = document.body\nbindEvent(body, &apos;click&apos;, function (e) {\n    // 所有 p 的点击都会冒泡到 body 上，因为 DOM 结构中 body 是 p 的上级节点，事件会沿着 DOM 树向上冒泡\n    alert(&apos;取消&apos;)\n})\n\nvar p1 = document.getElementById(&apos;p1&apos;)\nbindEvent(p1, &apos;click&apos;, function (e) {\n    e.stopPropagation() // 阻止冒泡\n    alert(&apos;激活&apos;)\n})\n</code></pre><p>复制</p>\n<p>如果我们在<code>p1`</code>div1<code></code>body<code>中都绑定了事件，它是会根据 DOM 的结构来冒泡，从下到上挨个执行的。但是我们使用</code>e.stopPropagation()`就可以阻止冒泡</p>\n<blockquote>\n<p>题目：如何使用事件代理？有何好处？</p>\n</blockquote>\n<h3 id=\"事件代理\"><a href=\"#事件代理\" class=\"headerlink\" title=\"事件代理\"></a><strong>事件代理</strong></h3><p>我们设定一种场景，如下代码，一个<code>&lt;div&gt;</code>中包含了若干个<code>&lt;a&gt;</code>，而且还能继续增加。那如何快捷方便地为所有<code>&lt;a&gt;</code>绑定事件呢？</p>\n<pre><code>&lt;div id=&quot;div1&quot;&gt;\n    &lt;a href=&quot;#&quot;&gt;a1&lt;/a&gt;\n    &lt;a href=&quot;#&quot;&gt;a2&lt;/a&gt;\n    &lt;a href=&quot;#&quot;&gt;a3&lt;/a&gt;\n    &lt;a href=&quot;#&quot;&gt;a4&lt;/a&gt;\n&lt;/div&gt;\n&lt;button&gt;点击增加一个 a 标签&lt;/button&gt;\n</code></pre><p>复制</p>\n<p>这里就会用到事件代理。我们要监听<code>&lt;a&gt;</code>的事件，但要把具体的事件绑定到<code>&lt;div&gt;</code>上，然后看事件的触发点是不是<code>&lt;a&gt;</code>。</p>\n<pre><code>var div1 = document.getElementById(&apos;div1&apos;)\ndiv1.addEventListener(&apos;click&apos;, function (e) {\n    // e.target 可以监听到触发点击事件的元素是哪一个\n    var target = e.target\n    if (e.nodeName === &apos;A&apos;) {\n        // 点击的是 &lt;a&gt; 元素\n        alert(target.innerHTML)\n    }\n})\n</code></pre><p>复制</p>\n<p>我们现在完善一下之前写的通用事件绑定函数，加上事件代理。</p>\n<pre><code>function bindEvent(elem, type, selector, fn) {\n    // 这样处理，可接收两种调用方式 bindEvent(div1, &apos;click&apos;, &apos;a&apos;, function () {...}) 和 bindEvent(div1, &apos;click&apos;, function () {...}) 这两种\n    if (fn == null) {\n        fn = selector\n        selector = null\n    }\n\n    // 绑定事件\n    elem.addEventListener(type, function (e) {\n        var target\n        if (selector) {\n            // 有 selector 说明需要做事件代理\n            // 获取触发时间的元素，即 e.target\n            target = e.target\n            // 看是否符合 selector 这个条件\n            if (target.matches(selector)) {\n                fn.call(target, e)\n            }\n        } else {\n            // 无 selector ，说明不需要事件代理\n            fn(e)\n        }\n    })\n}\n</code></pre><p>复制</p>\n<p>然后这样使用，简单很多。</p>\n<pre><code>// 使用代理，bindEvent 多一个 &apos;a&apos; 参数\nvar div1 = document.getElementById(&apos;div1&apos;)\nbindEvent(div1, &apos;click&apos;, &apos;a&apos;, function (e) {\n    console.log(this.innerHTML)\n})\n\n// 不使用代理\nvar a = document.getElementById(&apos;a1&apos;)\nbindEvent(div1, &apos;click&apos;, function (e) {\n    console.log(a.innerHTML)\n})\n</code></pre><p>复制</p>\n<p>最后，使用代理的优点如下：</p>\n<ul>\n<li>使代码简洁</li>\n<li>减少浏览器的内存占用</li>\n</ul>\n<hr>\n<h2 id=\"Ajax\"><a href=\"#Ajax\" class=\"headerlink\" title=\"Ajax\"></a><strong>Ajax</strong></h2><h3 id=\"XMLHttpRequest\"><a href=\"#XMLHttpRequest\" class=\"headerlink\" title=\"XMLHttpRequest\"></a><strong>XMLHttpRequest</strong></h3><blockquote>\n<p>题目：手写 XMLHttpRequest 不借助任何库</p>\n</blockquote>\n<p>这是很多奇葩的、个性的面试官经常用的手段。这种考查方式存在很多争议，但是你不能完全说它是错误的，毕竟也是考查对最基础知识的掌握情况。</p>\n<pre><code>var xhr = new XMLHttpRequest()\nxhr.open(&quot;GET&quot;, &quot;/api&quot;, false)\nxhr.onreadystatechange = function () {\n    // 这里的函数异步执行，可参考之前 JS 基础中的异步模块\n    if (xhr.readyState == 4) {\n        if (xhr.status == 200) {\n            alert(xhr.responseText)\n        }\n    }\n}\nxhr.send(null)\n</code></pre><p>复制</p>\n<p>当然，使用 jQuery、Zepto 或 Fetch 等库来写就更加简单了，这里不再赘述。</p>\n<h3 id=\"状态码说明\"><a href=\"#状态码说明\" class=\"headerlink\" title=\"状态码说明\"></a><strong>状态码说明</strong></h3><p>上述代码中，有两处状态码需要说明。<code>xhr.readyState</code>是浏览器判断请求过程中各个阶段的，<code>xhr.status</code>是 HTTP 协议中规定的不同结果的返回状态说明。</p>\n<p><code>xhr.readyState</code>的状态码说明：</p>\n<ul>\n<li>0 - (未初始化）还没有调用<code>send()</code>方法</li>\n<li>1 -（载入）已调用<code>send()</code>方法，正在发送请求</li>\n<li>2 -（载入完成）<code>send()</code>方法执行完成，已经接收到全部响应内容</li>\n<li>3 -（交互）正在解析响应内容</li>\n<li>4 -（完成）响应内容解析完成，可以在客户端调用了</li>\n</ul>\n<blockquote>\n<p>题目：HTTP 协议中，response 的状态码，常见的有哪些？</p>\n</blockquote>\n<p><code>xhr.status</code>即 HTTP 状态码，有 <code>2xx`</code>3xx<code>4xx</code>5xx` 这几种，比较常用的有以下几种：</p>\n<ul>\n<li><code>200</code> 正常</li>\n<li><code>3xx</code><ul>\n<li><code>301</code> 永久重定向。如<code>http://xxx.com</code>这个 GET 请求（最后没有<code>/</code>），就会被<code>301</code>到<code>http://xxx.com/</code>（最后是<code>/</code>）</li>\n<li><code>302</code> 临时重定向。临时的，不是永久的</li>\n<li><code>304</code> 资源找到但是不符合请求条件，不会返回任何主体。如发送 GET 请求时，head 中有<code>If-Modified-Since: xxx</code>（要求返回更新时间是<code>xxx</code>时间之后的资源），如果此时服务器 端资源未更新，则会返回<code>304</code>，即不符合要求</li>\n</ul>\n</li>\n<li><code>404</code> 找不到资源</li>\n<li><code>5xx</code> 服务器端出错了</li>\n</ul>\n<p>看完要明白，为何上述代码中要同时满足<code>xhr.readyState == 4</code>和<code>xhr.status == 200</code>。</p>\n<h3 id=\"Fetch-API\"><a href=\"#Fetch-API\" class=\"headerlink\" title=\"Fetch API\"></a><strong>Fetch API</strong></h3><p>目前已经有一个获取 HTTP 请求更加方便的 API：<code>Fetch</code>，通过<code>Fetch</code>提供的<code>fetch()</code>这个全局函数方法可以很简单地发起异步请求，并且支持<code>Promise</code>的回调。但是 Fetch API 是比较新的 API，具体使用的时候还需要查查 <a href=\"https://link.juejin.im?target=https%3A%2F%2Fcaniuse.com%2F\" target=\"_blank\" rel=\"noopener\">caniuse</a>，看下其浏览器兼容情况。</p>\n<p>看一个简单的例子：</p>\n<pre><code>fetch(&apos;some/api/data.json&apos;, {\n  method:&apos;POST&apos;, //请求类型 GET、POST\n  headers:{}, // 请求的头信息，形式为 Headers 对象或 ByteString\n  body:{}, //请求发送的数据 blob、BufferSource、FormData、URLSearchParams（get 或head 方法中不能包含 body）\n  mode:&apos;&apos;, //请求的模式，是否跨域等，如 cors、 no-cors 或 same-origin\n  credentials:&apos;&apos;, //cookie 的跨域策略，如 omit、same-origin 或 include\n  cache:&apos;&apos;, //请求的 cache 模式: default、no-store、reload、no-cache、 force-cache 或 only-if-cached\n}).then(function(response) { ... });\n</code></pre><p>复制</p>\n<p><code>Fetch</code> 支持<code>headers</code>定义，通过<code>headers</code>自定义可以方便地实现多种请求方法（ PUT、GET、POST 等）、请求头（包括跨域）和<code>cache</code>策略等；除此之外还支持 response（返回数据）多种类型，比如支持二进制文件、字符串和<code>formData</code>等。</p>\n<h3 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a><strong>跨域</strong></h3><blockquote>\n<p>题目：如何实现跨域？</p>\n</blockquote>\n<p>浏览器中有 <strong>同源策略</strong> ，即一个域下的页面中，无法通过 Ajax 获取到其他域的接口。例如有一个接口<code>http://m.juejin.com/course/ajaxcourserecom?cid=459</code>，你自己的一个页面<code>http://www.yourname.com/page1.html</code>中的 Ajax 无法获取这个接口。这正是命中了“同源策略”。如果浏览器哪些地方忽略了同源策略，那就是浏览器的安全漏洞，需要紧急修复。</p>\n<p>url 哪些地方不同算作跨域？</p>\n<ul>\n<li>协议</li>\n<li>域名</li>\n<li>端口</li>\n</ul>\n<p>但是 HTML 中几个标签能逃避过同源策略——<code>&lt;script src=&quot;xxx&quot;&gt;</code>、<code>&lt;img src=&quot;xxxx&quot;/&gt;</code>、<code>&lt;link href=&quot;xxxx&quot;&gt;</code>，这三个标签的<code>src/href</code>可以加载其他域的资源，不受同源策略限制。</p>\n<p>因此，这使得这三个标签可以做一些特殊的事情。</p>\n<ul>\n<li><code>&lt;img&gt;</code>可以做打点统计，因为统计方并不一定是同域的，在讲解 JS 基础知识异步的时候有过代码示例。除了能跨域之外，<code>&lt;img&gt;</code>几乎没有浏览器兼容问题，它是一个非常古老的标签。</li>\n<li><code>&lt;script&gt;</code>和<code>&lt;link&gt;</code>可以使用 CDN，CDN 基本都是其他域的链接。</li>\n<li>另外<code>&lt;script&gt;</code>还可以实现 JSONP，能获取其他域接口的信息，接下来马上讲解。</li>\n</ul>\n<p>但是请注意，所有的跨域请求方式，最终都需要信息提供方来做出相应的支持和改动，也就是要经过信息提供方的同意才行，否则接收方是无法得到它们的信息的，浏览器是不允许的。</p>\n<h3 id=\"解决跨域-JSONP\"><a href=\"#解决跨域-JSONP\" class=\"headerlink\" title=\"解决跨域 - JSONP\"></a><strong>解决跨域 - JSONP</strong></h3><p>首先，有一个概念你要明白，例如访问<code>http://coding.m.juejin.com/classindex.html</code>的时候，服务器端就一定有一个<code>classindex.html</code>文件吗？—— 不一定，服务器可以拿到这个请求，动态生成一个文件，然后返回。 同理，<code>&lt;script src=&quot;http://coding.m.juejin.com/api.js&quot;&gt;</code>也不一定加载一个服务器端的静态文件，服务器也可以动态生成文件并返回。OK，接下来正式开始。</p>\n<p>例如我们的网站和掘金网，肯定不是一个域。我们需要掘金网提供一个接口，供我们来获取。首先，我们在自己的页面这样定义</p>\n<pre><code>&lt;script&gt;\nwindow.callback = function (data) {\n    // 这是我们跨域得到信息\n    console.log(data)\n}\n&lt;/script&gt;\n</code></pre><p>复制</p>\n<p>然后掘金网给我提供了一个<code>http://coding.m.juejin.com/api.js</code>，内容如下（之前说过，服务器可动态生成内容）</p>\n<pre><code>callback({x:100, y:200})\n</code></pre><p>复制</p>\n<p>最后我们在页面中加入<code>&lt;script src=&quot;http://coding.m.juejin.com/api.js&quot;&gt;&lt;/script&gt;</code>，那么这个js加载之后，就会执行内容，我们就得到内容了。</p>\n<h3 id=\"解决跨域-服务器端设置-http-header\"><a href=\"#解决跨域-服务器端设置-http-header\" class=\"headerlink\" title=\"解决跨域 - 服务器端设置 http header\"></a><strong>解决跨域 - 服务器端设置 http header</strong></h3><p>这是需要在服务器端设置的，作为前端工程师我们不用详细掌握，但是要知道有这么个解决方案。而且，现在推崇的跨域解决方案是这一种，比 JSONP 简单许多。</p>\n<pre><code>response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://m.juejin.com/&quot;);  // 第二个参数填写允许跨域的域名称，不建议直接写 &quot;*&quot;\nresponse.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;);\nresponse.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;);\n\n// 接收跨域的cookie\nresponse.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);\n</code></pre><p>复制</p>\n<hr>\n<h2 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a><strong>存储</strong></h2><blockquote>\n<p>题目：cookie 和 localStorage 有何区别？</p>\n</blockquote>\n<h3 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a><strong>cookie</strong></h3><p>cookie 本身不是用来做服务器端存储的（计算机领域有很多这种“狗拿耗子”的例子，例如 CSS 中的 float），它是设计用来在服务器和客户端进行信息传递的，因此我们的每个 HTTP 请求都带着 cookie。但是 cookie 也具备浏览器端存储的能力（例如记住用户名和密码），因此就被开发者用上了。</p>\n<p>使用起来也非常简单，<code>document.cookie = ....</code>即可。</p>\n<p>但是 cookie 有它致命的缺点：</p>\n<ul>\n<li>存储量太小，只有 4KB</li>\n<li>所有 HTTP 请求都带着，会影响获取资源的效率</li>\n<li>API 简单，需要封装才能用</li>\n</ul>\n<h3 id=\"locationStorage-和-sessionStorage\"><a href=\"#locationStorage-和-sessionStorage\" class=\"headerlink\" title=\"locationStorage 和 sessionStorage\"></a><strong>locationStorage 和 sessionStorage</strong></h3><p>后来，HTML5 标准就带来了<code>sessionStorage</code>和<code>localStorage</code>，先拿<code>localStorage</code>来说，它是专门为了浏览器端缓存而设计的。其优点有：</p>\n<ul>\n<li>存储量增大到 5MB</li>\n<li>不会带到 HTTP 请求中</li>\n<li>API 适用于数据存储 <code>localStorage.setItem(key, value)`</code>localStorage.getItem(key)`</li>\n</ul>\n<p><code>sessionStorage</code>的区别就在于它是根据 session 过去时间而实现，而<code>localStorage</code>会永久有效，应用场景不同。例如，一些需要及时失效的重要信息放在<code>sessionStorage</code>中，一些不重要但是不经常设置的信息，放在<code>localStorage</code>中。</p>\n<p>另外告诉大家一个小技巧，针对<code>localStorage.setItem</code>，使用时尽量加入到<code>try-catch</code>中，某些浏览器是禁用这个 API 的，要注意。</p>\n<hr>\n<h2 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h2><p>本小节总结了 W3C 标准中 Web-API 部分，面试中常考的知识点，这些也是日常开发中最常用的 API 和知识。</p>\n<p>上一篇：<a href=\"541671\">一面 1：ES 基础知识点与高频考题解析</a>下一篇：<a href=\"541673\">一面 3：CSS-HTML 知识点与高频考题解析</a></p>\n<h1 id=\"一面-3：CSS-HTML-知识点与高频考题解析\"><a href=\"#一面-3：CSS-HTML-知识点与高频考题解析\" class=\"headerlink\" title=\"一面 3：CSS-HTML 知识点与高频考题解析\"></a><strong>一面 3：CSS-HTML 知识点与高频考题解析</strong></h1><p>CSS 和 HTML 是网页开发中布局相关的组成部分，涉及的内容比较多和杂乱，本小节重点介绍下常考的知识点。</p>\n<h2 id=\"知识点梳理-2\"><a href=\"#知识点梳理-2\" class=\"headerlink\" title=\"知识点梳理\"></a><strong>知识点梳理</strong></h2><ul>\n<li>选择器的权重和优先级</li>\n<li>盒模型<ul>\n<li>盒子大小计算</li>\n<li>margin 的重叠计算</li>\n</ul>\n</li>\n<li>浮动<code>float</code><ul>\n<li>浮动布局概念</li>\n<li>清理浮动</li>\n</ul>\n</li>\n<li>定位<code>position</code><ul>\n<li>文档流概念</li>\n<li>定位分类</li>\n<li>fixed 定位特点</li>\n<li>绝对定位计算方式</li>\n</ul>\n</li>\n<li><code>flex</code>布局</li>\n<li>如何实现居中对齐？</li>\n<li>理解语义化</li>\n<li>CSS3 动画</li>\n<li>重绘和回流</li>\n</ul>\n<hr>\n<h2 id=\"选择器的权重和优先级\"><a href=\"#选择器的权重和优先级\" class=\"headerlink\" title=\"选择器的权重和优先级\"></a><strong>选择器的权重和优先级</strong></h2><p>CSS 选择器有很多，不同的选择器的权重和优先级不一样，对于一个元素，如果存在多个选择器，那么就需要根据权重来计算其优先级。</p>\n<p>权重分为四级，分别是：</p>\n<ol>\n<li>代表内联样式，如<code>style=&quot;xxx&quot;</code>，权值为 1000；</li>\n<li>代表 ID 选择器，如<code>#content</code>，权值为 100；</li>\n<li>代表类、伪类和属性选择器，如<code>.content</code>、<code>:hover</code>、<code>[attribute]</code>，权值为 10；</li>\n<li>代表元素选择器和伪元素选择器，如<code>div</code>、<code>p</code>，权值为 1。</li>\n</ol>\n<p><strong>需要注意的是：通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以他们的权值都为 0</strong>。 权重值大的选择器其优先级也高，相同权重的优先级又遵循后定义覆盖前面定义的情况。</p>\n<h2 id=\"盒模型\"><a href=\"#盒模型\" class=\"headerlink\" title=\"盒模型\"></a><strong>盒模型</strong></h2><h3 id=\"什么是“盒子”\"><a href=\"#什么是“盒子”\" class=\"headerlink\" title=\"什么是“盒子”\"></a><strong>什么是“盒子”</strong></h3><p>初学 CSS 的朋友，一开始学 CSS 基础知识的时候一定学过<code>padding`</code>border<code>和</code>margin`，即内边距、边框和外边距。它们三者就构成了一个“盒子”。就像我们收到的快递，本来买了一部小小的手机，收到的却是那么大一个盒子。因为手机白色的包装盒和手机机器之间有间隔层（内边距），手机白色盒子有厚度，虽然很薄（边框），盒子和快递箱子之间还有一层泡沫板（外边距）。这就是一个典型的盒子。</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>如上图，真正的内容就是这些文字，文字外围有 10px 的内边距，5px 的边框，10px 的外边距。看到盒子了吧？</p>\n<blockquote>\n<p>题目：盒子模型的宽度如何计算</p>\n</blockquote>\n<h3 id=\"固定宽度的盒子\"><a href=\"#固定宽度的盒子\" class=\"headerlink\" title=\"固定宽度的盒子\"></a><strong>固定宽度的盒子</strong></h3><pre><code>&lt;div style=&quot;padding:10px; border:5px solid blue; margin: 10px; width:300px;&quot;&gt;\n    之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》，\n    文章言简意赅的介绍的浏览器的工作过程，web前端\n&lt;/div&gt;\n</code></pre><p>复制</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>如上图，得到网页效果之后，我们可以用截图工具来量一下文字内容的宽度。发现，文字内容的宽度刚好是 300px，也就是我们设置的宽度。</p>\n<p>因此，<strong>在盒子模型中，我们设置的宽度都是内容宽度，不是整个盒子的宽度。而整个盒子的宽度是：（内容宽度 + <code>border</code>宽度 + <code>padding</code>宽度 + <code>margin</code>宽度）之和</strong>。这样我们改四个中的其中一个，都会导致盒子宽度的改变。这对我们来说不友好。</p>\n<p>没关系，这个东西不友好早就有人发现了，而且已经解决，下文再说。</p>\n<h3 id=\"充满父容器的盒子\"><a href=\"#充满父容器的盒子\" class=\"headerlink\" title=\"充满父容器的盒子\"></a><strong>充满父容器的盒子</strong></h3><p>默认情况下，<code>div</code>是<code>display:block</code>，宽度会充满整个父容器。如下图：</p>\n<pre><code>&lt;div style=&quot;padding:10px; border:5px solid blue; margin: 10px; width:300px;&quot;&gt;\n    之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》，\n    文章言简意赅的介绍的浏览器的工作过程，web前端\n    之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》，\n    文章言简意赅的介绍的浏览器的工作过程，web前端\n&lt;/div&gt;\n</code></pre><p>复制</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>但是别忘记，这个 div 是个盒子模型，它的整个宽度包括（内容宽度 + <code>border</code>宽度 + <code>padding</code>宽度 + <code>margin</code>宽度），整个的宽度充满父容器。</p>\n<p>问题就在这里。如果父容器宽度不变，我们手动增大<code>margin</code>、<code>border</code>或<code>padding</code>其中一项的宽度值，都会导致内容宽度的减少。极端情况下，如果内容的宽度压缩到不能再压缩了（例如一个字的宽度），那么浏览器会强迫增加父容器的宽度。这可不是我们想要看到的。</p>\n<h3 id=\"包裹内容的盒子\"><a href=\"#包裹内容的盒子\" class=\"headerlink\" title=\"包裹内容的盒子\"></a><strong>包裹内容的盒子</strong></h3><p>这种情况下比较简单，内容的宽度按照内容计算，盒子的宽度将在内容宽度的基础上再增加（<code>padding</code>宽度 + <code>border</code>宽度 + <code>margin</code>宽度）之和。</p>\n<pre><code>&lt;div style=&quot;padding:10px; border:5px solid blue; margin: 10px; width:300px;&quot;&gt;\n    之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》\n&lt;/div&gt;\n</code></pre><p>复制</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<h3 id=\"box-sizing-border-box\"><a href=\"#box-sizing-border-box\" class=\"headerlink\" title=\"box-sizing:border-box\"></a><code>box-sizing:border-box</code></h3><p>前面提到，为盒子模型设置宽度，结果只是设置了内容的宽度，这个不合理。如何解决这一问题？答案就是为盒子指定样式：<strong><code>box-sizing:border-box</code></strong>。</p>\n<pre><code>&lt;div style=&quot;padding:10px; border:5px solid blue; margin: 10px; width:300px; box-sizing:border-box;&quot;&gt;\n    之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》\n&lt;/div&gt;\n</code></pre><p>复制</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>上图中，为<code>div</code>设置了<code>box-sizing:border-box</code>之后，300px 的<strong>宽度是内容 + <code>border</code> + 边框的宽度（不包括<code>margin</code>）</strong>，这样就比较符合我们的实际要求了。建议大家在为系统写 CSS 时候，第一个样式是：</p>\n<pre><code>* {\n    box-sizing:border-box;\n}\n</code></pre><p>复制</p>\n<p>大名鼎鼎的 Bootstrap 也把<code>box-sizing:border-box</code>加入到它的<code>*</code>选择器中，我们为什么不这样做呢？</p>\n<h3 id=\"纵向-margin-重叠\"><a href=\"#纵向-margin-重叠\" class=\"headerlink\" title=\"纵向 margin 重叠\"></a><strong>纵向 margin 重叠</strong></h3><p>这里提到 margin，就不得不提一下 margin 的这一特性——纵向重叠。如<code>&lt;p&gt;</code>的纵向 margin 是 16px，那么两个<code>&lt;p&gt;</code>之间纵向的距离是多少？—— 按常理来说应该是 16 + 16 = 32px，但是答案仍然是 16px。因为纵向的 margin 是会重叠的，如果两者不一样大的话，大的会把小的“吃掉”。</p>\n<hr>\n<h2 id=\"浮动float\"><a href=\"#浮动float\" class=\"headerlink\" title=\"浮动float\"></a><strong>浮动<code>float</code></strong></h2><p>float 用于网页布局比较多，使用起来也比较简单，这里总结了一些比较重要、需要注意的知识点，供大家参考。</p>\n<h3 id=\"误解和误用\"><a href=\"#误解和误用\" class=\"headerlink\" title=\"误解和误用\"></a><strong>误解和误用</strong></h3><p>float 被设计出来的初衷是用于<strong>文字环绕效果</strong>，即一个图片一段文字，图片<code>float:left</code>之后，文字会环绕图片。</p>\n<pre><code>&lt;div&gt;\n    &lt;img src=&quot;image/1.png&quot; style=&quot;float:left&quot;&gt;\n    一段文字一段文字一段文字一段文字一段文字一段文字一段文字一段文字一段文字\n&lt;/div&gt;\n</code></pre><p>复制</p>\n<p>但是，后来大家发现结合<code>float + div</code>可以实现之前通过<code>table</code>实现的网页布局，因此就被“误用”于网页布局了。</p>\n<blockquote>\n<p>题目：为何 float 会导致父元素塌陷？</p>\n</blockquote>\n<h3 id=\"破坏性\"><a href=\"#破坏性\" class=\"headerlink\" title=\"破坏性\"></a><strong>破坏性</strong></h3><p>![](data:image/svg+xml;utf8,)</p>\n<p>float 的<strong>破坏性</strong> —— float 破坏了父标签的原本结构，使得父标签出现了坍塌现象。导致这一现象的最根本原因在于：<strong>被设置了 float 的元素会脱离文档流</strong>。其根本原因在于 float 的设计初衷是解决文字环绕图片的问题。大家要记住 float 的这个影响。</p>\n<h3 id=\"包裹性\"><a href=\"#包裹性\" class=\"headerlink\" title=\"包裹性\"></a><strong>包裹性</strong></h3><p><strong>包裹性</strong>也是 float 的一个非常重要的特性，大家用 float 时一定要熟知这一特性。咱们还是先从一个小例子看起：</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>如上图，普通的 div 如果没有设置宽度，它会撑满整个屏幕，在之前的盒子模型那一节也讲到过。而如果给 div 增加<code>float:left</code>之后，它突然变得紧凑了，宽度发生了变化，把内容中的三个字包裹了——这就是包裹性。为 div 设置了 float 之后，其宽度会自动调整为包裹住内容宽度，而不是撑满整个父容器。</p>\n<p>注意，此时 div 虽然体现了包裹性，但是它的 display 样式是没有变化的，还是<code>display: block</code>。</p>\n<p>float 为什么要具有包裹性？其实答案还是得从 float 的设计初衷来寻找，float 是被设计用于实现文字环绕效果的。文字环绕图片比较好理解，但是如果想要让文字环绕一个 div 呢？此时 div 不被“包裹”起来的话，就无法实现环绕效果了。</p>\n<h3 id=\"清空格\"><a href=\"#清空格\" class=\"headerlink\" title=\"清空格\"></a><strong>清空格</strong></h3><p>float 还有一个大家可能不是很熟悉的特性——清空格。按照惯例，咱还是先举例子说明。</p>\n<pre><code>&lt;div style=&quot;border: 2px solid blue; padding:3px;&quot;&gt;\n    &lt;img src=&quot;image/1.png&quot;/&gt;\n    &lt;img src=&quot;image/2.png&quot;/&gt;\n    &lt;img src=&quot;image/3.png&quot;/&gt;\n    &lt;img src=&quot;image/4.png&quot;/&gt;\n&lt;/div&gt;\n</code></pre><p>复制</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>加上<code>float:left</code>之后：</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>上面第一张图中，正常的 img 中间是会有空格的，因为多个 img 标签会有换行，而浏览器识别换行为空格，这也是很正常的。第二张图中，为 img 增加了<code>float:left</code>的样式，这就使得 img 之间没有了空格，4 个 img 紧紧挨着。</p>\n<p>如果大家之前没注意，现在想想之前写过的程序，是不是有这个特性。为什么 float 适合用于网页排版（俗称“砌砖头”）？就是因为 float 排版出来的网页严丝合缝，中间连个苍蝇都飞不进去。</p>\n<p>“清空格”这一特性的根本原因是 float 会导致节点脱离文档流结构。它都不属于文档流结构了，那么它身边的什么换行、空格就都和它没了关系，它就尽量往一边靠拢，能靠多近就靠多近，这就是清空格的本质。</p>\n<blockquote>\n<p>题目：手写 clearfix</p>\n</blockquote>\n<h3 id=\"clearfix\"><a href=\"#clearfix\" class=\"headerlink\" title=\"clearfix\"></a><strong><code>clearfix</code></strong></h3><p>清除浮动的影响，一般使用的样式如下，统称<code>clearfix</code>代码。所有 float 元素的父容器，一般情况下都应该加<code>clearfix</code>这个 class。</p>\n<pre><code>.clearfix:after {\n    content: &apos;&apos;;\n    display: table;\n    clear: both;\n}\n.clearfix {\n    *zoom: 1; /* 兼容 IE 低版本 */\n}\n</code></pre><p>复制</p>\n<pre><code>&lt;div class=&quot;clearfix&quot;&gt;\n    &lt;img src=&quot;image/1.png&quot; style=&quot;float: left&quot;/&gt;\n    &lt;img src=&quot;image/2.png&quot; style=&quot;float: left&quot;/&gt;\n&lt;/div&gt;\n</code></pre><p>复制</p>\n<h3 id=\"小结-2\"><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h3><p>float 的设计初衷是解决文字环绕图片的问题，后来误打误撞用于做布局，因此有许多不合适或者需要注意的地方，上文基本都讲到了需要的知识点。如果是刚开始接触 float 的同学，学完上面的基础知识之后，还应该做一些练习实战一下 —— 经典的“圣杯布局”和“双飞翼布局”。这里就不再展开讲了，网上资料非常多，例如<a href=\"https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fentry%2F5a8868cdf265da4e7e10c133%3Futm_source%3Dgold_browser_extension\" target=\"_blank\" rel=\"noopener\">浅谈面试中常考的两种经典布局——圣杯与双飞翼</a>（此文的最后两张图清晰地展示了这两种布局）。</p>\n<hr>\n<h2 id=\"定位position\"><a href=\"#定位position\" class=\"headerlink\" title=\"定位position\"></a><strong>定位<code>position</code></strong></h2><p>position 用于网页元素的定位，可设置 static/relative/absolute/fixed 这些值，其中 static 是默认值，不用介绍。</p>\n<blockquote>\n<p>题目：relative 和 absolute 有何区别？</p>\n</blockquote>\n<h3 id=\"relative\"><a href=\"#relative\" class=\"headerlink\" title=\"relative\"></a><strong>relative</strong></h3><p>相对定位 relative 可以用一个例子很轻松地演示出来。例如我们写 4 个<code>&lt;p&gt;</code>，出来的样子大家不用看也能知道。</p>\n<pre><code>&lt;p&gt;第一段文字&lt;/p&gt;\n&lt;p&gt;第二段文字&lt;/p&gt;\n&lt;p&gt;第三段文字&lt;/p&gt;\n&lt;p&gt;第四段文字&lt;/p&gt;\n</code></pre><p>复制</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>然后我们在第三个<code>&lt;p&gt;</code>上面，加上<code>position:relative</code>并且设置<code>left</code>和<code>top</code>值，看这个<code>&lt;p&gt;</code>有什么变化。</p>\n<pre><code>&lt;p&gt;第一段文字&lt;/p&gt;\n&lt;p&gt;第二段文字&lt;/p&gt;\n&lt;p style=&quot;position:relative; top: 10px; left: 10px&quot;&gt;第三段文字&lt;/p&gt;\n&lt;p&gt;第四段文字&lt;/p&gt;\n</code></pre><p>复制</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>上图中，大家应该要识别出两个信息（相信大部分人会忽略第二个信息）</p>\n<ul>\n<li>第三个<code>&lt;p&gt;</code>发生了位置变化，分别向右向下移动了10px；</li>\n<li>其他的三个<code>&lt;p&gt;</code>位置没有发生变化，这一点也很重要。</li>\n</ul>\n<p>可见，<strong>relative 会导致自身位置的相对变化，而不会影响其他元素的位置、大小</strong>。这是 relative 的要点之一。还有第二个要点，就是 relative 产生一个新的定位上下文。下文有关于定位上下文的详细介绍，这里可以先通过一个例子来展示一下区别：</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>注意看这两图的区别，下文将有解释。</p>\n<h3 id=\"absolute\"><a href=\"#absolute\" class=\"headerlink\" title=\"absolute\"></a><strong>absolute</strong></h3><p>还是先写一个基本的 demo。</p>\n<pre><code>&lt;p&gt;第一段文字&lt;/p&gt;\n&lt;p&gt;第二段文字&lt;/p&gt;\n&lt;p style=&quot;background: yellow&quot;&gt;第三段文字&lt;/p&gt;\n&lt;p&gt;第四段文字&lt;/p&gt;\n</code></pre><p>复制</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>然后，我们把第三个<code>&lt;p&gt;</code>改为<code>position:absolute;</code>，看看会发生什么变化。</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>从上面的结果中，我们能看出几点信息：</p>\n<ul>\n<li>absolute 元素脱离了文档结构。和 relative 不同，其他三个元素的位置重新排列了。只要元素会脱离文档结构，它就会产生破坏性，导致父元素坍塌。（此时你应该能立刻想起来，float 元素也会脱离文档结构。）</li>\n<li>absolute 元素具有“包裹性”。之前<code>&lt;p&gt;</code>的宽度是撑满整个屏幕的，而此时<code>&lt;p&gt;</code>的宽度刚好是内容的宽度。</li>\n<li>absolute 元素具有“跟随性”。虽然 absolute 元素脱离了文档结构，但是它的位置并没有发生变化，还是老老实实地呆在它原本的位置，因为我们此时没有设置 top、left 的值。</li>\n<li>absolute 元素会悬浮在页面上方，会遮挡住下方的页面内容。</li>\n</ul>\n<p>最后，通过给 absolute元素设置 top、left 值，可自定义其内容，这个都是平时比较常用的了。这里需要注意的是，设置了 top、left 值时，元素是相对于最近的定位上下文来定位的，而不是相对于浏览器定位。</p>\n<h3 id=\"fixed\"><a href=\"#fixed\" class=\"headerlink\" title=\"fixed\"></a><strong>fixed</strong></h3><p>其实 fixed 和 absolute 是一样的，唯一的区别在于：absolute 元素是根据最近的定位上下文确定位置，而 fixed 根据浏览器确定位置。</p>\n<blockquote>\n<p>题目：relative、absolute 和 fixed 分别依据谁来定位？</p>\n</blockquote>\n<h3 id=\"定位上下文\"><a href=\"#定位上下文\" class=\"headerlink\" title=\"定位上下文\"></a><strong>定位上下文</strong></h3><p>relative 元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>fixed 元素的定位是相对于浏览器边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>absolute 的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了<code>position:relative/absolute/fixed</code>的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。如下两个图所示：</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<hr>\n<h2 id=\"flex布局\"><a href=\"#flex布局\" class=\"headerlink\" title=\"flex布局\"></a><strong><code>flex</code>布局</strong></h2><p>布局的传统解决方案基于盒子模型，依赖 <code>display</code> 属性 + <code>position</code> 属性 + <code>float</code> 属性。它对于那些特殊布局非常不方便，比如，垂直居中（下文会专门讲解）就不容易实现。在目前主流的移动端页面中，使用 flex 布局能更好地完成需求，因此 flex 布局的知识是必须要掌握的。</p>\n<h3 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a><strong>基本使用</strong></h3><p>任何一个容器都可以使用 flex 布局，代码也很简单。</p>\n<pre><code>&lt;style type=&quot;text/css&quot;&gt;\n    .container {\n      display: flex;\n    }\n    .item {\n        border: 1px solid #000;\n        flex: 1;\n    }\n&lt;/style&gt;\n\n&lt;div class=&quot;container&quot;&gt;\n    &lt;div class=&quot;item&quot;&gt;aaa&lt;/div&gt;\n    &lt;div class=&quot;item&quot; style=&quot;flex: 2&quot;&gt;bbb&lt;/div&gt;\n    &lt;div class=&quot;item&quot;&gt;ccc&lt;/div&gt;\n    &lt;div class=&quot;item&quot;&gt;ddd&lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>复制</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>注意，第三个<code>&lt;div&gt;</code>的<code>flex: 2</code>，其他的<code>&lt;div&gt;</code>的<code>flex: 1</code>，这样第二个<code>&lt;div&gt;</code>的宽度就是其他的<code>&lt;div&gt;</code>的两倍。</p>\n<h3 id=\"设计原理\"><a href=\"#设计原理\" class=\"headerlink\" title=\"设计原理\"></a><strong>设计原理</strong></h3><p>设置了<code>display: flex</code>的元素，我们称为“容器”（flex container），其所有的子节点我们称为“成员”（flex item）。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>将以上文字和图片结合起来，再详细看一遍，这样就能理解 flex 的设计原理，才能更好地实际使用。</p>\n<h3 id=\"设置主轴的方向\"><a href=\"#设置主轴的方向\" class=\"headerlink\" title=\"设置主轴的方向\"></a><strong>设置主轴的方向</strong></h3><p><code>flex-direction</code>可决定主轴的方向，有四个可选值：</p>\n<ul>\n<li>row（默认值）：主轴为水平方向，起点在左端。</li>\n<li>row-reverse：主轴为水平方向，起点在右端。</li>\n<li>column：主轴为垂直方向，起点在上沿。</li>\n<li><p>column-reverse：主轴为垂直方向，起点在下沿。</p>\n<p>.box {<br>  flex-direction: column-reverse| column | row | row-reverse;<br>}</p>\n</li>\n</ul>\n<p>复制</p>\n<p>以上代码设置的主轴方向，将依次对应下图：</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<h3 id=\"设置主轴的对齐方式\"><a href=\"#设置主轴的对齐方式\" class=\"headerlink\" title=\"设置主轴的对齐方式\"></a><strong>设置主轴的对齐方式</strong></h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式，值如下：</p>\n<ul>\n<li>flex-start（默认值）：向主轴开始方向对齐。</li>\n<li>flex-end：向主轴结束方向对齐。</li>\n<li>center： 居中。</li>\n<li>space-between：两端对齐，项目之间的间隔都相等。</li>\n<li><p>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</p>\n<p>.box {</p>\n<pre><code>justify-content: flex-start | flex-end | center | space-between | space-around;\n</code></pre><p>}</p>\n</li>\n</ul>\n<p>复制</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<h3 id=\"交叉轴的对齐方式\"><a href=\"#交叉轴的对齐方式\" class=\"headerlink\" title=\"交叉轴的对齐方式\"></a><strong>交叉轴的对齐方式</strong></h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐，值如下：</p>\n<ul>\n<li>flex-start：交叉轴的起点对齐。</li>\n<li>flex-end：交叉轴的终点对齐。</li>\n<li>center：交叉轴的中点对齐。</li>\n<li>baseline: 项目的第一行文字的基线对齐。</li>\n<li><p>stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。</p>\n<p>.box {</p>\n<pre><code>align-items: flex-start | flex-end | center | baseline | stretch;\n</code></pre><p>}</p>\n</li>\n</ul>\n<p>复制</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<hr>\n<h2 id=\"如何实现居中对齐？\"><a href=\"#如何实现居中对齐？\" class=\"headerlink\" title=\"如何实现居中对齐？\"></a><strong>如何实现居中对齐？</strong></h2><blockquote>\n<p>题目：如何实现水平居中？</p>\n</blockquote>\n<h3 id=\"水平居中\"><a href=\"#水平居中\" class=\"headerlink\" title=\"水平居中\"></a><strong>水平居中</strong></h3><p>inline 元素用<code>text-align: center;</code>即可，如下：</p>\n<pre><code>.container {\n   text-align: center;\n}\n</code></pre><p>复制</p>\n<p>block 元素可使用<code>margin: auto;</code>，PC 时代的很多网站都这么搞。</p>\n<pre><code>.container {\n    text-align: center; \n}\n.item {\n    width: 1000px;\n    margin: auto; \n}\n</code></pre><p>复制</p>\n<p>绝对定位元素可结合<code>left</code>和<code>margin</code>实现，但是必须知道宽度。</p>\n<pre><code>.container {\n    position: relative;\n    width: 500px;\n}\n.item {\n    width: 300px;\n    height: 100px;\n    position: absolute;\n    left: 50%;\n    margin: -150px;\n}\n</code></pre><p>复制</p>\n<blockquote>\n<p>题目：如何实现垂直居中？</p>\n</blockquote>\n<h3 id=\"垂直居中\"><a href=\"#垂直居中\" class=\"headerlink\" title=\"垂直居中\"></a><strong>垂直居中</strong></h3><p>inline 元素可设置<code>line-height</code>的值等于<code>height</code>值，如单行文字垂直居中：</p>\n<pre><code>.container {\n   height: 50px;\n   line-height: 50px;\n}\n</code></pre><p>复制</p>\n<p>绝对定位元素，可结合<code>left</code>和<code>margin</code>实现，但是必须知道尺寸。</p>\n<ul>\n<li>优点：兼容性好</li>\n<li><p>缺点：需要提前知道尺寸</p>\n<p>.container {</p>\n<pre><code>position: relative;\nheight: 200px;\n</code></pre><p>}<br>.item {</p>\n<pre><code>width: 80px;\nheight: 40px;\nposition: absolute;\nleft: 50%;\ntop: 50%;\nmargin-top: -20px;\nmargin-left: -40px;\n</code></pre><p>}</p>\n</li>\n</ul>\n<p>复制</p>\n<p>绝对定位可结合<code>transform</code>实现居中。</p>\n<ul>\n<li>优点：不需要提前知道尺寸</li>\n<li><p>缺点：兼容性不好</p>\n<p>.container {</p>\n<pre><code>position: relative;\nheight: 200px;\n</code></pre><p>}<br>.item {</p>\n<pre><code>width: 80px;\nheight: 40px;\nposition: absolute;\nleft: 50%;\ntop: 50%;\ntransform: translate(-50%, -50%);\nbackground: blue;\n</code></pre><p>}</p>\n</li>\n</ul>\n<p>复制</p>\n<p>绝对定位结合<code>margin: auto</code>，不需要提前知道尺寸，兼容性好。</p>\n<pre><code>.container {\n    position: relative;\n    height: 300px;\n}\n.item {\n    width: 100px;\n    height: 50px;\n    position: absolute;\n    left: 0;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    margin: auto;\n}\n</code></pre><p>复制</p>\n<p>其他的解决方案还有，不过没必要掌握太多，能说出上文的这几个解决方案即可。</p>\n<hr>\n<h2 id=\"理解语义化\"><a href=\"#理解语义化\" class=\"headerlink\" title=\"理解语义化\"></a><strong>理解语义化</strong></h2><blockquote>\n<p>题目：如何理解 HTML 语义化？</p>\n</blockquote>\n<p>所谓“语义”就是为了更易读懂，这要分两部分：</p>\n<ul>\n<li>让人（写程序、读程序）更易读懂</li>\n<li>让机器（浏览器、搜索引擎）更易读懂</li>\n</ul>\n<h3 id=\"让人更易读懂\"><a href=\"#让人更易读懂\" class=\"headerlink\" title=\"让人更易读懂\"></a><strong>让人更易读懂</strong></h3><p>对于人来说，代码可读性、语义化就是一个非常广泛的概念了，例如定义 JS 变量的时候使用更易读懂的名称，定义 CSS class 的时候也一样，例如<code>length`</code>list<code>等，而不是使用</code>a<code></code>b`这种谁都看不懂的名称。</p>\n<p>不过我们平常考查的“语义化”并不会考查这么广义、这么泛的问题，而是考查 HTML 的语义化，是为了更好地让机器读懂 HTML。</p>\n<h3 id=\"让机器更易读懂\"><a href=\"#让机器更易读懂\" class=\"headerlink\" title=\"让机器更易读懂\"></a><strong>让机器更易读懂</strong></h3><p>HTML 符合 XML 标准，但又和 XML 不一样 —— HTML 不允许像 XML 那样自定义标签名称，HTML 有自己规定的标签名称。问题就在这里 —— HTML 为何要自己规定那么多标签名称呢，例如<code>p`</code>div<code>h1</code>ul<code>等 —— 就是为了语义化。其实，如果你精通 CSS 的话，你完全可以全部用</code><div><code>标签来实现所有的网页效果，其他的</code>p<code>h1</code>ul`等标签可以一个都不用。但是我们不推荐这么做，这样做就失去了 HTML 语义化的意义。</div></p>\n<p>拿搜索引擎来说，爬虫下载到我们网页的 HTML 代码，它如何更好地去理解网页的内容呢？—— 就是根据 HTML 既定的标签。<code>h1</code>标签就代表是标题；<code>p</code>里面的就是段落详细内容，权重肯定没有标题高；<code>ul</code>里面就是列表；<code>strong</code>就是加粗的强调的内容 …… 如果我们不按照 HTML 语义化来写，全部都用<code>&lt;div&gt;</code>标签，那搜索引擎将很难理解我们网页的内容。</p>\n<p>为了加强 HTML 语义化，HTML5 标准中又增加了<code>header`</code>section<code></code>artical`等标签。因此，书写 HTML 时，语义化是非常重要的，否则 W3C 也没必要辛辛苦苦制定出这些标准来。</p>\n<hr>\n<h2 id=\"CSS3-动画\"><a href=\"#CSS3-动画\" class=\"headerlink\" title=\"CSS3 动画\"></a><strong>CSS3 动画</strong></h2><p>CSS3 可以实现动画，代替原来的 Flash 和 JavaScript 方案。</p>\n<p>首先，使用<code>@keyframes</code>定义一个动画，名称为<code>testAnimation</code>，如下代码，通过百分比来设置不同的 CSS 样式，规定动画的变化。所有的动画变化都可以这么定义出来。</p>\n<pre><code>@keyframes testAnimation\n{\n    0%   {background: red; left:0; top:0;}\n    25%  {background: yellow; left:200px; top:0;}\n    50%  {background: blue; left:200px; top:200px;}\n    75%  {background: green; left:0; top:200px;}\n    100% {background: red; left:0; top:0;}\n}\n</code></pre><p>复制</p>\n<p>然后，针对一个 CSS 选择器来设置动画，例如针对<code>div</code>元素设置动画，如下：</p>\n<pre><code>div {\n    width: 100px;\n    height: 50px;\n    position: absolute;\n\n    animation-name: myfirst;\n    animation-duration: 5s;\n}\n</code></pre><p>复制</p>\n<p><code>animation-name</code>对应到动画名称，<code>animation-duration</code>是动画时长，还有其他属性：</p>\n<ul>\n<li><code>animation-timing-function</code>：规定动画的速度曲线。默认是<code>ease</code></li>\n<li><code>animation-delay</code>：规定动画何时开始。默认是 0</li>\n<li><code>animation-iteration-count</code>：规定动画被播放的次数。默认是 1</li>\n<li><code>animation-direction</code>：规定动画是否在下一周期逆向地播放。默认是<code>normal</code></li>\n<li><code>animation-play-state</code> ：规定动画是否正在运行或暂停。默认是<code>running</code></li>\n<li><code>animation-fill-mode</code>：规定动画执行之前和之后如何给动画的目标应用，默认是<code>none</code>，保留在最后一帧可以用<code>forwards</code></li>\n</ul>\n<blockquote>\n<p>题目：CSS 的<code>transition</code>和<code>animation</code>有何区别？</p>\n</blockquote>\n<p>首先<code>transition</code>和<code>animation</code>都可以做动效，从语义上来理解，<code>transition</code>是过渡，由一个状态过渡到另一个状态，比如高度<code>100px</code>过渡到<code>200px</code>；而<code>animation</code>是动画，即更专业做动效的，<code>animation</code>有帧的概念，可以设置关键帧<code>keyframe</code>，一个动画可以由多个关键帧多个状态过渡组成，另外<code>animation</code>也包含上面提到的多个属性。</p>\n<h2 id=\"重绘和回流\"><a href=\"#重绘和回流\" class=\"headerlink\" title=\"重绘和回流\"></a><strong>重绘和回流</strong></h2><p>重绘和回流是面试题经常考的题目，也是性能优化当中应该注意的点，下面笔者简单介绍下。</p>\n<ul>\n<li><strong>重绘</strong>：指的是当页面中的元素不脱离文档流，而简单地进行样式的变化，比如修改颜色、背景等，浏览器重新绘制样式</li>\n<li><strong>回流</strong>：指的是处于文档流中 DOM 的尺寸大小、位置或者某些属性发生变化时，导致浏览器重新渲染部分或全部文档的情况</li>\n</ul>\n<p>相比之下，<strong>回流要比重绘消耗性能开支更大</strong>。另外，一些属性的读取也会引起回流，比如读取某个 DOM 的高度和宽度，或者使用<code>getComputedStyle</code>方法。在写代码的时候要避免回流和重绘。比如在笔试中可能会遇见下面的题目：</p>\n<blockquote>\n<p>题目：找出下面代码的优化点，并且优化它</p>\n</blockquote>\n<pre><code>var data = [&apos;string1&apos;, &apos;string2&apos;, &apos;string3&apos;];\nfor(var i = 0; i &lt; data.length; i++){\n    var dom = document.getElementById(&apos;list&apos;);\n    dom.innerHTML += &apos;&lt;li&gt;&apos; + data[i] + &apos;&lt;/li&gt;&apos;;\n}\n</code></pre><p>复制</p>\n<p>上面的代码在循环中每次都获取<code>dom</code>，然后对其内部的 HTML 进行累加<code>li</code>，每次都会操作 DOM 结构，可以改成使用<code>documentFragment</code>或者先遍历组成 HTML 的字符串，最后操作一次<code>innerHTML</code>。</p>\n<hr>\n<h2 id=\"小结-3\"><a href=\"#小结-3\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h2><p>本小节总结了 CSS 和 HTML 常考的知识点，包括 CSS 中比较重要的定位、布局的知识，也介绍了一些 CSS3 的知识点概念和题目，以及 HTML 的语义化。</p>\n<p>上一篇：<a href=\"541672\">一面 2：JS-Web-API 知识点与高频考题解析</a>下一篇：<a href=\"541674\">一面 4：从容应对算法题目</a></p>\n<h1 id=\"一面-4：从容应对算法题目\"><a href=\"#一面-4：从容应对算法题目\" class=\"headerlink\" title=\"一面 4：从容应对算法题目\"></a><strong>一面 4：从容应对算法题目</strong></h1><p>由冯·诺依曼机组成我们知道：数据存储和运算是计算机工作的主要内容。<code>程序=数据结构+算法</code>，所以计算机类工程师必须掌握一定的数据结构和算法知识。</p>\n<h2 id=\"知识点梳理-3\"><a href=\"#知识点梳理-3\" class=\"headerlink\" title=\"知识点梳理\"></a><strong>知识点梳理</strong></h2><ul>\n<li>常见的数据结构<ul>\n<li>栈、队列、链表</li>\n<li>集合、字典、散列集</li>\n</ul>\n</li>\n<li>常见算法<ul>\n<li>递归</li>\n<li>排序</li>\n<li>枚举</li>\n</ul>\n</li>\n<li>算法复杂度分析</li>\n<li>算法思维<ul>\n<li>分治</li>\n<li>贪心</li>\n<li>动态规划</li>\n</ul>\n</li>\n<li>高级数据结构<ul>\n<li>树、图</li>\n<li>深度优先和广度优先搜索</li>\n</ul>\n</li>\n</ul>\n<p>本小节会带领大家快速过一遍数据结构和算法，重点讲解一些常考、前端会用到的算法和数据结构。</p>\n<hr>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a><strong>数据结构</strong></h2><p>数据结构决定了数据存储的空间和时间效率问题，数据的写入和提取速度要求也决定了应该选择怎样的数据结构。</p>\n<p>根据对场景需求的不同，我们设计不同的数据结构，比如：</p>\n<ul>\n<li>读得多的数据结构，应该想办法提高数据的读取效率，比如 IP 数据库，只需要写一次，剩下的都是读取；</li>\n<li>读写都多的数据结构，要兼顾两者的需求平衡，比如 LRU Cache 算法。</li>\n</ul>\n<p>算法是数据加工处理的方式，一定的算法会提升数据的处理效率。比如有序数组的二分查找，要比普通的顺序查找快很多，尤其是在处理大量数据的时候。</p>\n<p>数据结构和算法是程序开发的通用技能，所以在任何面试中都可能会遇见。随着近几年 AI、大数据、小游戏越来越火，Web 前端职位难免会跟数据结构和算法打交道，面试中也会出现越来越多的算法题目。学习数据结构和算法也能够帮助我们打开思路，突破技能瓶颈。</p>\n<h2 id=\"前端常遇见的数据结构问题\"><a href=\"#前端常遇见的数据结构问题\" class=\"headerlink\" title=\"前端常遇见的数据结构问题\"></a><strong>前端常遇见的数据结构问题</strong></h2><p>现在我来梳理下前端常遇见的数据结构：</p>\n<ul>\n<li>简单数据结构（必须理解掌握）<ul>\n<li>有序数据结构：栈、队列、链表，有序数据结构省空间（存储空间小）</li>\n<li>无序数据结构：集合、字典、散列表，无序数据结构省时间（读取时间快）</li>\n</ul>\n</li>\n<li>复杂数据结构<ul>\n<li>树、堆</li>\n<li>图</li>\n</ul>\n</li>\n</ul>\n<p>对于简单数据结构，在 ES 中对应的是数组（<code>Array</code>）和对象（<code>Object</code>）。可以想一下，数组的存储是有序的，对象的存储是无序的，但是我要在对象中根据<code>key</code>找到一个值是立即返回的，数组则需要查找的过程。</p>\n<p>这里我通过一个真实面试题目来说明介绍下数据结构设计。</p>\n<blockquote>\n<p>题目：使用 ECMAScript（JS）代码实现一个事件类<code>Event</code>，包含下面功能：绑定事件、解绑事件和派发事件。</p>\n</blockquote>\n<p>在稍微复杂点的页面中，比如组件化开发的页面，同一个页面由两三个人来开发，为了保证组件的独立性和降低组件间耦合度，我们往往使用「订阅发布模式」，即组件间通信使用事件监听和派发的方式，而不是直接相互调用组件方法，这就是题目要求写的<code>Event</code>类。</p>\n<p>这个题目的核心是一个事件类型对应回调函数的数据设计。为了实现绑定事件，我们需要一个<code>_cache</code>对象来记录绑定了哪些事件。而事件发生的时候，我们需要从<code>_cache</code>中读取出来事件回调，依次执行它们。一般页面中事件派发（读）要比事件绑定（写）多。所以我们设计的数据结构应该尽量地能够在事件发生时，更加快速地找到对应事件的回调函数们，然后执行。</p>\n<p>经过这样一番考虑，我简单写了下代码实现：</p>\n<pre><code>class Event {\n    constructor() {\n        // 存储事件的数据结构\n        // 为了查找迅速，使用了对象（字典）\n        this._cache = {};\n    }\n    // 绑定\n    on(type, callback) {\n        // 为了按类查找方便和节省空间，\n        // 将同一类型事件放到一个数组中\n        // 这里的数组是队列，遵循先进先出\n        // 即先绑定的事件先触发\n        let fns = (this._cache[type] = this._cache[type] || []);\n        if (fns.indexOf(callback) === -1) {\n            fns.push(callback);\n        }\n        return this;\n    }\n    // 触发\n    trigger(type, data) {\n        let fns = this._cache[type];\n        if (Array.isArray(fns)) {\n            fns.forEach((fn) =&gt; {\n                fn(data);\n            });\n        }\n        return this;\n    }\n    // 解绑\n    off(type, callback) {\n        let fns = this._cache[type];\n        if (Array.isArray(fns)) {\n            if (callback) {\n                let index = fns.indexOf(callback);\n                if (index !== -1) {\n                    fns.splice(index, 1);\n                }\n            } else {\n                //全部清空\n                fns.length = 0;\n            }\n        }\n        return this;\n    }\n}\n// 测试用例\nconst event = new Event();\nevent.on(&apos;test&apos;, (a) =&gt; {\n    console.log(a);\n});\nevent.trigger(&apos;test&apos;, &apos;hello world&apos;);\n\nevent.off(&apos;test&apos;);\nevent.trigger(&apos;test&apos;, &apos;hello world&apos;);\n</code></pre><p>复制</p>\n<p>类似于树、堆、图这些高级数据结构，前端一般也不会考查太多，但是它们的查找方法却常考，后面介绍。高级数据应该平时多积累，好好理解，比如理解了堆是什么样的数据结构，在面试中遇见的「查找最大的 K 个数」这类算法问题，就会迎刃而解。</p>\n<h2 id=\"算法的效率是通过算法复杂度来衡量的\"><a href=\"#算法的效率是通过算法复杂度来衡量的\" class=\"headerlink\" title=\"算法的效率是通过算法复杂度来衡量的\"></a><strong>算法的效率是通过算法复杂度来衡量的</strong></h2><p>算法的好坏可以通过算法复杂度来衡量，算法复杂度包括时间复杂度和空间复杂度两个。时间复杂度由于好估算、好评估等特点，是面试中考查的重点。空间复杂度在面试中考查得不多。</p>\n<p>常见的时间复杂度有：</p>\n<ul>\n<li>常数阶 <code>O(1)</code></li>\n<li>对数阶 <code>O(logN)</code></li>\n<li>线性阶 <code>O(n)</code></li>\n<li>线性对数阶 <code>O(nlogN)</code></li>\n<li>平方阶 <code>O(n^2)</code></li>\n<li>立方阶 <code>O(n^3)</code></li>\n<li>!k次方阶 <code>O(n^k)</code></li>\n<li>指数阶<code>O(2^n)</code></li>\n</ul>\n<p>随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低。</p>\n<p>一般做算法复杂度分析的时候，遵循下面的技巧：</p>\n<ol>\n<li>看看有几重循环，一般来说一重就是<code>O(n)</code>，两重就是 <code>O(n^2)</code>，以此类推</li>\n<li>如果有二分，则为<code>O(logN)</code></li>\n<li>保留最高项，去除常数项</li>\n</ol>\n<blockquote>\n<p>题目：分析下面代码的算法复杂度（为了方便，我已经在注释中加了代码分析）</p>\n</blockquote>\n<pre><code>let i =0; // 语句执行一次 \nwhile (i &lt; n) { // 语句执行 n 次 \n  console.log(`Current i is ${i}`); //语句执行 n 次\n  i++; // 语句执行 n 次\n}\n</code></pre><p>复制</p>\n<p>根据注释可以得到，算法复杂度为<code>1 + n + n + n = 1 + 3n</code>，去除常数项，为<code>O(n)</code>。</p>\n<pre><code>let number = 1; // 语句执行一次 \nwhile (number &lt; n) { // 语句执行 logN 次\n  number *= 2; // 语句执行 logN 次\n}\n</code></pre><p>复制</p>\n<p>上面代码<code>while</code>的跳出判断条件是<code>number&lt;n</code>，而循环体内<code>number</code>增长速度是<code>(2^n)</code>，所以循环代码实际执行<code>logN</code>次，复杂度为：<code>1 + 2 * logN = O(logN)</code></p>\n<pre><code>for (let i = 0; i &lt; n; i++) {// 语句执行 n 次\n  for (let j = 0; j &lt; n; j++) {// 语句执行 n^2 次\n    console.log(&apos;I am here!&apos;); // 语句执行 n^2 次\n  }\n}\n</code></pre><p>复制</p>\n<p>上面代码是两个<code>for</code>循环嵌套，很容易得出复杂度为：<code>O(n^2)</code></p>\n<h2 id=\"人人都要掌握的基础算法\"><a href=\"#人人都要掌握的基础算法\" class=\"headerlink\" title=\"人人都要掌握的基础算法\"></a><strong>人人都要掌握的基础算法</strong></h2><p>枚举和递归是最最简单的算法，也是复杂算法的基础，人人都应该掌握！枚举相对比较简单，我们重点说下递归。</p>\n<p>递归由下面两部分组成：</p>\n<ol>\n<li>递归主体，就是要循环解决问题的代码</li>\n<li>递归的跳出条件，递归不能一直递归下去，需要完成一定条件后跳出</li>\n</ol>\n<p>关于递归有个经典的面试题目是：</p>\n<blockquote>\n<p>实现 JS 对象的深拷贝</p>\n</blockquote>\n<p><strong>什么是深拷贝？</strong></p>\n<p>「深拷贝」就是在拷贝数据的时候，将数据的所有<strong>引用结构</strong>都拷贝一份。简单的说就是，在内存中存在两个数据结构完全相同又相互独立的数据，将引用型类型进行复制，而不是只复制其引用关系。</p>\n<p>分析下怎么做「深拷贝」：</p>\n<ol>\n<li>首先假设深拷贝这个方法已经完成，为 deepClone</li>\n<li><p>要拷贝一个数据，我们肯定要去遍历它的属性，如果这个对象的属性仍是对象，继续使用这个方法，如此往复</p>\n<p>function deepClone(o1, o2) {</p>\n<pre><code>for (let k in o2) {\n    if (typeof o2[k] === &apos;object&apos;) {\n        o1[k] = {};\n        deepClone(o1[k], o2[k]);\n    } else {\n        o1[k] = o2[k];\n    }\n}\n</code></pre><p>}<br>// 测试用例<br>let obj = {</p>\n<pre><code>a: 1,\nb: [1, 2, 3],\nc: {}\n</code></pre><p>};<br>let emptyObj = Object.create(null);<br>deepClone(emptyObj, obj);<br>console.log(emptyObj.a == obj.a);<br>console.log(emptyObj.b == obj.b);</p>\n</li>\n</ol>\n<p>复制</p>\n<p>递归容易造成爆栈，尾部调用可以解决递归的这个问题，Chrome 的 V8 引擎做了尾部调用优化，我们在写代码的时候也要注意尾部调用写法。递归的爆栈问题可以通过将递归改写成枚举的方式来解决，就是通过<code>for</code>或者<code>while</code>来代替递归。</p>\n<p>我们在使用递归的时候，要注意做优化，比如下面的题目。</p>\n<blockquote>\n<p>题目：求斐波那契数列（兔子数列） 1,1,2,3,5,8,13,21,34,55,89…中的第 n 项</p>\n</blockquote>\n<p>下面的代码中<code>count</code>记录递归的次数，我们看下两种差异性的代码中的<code>count</code>的值：</p>\n<pre><code>let count = 0;\nfunction fn(n) {\n    let cache = {};\n    function _fn(n) {\n        if (cache[n]) {\n            return cache[n];\n        }\n        count++;\n        if (n == 1 || n == 2) {\n            return 1;\n        }\n        let prev = _fn(n - 1);\n        cache[n - 1] = prev;\n        let next = _fn(n - 2);\n        cache[n - 2] = next;\n        return prev + next;\n    }\n    return _fn(n);\n}\n\nlet count2 = 0;\nfunction fn2(n) {\n    count2++;\n    if (n == 1 || n == 2) {\n        return 1;\n    }\n    return fn2(n - 1) + fn2(n - 2);\n}\n\nconsole.log(fn(20), count); // 6765 20\nconsole.log(fn2(20), count2); // 6765 13529\n</code></pre><p>复制</p>\n<h2 id=\"快排和二分查找\"><a href=\"#快排和二分查找\" class=\"headerlink\" title=\"快排和二分查找\"></a><strong>快排和二分查找</strong></h2><p>前端中面试排序和查找的可能性比较小，因为 JS 引擎已经把这些常用操作优化得很好了，可能项目中你费劲写的一个排序方法，都不如<code>Array.sort</code>速度快且代码少。因此，掌握快排和二分查找就可以了。</p>\n<p>快排和二分查找都基于一种叫做「分治」的算法思想，通过对数据进行分类处理，不断降低数量级，实现<code>O(logN)</code>（对数级别，比<code>O(n)</code>这种线性复杂度更低的一种）的复杂度。</p>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a><strong>快速排序</strong></h3><p>快排大概的流程是：</p>\n<ol>\n<li>随机选择数组中的一个数 A，以这个数为基准</li>\n<li>其他数字跟这个数进行比较，比这个数小的放在其左边，大的放到其右边</li>\n<li>经过一次循环之后，A 左边为小于 A 的，右边为大于 A 的</li>\n<li>这时候将左边和右边的数再递归上面的过程</li>\n</ol>\n<p>具体代码如下：</p>\n<pre><code>const Arr = [85, 24, 63, 45, 17, 31, 96, 50];\nfunction quickSort(arr) {\n    if (arr.length &lt;= 1) {\n        return arr;\n    }\n    let pivotIndex = Math.floor(arr.length / 2);\n    let pivot = arr.splice(pivotIndex, 1)[0];\n    let left = [];\n    let right = [];\n    for (let i = 0; i &lt; arr.length; i++) {\n        if (arr[i] &lt; pivot) {\n            left.push(arr[i]);\n        } else {\n            right.push(arr[i]);\n        }\n    }\n    // 递归\n    return quickSort(left).concat([pivot], quickSort(right));\n}\n\nconsole.log(quickSort(Arr));\n</code></pre><p>复制</p>\n<h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a><strong>二分查找</strong></h3><p>二分查找法主要是解决「在一堆有序的数中找出指定的数」这类问题，不管这些数是一维数组还是多维数组，只要有序，就可以用二分查找来优化。</p>\n<p>二分查找是一种「分治」思想的算法，大概流程如下：</p>\n<ol>\n<li>数组中排在中间的数字 A，与要找的数字比较大小</li>\n<li>因为数组是有序的，所以： a) A 较大则说明要查找的数字应该从前半部分查找 b) A 较小则说明应该从查找数字的后半部分查找</li>\n<li>这样不断查找缩小数量级（扔掉一半数据），直到找完数组为止</li>\n</ol>\n<blockquote>\n<p>题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>\n</blockquote>\n<pre><code>function Find(target, array) {\n    let i = 0;\n    let j = array[i].length - 1;\n    while (i &lt; array.length &amp;&amp; j &gt;= 0) {\n        if (array[i][j] &lt; target) {\n            i++;\n        } else if (array[i][j] &gt; target) {\n            j--;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\n\n//测试用例\nconsole.log(Find(10, [\n    [1, 2, 3, 4], \n    [5, 9, 10, 11], \n    [13, 20, 21, 23]\n    ])\n);\n</code></pre><p>复制</p>\n<p>另外笔者在面试中遇见过下面的问题：</p>\n<blockquote>\n<p>题目：现在我有一个 1~1000 区间中的正整数，需要你猜下这个数字是几，你只能问一个问题：大了还是小了？问需要猜几次才能猜对？</p>\n</blockquote>\n<p>拿到这个题目，笔者想到的就是电视上面有个「猜价格」的购物节目，在规定时间内猜对价格就可以把实物抱回家。所以问题就是让面试官不停地回答我猜的数字比这个数字大了还是小了。这就是二分查找！</p>\n<p>猜几次呢？其实这个问题就是个二分查找的算法时间复杂度问题，二分查找的时间复杂度是<code>O(logN)</code>，所以求<code>log1000</code>的解就是猜的次数。我们知道<code>2^10=1024</code>，所以可以快速估算出：<code>log1000</code>约等于 10，最多问 10 次就能得到这个数！</p>\n<h2 id=\"面试遇见不会的算法问题怎么办\"><a href=\"#面试遇见不会的算法问题怎么办\" class=\"headerlink\" title=\"面试遇见不会的算法问题怎么办\"></a><strong>面试遇见不会的算法问题怎么办</strong></h2><p>面试的时候，在遇见算法题目的时候，应该揣摩面试官的意图，听好关键词，比如：有序的数列做查找、要求算法复杂度是<code>O(logN)</code>这类一般就是用二分的思想。</p>\n<p>一般来说算法题目的解题思路分以下四步：</p>\n<ol>\n<li>先降低数量级，拿可以计算出来的情况（数据）来构思解题步骤</li>\n<li>根据解题步骤编写程序，优先将特殊情况做好判断处理，比如一个大数组的问题，如果数组为两个数长度的情况</li>\n<li>检验程序正确性</li>\n<li>是否可以优化（由浅到深），有能力的话可以故意预留优化点，这样可以体现个人技术能力</li>\n</ol>\n<h2 id=\"正则匹配解题\"><a href=\"#正则匹配解题\" class=\"headerlink\" title=\"正则匹配解题\"></a><strong>正则匹配解题</strong></h2><p>很多算法题目利用 ES 语法的特性来回答更加简单，比如正则匹配就是常用的一种方式。笔者简单通过几个真题来汇总下正则的知识点。</p>\n<blockquote>\n<p>题目：字符串中第一个出现一次的字符</p>\n</blockquote>\n<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符「go」时，第一个只出现一次的字符是「g」。当从该字符流中读出前六个字符「google」时，第一个只出现一次的字符是「l」。</p>\n<p>这个如果用纯算法来解答需要遍历字符串，统计每个字符出现的次数，然后按照字符串的顺序来找出第一次出现一次的字符，整个过程比较繁琐，如果用正则就简单多了。</p>\n<pre><code>function find(str){\n    for (var i = 0; i &lt; str.length; i++) {\n        let char = str[i]\n        let reg = new RegExp(char, &apos;g&apos;);\n        let l = str.match(reg).length\n        if(l===1){\n            return char\n        }\n    }\n}\n</code></pre><p>复制</p>\n<p>当然，使用<code>indexOf/lastIndexOf</code>也是一个取巧的方式。再来看一个千分位问题。</p>\n<blockquote>\n<p>题目：将<code>1234567</code> 变成 <code>1,234,567</code>，即千分位标注</p>\n</blockquote>\n<p>这个题目可以用算法直接来解，如果候选人使用正则来回答，这样主动展现了自己其他方面的优势，即使不是算法解答出来的，面试官一般也不会太难为他。这道题目可以利用正则的「零宽断言」<code>(?=exp)</code>，意思是它断言自身出现的位置的后面能匹配表达式 exp。数字千分位的特点是，第一个逗号后面数字的个数是3的倍数，正则：<code>/(\\d{3})+$/</code>；第一个逗号前最多可以有 1~3 个数字，正则：<code>/\\d{1,3}/</code>。加起来就是<code>/\\d{1,3}(\\d{3})+$/</code>，分隔符要从前往后加。</p>\n<p>对于零宽断言的详细介绍可以阅读「<a href=\"https://link.juejin.im?target=https%3A%2F%2Fdeerchao.net%2Ftutorials%2Fregex%2Fregex.htm%23lookaround\" target=\"_blank\" rel=\"noopener\">零宽断言</a>」这篇文章。</p>\n<pre><code>function exchange(num) {\n    num += &apos;&apos;; //转成字符串\n    if (num.length &lt;= 3) {\n        return num;\n    }\n\n    num = num.replace(/\\d{1,3}(?=(\\d{3})+$)/g, (v) =&gt; {\n        console.log(v)\n        return v + &apos;,&apos;;\n    });\n    return num;\n}\n\nconsole.log(exchange(1234567));\n</code></pre><p>复制</p>\n<p>当然上面讲到的多数是算法题目取巧的方式，下面这个题目是纯正则考查，笔者在面试的过程中碰见过，这里顺便提一下。</p>\n<blockquote>\n<p>题目，请写出下面的代码执行结果</p>\n</blockquote>\n<pre><code>var str = &apos;google&apos;;\nvar reg = /o/g;\nconsole.log(reg.test(str))\nconsole.log(reg.test(str))\nconsole.log(reg.test(str))\n</code></pre><p>复制</p>\n<p>代码执行后，会发现，最后一个不是为<code>true</code>，而是<code>false</code>，这是因为<code>reg</code>这个正则有个<code>g</code>，即<code>global</code>全局的属性，这种情况下<code>lastIndex</code>就发挥作用了，可以看下面的代码执行结果就明白了。</p>\n<pre><code>console.log(reg.test(str), reg.lastIndex)\nconsole.log(reg.test(str), reg.lastIndex)\nconsole.log(reg.test(str), reg.lastIndex)\n</code></pre><p>复制</p>\n<p>实际开发中也会犯这样的错误，比如为了减少变量每次都重新定义，会把用到的变量提前定义好，这样在使用的时候容易掉进坑里，比如下面代码：</p>\n<pre><code>(function(){\n    const reg = /o/g;\n    function isHasO(str){\n        // reg.lastIndex = 0; 这样就可以避免这种情况\n        return reg.test(str)\n    }\n    var str = &apos;google&apos;;\n    console.log(isHasO(str))\n    console.log(isHasO(str))\n    console.log(isHasO(str))\n}())\n</code></pre><p>复制</p>\n<h2 id=\"小结-4\"><a href=\"#小结-4\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h2><p>本小节介绍了数据结构和算法的关系，作为普通的前端也应该学习数据结构和算法知识，并且顺带介绍了下正则匹配。具体来说，本小节梳理了以下几部分数据结构和算法知识点：</p>\n<ol>\n<li>经常用到的数据结构有哪些，它们的特点有哪些</li>\n<li>递归和枚举是最基础的算法，必须牢牢掌握</li>\n<li>排序里面理解并掌握快速排序算法，其他排序算法可以根据个人实际情况大概了解</li>\n<li>有序查找用二分查找</li>\n<li>遇见不会的算法问题，先缩小数量级，然后分析推导</li>\n</ol>\n<p>当然算法部分还有很多知识，比如动态规划这些算法思想，还有图和树常用到的广度优先搜索和深度优先搜索。这些知识在前端面试和项目中遇见得不多，感兴趣的读者可以在梳理知识点的时候根据个人情况自行决定是否复习。</p>\n<p>上一篇：<a href=\"541673\">一面 3：CSS-HTML 知识点与高频考题解析</a>下一篇：<a href=\"541675\">一面 5：浏览器相关知识点与高频考题解析</a></p>\n<h1 id=\"一面-5：浏览器相关知识点与高频考题解析\"><a href=\"#一面-5：浏览器相关知识点与高频考题解析\" class=\"headerlink\" title=\"一面 5：浏览器相关知识点与高频考题解析\"></a><strong>一面 5：浏览器相关知识点与高频考题解析</strong></h1><p>Web 前端工程师写的页面要跑在浏览器里面，所以面试中也会出现很多跟浏览器相关的面试题目。</p>\n<h2 id=\"知识点梳理-4\"><a href=\"#知识点梳理-4\" class=\"headerlink\" title=\"知识点梳理****\"></a><strong>知识点梳理</strong>****</h2><ul>\n<li>浏览器加载页面和渲染过程</li>\n<li>性能优化</li>\n<li>Web 安全</li>\n</ul>\n<p>本小节会从浏览器的加载过程开始讲解，然后介绍如何进行性能优化，最后介绍下 Web 开发中常见的安全问题和预防。</p>\n<hr>\n<h2 id=\"加载页面和渲染过程\"><a href=\"#加载页面和渲染过程\" class=\"headerlink\" title=\"加载页面和渲染过程\"></a><strong>加载页面和渲染过程</strong></h2><p>可将加载过程和渲染过程分开说。回答问题的时候，关键要抓住核心的要点，把要点说全面，稍加解析即可，简明扼要不拖沓。</p>\n<blockquote>\n<p>题目：浏览器从加载页面到渲染页面的过程</p>\n</blockquote>\n<h3 id=\"加载过程\"><a href=\"#加载过程\" class=\"headerlink\" title=\"加载过程\"></a><strong>加载过程</strong></h3><p>要点如下：</p>\n<ul>\n<li>浏览器根据 DNS 服务器得到域名的 IP 地址</li>\n<li>向这个 IP 的机器发送 HTTP 请求</li>\n<li>服务器收到、处理并返回 HTTP 请求</li>\n<li>浏览器得到返回内容</li>\n</ul>\n<p>例如在浏览器输入<code>https://juejin.im/timeline</code>，然后经过 DNS 解析，<code>juejin.im</code>对应的 IP 是<code>36.248.217.149</code>（不同时间、地点对应的 IP 可能会不同）。然后浏览器向该 IP 发送 HTTP 请求。</p>\n<p>server 端接收到 HTTP 请求，然后经过计算（向不同的用户推送不同的内容），返回 HTTP 请求，返回的内容如下：</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<p>其实就是一堆 HMTL 格式的字符串，因为只有 HTML 格式浏览器才能正确解析，这是 W3C 标准的要求。接下来就是浏览器的渲染过程。</p>\n<h3 id=\"渲染过程\"><a href=\"#渲染过程\" class=\"headerlink\" title=\"渲染过程\"></a><strong>渲染过程</strong></h3><p>要点如下：</p>\n<ul>\n<li>根据 HTML 结构生成 DOM 树</li>\n<li>根据 CSS 生成 CSSOM</li>\n<li>将 DOM 和 CSSOM 整合形成 RenderTree</li>\n<li>根据 RenderTree 开始渲染和展示</li>\n<li>遇到<code>&lt;script&gt;</code>时，会执行并阻塞渲染</li>\n</ul>\n<p>上文中，浏览器已经拿到了 server 端返回的 HTML 内容，开始解析并渲染。最初拿到的内容就是一堆字符串，必须先结构化成计算机擅长处理的基本数据结构，因此要把 HTML 字符串转化成 DOM 树 —— 树是最基本的数据结构之一。</p>\n<p>解析过程中，如果遇到<code>&lt;link href=&quot;...&quot;&gt;</code>和<code>&lt;script src=&quot;...&quot;&gt;</code>这种外链加载 CSS 和 JS 的标签，浏览器会异步下载，下载过程和上文中下载 HTML 的流程一样。只不过，这里下载下来的字符串是 CSS 或者 JS 格式的。</p>\n<p>浏览器将 CSS 生成 CSSOM，再将 DOM 和 CSSOM 整合成 RenderTree ，然后针对 RenderTree 即可进行渲染了。大家可以想一下，有 DOM 结构、有样式，此时就能满足渲染的条件了。另外，这里也可以解释一个问题 —— <strong>为何要将 CSS 放在 HTML 头部？</strong>—— 这样会让浏览器尽早拿到 CSS 尽早生成 CSSOM，然后在解析 HTML 之后可一次性生成最终的 RenderTree，渲染一次即可。如果 CSS 放在 HTML 底部，会出现渲染卡顿的情况，影响性能和体验。</p>\n<p>最后，渲染过程中，如果遇到<code>&lt;script&gt;</code>就停止渲染，执行 JS 代码。因为浏览器渲染和 JS 执行共用一个线程，而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。待<code>&lt;script&gt;</code>内容执行完之后，浏览器继续渲染。最后再思考一个问题 —— <strong>为何要将 JS 放在 HTML 底部？</strong>—— JS 放在底部可以保证让浏览器优先渲染完现有的 HTML 内容，让用户先看到内容，体验好。另外，JS 执行如果涉及 DOM 操作，得等待 DOM 解析完成才行，JS 放在底部执行时，HTML 肯定都解析成了 DOM 结构。JS 如果放在 HTML 顶部，JS 执行的时候 HTML 还没来得及转换为 DOM 结构，可能会报错。</p>\n<p>关于浏览器整个流程，百度的多益大神有更加详细的文章，推荐阅读下：《<a href=\"https://link.juejin.im?target=http%3A%2F%2Ffex.baidu.com%2Fblog%2F2014%2F05%2Fwhat-happen%2F\" target=\"_blank\" rel=\"noopener\">从输入 URL 到页面加载完成的过程中都发生了什么事情？</a> 》。</p>\n<hr>\n<h2 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a><strong>性能优化</strong></h2><p>性能优化的题目也是面试常考的，这类题目有很大的扩展性，能够扩展出来很多小细节，而且对个人的技术视野和业务能力有很大的挑战。这部分笔者会重点讲下常用的性能优化方案。</p>\n<blockquote>\n<p>题目：总结前端性能优化的解决方案</p>\n</blockquote>\n<h3 id=\"优化原则和方向\"><a href=\"#优化原则和方向\" class=\"headerlink\" title=\"优化原则和方向\"></a><strong>优化原则和方向</strong></h3><p>性能优化的原则是<strong>以更好的用户体验为标准</strong>，具体就是实现下面的目标：</p>\n<ol>\n<li>多使用内存、缓存或者其他方法</li>\n<li>减少 CPU 和GPU 计算，更快展现</li>\n</ol>\n<p>优化的方向有两个：</p>\n<ul>\n<li><strong>减少页面体积，提升网络加载</strong></li>\n<li><strong>优化页面渲染</strong></li>\n</ul>\n<h3 id=\"减少页面体积，提升网络加载\"><a href=\"#减少页面体积，提升网络加载\" class=\"headerlink\" title=\"减少页面体积，提升网络加载\"></a><strong>减少页面体积，提升网络加载</strong></h3><ul>\n<li>静态资源的压缩合并（JS 代码压缩合并、CSS 代码压缩合并、雪碧图）</li>\n<li>静态资源缓存（资源名称加 MD5 戳）</li>\n<li>使用 CDN 让资源加载更快</li>\n</ul>\n<h3 id=\"优化页面渲染\"><a href=\"#优化页面渲染\" class=\"headerlink\" title=\"优化页面渲染\"></a><strong>优化页面渲染</strong></h3><ul>\n<li>CSS 放前面，JS 放后面</li>\n<li>懒加载（图片懒加载、下拉加载更多）</li>\n<li>减少DOM 查询，对 DOM 查询做缓存</li>\n<li>减少DOM 操作，多个操作尽量合并在一起执行（<code>DocumentFragment</code>）</li>\n<li>事件节流</li>\n<li>尽早执行操作（<code>DOMContentLoaded</code>）</li>\n<li>使用 SSR 后端渲染，数据直接输出到 HTML 中，减少浏览器使用 JS 模板渲染页面 HTML 的时间</li>\n</ul>\n<h3 id=\"详细解释\"><a href=\"#详细解释\" class=\"headerlink\" title=\"详细解释\"></a><strong>详细解释</strong></h3><h4 id=\"静态资源的压缩合并\"><a href=\"#静态资源的压缩合并\" class=\"headerlink\" title=\"静态资源的压缩合并\"></a><strong>静态资源的压缩合并</strong></h4><p>如果不合并，每个都会走一遍之前介绍的请求过程</p>\n<pre><code>&lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;b.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;c.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>复制</p>\n<p>如果合并了，就只走一遍请求过程</p>\n<pre><code>&lt;script src=&quot;abc.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>复制</p>\n<h4 id=\"静态资源缓存\"><a href=\"#静态资源缓存\" class=\"headerlink\" title=\"静态资源缓存\"></a><strong>静态资源缓存</strong></h4><p>通过链接名称控制缓存</p>\n<pre><code>&lt;script src=&quot;abc_1.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>复制</p>\n<p>只有内容改变的时候，链接名称才会改变</p>\n<pre><code>&lt;script src=&quot;abc_2.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>复制</p>\n<p>这个名称不用手动改，可通过前端构建工具根据文件内容，为文件名称添加 MD5 后缀。</p>\n<h4 id=\"使用-CDN-让资源加载更快\"><a href=\"#使用-CDN-让资源加载更快\" class=\"headerlink\" title=\"使用 CDN 让资源加载更快\"></a><strong>使用 CDN 让资源加载更快</strong></h4><p>CDN 会提供专业的加载优化方案，静态资源要尽量放在 CDN 上。例如：</p>\n<pre><code>&lt;script src=&quot;https://cdn.bootcss.com/zepto/1.0rc1/zepto.min.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>复制</p>\n<h4 id=\"使用-SSR-后端渲染\"><a href=\"#使用-SSR-后端渲染\" class=\"headerlink\" title=\"使用 SSR 后端渲染\"></a><strong>使用 SSR 后端渲染</strong></h4><p>可一次性输出 HTML 内容，不用在页面渲染完成之后，再通过 Ajax 加载数据、再渲染。例如使用 smarty、Vue SSR 等。</p>\n<h4 id=\"CSS-放前面，JS-放后面\"><a href=\"#CSS-放前面，JS-放后面\" class=\"headerlink\" title=\"CSS 放前面，JS 放后面\"></a><strong>CSS 放前面，JS 放后面</strong></h4><p>上文讲述浏览器渲染过程时已经提过，不再赘述。</p>\n<h4 id=\"懒加载\"><a href=\"#懒加载\" class=\"headerlink\" title=\"懒加载\"></a><strong>懒加载</strong></h4><p>一开始先给为 <code>src</code> 赋值成一个通用的预览图，下拉时候再动态赋值成正式的图片。如下，<code>preview.png</code>是预览图片，比较小，加载很快，而且很多图片都共用这个<code>preview.png</code>，加载一次即可。待页面下拉，图片显示出来时，再去替换<code>src</code>为<code>data-realsrc</code>的值。</p>\n<pre><code>&lt;img src=&quot;preview.png&quot; data-realsrc=&quot;abc.png&quot;/&gt;\n</code></pre><p>复制</p>\n<p>另外，这里为何要用<code>data-</code>开头的属性值？—— 所有 HTML 中自定义的属性，都应该用<code>data-</code>开头，因为<code>data-</code>开头的属性浏览器渲染的时候会忽略掉，提高渲染性能。</p>\n<h4 id=\"DOM-查询做缓存\"><a href=\"#DOM-查询做缓存\" class=\"headerlink\" title=\"DOM 查询做缓存\"></a><strong>DOM 查询做缓存</strong></h4><p>两段代码做一下对比：</p>\n<pre><code>var pList = document.getElementsByTagName(&apos;p&apos;)  // 只查询一个 DOM ，缓存在 pList 中了\nvar i\nfor (i = 0; i &lt; pList.length; i++) {\n}\n</code></pre><p>复制</p>\n<pre><code>var i\nfor (i = 0; i &lt; document.getElementsByTagName(&apos;p&apos;).length; i++) {  // 每次循环，都会查询 DOM ，耗费性能\n}\n</code></pre><p>复制</p>\n<p>总结：DOM 操作，无论查询还是修改，都是非常耗费性能的，应尽量减少。</p>\n<h4 id=\"合并-DOM-插入\"><a href=\"#合并-DOM-插入\" class=\"headerlink\" title=\"合并 DOM 插入\"></a><strong>合并 DOM 插入</strong></h4><p>DOM 操作是非常耗费性能的，因此插入多个标签时，先插入 Fragment 然后再统一插入 DOM。</p>\n<pre><code>var listNode = document.getElementById(&apos;list&apos;)\n// 要插入 10 个 li 标签\nvar frag = document.createDocumentFragment();\nvar x, li;\nfor(x = 0; x &lt; 10; x++) {\n    li = document.createElement(&quot;li&quot;);\n    li.innerHTML = &quot;List item &quot; + x;\n    frag.appendChild(li);  // 先放在 frag 中，最后一次性插入到 DOM 结构中。\n}\nlistNode.appendChild(frag);\n</code></pre><p>复制</p>\n<h4 id=\"事件节流\"><a href=\"#事件节流\" class=\"headerlink\" title=\"事件节流\"></a><strong>事件节流</strong></h4><p>例如要在文字改变时触发一个 change 事件，通过 keyup 来监听。使用节流。</p>\n<pre><code>var textarea = document.getElementById(&apos;text&apos;)\nvar timeoutId\ntextarea.addEventListener(&apos;keyup&apos;, function () {\n    if (timeoutId) {\n        clearTimeout(timeoutId)\n    }\n    timeoutId = setTimeout(function () {\n        // 触发 change 事件\n    }, 100)\n})\n</code></pre><p>复制</p>\n<h4 id=\"尽早执行操作\"><a href=\"#尽早执行操作\" class=\"headerlink\" title=\"尽早执行操作\"></a><strong>尽早执行操作</strong></h4><pre><code>window.addEventListener(&apos;load&apos;, function () {\n    // 页面的全部资源加载完才会执行，包括图片、视频等\n})\ndocument.addEventListener(&apos;DOMContentLoaded&apos;, function () {\n    // DOM 渲染完即可执行，此时图片、视频还可能没有加载完\n})\n</code></pre><p>复制</p>\n<h4 id=\"性能优化怎么做\"><a href=\"#性能优化怎么做\" class=\"headerlink\" title=\"性能优化怎么做\"></a><strong>性能优化怎么做</strong></h4><p>上面提到的都是性能优化的单个点，性能优化项目具体实施起来，应该按照下面步骤推进：</p>\n<ol>\n<li>建立性能数据收集平台，摸底当前性能数据，通过性能打点，将上述整个页面打开过程消耗时间记录下来</li>\n<li>分析耗时较长时间段原因，寻找优化点，确定优化目标</li>\n<li>开始优化</li>\n<li>通过数据手机平台记录优化效果</li>\n<li>不断调整优化点和预期目标，循环2~4步骤</li>\n</ol>\n<p>性能优化是个长期的事情，不是一蹴而就的，应该本着先摸底、再分析、后优化的原则逐步来做。</p>\n<hr>\n<h2 id=\"Web-安全\"><a href=\"#Web-安全\" class=\"headerlink\" title=\"Web 安全\"></a><strong>Web 安全</strong></h2><blockquote>\n<p>题目：前端常见的安全问题有哪些？</p>\n</blockquote>\n<p>Web 前端的安全问题，能回答出下文的两个问题，这个题目就能基本过关了。开始之前，先说一个最简单的攻击方式 —— SQL 注入。</p>\n<p>上学的时候就知道有一个「SQL注入」的攻击方式。例如做一个系统的登录界面，输入用户名和密码，提交之后，后端直接拿到数据就拼接 SQL 语句去查询数据库。如果在输入时进行了恶意的 SQL 拼装，那么最后生成的 SQL 就会有问题。但是现在稍微大型一点的系统，都不会这么做，从提交登录信息到最后拿到授权，要经过层层的验证。因此，SQL 注入都只出现在比较低端小型的系统上。</p>\n<h3 id=\"XSS（Cross-Site-Scripting，跨站脚本攻击）\"><a href=\"#XSS（Cross-Site-Scripting，跨站脚本攻击）\" class=\"headerlink\" title=\"XSS（Cross Site Scripting，跨站脚本攻击）\"></a><strong>XSS（Cross Site Scripting，跨站脚本攻击）</strong></h3><p>这是前端最常见的攻击方式，很多大型网站（如 Facebook）都被 XSS 攻击过。</p>\n<p>举一个例子，我在一个博客网站正常发表一篇文章，输入汉字、英文和图片，完全没有问题。但是如果我写的是恶意的 JS 脚本，例如获取到<code>document.cookie</code>然后传输到自己的服务器上，那我这篇博客的每一次浏览都会执行这个脚本，都会把访客 cookie 中的信息偷偷传递到我的服务器上来。</p>\n<p>其实原理上就是黑客通过某种方式（发布文章、发布评论等）将一段特定的 JS 代码隐蔽地输入进去。然后别人再看这篇文章或者评论时，之前注入的这段 JS 代码就执行了。<strong>JS 代码一旦执行，那可就不受控制了，因为它跟网页原有的 JS 有同样的权限</strong>，例如可以获取 server 端数据、可以获取 cookie 等。于是，攻击就这样发生了。</p>\n<h4 id=\"XSS的危害\"><a href=\"#XSS的危害\" class=\"headerlink\" title=\"XSS的危害\"></a><strong>XSS的危害</strong></h4><p>XSS 的危害相当大，如果页面可以随意执行别人不安全的 JS 代码，轻则会让页面错乱、功能缺失，重则会造成用户的信息泄露。</p>\n<p>比如早些年社交网站经常爆出 XSS 蠕虫，通过发布的文章内插入 JS，用户访问了感染不安全 JS 注入的文章，会自动重新发布新的文章，这样的文章会通过推荐系统进入到每个用户的文章列表面前，很快就会造成大规模的感染。</p>\n<p>还有利用获取 cookie 的方式，将 cookie 传入入侵者的服务器上，入侵者就可以模拟 cookie 登录网站，对用户的信息进行篡改。</p>\n<h4 id=\"XSS的预防\"><a href=\"#XSS的预防\" class=\"headerlink\" title=\"XSS的预防\"></a><strong>XSS的预防</strong></h4><p>那么如何预防 XSS 攻击呢？—— 最根本的方式，就是对用户输入的内容进行验证和替换，需要替换的字符有：</p>\n<pre><code>&amp; 替换为：&amp;amp;\n&lt; 替换为：&amp;lt;\n&gt; 替换为：&amp;gt;\n” 替换为：&amp;quot;\n‘ 替换为：&amp;#x27;\n/ 替换为：&amp;#x2f;\n</code></pre><p>复制</p>\n<p>替换了这些字符之后，黑客输入的攻击代码就会失效，XSS 攻击将不会轻易发生。</p>\n<p>除此之外，还可以通过对 cookie 进行较强的控制，比如对敏感的 cookie 增加<code>http-only</code>限制，让 JS 获取不到 cookie 的内容。</p>\n<h3 id=\"CSRF（Cross-site-request-forgery，跨站请求伪造）\"><a href=\"#CSRF（Cross-site-request-forgery，跨站请求伪造）\" class=\"headerlink\" title=\"CSRF（Cross-site request forgery，跨站请求伪造）\"></a><strong>CSRF（Cross-site request forgery，跨站请求伪造）</strong></h3><p>CSRF 是借用了当前操作者的权限来偷偷地完成某个操作，而不是拿到用户的信息。</p>\n<p>例如，一个支付类网站，给他人转账的接口是<code>http://buy.com/pay?touid=999&amp;money=100</code>，而这个接口在使用时没有任何密码或者 token 的验证，只要打开访问就直接给他人转账。一个用户已经登录了<code>http://buy.com</code>，在选择商品时，突然收到一封邮件，而这封邮件正文有这么一行代码<code>&lt;img src=&quot;http://buy.com/pay?touid=999&amp;money=100&quot;/&gt;</code>，他访问了邮件之后，其实就已经完成了购买。</p>\n<p>CSRF 的发生其实是借助了一个 cookie 的特性。我们知道，登录了<code>http://buy.com</code>之后，cookie 就会有登录过的标记了，此时请求<code>http://buy.com/pay?touid=999&amp;money=100</code>是会带着 cookie 的，因此 server 端就知道已经登录了。而如果在<code>http://buy.com</code>去请求其他域名的 API 例如<code>http://abc.com/api</code>时，是不会带 cookie 的，这是浏览器的同源策略的限制。但是 —— <strong>此时在其他域名的页面中，请求<code>http://buy.com/pay?touid=999&amp;money=100</code>，会带着<code>buy.com</code>的 cookie ，这是发生 CSRF 攻击的理论基础。</strong></p>\n<p>预防 CSRF 就是加入各个层级的权限验证，例如现在的购物网站，只要涉及现金交易，肯定要输入密码或者指纹才行。除此之外，敏感的接口使用<code>POST</code>请求而不是<code>GET</code>也是很重要的。</p>\n<hr>\n<h2 id=\"小结-5\"><a href=\"#小结-5\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h2><p>本小节总结了前端运行环境（即浏览器）的一些常考查知识点，包括页面加载过程、如何性能优化以及需要注意的安全问题。</p>\n<p>上一篇：<a href=\"541674\">一面 4：从容应对算法题目</a>下一篇：<a href=\"541676\">一面 6：开发环境相关知识点与高频考题解析</a></p>\n<h1 id=\"一面-6：开发环境相关知识点与高频考题解析\"><a href=\"#一面-6：开发环境相关知识点与高频考题解析\" class=\"headerlink\" title=\"一面 6：开发环境相关知识点与高频考题解析\"></a><strong>一面 6：开发环境相关知识点与高频考题解析</strong></h1><p>工程师的开发环境决定其开发效率，常用的开发环境配置也是面试考查点之一。</p>\n<h2 id=\"知识点梳理-5\"><a href=\"#知识点梳理-5\" class=\"headerlink\" title=\"知识点梳理\"></a><strong>知识点梳理</strong></h2><ul>\n<li>IDE</li>\n<li>Git</li>\n<li>Linux 基础命令</li>\n<li>前端构建工具</li>\n<li>调试方法</li>\n</ul>\n<p>本小节会重点介绍 Git 的基本用法、代码部署和开发中常用的 Linux 命令，然后以 webpack 为例介绍下前端构建工具，最后介绍怎么抓包解决线上问题。这些都是日常开发和面试中常用到的知识。</p>\n<hr>\n<h2 id=\"IDE\"><a href=\"#IDE\" class=\"headerlink\" title=\"IDE\"></a><strong>IDE</strong></h2><blockquote>\n<p>题目：你平时都使用什么 IDE 编程？有何提高效率的方法？</p>\n</blockquote>\n<p>前端最常用的 IDE 有 <a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.jetbrains.com%2Fwebstorm%2F\" target=\"_blank\" rel=\"noopener\">Webstorm</a>、<a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.sublimetext.com%2F\" target=\"_blank\" rel=\"noopener\">Sublime</a>、<a href=\"https://link.juejin.im?target=https%3A%2F%2Fatom.io%2F\" target=\"_blank\" rel=\"noopener\">Atom</a> 和 <a href=\"https://link.juejin.im?target=https%3A%2F%2Fcode.visualstudio.com%2F\" target=\"_blank\" rel=\"noopener\">VSCode</a>，我们可以分别去它们的官网看一下。</p>\n<p>Webstorm 是最强大的编辑器，因为它拥有各种强大的插件和功能，但是我没有用过，因为它收费。不是我舍不得花钱，而是因为我觉得免费的 Sublime 已经够我用了。跟面试官聊到 Webstorm 的时候，没用过没事儿，但一定要知道它：第一，强大；第二，收费。</p>\n<p>Sublime 是我日常用的编辑器，第一它免费，第二它轻量、高效，第三它插件非常多。用 Sublime 一定要安装各种插件配合使用，可以去网上搜一下“sublime”常用插件的安装以及用法，还有它的各种快捷键，并且亲自使用它。这里就不一一演示了，网上的教程也很傻瓜式。</p>\n<p>Atom 是 GitHub 出品的编辑器，跟 Sublime 差不多，免费并且插件丰富，而且跟 Sublime 相比风格上还有些小清新。但是我用过几次就不用了，因此它打开的时候会比较慢，卡一下才打开。当然总体来说也是很好用的，只是个人习惯问题。</p>\n<p>VSCode 是微软出品的轻量级（相对于 Visual Studio 来说）编辑器，微软做 IDE 那是出了名的好，出了名的大而全，因此 VSCode 也有上述 Sublime 和 Atom 的各种优点，但是我也是因为个人习惯问题（本人不愿意尝试没有新意的新东西），用过几次就不用了。</p>\n<p>总结一下：</p>\n<ul>\n<li>如果你要走大牛、大咖、逼格的路线，就用 Webstorm</li>\n<li>如果你走普通、屌丝、低调路线，就用 Sublime</li>\n<li>如果你走小清新、个性路线，就用 VSCode 或者 Atom</li>\n<li>如果你面试，最好有一个用的熟悉，其他都会一点</li>\n</ul>\n<p>最后注意：千万不要说你使用 Dreamweaver 或者 notepad++ 写前端代码，会被人鄙视的。如果你不做 .NET 也不要用 Visual Studio ，不做 Java 也不要用 Eclipse。</p>\n<hr>\n<h2 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a><strong>Git</strong></h2><p>你此前做过的项目一定要用过 Git，而且必须是命令行，如果没用过，你自己也得恶补一下。对 Git 的基本应用比较熟悉的同学，可以跳过这一部分了。macOS 自带 Git，Windows 需要安装 Git 客户端，去 <a href=\"https://link.juejin.im?target=https%3A%2F%2Fgit-scm.com%2Fdownload%2Fwin\" target=\"_blank\" rel=\"noopener\">Git 官网</a> 下载即可。</p>\n<p>国内比较好的 Git 服务商有 <a href=\"http://coding.net\" target=\"_blank\" rel=\"noopener\">coding.net</a>，国外有大名鼎鼎的 GitHub，但是有时会有网络问题，因此建议大家注册一个 <a href=\"http://coding.net\" target=\"_blank\" rel=\"noopener\">coding.net</a> 账号然后创建项目，来练练手。</p>\n<blockquote>\n<p>题目：常用的 Git 命令有哪些？如何使用 Git 多人协作开发？</p>\n</blockquote>\n<h3 id=\"常用的-Git-命令\"><a href=\"#常用的-Git-命令\" class=\"headerlink\" title=\"常用的 Git 命令\"></a><strong>常用的 Git 命令</strong></h3><p>首先，通过<code>git clone &lt;项目远程地址&gt;</code>下载下来最新的代码，例如<code>git clone git@git.coding.net:username/project-name.git</code>，默认会下载<code>master</code>分支。</p>\n<p>然后修改代码，修改过程中可以通过<code>git status</code>看到自己的修改情况，通过<code>git diff &lt;文件名&gt;</code>可查阅单个文件的差异。</p>\n<p>最后，将修改的内容提交到远程服务器，做如下操作</p>\n<pre><code>git add .\ngit commit -m &quot;xxx&quot;\ngit push origin master\n</code></pre><p>复制</p>\n<p>如果别人也提交了代码，你想同步别人提交的内容，执行<code>git pull origin master</code>即可。</p>\n<h3 id=\"如何多人协作开发\"><a href=\"#如何多人协作开发\" class=\"headerlink\" title=\"如何多人协作开发\"></a><strong>如何多人协作开发</strong></h3><p>多人协作开发，就不能使用<code>master</code>分支了，而是要每个开发者单独拉一个分支，使用<code>git checkout -b &lt;branchname&gt;</code>，运行<code>git branch</code>可以看到本地所有的分支名称。</p>\n<p>自己的分支，如果想同步<code>master</code>分支的内容，可运行<code>git merge master</code>。切换分支可使用<code>git checkout &lt;branchname&gt;</code>。</p>\n<p>在自己的分支上修改了内容，可以将自己的分支提交到远程服务器</p>\n<pre><code>git add .\ngit commit -m &quot;xxx&quot;\ngit push origin &lt;branchname&gt;\n</code></pre><p>复制</p>\n<p>最后，待代码测试没问题，再将自己分支的内容合并到<code>master</code>分支，然后提交到远程服务器。</p>\n<pre><code>git checkout master\ngit merge &lt;branchname&gt;\ngit push origin master\n</code></pre><p>复制</p>\n<h3 id=\"关于-SVN\"><a href=\"#关于-SVN\" class=\"headerlink\" title=\"关于 SVN\"></a><strong>关于 SVN</strong></h3><p>关于 SVN 笔者的态度和针对 IE 低版本浏览器的态度一样，你只需要查询资料简单了解一下。面试的时候可能会问到，但你只要熟悉了 Git 的操作，面试官不会因为你不熟悉 SVN 而难为你。前提是你要知道一点 SVN 的基本命令，自己上网一查就行。</p>\n<p>不过 SVN 和 Git 的区别你得了解。SVN 是每一步操作都离不开服务器，创建分支、提交代码都需要连接服务器。而 Git 就不一样了，你可以在本地创建分支、提交代码，最后再一起 push 到服务器上。因此，Git 拥有 SVN 的所有功能，但是却比 SVN 强大得多。（Git 是 Linux 的创始人 Linus 发明的东西，因此也倍得推崇。）</p>\n<hr>\n<h2 id=\"Linux-基础命令\"><a href=\"#Linux-基础命令\" class=\"headerlink\" title=\"Linux 基础命令\"></a>Linux 基础命令</h2><p>目前互联网公司的线上服务器都使用 Linux 系统，测试环境为了保证和线上一致，肯定也是使用 Linux 系统，而且都是命令行的，没有桌面，不能用鼠标操作。因此，掌握基础的 Linux 命令是非常必要的。下面总结一些最常用的 Linux 命令，建议大家在真实的 Linux 系统下亲自试一下。</p>\n<p>关于如何得到 Linux 系统，有两种选择：第一，在自己电脑的虚拟机中安装一个 Linux 系统，例如 Ubuntu/CentOS 等，下载这些都不用花钱；第二，花钱去阿里云等云服务商租一个最便宜的 Linux 虚拟机。推荐第二种。一般正式入职之后，公司都会给你分配开发机或者测试机，给你账号和密码，你自己可以远程登录。</p>\n<blockquote>\n<p>题目：常见 linux 命令有哪些？</p>\n</blockquote>\n<h3 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a><strong>登录</strong></h3><p>入职之后，一般会有现有的用户名和密码给你，你拿来之后直接登录就行。运行 <code>ssh name@server</code> 然后输入密码即可登录。</p>\n<h3 id=\"目录操作\"><a href=\"#目录操作\" class=\"headerlink\" title=\"目录操作\"></a><strong>目录操作</strong></h3><ul>\n<li>创建目录 <code>mkdir &lt;目录名称&gt;</code></li>\n<li>删除目录 <code>rm &lt;目录名称&gt;</code></li>\n<li>定位目录 <code>cd &lt;目录名称&gt;</code></li>\n<li>查看目录文件 <code>ls`</code>ll`</li>\n<li>修改目录名 <code>mv &lt;目录名称&gt; &lt;新目录名称&gt;</code></li>\n<li>拷贝目录 <code>cp &lt;目录名称&gt; &lt;新目录名称&gt;</code></li>\n</ul>\n<h3 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a><strong>文件操作</strong></h3><ul>\n<li>创建文件 <code>touch &lt;文件名称&gt;`</code>vi &lt;文件名称&gt;`</li>\n<li>删除文件 <code>rm &lt;文件名称&gt;</code></li>\n<li>修改文件名 <code>mv &lt;文件名称&gt; &lt;新文件名称&gt;</code></li>\n<li>拷贝文件 <code>cp &lt;文件名称&gt; &lt;新文件名称&gt;</code></li>\n</ul>\n<h3 id=\"文件内容操作\"><a href=\"#文件内容操作\" class=\"headerlink\" title=\"文件内容操作\"></a><strong>文件内容操作</strong></h3><ul>\n<li>查看文件 <code>cat &lt;文件名称&gt;`</code>head &lt;文件名称&gt;<code></code>tail &lt;文件名称&gt;`</li>\n<li>编辑文件内容 <code>vi &lt;文件名称&gt;</code></li>\n<li>查找文件内容 <code>grep &#39;关键字&#39; &lt;文件名称&gt;</code></li>\n</ul>\n<hr>\n<h2 id=\"前端构建工具\"><a href=\"#前端构建工具\" class=\"headerlink\" title=\"前端构建工具\"></a><strong>前端构建工具</strong></h2><p>构建工具是前端工程化中不可缺少的一环，非常重要，而在面试中却有其特殊性 —— <strong>面试官会通过询问构建工具的作用、目的来询问你对构建工具的了解，只要这些你都知道，不会再追问细节</strong>。因为，在实际工作中，真正能让你编写构建工具配置文件的机会非常少，一个项目就配置一次，后面就很少改动了。而且，如果是大众使用的框架（如 React、Vue 等），还会直接有现成的脚手架工具，一键创建开发环境，不用手动配置。</p>\n<blockquote>\n<p>题目：前端为何要使用构建工具？它解决了什么问题？</p>\n</blockquote>\n<h3 id=\"何为构建工具\"><a href=\"#何为构建工具\" class=\"headerlink\" title=\"何为构建工具\"></a><strong>何为构建工具</strong></h3><p>“构建”也可理解为“编译”，就是将开发环境的代码转换成运行环境代码的过程。<strong>开发环境的代码是为了更好地阅读，而运行环境的代码是为了更快地执行，两者目的不一样，因此代码形式也不一样</strong>。例如，开发环境写的 JS 代码，要通过混淆压缩之后才能放在线上运行，因为这样代码体积更小，而且对代码执行不会有任何影响。总结一下需要构建工具处理的几种情况：</p>\n<ul>\n<li><strong>处理模块化</strong>：CSS 和 JS 的模块化语法，目前都无法被浏览器兼容。因此，开发环境可以使用既定的模块化语法，但是需要构建工具将模块化语法编译为浏览器可识别形式。例如，使用 webpack、Rollup 等处理 JS 模块化。</li>\n<li><strong>编译语法</strong>：编写 CSS 时使用 Less、Sass，编写 JS 时使用 ES6、TypeScript 等。这些标准目前也都无法被浏览器兼容，因此需要构建工具编译，例如使用 Babel 编译 ES6 语法。</li>\n<li><strong>代码压缩</strong>：将 CSS、JS 代码混淆压缩，为了让代码体积更小，加载更快。</li>\n</ul>\n<h3 id=\"构建工具介绍\"><a href=\"#构建工具介绍\" class=\"headerlink\" title=\"构建工具介绍\"></a><strong>构建工具介绍</strong></h3><p>最早普及使用的构建工具是 <a href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.gruntjs.net%2F\" target=\"_blank\" rel=\"noopener\">Grunt</a> ，不久又被 <a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.gulpjs.com.cn%2F\" target=\"_blank\" rel=\"noopener\">Gulp</a> 给追赶上。Gulp 因其简单的配置以及高效的性能而被大家所接受，也是笔者个人比较推荐的构建工具之一。如果你做一些简单的 JS 开发，可以考虑使用。</p>\n<p>如果你的项目比较复杂，而且是多人开发，那么你就需要掌握目前构建工具届的神器 —— webpack 。不过神器也有一个缺点，就是学习成本比较高，需要拿出专门的时间来专心学习，而不是三言两语就能讲完的。我们下面就演示一下 webpack 最简单的使用，全面的学习还得靠大家去认真查阅相关文档，或者参考专门讲解 webpack 的教程。</p>\n<h3 id=\"webpack-演示\"><a href=\"#webpack-演示\" class=\"headerlink\" title=\"webpack 演示\"></a><strong>webpack 演示</strong></h3><p>接下来我们演示一下 webpack 处理模块化和混淆压缩代码这两个基本功能。</p>\n<p>首先，你需要安装 Node.js，没有安装的可以去 <a href=\"https://link.juejin.im?target=http%3A%2F%2Fnodejs.cn%2Fdownload%2F\" target=\"_blank\" rel=\"noopener\">Node.js 官网</a> 下载并安装。安装完成后运行如下命令来验证是否安装成功。</p>\n<pre><code>node -v\nnpm -v\n</code></pre><p>复制</p>\n<p>然后，新建一个目录，进入该目录，运行<code>npm init</code>，按照提示输入名称、版本、描述等信息。完成之后，该目录下出现了一个<code>package.json</code>文件，是一个 JSON 文件。</p>\n<p>接下来，安装 wepback，运行<code>npm i --save-dev webpack</code>，网络原因需要耐心等待几分钟。</p>\n<p>接下来，编写源代码，在该目录下创建<code>src</code>文件夹，并在其中创建<code>app.js</code>和<code>dt.js</code>两个文件，文件内容分别是：</p>\n<pre><code>// dt.js 内容\nmodule.exports = {\n    getDateNow: function () {\n        return Date.now()\n    }\n}\n\n// app.js 内容\nvar dt = require(&apos;./dt.js&apos;)\nalert(dt.getDateNow())\n</code></pre><p>复制</p>\n<p>然后，再返回上一层目录，新建<code>index.html</code>文件（该文件和<code>src</code>属于同一层级），内容是</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;test&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div&gt;test&lt;/div&gt;\n\n    &lt;script src=&apos;./dist/bundle.js&apos;&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>复制</p>\n<p>然后，编写 webpack 配置文件，新建<code>webpack.config.js</code>，内容是</p>\n<pre><code>const path = require(&apos;path&apos;);\nconst webpack = require(&apos;webpack&apos;);\nmodule.exports = {\n  context: path.resolve(__dirname, &apos;./src&apos;),\n  entry: {\n    app: &apos;./app.js&apos;,\n  },\n  output: {\n    path: path.resolve(__dirname, &apos;./dist&apos;),\n    filename: &apos;bundle.js&apos;,\n  },\n  plugins: [\n    new webpack.optimize.UglifyJsPlugin({\n        compress: {\n          //supresses warnings, usually from module minification\n          warnings: false\n        }\n    }),\n  ]\n};\n</code></pre><p>复制</p>\n<p>总结一下，目前项目的文件目录是：</p>\n<pre><code>src\n  +-- app.js\n  +-- dt.js\nindex.html\npackage.json\nwebpack.config.js\n</code></pre><p>复制</p>\n<p>接下来，打开<code>package.json</code>，然后修改其中<code>scripts</code>的内容为：</p>\n<pre><code>&quot;scripts&quot;: {\n  &quot;start&quot;: &quot;webpack&quot;\n}\n</code></pre><p>复制</p>\n<p>在命令行中运行<code>npm start</code>，即可看到编译的结果，最后在浏览器中打开<code>index.html</code>，即可弹出<code>Date.now()</code>的值。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>最后再次强调，<strong>深刻理解构建工具存在的价值，比你多会一些配置代码更加有意义，特别是对于应对面试来说</strong>。</p>\n<hr>\n<h2 id=\"调试方法\"><a href=\"#调试方法\" class=\"headerlink\" title=\"调试方法\"></a><strong>调试方法</strong></h2><p>调试方法这块被考查最多的就是如何进行抓包。</p>\n<blockquote>\n<p>题目：如何抓取数据？如何使用工具来配置代理？</p>\n</blockquote>\n<p>PC 端的网页，我们可以通过 Chrome、Firefox 等浏览器自带的开发者工具来查看网页的所有网络请求，以帮助排查 bug。这种监听、查看网络请求的操作称为<strong>抓包</strong>。</p>\n<p>针对移动端的抓包工具，Mac 系统下推荐使用 Charles 这个工具，首先 <a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.charlesproxy.com%2Fdownload%2F\" target=\"_blank\" rel=\"noopener\">下载</a> 并安装，打开。Windows 系统推荐使用 <a href=\"https://link.juejin.im?target=http%3A%2F%2Frj.baidu.com%2Fsoft%2Fdetail%2F10963.html\" target=\"_blank\" rel=\"noopener\">Fiddler</a>，下载安装打开。两者使用基本一致，下面以 Charles 为例介绍。</p>\n<p>接下来，将安装好 Charles 的电脑和要抓包的手机，连接到同一个网络（一般为公司统一提供的内网，由专业网络工程师搭建），保证 IP 段相同。然后，将手机设置网络代理（每种不同手机如何设置网络代理，网上都有傻瓜式教程），代理的 IP 为电脑的 IP，代理的端口为<code>8888</code>。然后，Charles 可能会有一个弹框提示是否允许连接代理，这里选择“允许”即可。这样，使用手机端访问的网页或者联网的请求，Charles 就能监听到了。</p>\n<p>在开发过程中，经常用到抓包工具来做代理，将线上的地址代理到测试环境，Charles 和 Fiddler 都可实现这个功能。以 Charles 为例，点击菜单栏中 Tools 菜单，然后二级菜单中点击 Map Remote，会弹出配置框。首先，选中 Enable Map Remote 复选框，然后点击 Add 按钮，添加一个代理项。例如，如果要将线上的<code>https://www.aaa.com/api/getuser?name=xxx</code>这个地址代理到测试地址<code>http://168.1.1.100:8080/api/getuser?name=xxx</code>，配置如下图</p>\n<p>![](data:image/svg+xml;utf8,)</p>\n<hr>\n<h2 id=\"小结-6\"><a href=\"#小结-6\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h2><p>本小节总结了前端开发环境常考查的知识，这些知识也是前端程序员必须掌握的，否则会影响开发效率。</p>\n<p>上一篇：<a href=\"541675\">一面 5：浏览器相关知识点与高频考题解析</a>下一篇：<a href=\"541677\">二面 1：如何回答常见的软技能问题</a></p>\n<h1 id=\"二面-1：如何回答常见的软技能问题\"><a href=\"#二面-1：如何回答常见的软技能问题\" class=\"headerlink\" title=\"二面 1：如何回答常见的软技能问题\"></a><strong>二面 1：如何回答常见的软技能问题</strong></h1><p>面试是个技术活，不仅仅是技术，各种软技能的面试技巧也是非常重要的，尤其是程序员一般对于自己的软技能不是很看重，其实<strong>软技能才是决定你职场能够走多远的关键</strong>。</p>\n<h2 id=\"程序员应该具备的软技能\"><a href=\"#程序员应该具备的软技能\" class=\"headerlink\" title=\"程序员应该具备的软技能\"></a><strong>程序员应该具备的软技能</strong></h2><p>程序员除了业务技能外，应该具有下面的软技能：</p>\n<ol>\n<li>韧性：抗压能力，在一定项目压力下能够迎难而上，比如勇于主动承担和解决技术难题</li>\n<li>责任心：对于自己做过的项目，能够出现 bug 之类主动解决</li>\n<li>持续学习能力：IT 行业是个需要不断充电的行业，尤其 Web 前端这些年一直在巨变，所以持续学习能力很重要</li>\n<li>团队合作能力：做项目不能个人英雄主义，应该融入团队，跟团队一起打仗</li>\n<li>交流沟通能力：经常会遇见沟通需求和交互设计的工作，应该乐于沟通分享</li>\n</ol>\n<p>另外在《软技能：代码之外的生存指南》这本书里提到了下面一些软技能：</p>\n<ol>\n<li>职业</li>\n<li>自我营销</li>\n<li>学习能力</li>\n<li>提升工作效率</li>\n<li>理财</li>\n<li>健身</li>\n<li>积极的人生观</li>\n</ol>\n<h2 id=\"常见的软技能问题和提升\"><a href=\"#常见的软技能问题和提升\" class=\"headerlink\" title=\"常见的软技能问题和提升\"></a><strong>常见的软技能问题和提升</strong></h2><p>回答软技能类的问题，应该注意在回答过程中体现自己具备的软技能。下面列举几个常见的软技能类的问题。</p>\n<h3 id=\"回想下你遇见过最难打交道的同事，你是如何跟他沟通的\"><a href=\"#回想下你遇见过最难打交道的同事，你是如何跟他沟通的\" class=\"headerlink\" title=\"回想下你遇见过最难打交道的同事，你是如何跟他沟通的\"></a><strong>回想下你遇见过最难打交道的同事，你是如何跟他沟通的</strong></h3><p>一般来说，工作中总会遇见一两个自己不喜欢的人，这种情况应该尽量避免冲突，从自己做起慢慢让对方感觉到自己的合作精神。</p>\n<p>所以，遇见难打交道的同事，不要急于上报领导，应该自己主动多做一些事情，比如规划好工作安排，让他选择自己做的事情，有了结论记得发邮件确认下来，这样你们的领导和其他成员都会了解到工作的安排，在鞭笞对方的同时，也做到了职责明确。在项目当中，多主动检查项目进展，提前发现逾期的问题。</p>\n<p>重点是突出：自己主动沟通解决问题的意识，而不是遇见问题就找领导。</p>\n<h3 id=\"当你被分配一个几乎不可能完成的任务时，你会怎么做\"><a href=\"#当你被分配一个几乎不可能完成的任务时，你会怎么做\" class=\"headerlink\" title=\"当你被分配一个几乎不可能完成的任务时，你会怎么做\"></a><strong>当你被分配一个几乎不可能完成的任务时，你会怎么做</strong></h3><p>这种情况下，一般通过下面方式来解决：</p>\n<ol>\n<li>自己先查找资料，寻找解决方案，评估自己需要怎样的资源来完成，需要多长时间</li>\n<li>能不能借助周围同事来解决问题</li>\n<li>拿着分析结果跟上级反馈，寻求帮助或者资源</li>\n</ol>\n<p>突出的软技能：分析和解决问题，沟通寻求帮助。</p>\n<h3 id=\"业余时间都做什么？除了写码之外还有什么爱好\"><a href=\"#业余时间都做什么？除了写码之外还有什么爱好\" class=\"headerlink\" title=\"业余时间都做什么？除了写码之外还有什么爱好\"></a><strong>业余时间都做什么？除了写码之外还有什么爱好</strong></h3><p>这类问题也是面试官的高频问题，「一个人的业余时间决定了他的未来」，如果回答周末都在追剧打游戏之类的，未免显得太不上进。</p>\n<p>一般来说，推荐下面的回答：</p>\n<blockquote>\n<p>周末一般会有三种状态：</p>\n<ol>\n<li>和朋友一起去做做运动，也会聚会聊天，探讨下新技术之类的；</li>\n<li>也会看一些书籍充充电，比如我最近看的 xx，有什么的想法；</li>\n<li>有时候会闷在家用最近比较火的技术做个小项目或者实现个小功能之类的。</li>\n</ol>\n</blockquote>\n<p>这样的回答，既能表现自己阳光善于社交沟通的一面，又能表现自己的上进心。</p>\n<h2 id=\"小结-7\"><a href=\"#小结-7\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h2><p>本小节介绍了程序员除了业务技术能力之外应该日常修炼的软技能，在面试中，软技能会被以各种形式问起，候选人应该先了解有哪些软技能可以修炼，才能在回答软技能问题的时候，尽量提到自己具备的软技能。</p>\n<p>上一篇：<a href=\"541676\">一面 6：开发环境相关知识点与高频考题解析</a>下一篇：<a href=\"541678\">二面 2：如何介绍项目及应对项目细节追问</a></p>\n<h1 id=\"二面-2：如何介绍项目及应对项目细节追问\"><a href=\"#二面-2：如何介绍项目及应对项目细节追问\" class=\"headerlink\" title=\"二面 2：如何介绍项目及应对项目细节追问\"></a><strong>二面 2：如何介绍项目及应对项目细节追问</strong></h1><p>一个标准的面试流程中，肯定会在一面二面中问到你具体做过的项目，然后追问项目的细节。这类问题往往会通过下面形式来提问：</p>\n<ol>\n<li>发现你简历的一个项目，直接让你介绍下这个项目</li>\n<li>让你回忆下你做过的项目中，最值得分享（最大型/最困难/最能体现技术能力/最难忘）的</li>\n<li>如果让你设计 xx 系统/项目，你会怎么着手干</li>\n</ol>\n<p>这类跟项目相关的综合性问题，既能体现候选人的技术水平、业务水平和架构能力，也能够辨别候选人是不是真的做过项目，还能够发现候选人的一些软技能。</p>\n<p>下面分享下，遇见这类问题应该怎样回答。</p>\n<h2 id=\"怎样介绍自己做过的一个项目\"><a href=\"#怎样介绍自己做过的一个项目\" class=\"headerlink\" title=\"怎样介绍自己做过的一个项目\"></a><strong>怎样介绍自己做过的一个项目</strong></h2><p>按照第 1 小节说的，简历当中的项目，你要精挑细选，既要体现技术难度，又要想好细节。具体要介绍一个项目（包括梳理一个项目），可以按照下面几个阶段来做。</p>\n<p>###** 1. 介绍项目背景**</p>\n<p>这个项目为什么做，当初大的环境背景是什么？还是为了解决一个什么问题而设立的项目？背景是很重要的，如果不了解背景，一上来就听一个结论性的项目，面试官可能对于项目的技术选型、技术难度会有理解偏差，甚至怀疑是否真的有过这样的项目。</p>\n<blockquote>\n<p>比如一上来就说：我们的项目采用了「backbone」来做框架，然后。。。而「backbone」已经是三四年前比较新鲜的技术，现在会有更好的选择方案，如果不介绍项目的时间背景，面试官肯定一脸懵逼。</p>\n</blockquote>\n<h3 id=\"2-承担角色\"><a href=\"#2-承担角色\" class=\"headerlink\" title=\"2. 承担角色\"></a><strong>2. 承担角色</strong></h3><p>项目涉及的人员角色有哪些，自己在其中扮演的角色是什么？</p>\n<p>这里候选往往人会自己给自己挖坑，比如把自己在项目中起到的作用夸大等。一般来说，面试官细节追问的时候，如果候选人能够把细节或者技术方案等讲明白、讲清楚，不管他是真的做过还是跟别人做过，或者自己认真思考过，都能体现候选人的技术水平和技术视野。前提还是在你能够兜得住的可控范围之内做适当的「美化」。</p>\n<h3 id=\"3-最终的结果和收益\"><a href=\"#3-最终的结果和收益\" class=\"headerlink\" title=\"3. 最终的结果和收益\"></a><strong>3. 最终的结果和收益</strong></h3><p>项目介绍过程中，应该介绍项目最终的结果和收益，比如项目最后经过多久的开发上线了，上线后的数据是怎样的，是否达到预期，还是带来了新的问题，遇见了问题自己后续又是怎样补救的。</p>\n<h3 id=\"4-有始有终：项目总结和反思\"><a href=\"#4-有始有终：项目总结和反思\" class=\"headerlink\" title=\"4. 有始有终：项目总结和反思\"></a>4. 有始有终：项目总结和反思</h3><p>有总结和反思，才会有进步。 项目做完了往往会有一些心得和体会，这时候应该跟面试官说出来。在梳理项目的总结和反思时，可以按照下面的列表来梳理：</p>\n<ul>\n<li>收获有哪些？</li>\n<li>是否有做得不足的地方，怎么改进？</li>\n<li>是否具有可迁移性？</li>\n</ul>\n<p>比如，之前详细介绍了某个项目，这个项目当时看来没有什么问题，但是现在有更好的解决方案了，候选人就应该在这里提出来：现在看来，这个项目还有 xx 的问题，我可以通过 xx 的方式来解决。</p>\n<p>再比如：做这个项目的时候，你做得比较出彩的地方，可以迁移到其他项目中直接使用，小到代码片段，大到解决方案，总会有你值得总结和梳理的地方。</p>\n<p>介绍完项目总结这部分，也可以引导面试官往自己擅长的领域思考。比如上面提到项目中的问题，可以往你擅长的方面引导，即使面试官没有问到，你也介绍到了。</p>\n<p>按照上面的四段体介绍项目，会让面试官感觉候选人有清晰的思路，对整个项目也有理解和想法，还能够总结反思项目的收益和问题，可谓「一箭三雕」。</p>\n<h2 id=\"没有做过大型项目怎么办\"><a href=\"#没有做过大型项目怎么办\" class=\"headerlink\" title=\"没有做过大型项目怎么办\"></a><strong>没有做过大型项目怎么办</strong></h2><p>对于刚刚找工作的应届生，或者面试官让你进行一个大型项目的设计，候选人可能没有类似的经验。这时候不要用「我不会、没做过」一句话就带过。</p>\n<p>如果是实在没有项目可以说，那么可以提自己日常做的练手项目，或者看到一个解决方案的文章/书，提到的某个项目，抒发下自己的想法。</p>\n<p>如果是对于面试官提出来需要你设计的项目/系统，可以按照下面几步思考：</p>\n<ol>\n<li>有没有遇见过类似的项目</li>\n<li>有没有读过类似解决方案的文章</li>\n<li>项目能不能拆解，拆解过程中能不能发现自己做过的项目可以用</li>\n<li>项目解决的问题是什么，这类问题有没有更好的解决方案</li>\n</ol>\n<p>总之，切记不要一句「不知道、没做过」就放弃，每一次提问都是自己表现的机会。</p>\n<h2 id=\"项目细节和技术点的追问\"><a href=\"#项目细节和技术点的追问\" class=\"headerlink\" title=\"项目细节和技术点的追问\"></a><strong>项目细节和技术点的追问</strong></h2><p>介绍项目的过程中，面试官可能会追问技术细节，所以我们在准备面试的时候，应该尽量把技术细节梳理清楚，技术细节包括：</p>\n<ol>\n<li>技术选型方案：当时做技术选型所面临的状况</li>\n<li>技术解决方案：最终确定某种技术方案的原因，比如：选择用 Vue 而没有用 React 是为什么？</li>\n<li>项目数据和收益</li>\n<li>项目中最难的地方</li>\n<li>遇见的坑：如使用某种框架遇见哪些坑</li>\n</ol>\n<p>一般来说，做技术选型的时候需要考虑下面几个因素：</p>\n<ol>\n<li>时代：现在比较火的技术是什么，为什么火起来，解决了什么问题，能否用到我的项目中？</li>\n<li>团队：个人或者团队对某种技术的熟悉程度是怎样的，学习成本又是怎样的？</li>\n<li>业务需求：需求是怎样的，能否套用现在的成熟解决方案/库来快速解决？</li>\n<li>维护成本：一个解决方案的是否再能够 cover 住的范围之内？</li>\n</ol>\n<p>在项目中遇见的数据和收益应该做好跟踪，保证数据的真实性和可信性。另外，遇见的坑可能是面试官问得比较多的，尤其现在比较火的一些技术（Vue、React、webpack），一般团队都在使用，所以一定要提前准备下。</p>\n<h2 id=\"小结-8\"><a href=\"#小结-8\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h2><p>本小节介绍了面试中关于项目类问题的回答方法，介绍项目要使用四段体的方式，从背景、承担角色、收益效果和总结反思四个部分来介绍项目。</p>\n<p>准备这个面试环节的时候，利用笔者一直提倡的「思维导图」法，好好回顾和梳理自己的项目。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjuanzkim000qjgf2o4z996l1","tag_id":"cjuanzkio000sjgf2e6ecfoo7","_id":"cjuanzkiz000vjgf2t0wyzk90"}],"Tag":[{"name":"Javascript 闭包","_id":"cjuanzkio000sjgf2e6ecfoo7"}]}}